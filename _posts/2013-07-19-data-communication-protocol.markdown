---

title: Data communication protocol
abstract: Described is a data communication protocol, in which a client and server negotiate in a manner that does not require the client to retry negotiation when servers are not capable of the client-desired protocol. In one example implementation, the desired protocol is SMB 2.0 or greater. The protocol describes a create command with possibly additional context data attached for built-in extensibility, and a compound command comprising a plurality of related commands or unrelated commands. A multi-channel command requests data transfer on a separate data channel, a signed capability verification may be used to ensure that a secure connection is established, and the protocol provides the ability to transfer extended error data from the server in response to a request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09438696&OS=09438696&RS=09438696
owner: Microsoft Technology Licensing, LLC
number: 09438696
owner_city: Redmond
owner_country: US
publication_date: 20130719
---
The present application is a continuation of United States Application Ser. No. 13 663 827 filed Oct. 30 2012 now U.S. Pat. No. 8 825 885 issued Sep. 2 2014 which is a continuation of United States Application Ser. No. 11 182 251 filed Jul. 15 2005 now U.S. Pat. 8 332 526 issued Dec. 11 2012 which claims priority to U.S. provisional patent application Ser. No. 60 685 008 filed May 25 2005 and herein incorporated by reference. The present application is related to copending United States patent application entitled Data Communication Coordination with Sequence Numbers U.S. Application Ser. No. 11 182 989 filed concurrently herewith now U.S. Pat. No. 8 316 129 issued Nov. 20 2012 assigned to the assignee of the present invention and hereby incorporated by reference.

Many data communication protocols that are still in use today such as the SMB Server Message Block protocol were developed at a time when computing resources were very different e.g. network bandwidth was typically limited and memory was very precious. As a result when used in contemporary networks such protocols may limit overall performance. For example because of having been designed when memory was limited small buffer sizes are used requiring more round trips to communicate large amounts of data.

Moreover the existing SMB protocol has other limitations that have become apparent over time. For example the existing SMB protocol is susceptible to denial of service attacks the design of the protocol makes it difficult to fight these attacks. Likewise the method for ensuring packet security is cumbersome. Also there is no current mechanism for performing quality of service like operations in that a trusted client for example obtains the same server resources as an untrusted client.

Although various revisions or dialects of the SMB protocol have been developed over time each those dialects are essentially patch based approaches that tweak various parts to add some additional features. Thus extensibility is not straightforward. In sum while still a frequently used and valuable protocol existing SMB versions are less than ideal when used with contemporary network resources.

Briefly various aspects of the present invention are directed towards a data communication protocol which a client and server use for communication such as for file sharing. The client sends a negotiation packet to a server that identifies a set of protocol dialects the client understands. The packet is in a format such that without requiring another request a server incapable of communicating via the second data communication protocol will indicate the first communication protocol should be used. If the server is capable of communicating via the second data communication protocol it will respond as such. The client will invoke a driver that handles communication with the server via the corresponding protocol indicated by the server. In one example implementation the second communication protocol is SMB 2.0 or greater.

Other aspects and enhancements of the protocol may include a create command with additional context data attached and a compound command comprising a plurality of related commands or unrelated commands. Still other aspects and enhancements include a multi channel command related to requesting data transfer on a separate data channel a signed capability verification request to ensure that a secure connection is established and the ability to transfer extended error data from the server in response to a request.

When a server receives a compound request the server determines whether the compound request contains unrelated commands or related commands. When the compound request contains unrelated commands each request is handled as a separate request otherwise when the compound request contains related commands each request is handled sequentially. When the related commands including a create open command the file handle from the create open command is used for each subsequent related command at the server e.g. without needing to wait for the handle back from the client.

Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices tablet devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices one of variety of network appliance devices such as print servers or printers themselves as well as NAS storage devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in local and or remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media described above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a tablet or electronic digitizer a microphone a keyboard and pointing device commonly referred to as mouse trackball or touch pad. Other input devices not shown in may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . The monitor may also be integrated with a touch screen panel or the like. Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer. In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various aspects of the technology described herein are directed towards a data communication protocol such as a later version 2.x or greater of the SMB protocol. In one example implementation generally described herein the SMB protocol is used for file data transfer. However as can be readily appreciated the present invention is not limited to file data let alone any particular implementation or examples described herein. Instead numerous ways to implement the present invention are feasible including for use in communication with printers named data pipes generic devices and so forth. As such the present invention is not limited to any of the particular file based examples used herein but rather may be used numerous ways that provide benefits and advantages in computing in general.

Other various aspects of the technology described herein are directed towards a new revision of SMB upon which file server interaction may be built. As will be understood a more lightweight protocol is provided that supports existing up level functionality along with being more scalable and easier to update with new features.

Turning to of the drawings there is shown a block diagram representing an example networking environment in which a client communicates with a server through one or more communication channels. Although the functions and components of the client machine and the server are described as being located within two separate computers such as the main computer system and remote computer system of the components of these two computers or the functions performed thereby may be provided on one machine or may be distributed over a number of computers.

Network file system commands from an application program are handled by a client redirector component which communicates with a counterpart common network module SRVNET to carry out the commands on the file system . Before such commands are processed a communication protocol that the client and server agree upon generally the most recent version dialect that both understand is negotiated.

In general the client establishes a connection and then negotiates with the server to ultimately set up a session as generally represented in . While a client may directly indicate to a server that it is an SMB 2.x client wherein as used herein the number 2.x represents any newer version relative to existing SMB 1.x versions a client may also negotiate via a backwards compatible negotiation packet. In this way a client can also communicate with a server that is only SMB 1.x capable yet do so without needing to set up a separate connection should an attempt at a higher level negotiation fails. At the same time the code for implementing each protocol may be packaged into its own independent driver.

In one example implementation a client SMB engine component provides a packet to a server e.g. the server that indicates that the client is negotiating at least an SMB 1.0 session. For a client that speaks both the SMB1 dialects and the new SMB2 revision of the protocol the client may send a traditional SMB1 negotiate packet but that further contains an indication that this packet is actually requesting SMB 2.x if available. An SMB2 capable server will detect this request and respond with an SMB2 negotiate response. More particularly to indicate that the client is capable of SMB 2.x the SMB 1.0 negotiation packet includes a set of dialect strings one of which indicates that the client is also capable of SMB 2.x communication.

The client thus sends an initial negotiate that includes the minor revision numbers that the client supports. One current revision is 0 zero i.e. SMB 2.0 in the future a client may claim to support any subset of the dialect revisions.

When the server receives the packet it will respond based on its capabilities. A server may respond with an SMB 1.0 negotiation response along with any 1.x dialect information or if capable of SMB 2.x communication will respond with an SMB 2.0 negotiation response. A particular SMB dialect revision may also be returned that matches one of the dialect strings ordinarily the largest numbered version that the server can handle among the dialect versions that the client provided.

To this end once the server knows which dialect revisions the client speaks it compares these to the revisions that the server understands and returns the preferred common dialect revision which will usually be the highest . For example if the server supports dialects 1 8 but the client only supports 1 2 and 4 the server will return 4. This gives the client a clear understanding of which commands it will be able to send to the server . To select which dialect to use the SRVNET module essentially starts a negotiation handing the packet to each SMB provider that it has from highest to lowest in order with respect to versions dialects until one SMB provider agrees to handle this communication session based on the packet contents. Thereafter communications on this connection are routed to that provider in this example the SMB 2.0 provider .

At the client end the SMB engine component receives the response and based on the version dialect information in the response knows which client SMB component to use to communicate with the server. In this manner both the client and server agree on which SMB dialect to use for a given session. Note that a client may have multiple SMB components running at the same time each a different version dialect whereby for example a client may be communicating with one server over SMB 1.x at the same time the client is communicating with another server over SMB 2.x.

The server also returns other information to the client including a security mode which tells the client whether the server will require security signatures. Note that previously security signatures were available however the first few e.g. capabilities negotiation packets were in the clear whereby an attacker could force a client into a lower level protocol in which the attacker knows its vulnerabilities.

Secure connect operates by providing another capabilities verification round trip that is signed regardless of whether signing is enabled or not . shows such a request response following session setup. Other information can be put in the packet such as an IP address so that the server can actually verify that it and not another entity responded. Signing can be turned off if IPSEC or any other form of network security is active.

The server may return capabilities bits for the server e.g. whether the server is DFS Distributed File System aware and whether it is LWIO Lightweight IO capable. The client disregards any capability bits it does not understand which may happen if the server has a newer version than the client s corresponding version. Other information that may be returned in the negotiate exchange includes the server s unique ID the maximum read write size the server will accept a data offset hint for faster write processing the current system time of the server and security information used to seed authentication in the case of extended security.

Session setup handles the authentication process for a new session which may be a multiple round trip event. The client queries the local security system for a security blob to send over the network and sends the first session setup filling in the capabilities the maximum size fields and a VcNumber described below. The server receives this blob and gives it to the security system. If the server determines that more information is needed it will return its own security blob with the error code STATUS MORE PROCESSING REQUIRED. The client passes this blob back to the local security system and the process will repeat until a failure occurs or authentication is successful.

The VcNumber tells the server whether there may be other connections established from this same client . If this is zero the server assumes no other connections have been made from this client and will tear down any such connections it finds assuming them to be stale . If the VcNumber is one or more the server will not tear down any existing connections.

The Channel tells the server that this client is attempting to establish another connection with an existing session. The session can be identified by the user computer pair from which this session setup was received. The channels share the same TreeId UserId ProcessId FileId information. For a channel authentication the authentication blob may be a challenge response that is encrypted across the first channel and sent back out across the second channel to allow the client and server to mutually authenticate each other. On a successful response the server will also notify the client if it has been authenticated as Guest or as a Null user if either is applicable.

Once a session is set up the client may perform data transfer using the various commands described below including create read write and close as well as perform file locking and directory related operations. As described in the aforementioned Data Communication Coordination with Sequence Numbers patent application when using these commands the server is able to control the client s use of server resources. Also the protocol provides a number of efficiency improvements with respect to what information is communicated and how it is communicated.

As generally represented in the create command has been extended to allow context information to be attached to the command in general the context information comprises arbitrary extra create parameters that are tagged to the create command. For example a transaction identifier for a transactional file system related create command may be attached. As long as the server understands the extra context information the server can be informed of the extended information note that servers will ignore extra data that they not understood and return information associated with the context. As can be readily appreciated this provides for additional functionality without changing the protocol essentially providing built in extensibility.

Command IDs and dialect revision numbers are provided for in a new SMB header set forth below. The header has a USHORT for the command field as opposed to a UCHAR by using the first byte of this USHORT to denote the dialect and the latter byte to denote the command the command table is well defined for existing commands with a large proportion open for later expansion. In general the client may maintain a table for each dialect that contains the pointers to the function to issue a given command. For a client with a single dialect supported the table would be as set forth below 

For caching functionality more information may be retrieved from the file on Close. As such a new Close command is provided to support this new functionality. Now the client supports two dialects and the table is as set forth below 

Note that most of the functionality stayed the same except for the changed Close command. Also the client can now talk to Dialect 2 servers and use the new functionality but for Dialect 1 servers it still uses the old functionality. There are no changes to the communicating with Dialect 1 servers.

As technology evolves new network hardware becomes available such as capable of performing relatively much larger reads and writes. For this release Dialect 3 is provided whereby the table is enlarged as follows 

A client with such a table can speak the three dialects and will take advantage of the functionality that is available in each dialect. Some advantages of using this method include that each SMB command can be mapped back to the dialect it was introduced into because the command is made of Dialect Command . This makes it easy to determine when commands were introduced and what servers support them. If the functionality for a given command is not changed in a new dialect the code does not change. If the functionality is changed the down level interface code does not change but rather new code is added to support the new functionality.

On the server side a server dispatch table becomes a double switch between Dialect and Command . This allows for logically separating the new functionality in the code making it easier to understand and change.

Turning to one aspect of the protocol that provides efficiency multiple commands may be compounded into a single packet or some lesser number of packets . Complex tasks may thus be performed in a manner that reduces the number of round trips between the client and server . By way of example a compound request packet may contain a command to create open a file a command to write to the file and a command read from the file. Compounding thus works with related operations e.g. having the same file handle and also provides for unrelated operations to be combined.

An example of compounding related requests is generally represented in where in contrast to for example a single request can handle a write and read providing the appropriate parameters. Note that as represented in a single request may receive a compound response and or individual responses depending for example on when they complete. More complex requests such as create open read write and close may be in a single request. This is accomplished by marking a packet as having related operations the server will know that the file handle it receives following the create open applies to the other commands in the compound request. Note however that related compound requests are handled in the order they are packaged and thus it is up to the client to ensure they are ordered correctly before sending.

Compounding in SMB2 is simpler than the complex rules that existed in SMB1. To this end the SMB2 HEADER detailed below contains a NextOffset that is used to identify the offset of the header of the next command from the header of the current command. Each command has its own SMB2 HEADER including a separate MessageId. The server response or responses may come as a single compounded response or as separate responses as represented in . In the event of a failure the response would be the same as any other failed command.

For unrelated messages the commands will always be processed as if they were received separately. This allows a redirector or intermediate component to automatically compound packets that are unrelated. A delay may be used to obtain packets to compound particularly if the delay time is small relative to the round trip time. Because the server treats them as received separately the server need not be otherwise modified to unpack such compound unrelated requests. The entity that performed the compounding may have to separate any compound responses however since the server may combine otherwise separate responses.

The related mode allows the client to send a series of commands that are to be executed in sequence with the result of one command potentially being used in the next command. Such commands share the same Session Process Tree File ID they will be executed sequentially and will stop processing on the first error. If there were other commands to process after the failure the operations are immediately failed with STATUS NOT PROCESSED. An example of how this may be used is to pair a Session Setup with a Tree Connect. If the session fails to be established the tree connect will never be attempted and will fail with STATUS NOT PROCESSED. If the session setup succeeds the tree connect is done using the SessionId from the session setup command. The same method could be used to do a Create followed by a QueryFileInformation or even a Create Read Close set.

Conditional and implied compounding are also feasible. For example a conditional compound command may be sent such as open and also read if the file is less than 64 KB thus opening and automatically obtaining small files in one round trip but only opening large files. Implied compounding such as automatically returning directory enumeration data in response to an open directory request even if not expressly requested may also cut down round trips. The benefits and advantages to such enhanced compounding increase in high latency networks.

Another way in which the protocol facilitates improved efficiency is via multiple channel communication. Between a client and server a transport connection for commands may be used with a command that specifies an alternate channel to stream data. For example a read request may specify the offset and length as well as an alternate channel to read data into a write request operates similarly. shows an example of a 1 GB read request starting from offset 0 and requesting the data to be streamed to data channel 5.

Streaming data on an alternate channel provides a number of benefits includes eliminating the need to include and process packet headers. The client can pre post a buffer and have the data streamed therein eliminating the need to copy from one buffer to another as in conventional single channel communication. Fairness is another benefit in that for example one request on the control channel will not have to wait for a large amount of data e.g. 5 GB to complete be transmitted before that other request is handled because the 5 GB will go over the data channel.

As multiple NIC s are becoming more common the protocol takes advantage of any available network bandwidth. This includes working across multiple connections for the same session regardless of the transport or NIC on which they are established. Specialized hardware may be employed.

Thus with SMB 2.x a session is not bound to a connection. Instead multiple channels may be established that exist across different physical connections. Sessions can exist on each of these connections and the IDs used to refer to files and processes are common across channels. This allows for having a normal channel for doing namespace operations and creates but using specialized network hardware for reads and writes when available. Still further small network glitches may not result in lost data because as long as one channel remains open to a session the session stays alive. Various implementation details are described herein with reference to the Session Setup command and the Read Write commands.

By way of example consider a client that establishes a connection over simple TCP to the server over an enterprise s public network. This is the first connection so it is always channel 0. Once both sides detect that they have a private network for doing data transfers e.g. each has a gigabit card the client and server may establish a second connection over this card as channel 1. While the client is browsing some files the directory queries are being sent over channel 0 while the data is being sent over channel 1. If the client wants to browse into some directories that are encrypted on the server when the client requests the data the redirector realizes that the data is sensitive so it establishes a new channel channel 2 to the server that has IP Sec IP security active on it. When the client requests the sensitive data it will ask it be sent over channel 2 while normal less sensitive data could continue to come over channel 1 as it is faster .

As can be readily appreciated the opportunity for QoS and security improvements along with the simple bandwidth gain provides significant benefits. Note that on a channel read write the server client can lay down the receive buffer before any data is read so the mechanism can further eliminate the need to copy out of the data movement which can also improve server client scalability.

Further SMB error packets are allowed to be tagged with arbitrary data. Thus a description of why something failed which may provide value. Symbolic link evaluation is one example where tagging with arbitrary data provides a client with useful information as generally represented in . Essentially a client create request may fail by asking for a path that is actually a symbolic link to another path. Instead of simply failing the request information providing the new path allows the client to change to a reparse path which will ultimately succeed note that iteration over a number of requests may be required to find a path that will succeed.

Protocol is simply the protocol identifier to identify the packet. For the existing SMB implementations this consists of 0xFF S M B . For the new protocol this shall be 0xFE S M B .

StructureSize identifies the size of the SMB2 HEADER structure and will be used for minor versioning within the Header itself if other changes are introduced later on.

Epoch represents the version count of a server. This is incremented when a server is cycled or the server service is stopped and started to indicate to the client whether the server might have maintained state across a disconnect. This is for future use with persistent handles and can be considered Reserved for the time being.

CreditsGranted CreditsRequested are used by the client on a send to request more credits and by the server on the response to grant more credits within the new credit management scheme as described in the related patent application entitled Data Communication Coordination with Sequence Numbers. 

On response the server returns STATUS PENDING with this flag set to indicate that we are processing it asynchronously.

Set on a client message send of a compounded message to indicate that the operations are related so the file opened in the Create is used as the FileId for later operations.

Set when the packet has been signed. The receiver should verify the signature. The key used for signing is based on the session that sent the packet.

This is a DFS operation. The server should allow DFS to munge the name. This could be replaced with a create option.

AsyncId as described in the related patent application entitled Data Communication Coordination with Sequence Numbers message IDs are actually sequence numbers and the window of available sequence numbers is always set to slide to the right. A command that will run for an extremely long time such as a named pipe read or change notification or a create that pends on an oplock break any of which can block indefinitely may hold up the ability of the window to slide. To work around this issue the server can optionally respond to any command with STATUS PENDING and setting the SMB2 FLAGS ASYNC COMMAND flag mentioned above and providing a unique identifier in place of the Session Tree ProcessId. This means the client can continue sliding the window as if it received a response. At some point later the true response will come with a matching AsyncId and CommandId to satisfy the request. In the event that the client wants to cancel such a command the client sends a cancel with the flag set and the matching AsyncId.

The security signature is the same as in the previous protocol except that there is no longer a hidden index number. The index is not necessary with the use of sequence numbers for the MID. This prevents replayability directly . This allows the use of security signatures without forcing the operations to be sequenced on their way to the transport.

NextCommand is the offset of the next command in the message from the beginning of this header. Messages should be quad aligned. The use of the SMB2 FLAGS RELATED COMMAND allows various abilities for compounding as described above.

As described above the client and server exchange negotiate request and response as part of the handshake that helps them determine each other s capabilities.

This command tears down the session with the SessionId specified in the header. Open files are closed and other existing structures tree connects etc. are torn down. No more operations can be processed for the given SessionId.

The client issues this command to the server to establish a tree connection. The Path is of the form server share and is filled into the buffer. Inclusion of the server name allows for features like share scoping.

On successful response from the server the client receives the TreeId in the header along with the ShareFlags and ShareCapabilities. Currently the share flags indicate to the client what the CSC caching properties are for a share but more may be added later on. The capabilities tell the client whether the file system backing the share supports either file level security timewarp TxF transactional file system or client side encryption. If a file system supports these properties on some subtrees but not all such as the case of mount points it should return that it does support them and simply fail the individual requests to use them in cases where it is not allowed. The client should ignore any flags or capabilities it does not understand.

Once the command is processed no more operations can be successfully completed on the given TreeId. The TreeId is taken from the header.

The create request is a variable length request to allow creation of files with various attributes other than the traditional well defined attributes. The standard case where no extended attributes are present is straightforward the client fills in the RootDirectoryFid for a relative open if desired the DesiredAccess FileAttributes ShareAccess CreateDisposition and CreateOptions. They set the desired oplock level and fill in the SecurityFlags Impersonation level for QoS. Currently there are no SmbCreateFlags defined but space has been allocated for their use. The client sends this packet to the server which opens the file and either returns a failure code or returns Success along with the FileId that identifies the file the Creation LastAccess LastWrite LastChangeTime the AllocationSize and EndOfFile information and the FileAttributes.

That is the normal case that operates in much the same way that the current protocol does. For more advanced cases consider that the user wants to create a file with extended attributes EAs . In the previous protocol there was an entirely different way of handling this through a Transact call. Now the client can build up the create request as normal but also add a CreateContext to the end of the create request. The request would have the name ExtA and the Data would contain the EAs to set on the file. When the server receives this it would parse out the EA data and issue it with the create. Create contexts can also be returned on the create response to provide additional information. For the first iteration the names will be of length so we can format them as a long and switch on them. The current list of CreateContext s is as follows 

A client sends a Close to close an instance of a file that was opened previously. Once a close is processed no file operations are allowed on the previous FID.

For the Close command the client specifies the FileId of the file being closed along with the LastWriteTime in SystemTime format . This allows the client to set the last time a cached write was performed on the file as the last written time on the file. The client can also send zero for the LastWriteTime to indicate that they do not wish to specify one. The structure also allots room for Close flags which are currently undefined but may be used at a later point.

Upon successful response from the server the client is guaranteed that all cached data has been flushed to its backing persistent store. The client specifies the FileId of the file it wishes to flush. A flush on a pipe will not return until all data is consumed from that pipe which may take a while.

Read is pretty self explanatory. The client specifies the file via FileId the offset and the length of the read and the server returns the data. There are a couple other things the client can specify. The MinCount tells the server the minimum amount it will read from a file for a successful return. If the read comes up short the server will simply return a failure instead of returning the entire data buffer. The client can also recommend Padding for better processing. This is the offset into the read response packet where the server should put the data. This allows the client to lay down the read response buffers in a more efficient way when it receives the information off the transports. The remaining field indicates to the server how much the entire read will be for if this is only a section of the read. Thus if the client is going to read 8 k in 1 k chunks it would issue a read for 1 k with Remaining 7 k. This allows the server the option to optimize by reading the entire 8 k in one operation and buffering the data back to the client.

On the server response it indicates how much data it is returning in the DataLength field along with the DataRemaining that was specified in the read command.

If the channel specified in the command is not the channel that the command came in on than the user is asking for a channel read. This means that if I request a read on channel 0 with channel 1 and Length 0 Remaining 64 k the server will respond with DataLength 0 DataRemaining 64 k and the next 64 k bytes that come across Channel 1 will be the data. The client is responsible for synchronizing this to make sure no data responses are outstanding on channel 1 when this command is issued. A client could also issue on channel 0 read Channel 1 DataLength 1 k Remaining 7 k such that the response would contain the first 1 k of data and the rest of the data the last 7 k would be streamed across channel 1.

The client fills in the file identified by the FileId the offset and the length for the write and attached the data. It is recommended that the data be padded as returned in the original negotiate response to help server performance. The client can also indicate how much more data it will write to the server to allow the server to optimize. On the response the server indicates how much was written and returns the amount it is still expecting.

If the channel specified in the write is not the channel the command came in on than the client is asking to stream the data on another channel. An example would be a write received on channel 0 with Channel 1 Length 0 Remaining 64 k . The client is asking to stream a 64 k write on Channel 1. The server would respond with Count 0 Remaining 64 k to allow the write. The response will include and AsyncId for a second response that will come after the data is sent on the channel and ack d. Then the next 64 k bytes streamed on Channel 1 would be the data. No header . Upon completion the server will send a SMB2 RESP WRITE on channel 0 to indicate the success failure of the operation and use the AsyncId information to send a second reply unless the specific channel allows for inherent acknowledgement in which case it will occur on the channel itself.

When another user requests access to a file that a client holds an opportunistic lock on in a fashion that requires breaking the existing lock SRV will send an SMB2 RESP BREAK OPLOCK to the client. The client is then expected to send a REQ BREAK OPLOCK for the given file to release their oplock and SRV will respond again to acknowledge this.

Used to request byte range locks and also used to request opportunistic locks and inform the client when one is broken .

Syntax for the LOCK request is similar to the SMB1 Lock request. The client specifies the FileId and one or more SMB LOCK structures indicating the offset and length they wish to lock. All of these LOCK structures must be either locks or unlocks. However you can mix shared and exclusive lock requests in a single batched lock operation. The most common use for lock batching would be claiming a series of locks as part of a batch oplock break and is most useful when you are assured that all the locks will succeed.

A successful return indicates to the client that they attained or released the requested byte range locks. On the failure case the byte range locks were not granted.

Echo is used by a client to determine whether a server is still up at a given point in time. Upon receipt of this command the server will simply turn it around and return success.

The server responds to the packet to indicate it is working properly. Used to allow the client to ping the server.

A cancel has no response but should result in the command itself either being completed successfully or failing with STATUS CANCELLED and it should happen as soon as possible. The operation being sent is identified because it will share the MessageId of the cancel command. This is the one case where a MessageId sent to the server may already have been used previously. If a response came with an AsyncId that should be present in the header and will be used to locate the command on the server.

An IOCTL is used for issuing a generic file system or device control command across the network. It packs the input and output buffers based on the METHOD of the control code and sends them across the network. The server side than repackages them and issues the FSCTL IOCTL against the file object. The results are likewise packed up and returned to the user with the status code. The set of allowable FSCTL IOCTL codes can be limited by both SRV or the underlying file systems. Not all are necessarily valid remotely. 

For buffered or direct requests only Input is valid on request and Output is sent on response. For neither requests both Input and Output are sent both ways.

The QueryDirectory call matches existing NT semantics very closely. The caller provides the InfoClass the FileId for the directory open the filename portion that specifies either the wildcard file search params or the resume name for an existing search and any valid SL flags associated with the call and SRV will return a buffer up to OutputBufferLength.

There is also a new flag SMB2 REOPEN that can be included in the QueryDirectory flags structure. This flag is a stronger version of the SL RESTART SCAN flag. The latter only allows restarting scans where the search specified hasn t changed. i.e. restart a . or a t search. The latter tells the server to restart a scan where the search specified has changed. To use this flag the caller must guarantee exclusive use across the call and no outstanding operations such as change notifies . The server takes the appropriate steps to perform this operation which may involve closing and reopening the underlying directory handle on the server side. This is transparent to the client.

This potentially long running operation allows a client to register for change notifications on a directory.

The caller sends the FileId for the directory along with a CompletionFilter specifying which changes the caller is interested in. They also can send the SL WATCH TREE flag to indicate a recursive notify operation. This operation will almost always invoke the async behavior since it can pend for an infinite amount of time. Also note that any further change notify requests on the same handle will pend waiting for the first to complete just as in local file system behavior.

Allows the client to query information from the remote system. Currently this can be used to query file information file system information security information or quota information.

The client specifies in the InfoType the SMB2 0 INFO  options to indicate whether this is a request for file information file system information security information or quota information. The FileId denotes the file in question for file info or security information. The volume the file resides on is used for file system info or quota requests.

The sub information level is filled into FileInfoClass and is dependent on the type of information being queried. For file information queries it will be a FILE INFORMATION CLASS where as for file system information it will be a FS INFORMATION CLASS. For quota and security it will be 0.

The input buffer is currently only used for Quota requests as they take the SMB2 QUERY QUOTA INFO structure on input to determine what is being asked for. For the other requests it will be empty.

Allows the client to set information on the remote system. Currently this can be used to set file information file system information security information or quota information.

The type of information being set and the specific class are set in the Flags and FileInfoClass fields as described for QUERY INFO. The input buffer provided is the information being set and the FileId identifies the file.

For SetSecurity calls the SecurityInformation field denotes the info being set. i.e. OWNER SECURITY INFORMATION etc. 

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

