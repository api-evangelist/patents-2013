---

title: Discovering and installing web application plugins
abstract: A method for discovering and installing web application plugins is disclosed. In one embodiment, such a method includes initiating a client-side component of a server-based web application. The client side-component hosts a first document. The method opens an inline frame, such as an IFrame or Web Worker, within the first document that hosts a second document. The method uses cross-document messaging to communicate, from the second document to the first document, metadata describing a plugin's capabilities and metadata describing an API to access the plugin's capabilities via cross-document messaging. The method utilizes the capabilities of the plugin using cross-document messaging in accordance with the API. A corresponding system and computer program product are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08839233&OS=08839233&RS=08839233
owner: International Business Machines Corporation
number: 08839233
owner_city: Armonk
owner_country: US
publication_date: 20130315
---
This invention relates to systems and methods for discovering and installing plugins for web applications.

A web application is an application that is accessed over a network such as the Internet. Commonly web applications are applications hosted in browser controlled environments e.g. Java applets or coded in browser supported languages e.g. JavaScript combined with a browser rendered markup language such as HTML and reliant on web browsers for execution. Web applications are popular because of the ubiquity of web browsers and the convenience of using a web browser as a client also referred to as a thin client. The ability to update and maintain web applications without distributing and installing software on potentially thousands of client computers is a key reason for their popularity as is the inherent support for cross platform compatibility. Common web applications include web email online retail sales online auctions and the like.

Typically adding new functionality also referred to as plugins or extensions to a web application that is designed for extensibility involves installing new software on the origin server i.e. the server hosting the web application . In cases where the new functionality is not directly installable on the origin server the origin server may act as a proxy to another server that offers the new functionality. Both of these approaches however may be subject to administrative overhead and delay since users may need to wait for administrators to add or reference the new functionality before the new functionality is available for use. In many cases adding or referencing the new functionality is a non trivial and expensive process. In many environments any modification to server side resources is considered highly undesirable since the modification has the potential to destabilize the web application and cause an outage for all users.

In view of the foregoing what are needed are improved systems and methods to add new functionality to web applications. Ideally such systems and methods can be implemented without modifying server side resources thereby reducing the chance that the addition will cause an outage. Such systems and methods will also ideally provide security and privacy to users wishing to use the new functionality.

The invention has been developed in response to the present state of the art and in particular in response to the problems and needs in the art that have not yet been fully solved by currently available systems and methods. Accordingly the invention has been developed to provide improved systems and methods for discovering and installing web application plugins. The features and advantages of the invention will become more fully apparent from the following description and appended claims or may be learned by practice of the invention as set forth hereinafter.

Consistent with the foregoing a method for discovering and installing web application plugins is disclosed herein. In one embodiment such a method includes initiating a client side component of a server based web application. The client side component hosts a first document. The method opens an inline frame such as an IFrame or Web Worker within the first document that hosts a second document. The method uses cross document messaging to communicate from the second document to the first document metadata describing a plugin s capabilities and metadata describing an API to access the plugin s capabilities via cross document messaging. The method utilizes the capabilities of the plugin using cross document messaging in accordance with the API.

It will be readily understood that the components of the present invention as generally described and illustrated in the Figures herein could be arranged and designed in a wide variety of different configurations. Thus the following more detailed description of the embodiments of the invention as represented in the Figures is not intended to limit the scope of the invention as claimed but is merely representative of certain examples of presently contemplated embodiments in accordance with the invention. The presently described embodiments will be best understood by reference to the drawings wherein like parts are designated by like numerals throughout.

As will be appreciated by one skilled in the art the present invention may be embodied as an apparatus system method or computer program product. Furthermore the present invention may take the form of a hardware embodiment a software embodiment including firmware resident software microcode etc. configured to operate hardware or an embodiment combining software and hardware aspects that may all generally be referred to herein as a module or system. Furthermore the present invention may take the form of a computer usable storage medium embodied in any tangible medium of expression having computer usable program code stored therein.

Any combination of one or more computer usable or computer readable storage medium s may be utilized to store the computer program product. The computer usable or computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device. More specific examples a non exhaustive list of the computer readable storage medium may include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CDROM an optical storage device or a magnetic storage device. In the context of this document a computer usable or computer readable storage medium may be any medium that can contain store or transport the program for use by or in connection with the instruction execution system apparatus or device.

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like conventional procedural programming languages such as the C programming language scripting languages such as JavaScript or similar programming languages. Computer program code for implementing the invention may also be written in a low level programming language such as assembly language.

Embodiments of the invention may be described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams may be implemented by computer program instructions or code. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be stored in a computer readable storage medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable storage medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring to one example of a client computing system is illustrated. The computing system is presented to show one example of an environment where a method in accordance with the invention may be implemented. The computing system is presented only by way of example and is not intended to be limiting. Indeed the methods disclosed herein may be applicable to a wide variety of different computing systems in addition to the computing system shown. The methods disclosed herein may also potentially be distributed across multiple computing systems .

As shown the computing system includes at least one processor and may include more than one processor . The processor may be operably connected to a memory . The memory may include one or more non volatile storage devices such as hard drives solid state drives CD ROM drives DVD ROM drives tape drives or the like. The memory may also include non volatile memory such as a read only memory e.g. ROM EPROM EEPROM and or Flash ROM or volatile memory such as a random access memory RAM or operational memory . A bus or plurality of buses may interconnect the processor memory devices and other devices to enable data and or instructions to pass therebetween.

To enable communication with external systems or devices the computing system may include one or more ports . Such ports may be embodied as wired ports e.g. USB ports serial ports Firewire ports SCSI ports parallel ports etc. or wireless ports e.g. Bluetooth IrDA etc. . The ports may enable communication with one or more input devices e.g. keyboards mice touchscreens cameras microphones scanners storage devices etc. and output devices e.g. displays monitors speakers printers storage devices etc. . The ports may also enable communication with other computing systems .

In certain embodiments the computing system includes a network adapter to connect the computing system to a network such as a LAN WAN or the Internet. Such a network may enable the computing system to connect to one or more servers workstations personal computers mobile computing devices or other devices. The network may also enable the computing system to connect to another network by way of a router or other device . Such a router may allow the computing system to communicate with servers workstations personal computers or other devices located on different networks.

Referring to one example of a conventional system for adding functionality to a web application is illustrated. As shown a web application is stored on a server also referred to as an origin server . This web application may be accessed by a client computer over a network such as the Internet or an intranet. As shown the web application includes a client side component which is hosted in a web browser of the client computer . In one example the client side component includes software applications such as Java applets that are configured to run in the web browser using a Java Virtual Machine Java Virtual Machine . In another example the client side component includes software applications that are coded in browser supported languages such as JavaScript or JavaScript combined with a browser rendered markup language such as HTML. Other examples of client side components are possible and within the scope of the invention.

In a conventional system such as that illustrated in adding new functionality referred to hereinafter as plugins or plugin applications to a web application that is designed for extensibility may involve installing new applications on the origin server . Adding functionality in this manner can be both non trivial and expensive. For example properly installing and configuring a plugin application may involve issues such as deciding which users of the web application will be allowed to see and or use the new functionality i.e. some users may not want or require the new functionality while other users may be prohibited or restricted from using the new functionality . In short installing and configuring new plugin applications may involve substantial administrative overhead requiring users to wait for an administrator to add new functionality to the origin server before the new functionality can be used.

Adding new applications to the origin server unfortunately has the potential to destabilize the origin server . This is highly undesirable since any destabilization may cause the web application to experience an outage possibly denying access to all users. For example an outage associated with a web banking application or similar web applications can be extremely expensive even for very short periods of time. Thus modifying the origin server in any way may be viewed as highly undesirable.

Referring to another conventional system for installing web application plugins is illustrated. In cases where new functionality is not directly installable on an origin server the origin server may act as a proxy to another server that offers the new functionality . In such a case the origin server may act on the client s behalf to retrieve or access new functionality located on another server . In addition to introducing the administrative overhead and delay discussed above with respect to this approach may also introduce unwanted complexity as well as various security issues.

One disadvantage of the conventional approaches illustrated in is that they can potentially compromise the security and or privacy of a user using a particular plugin application . For example because all requests are routed to an origin server the origin server will mediate all data exchanges and communications with the plugin application . This is the result of the single origin policy which is an important security concept for browser side programming languages such as JavaScript. This policy permits scripts running on pages originating from the same site to access each other s methods and properties without any restrictions but prevents access to most methods and properties originating from pages of different sites. Unfortunately this policy may also have the undesired effect of exposing the origin server to information that a user wants kept private. Thus improved systems and methods are needed to discover install and utilize plugin applications in a way that circumvents the single origin policy while not compromising security.

Referring to a high level view of one embodiment of an improved system for discovering and installing web application plugins is illustrated. As shown instead of modifying the origin server where a web application resides as shown in or modifying a server for which the origin server acts as a proxy as shown in the client side component is configured to discover and install plugin applications in a way that circumvents the single origin policy while still preserving security. More specifically the client side component is configured to discover and install plugin applications on a different server and site than the origin server . This allows a user to keep certain information private that may otherwise be exposed to the origin server . The details of how the system works will be described in association with .

Referring to a high level block diagram showing a more detailed view of the system of is illustrated. As shown a client side component includes a plugin registry which stores metadata for each installed plugin associated with a web application . In certain embodiments the client side component uses the browser s localStorage or sessionStorage i.e. storage provide by the browser to implement the plugin registry . In certain embodiments the plugin registry is used in conjunction with a more durable data store on the server although this is not necessary. The server data store may provide a way to ensure that if plugins are installed on a first machine e.g. a personal desktop computer of a user the environment can be replicated on another machine e.g. a laptop of the user without having to reinstall the plugins . Thus each machine of a user may access the user s metadata in the data store .

In certain embodiments the metadata in the plugin registry may contain information needed to identify each installed plugin such as a Universal Resource Locator URL for each installed plugin . The metadata may also include data needed to provide an entry point into the client side component for each installed plugin i.e. inform the client side component of the capabilities provided by each installed plugin application . The metadata may also include information indicating how to load the functional capabilities of the installed plugins into the client side component when the capabilities of the plugins are needed.

As shown in the client side component may host a first document e.g. a first HTML page that originates from the origin server hosting the web application . To install a new plugin the client side component opens an inline frame e.g. an HTML IFrame or Web Worker in the first document . This inline frame hosts a second document e.g. a second HTML page that originates from a site that hosts the plugin application . In most cases this site and plugin application will reside on a different server than the origin server .

The second document is configured to use cross document messaging e.g. window.postMessage to communicate the plugin s metadata which describes the plugin s capabilities and how to use the capabilities to the client side component . This in essence exposes the plugin s application programming interface API to the client side component . At this point the client side component may decide to discard the metadata if the plugin does not provide the desired functionality. Alternatively the client side component may decide to use the plugin s capabilities by exchanging data and parameters with the open inline frame using cross document messaging in accordance with the API.

If the client side component wants to use the plugin at a later time the client side component potentially with the authorization or input of a user may conceptually install the plugin . Installing the plugin may be as simple as recording all or part of the metadata received from the inline frame in the plugin registry . As described above the metadata may include information describing the capabilities of the plugin as well as information needed to locate and access the capabilities. When installation is complete the client side component may close the associated inline frame or decide to immediately make use of the plugin s capabilities in which case the inline frame may remain open. As mentioned above the client side component may utilize the plugin s capabilities by exchanging data and parameters with the open inline frame using cross document messaging.

If the client side component closes the inline frame but later decides to use the plugin s capability the client side component may simply open a new inline frame and locate the plugin application using the identity information stored in the plugin registry . The client side component may then utilize the plugin s capabilities using cross document messaging as described above. To uninstall a plugin the client side component may simply delete the plugin s metadata from the plugin registry . This may include deleting the plugin s metadata from the server data store if such a data store exists.

In certain embodiments to take advantage of the capabilities of an installed plugin in a certain context or situation the client side component may provide a context menu whose entries are supplied from the metadata in the plugin registry . For example consider the case where the web application is an online text editor used to edit program code such as JavaScript and the plugin application hereinafter referred to as a coloring plugin is a software application used to color different portions of the program code in accordance with the code s syntax thereby making the program code more readable.

In one embodiment in order to utilize the functionality of the coloring plugin the user may right click on a portion of the program code to reveal the above described context menu. This context menu may display a list of one or more plugin applications that may be used to perform various operations or transformations on the text of the program code. Selecting the coloring plugin option from the context menu may trigger the opening of an inline frame to load the coloring plugin . The functionality of the coloring plugin may then be accessed by exchanging data and parameters with the inline frame using cross document messaging. For example the client side component could pass the program code to the coloring plugin application using cross document messaging and the coloring plugin application could operate on the program code and return the syntax colored program code to the client side component by way of cross document messaging. The client side component may then display the syntax colored program code to the user for editing.

Later the user may choose to uninstall the coloring plugin . This will delete the coloring plugin s metadata from the plugin registry . The next time the user uses the online text editor and right clicks on the program code a context menu will appear that omits the coloring plugin as an option.

Other techniques or graphical elements other than a context menu may be used to trigger the opening of inline frame and loading of an associated plugin application . The example provided above is simply an example and is not intended to be limiting.

The systems and methods discussed in association with provide various advantages over conventional systems and methods for installing plugin applications . For example the improved systems and methods may be implemented without modifying the origin server . This reduces the chance that the origin server will be destabilized. The systems and methods may also reduce networking and trust overhead that is introduced by using the origin server as a proxy to another server . Because the plugin application is isolated from the host web application the implementer is free to implement the plugin application as he or she sees fit. Furthermore the disclosed systems and methods may provide increased security and privacy to users since communications with the plugin application are not necessarily routed through the origin server .

The block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer usable storage media according to various embodiments of the present invention. In this regard each block in the block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions discussed in association with a block may occur in a different order than discussed. For example two functions occurring in succession may in fact be implemented in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and combinations of blocks in the block diagrams may be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

