---

title: Management and prioritization of processing multiple requests
abstract: Systems and methods are described for systems that utilize an interaction manager to manage interactions—also known as requests or dialogues—from one or more applications. The interactions are managed properly even if multiple applications use different grammars. The interaction manager maintains a priority for each of the interactions, such as via an interaction list, where the priority of the interactions corresponds to an order in which the interactions are to be processed. Interactions are normally processed in the order in which they are received. However, the systems and method described herein may provide a grace period after processing a first interaction and before processing a second interaction. If a third interaction that is chained to the first interaction is received during this grace period, then the third interaction may be processed before the second interaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08660843&OS=08660843&RS=08660843
owner: Microsoft Corporation
number: 08660843
owner_city: Redmond
owner_country: US
publication_date: 20130123
---
This patent application claims priority to U.S. patent application Ser. No. 11 275 189 filed Dec. 16 2005 and entitled Systems And Methods For Managing Interactions From Multiple Speech Enabled Applications which claims priority to U.S. patent application Ser. No. 10 067 519 filed Feb. 4 2002 and entitled Systems And Methods For Managing Interactions From Multiple Speech Enabled Applications which issued as U.S. Pat. No. 7 139 713 on Nov. 21 2006.

The systems and methods described herein relate to speech systems and speech enabled applications that run on speech systems. More particularly the described invention relates to managing interactions from multiple speech enabled applications that utilize more than one grammar.

Speech systems have been incorporated into many useful applications so that users may utilize the applications without having to manually operate an input device such as a mouse or a keyboard. Personal computer systems desktop laptop handheld etc. and automobile systems are only two examples of systems or platforms that may include integrated speech recognition functions.

A single platform may have several applications executing at a given time. For example in an automobile computer system that utilizes speech recognition software there may be speech enabled applications for radio operation navigational tools climate controls mail etc. Personal computers may include word processors spreadsheets databases and or other programs that utilize speech recognition. Each speech enabled application has a grammar associated with it that is a set of commands that the application is attempting to detect at any one time.

Different applications may have different grammars. For instance a word processing speech enabled application may use a grammar that enables it to detect the command print. However an automobile speech enabled application that controls a car radio would not have such a command. On the other hand the car radio application may have a grammar that enables the speech system to recognize the command FM to set the radio to the FM band. The word processor would not waste overhead by including an FM command in its relevant grammar.

As the number of speech enabled applications and grammars has increased it has become increasingly problematic to run multiple speech enabled applications on a single platform. Although each speech enabled application may have its own unique grammar certain commands may be used in more than one grammar e.g. stop. When a speech system receives such a command it must be able to determine which application the speaker directed the command to and which application should respond to the user.

Similarly multiple speech enabled applications may attempt to deliver speech feedback simultaneously. This can result in a garbled communication that a user cannot understand. Such a result renders one or more of the applications useless. Also if speech feedback from one speech enabled application interrupts speech feedback from another similar application the feedback from one or both applications may not be understandable to a user.

For example suppose a first application asks a question of the user and awaits a response. But before the user responds to the first application a second application asks the user a question. Which application will accept the user s first answer Will one of the applications accept an answer intended for the other application Will either application be able to function properly with the response s it receives With no control over specific interactions between the system and the user there is no certain answer to any of these questions.

One method that has been devised to handle this problem is to create a token that indicates which application has the right to execute at any given time. When an application is ready to execute it requests a token. When the application receives the token the application may execute.

One of several drawbacks of such a system is that applications may crash or hang. If an application that currently holds the token crashes then the system may not recover unless the system is prepared for application crashes. If the application hangs then the system may never be able to regain control. Therefore a token system is an inadequate solution to the problems encountered when attempting to execute multiple speech enabled applications.

Another problem that is encountered by speech enabled applications is that when a command is given to an application that is not currently running the command simply falls on deaf ears so to speak and there is no response to the command. Therefore a user must first manually or vocally launch the application then speak the desired command for the application. This means that a user must always be aware of which applications are running and which are not so that the user knows whether she must launch an application before issuing certain commands. For example if an automobile driver wants to play song A.mp3 on a car radio the driver must first issue a command or manually launch an MP3 player then command the player to play song A. It would be desirable to minimize the actions required to launch an application and subsequently issue a command.

Systems and methods are described for managing and prioritizing requests e.g. interactions in a system e.g. a speech system which may utilize more than one grammar from more than one speech enabled applications. More particularly the systems and processes described herein may assign priorities to multiple requests where a priority of each request may correspond to a priority in which the request is to be processed by the system. For instance a first request that has a higher priority may be processed before a second request having a lower priority.

In one or more implementation a speech system interaction manager hereinafter an interaction manager is described. An interaction as used herein is defined as a complete exchange between a user and a speech system. The interaction manager manages interactions between multiple speech applications and a user so that a it is clear to the user which application the user is speaking to and b it is clear to the applications which application is active.

When an application wishes to utilize a speech system the application submits an interaction to the interaction manager. The submitted interaction is assigned a priority relative to other previously received interactions such as being placed within an interaction list containing interactions to be processed by the speech system. For instance the submitted interaction may be assigned a lower processing priority with respect to other previously submitted interactions. The only time that an interaction is assigned a priority that is higher than the priority of previously submitted requests is when an application indicates that the interaction is to be given a higher e.g. a highest priority i.e. the interaction is to be processed immediately. If this is indicated the interaction is assigned a higher or highest priority. In one implementation this indication is made by the application designating a particular grammar to be used with the interaction that is configured to be processed immediately. This type of grammar is referred to as a global grammar.

If an interaction is added to the interaction list while another interaction is being processed then the interaction waits until the current interaction has concluded processing unless the application specifies in the interaction that the interaction is to interrupt any interaction currently being processed. If this is so indicated then the current interaction is interrupted so that the interrupting interaction can be processed. After the interrupting interaction is processed the interrupted interaction may be configured to pick up where it left off start over re prompt somewhere in the middle of the interaction or cancel itself. Interaction processing then proceeds normally.

In some embodiments after processing a first request e.g. interaction the system may wait a period of time e.g. a predetermined grace period before beginning to process a second request that has a next highest priority. If the system receives a third request during this period of time and it is determined that the third request is chained to e.g. related to associated with etc. the first request then the system may process the third request prior to processing the second request.

An application may also indicate that an interaction is not to be added to the interaction list if the interaction list is not empty at the time the interaction is submitted. Such an indication may be used on an interaction that pertains to time sensitive data that may be stale if it is not processed immediately but is not of an importance such that it should interrupt another interaction.

The interaction manager keeps applications informed as to the status of interactions belonging to the applications. For example the interaction manager sends messages to applications such as an interaction activated message an interaction interrupted message an interaction self destructed message an interaction re activated message and an interaction completed message.

The interaction manager keeps track of the interactions being processed by the speech system so that the speech system only processes one interaction at a time. In this way the interactions are processed in an orderly manner that allows multiple applications to run concurrently on the speech system even if the multiple applications each use a different grammar. As a result a user can better communicate with each of the applications.

This invention concerns a speech system that is able to manage interactions from multiple speech enabled applications to facilitate meaningful dialogue between a user and the speech system. This invention speech system may be applied to a continuous speech system as well as a discrete speech system.

Furthermore the invention may be described herein as an automobile speech system or systems. However the invention may also be implemented in non automobile environments. Reference may be made to one or more of such environments. Those skilled in the art will recognize the multitude of environments in which the present invention may be implemented.

Following is a brief description of some of the terms used herein. Some of the terms are terms of art while others are novel and unique to the described invention. Describing the terms initially will provide proper context for the discussion of the invention although the descriptions are not meant to limit the scope of the terms in the event that one or more of the descriptions conflict with how the terms are used in describing the invention.

As previously stated each speech enabled application likely has its own specific grammar that a speech system must recognize. There are a variety of different things that applications will want to do with their grammars such as constructing new grammars using static grammars enable disable rules or entire grammars persist grammars make the grammars continually available etc. The speech system described herein exposes methods to accomplish these things and more.

Different grammars can have different attributes. A static grammar is one that will not change after being loaded and committed. A dynamic grammar to the contrary is a grammar that may change after a commit Whether a grammar is static or dynamic must be known when the grammar is created or registered with the speech system. Rules may also be static or dynamic. A static rule cannot be changed after it is committed while a dynamic rule may be changed after it is committed. A static rule can include a dynamic rule as a part of the static rule.

A grammar may at any time be an enabled grammar or a disabled grammar. A disabled grammar is still within the speech system but is not being listened for by the system. An enabled grammar may also be called an active grammar a disabled grammar may also be referred to as an inactive grammar.

Reference is made herein to transient and persistent grammars. A transient grammar is a grammar that is only active while its corresponding application is executing. When the application halts execution i.e. shuts down the grammar is removed from the speech system. A persistent grammar is always present in the speech system whether the application to which the grammar belongs is present in the system. If an utterance is heard that belongs to a persistent grammar and the application is not running to handle it the speech system launches the application.

Furthermore reference is made herein to global and yielding grammars. A global grammar contains terms that the speech system is always listening for. Global grammars are used sparingly to avoid confusion between applications. An example of a global grammar is a call 9 1 1 command. A yielding grammar is active unless another grammar takes focus. The reason that another grammar would take focus is that a conversation unrelated to the grammar becomes active and yielding grammars outside the conversation are disabled.

The term interaction is used herein to refer to a complete exchange between a speech enabled application and a user. An interaction is a context of communication that unitizes one or more elements of a dialogue exchange. For example an application developer may want to program a speech enabled application to alert a user with a tone ask the user a question and await a response from the user. The developer would likely want these three events to occur sequentially without interruption from another application in order for the sequence to make sense to the user. In other words the developer would not want the alert tone sounded and the question asked only to be interrupted at that point with a communication from another application. The user may then not know how or when to respond to the question. Therefore with the present invention the developer may include the three actions in one interaction that is submitted to a speech system for sequential execution. Only in special circumstances will an interaction be interrupted. Interactions will be discussed in greater detail below.

A series of related interactions may be referred to herein as a conversation. A conversation is intended to execute with minimal interruptions.

The invention is illustrated in the drawings as being implemented in a suitable computing environment. Although not required the invention is described in the general context of computer executable instructions such as program modules to be executed by a computing device such as a personal computer or a hand held computer or electronic device. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations including multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The speech system includes a speech engine having a text to speech TTS converter and a speech recognizer SR . The TTS converter and the speech recognizer are components typically found in speech systems. The speech recognizer is configured to receive speech input from the microphone and the TTS converter is configured to receive electronic data and convert the data into recognizable speech that is output by the speaker .

The speech system also includes a speech server that communicates with the speech engine by way of a speech application programming interface SAPI . Since the speech engine is separate from the speech server the speech server can operate with any number of vendor specific speech engines via the speech API . However such a specific configuration is not required.

The SAPI includes a vocabulary that is the entire set of speech commands recognizable by the speech system . It is noted that speech engine may include the vocabulary or a copy of the vocabulary that is contained in the SAPI . However the present discussion assumes the vocabulary is included in the SAPI .

Several applications may be stored in the memory including application1 application2 and application n . Depending on the components that make up the computer system virtually any practical number of applications may be stored in the memory for execution on the speech server . Each application is shown including at least one control Application1 includes a question control application2 includes an announcer control and application n includes a command control and a word trainer control .

Each control uses a specific grammar the question control uses grammar1 the announcer control uses grammar2 the command control uses grammar3 and the word trainer control uses grammar4 .

The controls are designed to provide application developers a robust reliable set of user interface tools with which to build applications. The controls are code modules that perform recurring functions desired by application developers. The controls decrease the programming effort required by an original equipment manufacturer or an independent vendor to create a rich application user interface.

The question control gives an application developer an easy way to create various system initiated interactions or dialogues. The announcer control provides a developer a simple way to deliver verbal feedback to users including short notices and long passages of text to speech. The command control provides a way for applications to specify what grammar it is interested in listening to and communicates to the applications if and when a recognition occurs. The word trainer control provides an easy way to implement a speech oriented word training interaction with a user. These controls will be discussed in greater detail below.

It is noted that the speech server and the applications are separate processes. In most modern operating systems each process is isolated and protected from other processes. This is to prevent one application from causing another application that is running to crash. A drawback with utilizing separate processes is that it makes sharing data between two processes difficult which is what the speech server needs to do in this case. Therefore data must be marshaled between the applications and the speech server .

There are various ways to marshal data across process boundaries and any of those ways may be used with the present invention. A common way to marshal data is with the use of a proxy and a stub object. A proxy resides in the application process space. As far as the proxy is concerned the stub object is the remote object it calls. When an application calls some method on a proxy object it does so internally which is necessary to package data passed by the application into the speech server process space the stub object receives the data and calls a target object in the speech server. However it is noted that any method known in the art to marshal data between processes may be used.

The speech server also includes an interaction manager and a master grammar table . The master grammar table contains one or more grammars that are registered with the speech server by one or more applications. The master grammar table and the registration of grammars will be discussed in greater detail below with reference to .

The interaction manager maintains an interaction list of one or more interactions interaction1 interaction2 interaction3 interaction n from one or more applications in a particular order for processing by the speech server . As previously discussed an interaction is a logical context used by an application to communicate with a user. At any given time there can be at most one active interaction between the user and an application. The interaction manager processes the interactions in order. Interactions can be inserted at the front of the interaction list i.e. before interaction1 or at the end of the interaction list i.e. interaction n. If an interaction is inserted at the front of the interaction list the processing of interaction1 will be interrupted. In one implementation the interrupting interaction will only interrupt a current interaction if the interrupting interaction is configured to take precedence over a currently executing interaction.

The interaction manager is also configured to notify the applications of the following transitions so that the applications may modify the state or content of an interaction as it is processed in the interaction list interaction activated interaction interrupted interaction self destructed interaction re activated and interaction completed. As a result the applications can be aware of the state of the speech system at all times.

As previously noted an interaction contains one or more elements that represent a turn of communication. A turn is a single action taken by either the system of the user during an interaction. For example the system may announce Fast or scenic route during a turn. In response the user may answer Fast which is the user s turn.

There is another type of element not shown that may be inserted into an interaction to cause a delay or time out before the system processes subsequent elements. This type of element is referred to as a NULL element. A NULL element would be inserted into an interaction to allow additional time for the interaction to be processed.

Referring now back to the interaction manager provides for the ordering of interactions including the elements EC TTS WT NULL SR discussed above. This prevents more than one application from addressing the user simultaneously. The interaction manager processes the interactions in the interaction list in the order in which the interactions are submitted to the interaction manager i.e. on a first in first out basis . An exception to this is that an application is provided the ability to submit an interaction directly to the beginning of the interaction list in situations where the application considers the interaction a high priority.

At block interaction A is active while interaction B and interaction C wait in the interaction list to be processed. At block interaction n is added to the end of the interaction list . Interaction A continues processing at block No branch block until it concludes. Then interaction B becomes active i.e. begins processing at block Yes branch block .

Interruption occurs when an application places an interaction at the beginning of the interaction list without regard to an interaction already active there. When an interruption occurs the active interaction is deactivated and the interrupting interaction is activated.

Interaction n is then processed at block No branch block until it has completed i.e. actions related to any and all elements contained in interaction n have been performed. Only when interaction n has completed processing Yes branch block does interaction A have the capability to process again.

However interactions submitted to the interaction list have a self destruct option that when used terminates the interaction in the event that the interaction is interrupted. In some cases an interaction may need to self destruct due to internal failure. In such cases the situation is treated the same as a normal self destruction.

At block it is determined whether interaction A has set a self destruct flag that indicates the interaction should self destruct upon interruption. If the self destruct flag not shown is set Yes branch block interaction A terminates block . If the self destruction flag is not set No branch block then interaction A finishes processing at block .

Interactions do not have an inherent priority. The applications only have an absolute ability to place an interaction at the front of the interaction list . Such a placement results in interruption of a current interaction being processed.

In another implementation not shown an interrupting interaction will not be processed until a current interaction has concluded if the current interaction will conclude in a pre determined period of time. If the current interaction will take a longer amount of time than the pre determined time to conclude it is interrupted as described above.

For example suppose that an interrupting interaction will only interrupt a current interaction if the current interaction will not complete within three seconds. If a driver is just completing a long interaction that has taken thirty seconds to process but will conclude in two seconds it may be desirable to let the interaction finish before interrupting with say an engine overheating announcement. If the current interaction is not self destructing the driver may have to endure another thirty two seconds of interaction that he doesn t want to hear if the current interaction is repeated after the overheating announcement concludes. This would become even more irritable if another engine overheating announcement interrupted the current interaction again and the current interaction repeated again.

Interactions may also be chained together by speech enabled applications using the speech server . An application may want a certain interaction to establish a chain of interactions that constitutes a conversation. When this is the case when an interaction concludes processing the speech server will wait a pre determined grace period or time out before processing the next interaction in the interaction list . During the grace period the application may submit a subsequent interaction.

An example of when interaction chaining may be used is when an automobile navigation system queries a driver for a destination. The navigation application may submit an interaction that asks for a destination state. If the state is submitted the application may then submit an interaction that asks for a destination city. If the driver submits the city the application may then submit an interaction that asks for the destination address.

It is easy to understand why a navigation application would not want these interactions broken up. If the interactions are separated the driver or the speech system may become confused as to where the other is in the dialogue.

At block interaction A is active while interaction B and interaction C are inactive and waiting in the interaction list to be processed. After interaction A concludes processing at block the interaction manager waits for the pre determined grace period before moving on to processing interaction B block .

At block the application that submitted interaction A submits interaction n to be processed to complete the conversation. The submission of interaction n occurs before the grace period has expired. If interaction n is not submitted before the grace period expires interaction B will begin processing.

When interaction n is submitted before the grace period expires Yes branch block interaction n is processed immediately at block . There are no additional interactions to be processed after interaction n has completed processing No branch block so interaction B begins processing at block . The desired result is achieved because the complete conversation interaction A and interaction n was processed without separating the interactions.

Although it is not typically desired chained interactions may be interrupted by another application. If an application submits an interaction that is flagged to be processed immediately that interaction will be placed at the front of the interaction list even if doing so will interrupt a conversation. This is one reason that use of the process immediately option should be used sparingly by applications. An example of when the process immediately option may be used is when an automobile engine is overheating. It is probably desirable to interrupt any interactions being processed to tell the driver of the situation since the situation requires immediate attention.

At block interaction A is active while interaction B and interaction C are inactive and waiting in the interaction list to be processed. When interaction A concludes processing at block a grace period is established at block .

If no interaction is submitted by the same application No branch block then interaction B is processed at block . However in this example interaction n is submitted before the grace period expires Yes branch block . Therefore interaction n begins processing at block . At block interaction m is submitted and is flagged to be processed immediately so it begins processing at block . Interaction m continues to be processed until it is completed No branch block . When interaction m has concluded Yes branch block the interaction manager determines if interaction n which was interrupted is set to self destruct in the event that it is interrupted. If interaction n is to self destruct Yes branch block then interaction B begins to be processed at block . If interaction n does not self destruct No branch block then interaction n finishes processing at block .

Interruptions may also occur during a grace period because the grace period does not preclude any application from interrupting. is a flow diagram that depicts the process that takes place when an application submits an interrupting interaction during a grace period. As before a current state of the interaction list is shown corresponding to the blocks of the flow diagram.

At block interaction A is active while interaction B and interaction C are inactive and waiting in the interaction list to be processed. When interaction A concludes processing at block a grace period is established at block .

Before the grace period has timed out interaction n interrupts and is placed at the front of the interaction list block . It is noted that interaction n is not a part of the conversation that began with interaction A . Interaction n is processed at block for as long as the interaction needs to run No branch block . Only when interaction n has concluded processing Yes branch block will interaction B the second interaction of the conversation be processed block .

An application may also indicate that an interaction is not to be added to the interaction list if the interaction list is not empty at the time the interaction is submitted. One scenario in which this might be desirable is in the event that an application included a verbal clock that announced a current time every minute. If during the time where the minute would normally be announced another application was speaking to the user the announcement interaction would not be added to the interaction list because the announcement might be out of date by the time it is processed.

Another scenario might be a navigation application that announces a current location block by block as one drives e.g. You are on 1and Main . . . You are on 2and Main etc. It would not be desirable to add such interactions to the interaction list if the driver were speaking to another application.

The interaction manager must also use specific attributes of each grammar that it processes to process grammar interactions correctly. When the speech system is initially booted any applications that are present at startup are registered with the master grammar table whether running or not so that the speech system is aware of each grammar that may possibly be active. Additionally if an application launches or is added while the speech system is running the application will register its grammar in the master grammar table .

As shown in a grammar table for grammar1 is included in the master grammar table . Similarly a grammar table for grammar2 a grammar table for grammar3 and a grammar table for grammar4 are included in the master grammar table . It is noted that practically any number of grammar tables may be stored in the master grammar table between grammar table and grammar table .

The grammar identifier is a value that is uniquely associated with a grammar that corresponds to the grammar table . The grammar identifier is used with interactions to identify a grammar that is associated with the grammar identifier. Including the grammar identifier with an interaction solves a problem of latency that is inherent in the speech system . After an application submits an interaction that is placed in the interaction list of the interaction manager the application must wait until the interaction reaches the front of the interaction list before it is processed. When the interaction finally reaches the front of the interaction list the speech server immediately knows which grammar from the master grammar table is associated with and therefore used with the interaction. If the grammar identifier were not included in the interaction the speech server would first have to notify the application that the interaction submitted by the application is about to be processed. Then the speech server would have to wait for the application to tell it which grammar to utilize. Since the grammar identifier is included with a submitted interaction the speech server can begin processing the interaction immediately.

The executable command is a command including a path if necessary that may be used to launch an application associated with the grammar table . This allows the speech server to launch an application with the executable command even though the corresponding application is not loaded into the system. If the speech server receives an indication that a recognition occurs for a particular grammar the speech server passes the recognition to an application that has registered the grammar if such an application is running. If however no application using the identified grammar is running the speech server launches the application and passes the recognition to the application. This solves the problem of having to first launch an application manually before it may receive a command.

For example suppose an automobile driver is driving down the road when she decides she wants to play an MP3 file by say David Bowie on the automobile radio. Assume for this example that the executable command is a typical path such as win . . . mp3.exe and that the recognition term is play mp3. 

Instead of having to manually activate an MP3 player and then command it to play David Bowie the driver simply commands the system to play MP3 David Bowie. Even though the MP3 player may not be running the speech server will recognize the command play MP3 and execute the executable command to start the MP3 player. The grammar associated with the MP3 player not shown will recognize David Bowie and play the desired selection that is associated with that command.

The global flag is a value that when set indicates that the grammar associated with the grammar table is a global grammar that may not be interrupted by another application or the speech system but only the same application . If the global flag is not set then the grammar is a yielding grammar that can be interrupted by other applications or by the speech system . As will be discussed in greater detail below a global grammar is always active although parts of it may be deactivated by the application to which it corresponds.

It is noted that the global flag may be implemented as a yielding flag not shown which when set indicates that the grammar is not a global grammar. The logic described for utilizing the global flag would in that case simply be reversed.

The persistent flag is a value that when set indicates that the grammar associated with the grammar table is persistent and not transient. A persistent grammar is a grammar that is loaded by default when the speech system is running irrespective of the run state of its corresponding application. If the persistent flag is set then the grammar associated with the grammar table should not be removed from the master grammar table .

The active flag is a value that when set indicates that the grammar associated with the grammar table is currently active. When a grammar is active the speech recognitions system actively listens for the commands included in the grammar. When an interaction is submitted to the interaction manager the interaction manager indicates to the speech server that other grammars should yield to a certain grammar if applicable. The speech server sets the active flag to a value that indicates the grammar associated with the grammar table is active. Simultaneously the interaction manager will clear the active flag for each yielding grammar in the master grammar table . As a result the set of commands that the speech system listens for is reduced.

When the yielding grammars are de activated i.e. the active flags are cleared any grammar that is global i.e. the global flag is set remains active. This is because a global grammar is always active. Therefore at any given time that an application is executing the speech system is listening for all global grammars in the master grammar table and one yielding grammar that is currently active i.e. is associated with the application that is currently executing in the master grammar table . If no application is currently executing the speech system listens for all grammars whether global or yielding.

In one implementation the speech server does not de activate all yielding grammars other than a grammar associated with a currently executing application unless an interaction in the interaction list includes a method that informs the speech server that all other yielding grammars should be de activated. When the interaction manager identifies such a method the interaction manager sends a message to the speech server to de activate all other yielding grammars in the master grammar table .

Finally the static flag is a value that when set indicates that the grammar associated with the grammar table is a static grammar and therefore will not change after it is registered in the master grammar table .

The functional scenarios that follow are not discussed in detail with respect to the speech system but may also be implemented with the features described above. The functional scenarios merely require that the interaction manager be configured to handle the scenarios.

Push to talk PTT is used to indicate that a command from the user is imminent which allows a user to initiate a command. For example a user may PTT and say lock the doors to actuate a vehicle s door locks. A push to talk PTT event instantiated by a user interrupts any current interaction.

PTT may also be used to provide a response to a system initiated interaction. For example if a navigation application asks Fast or scenic route the user pushes push to talk and answers fast or scenic. 

The speech server may also be configured to allow a user to barge in with a response. For example if a navigation application asks Fast or scenic route the user may interrupt without PTT and answer fast or scenic. 

The speech server may be configured to provide an immediate response to a user command. For example while an automobile system is announcing a driving instruction to a driver the driver commands the system to disconnect. The speech server either disconnects immediately or confirms the disconnect command by stating OK to disconnect interrupting the original driving instruction.

The applications may also abort an interaction in certain circumstances. For example a navigation application needs to tell a driver that a point of interest is drawing near but other applications are currently talking to the driver. By the time the other applications have concluded the point of interest is passed. The navigation application aborts the announcement interaction before it begins. If the point of interest has not been passed the announcement is made delaying only until the other applications have concluded.

The speech server may also de activate some grammars and leave active an interaction specific grammar. For example a navigation application asks a driver fast or scenic route. Since the interaction is expecting a specific reply for a specific grammar the specific grammar is activated or remains active to give the words fast and scenic priority over other grammars. This reduces the overhead required to process the driver s response since the speech server does not have to listen for as many terms.

The speech server may also be configured to enhance a prompt during an interrupted conversation. If for example a navigation application asks for the driver s destination by stating first please say the state. The driver responds with the destination state. The navigation application then asks please say the city. However during the announcement or before the driver answers with the destination city the question is interrupted with an important announcement. After the announcement concludes the original conversation resumes. To make up for the lost context the speech server is configured to revise the question to for your destination please say the city. By re focusing the driver on the navigation application conversation the driver is less likely to be confused about what the system is saying.

The speech controls are provided in the speech server to provide timesaving tools to developers who create applications to run with the speech server . The speech controls are computer executable code modules that provide canned functions for developers to use for common interactions utilized in speech enabled applications thereby saving the developers the time and effort required to code the interaction for each use.

The question control gives an application developer an easy way to create various modal system initiated interactions or dialogues. Such interactions are used to obtain information from a user by asking the user a question. The following scenarios exemplify common uses of the question control to obtain desirable characteristics.

User Interface Consistency A user tries an in car computer system in his friend s car. He then goes out to shop for a new car. He notices that although other systems sound a little different working with their speech user interface dialogues is just the same.

Application Compatibility A user buys a full featured navigation system software package for her car computer. She then buys a new car of a different make. She is still able to install her navigation software in her new car and it works the same as it did in her old car.

Hardware Software Compatibility A developer can design a unique speech hardware and or software subsystem to work in conjunction with the question control without compromising application compatibility or user interface consistency.

The question control allows flexible programming so that a variety of question scenarios can be implemented. For example the question control may be used to ask a driver a simple question that may be answered yes or no or a more complex question such as fast or scenic route and receive fast or scenic as appropriate answers.

The question control also allows greater flexibility by allowing the use of dynamic grammars. A question control has a grammar associated with it. In the above examples the grammar may only consist of yes and no or fast or scenic. The question control can be configured by a developer or OEM to standardize behavior of certain types of questions that can t be provided with a simple list. For example a hierarchical grammar such as a time or date grammar may be associated with a question control. Such types of grammars involve too many list choices to practically list for a user.

The question control may also be used to provide an interrupting question. For example while a system is reading a news story via TTS a car application asks Your gas tank is close to empty do you want instructions to the nearest gas station Similarly a question programmed with the question control may be interrupted. For example while an e mail application is asking You have mail do you want to read it now a car application announces Your engine is overheating. 

TYPE PROPERTY The question control supports a Type property that can be used to determine the behavioral or content characteristics of the application using the question control. The Type property ultimately determines properties used in defining the application s behavior.

INTERRUPTING PROPERTY The Interrupting property determines whether the application will interrupt other interactions in the interaction list of the interaction manager . If the Interrupting property value is true then the application i.e. the question created with the question control interrupts any other interaction in the interaction list . If the Interrupting property is false then the application does not interrupt other interactions but places its interactions at the end of the interaction list .

PROMPT PROPERTY The question control is able to verbally prompt a user in order to solicit a response. The Prompt property contains what is announced when the application question is started. The Prompt property value is interpreted according to the value of a PromptType property which is text to speech or pre recorded. If the prompt is TTS then the prompt announces the TTS string. If the prompt is pre recorded then the prompt announces the contents of a file that contains the recording.

PROMPT VERBOSE PROPERTY The Prompt Verbose property is a prompt that an interaction plays if the application question is re activated after it is interrupted. This property may be NULL and if so the interaction plays whatever is specified by the Prompt property the prompt initially stated at the beginning of the interaction i.e. application question . Similar to the Prompt property the Prompt Verbose property includes a PromptType that may be a TTS string or a string stored in a file.

EARCON MODE PROPERTY The Earcon Mode property determines if the question control will play an audio file when the question control is activated or re activated. The audio file played is determined by a currently selected Type property. The Type property may be Always After Interruption or Never. 

If the Type property is Always then the audio file always plays on activation or re activation. For example if the audio file is a ding then the ding will be played when the system initiates a sole interaction or a first interaction in a conversation.

If the Type property is After Interruption then the audio file is only played on re activation. For example if a car system asks a user Fast or scenic route after first being interrupted by a global announcement the audio file i.e. ding sounds before the question repeats after the interruption.

If the Type property is Never then the audio file is never played. The application may modify the Type property between Always and Never. The Never Type property may be set by an application when the application has a special need not to play the audio file.

APPLICATION PROVIDED GRAMMAR An application can provide the question control with a list of options from which the user may choose. For each option offered the application may provide one or more phrases whose recognition constitutes that choice. Any choices added are in addition to any grammars implemented in the question control. For example a navigation application may provide a list having two options fast and scenic. If the words fast and scenic are not already included in an active grammar then they are automatically added.

In one implementation the question control provides a spoken choice feature. The spoken choice feature may be used when a question is configured to have two or more possible answers for one answer choice. For example a question may ask What is the current season The answers may be Spring Summer Autumn and Winter. In addition the word Fall may be used instead of Autumn. The question control may be configured to respond to a user inquiry as to possible answers as including either Autumn or Fall. As a result the list choices provided to a user would be Spring Summer Autumn and Winter or Spring Summer Fall and Winter. 

Another user for the spoken choice feature is for speech systems that may mispronounce one or more words. For example many speech systems will mispronounce Spokane Wash. as having a long a sound since that is how phonetics rules dictate instead of the correct short a sound . If a speech system is to announce the word Spokane to a user the question control or another control can be programmed to play a designated audio file that correctly pronounces Sp kan instead of using a standard TTS. In another implementation the correct pronunciation may be specified as a spoken choice string as described above.

The application s various grammars are activated in the system immediately upon starting the control. This provides for the user s ability to barge in using push to talk and respond to the question control before it is finished.

LIST CHOICES PROPERTY The List Choices property determines whether the question control will automatically TTS the list of valid choices to a user after playing the prompt. This option is particularly useful when the user is likely to be unaware of the valid responses. For example a navigation application may ask a driver who has just entered a destination Which route would you like to take fast or scenic 

SELECTION FEEDBACK PROPERTY The Selection Feedback property determines if the question control will play feedback automatically when the user answers one of the application provided or system provided options that are enumerated by the List Choices property. If the Selection Feedback property has a value of None no feedback is played when the user makes a choice. If the Selection Feedback property has a value of Earcon then a designated satisfaction earcon is played when the user makes a choice. If the Selection Feedback property has a value of Echo Choice value then a TTS of the user s choice is played when the user makes a choice.

At block the question control is launched. If there is an earcon to be played to indicate a question prompt is about to be asked Yes branch block then the earcon is played at block . Otherwise no earcon is played No branch block . The question prompt is then played at block .

The choices with which the user may respond to the question prompt may be announced for the user at block Yes branch block . But this may not be desirable and therefore the play list choices block may be skipped No branch block .

Just as an earcon may be played to alert the user that a question prompt if forthcoming an earcon may also be played after the question block prompt to indicate to the user that the system is ready for the user s answer Yes branch block . If this is not desirable the application may be programmed so that no such earcon is played No branch block .

Blocks represent the possible user responses to the question prompt block . At block the user may answer What can I say Yes branch block indicating that the user desires to hear the possible responses to the question prompt. Control of the process then returns to block where the play list choice prompt is repeated to the user.

If the user s response is to repeat the question prompt Yes branch block then control of the process returns to block where the question prompt is repeated to the user. If the user s response is ambiguous i.e. it is a response that the system does not understand Yes branch block then the system TTS s Answer is ambiguous at block . Control of the process returns to block to receive a new answer from the user.

If the question control receives a valid response from the user Yes branch block then feedback may be returned to the user to verify that the user has returned a valid response. If there is no feedback None branch block then the result i.e. the user s choice is returned by the question control at block . If the feedback is an earcon to indicate a valid response EC branch block then the earcon is played at block and the result is returned to the application at block . If the feedback is to play TTS of the user s choice Echo branch block then the user s response is TTS d to the user at block and the response is returned by the question control to the application at block .

In one implementation of the question control described herein a user may have an option to cancel a question process. If the user s response to the question prompt is to cancel Yes branch block and if canceled is enabled Yes branch block then the question is canceled. If an earcon is to be played to verify the cancellation Yes branch block then the appropriate earcon is played at block and a cancel value is returned to the application to indicate the cancellation. If an earcon is not to be played upon cancellation No branch block then cancel is returned at block without playing an earcon.

If the cancel option is not enabled No branch block then the system does not respond to the cancel command. If after a pre determined timeout period elapses without receiving a response from the user Yes branch block the cancel is returned to the application at block . Cancel is returned after an earcon is played block if a cancel earcon is enabled Yes branch block . Otherwise No branch block cancel is returned without first playing a cancel earcon. Note that there is not a No branch to block this is due to the fact that if a response is returned the response will have been handled before a determination is made as to whether a response was received during the timeout period. Other implementations may handle the process of the control differently.

The announcer control provides a developer an easy way to deliver verbal feedback to users including short notices and long passages of text to speech. The announcer control implements a simple mechanism for playing pre recorded speech or TTS text and for giving a user standardized control of such playback. Use of the announcer control significantly decreases the effort required by application developers to build a rich application user interface.

READ E MAIL A user request that an electronic mail message be read. The system begins TTS ing the message. The user is able to pause fast forward rewind etc.

INTERRUPTING ANNOUNCER While a navigation application is asking Fast or scenic route the user commands Read e mail. The system begins to read the e mail immediately.

INTERRUPTED ANNOUNCER While the system is reading a news story via TTS an automobile application asks Your gas tank is close to empty. Do you want instructions to the nearest gas station 

CONVERSATION STATEMENT A user answers the last question to specify a navigation destination and the system announces Turn right at the next intersection. 

REPEATED ANNOUNCEMENT A navigation application announces Turn right at the next intersection. But the user did not hear it. The user says Repeat and the system repeats the announcement.

The following features or properties may be available on the announcer control . Table 2 lists announcer control properties and types. Discussion follows.

TYPE PROPERTY The announcer control supports the Type property that can be used to determine the behavioral or content characteristics of the application announcement. The Type property ultimately determines the properties used in defining the application s announcement s behavior. The speech server defines the Type property s valid values.

INTERRUPTING PROPERTY The Interrupting property determines whether the application announcement will interrupt other interactions present in the interaction list of the interaction manager . If the Interrupting property value is True an announcement interaction will immediately interrupt any other interactions in the interaction list . If the value is False an announcement interaction will be placed at the end of the interaction list .

CONVERSATION ID PROPERTY The Conversation ID property determines whether the application announcement will operate in the context of the named conversation. The Conversation ID property is a string associated with a control instance. The interaction queue uses the Conversation ID property o identify which interaction belongs with which conversation.

ABORT WHEN INTERRUPTED PROPERTY The Abort When Interrupted property determines whether the announcement will automatically self destruct if it is interrupted by another interaction. If the property value is True then the announcement aborts when interrupted if the value if False the announcement does not abort.

EARCON MODE Property The Earcon Mode property determines if the application will play an audio file when it is activated or re activated. If the Earcon Mode property has a value of Always the designated audio file is always played upon activation or re activation. If the value is After Interruption the audio file is only played on re activation not on activation. If the value is Never an audio file is not played on activation or re activation.

ANNOUNCEMENT PROPERTY The Announcement property contains what is announced when the control is started. If an Announcement Type associated with the Announcement property is TTS then the Announcement property contains a string that is to be TTS ed. If the Announcement Type is Pre recorded then the Announcement property contains a string designating a file to be announced i.e. a file name. If the Announcement Type is Combination then the Announcement property contains a TTS string and an audio file name.

CANCEL EARCON PROPERTY The Cancel Earcon property determines if the announcer control will play an audio file automatically when the user answers cancel or its equivalent . If the Cancel Earcon property is True then an earcon is played upon canceling otherwise an earcon is not played.

POST DELAY PROPERTY The Post Delay property determines if the application will pause for a definable period of time after the announcement has been completely delivered. This features gives a user some time to issue a repeat or rewind command. It also provides for a natural pause between interactions. If the Post Delay property value is True then a post delay is provided when not in the context of a conversation. If the value is False then a post delay is not provided.

There may be a post delay after the announcement has completed Yes branch block . If the user asks the system to repeat the announcement during a post delay period Yes branch block then the announcement is replayed at block . If the user does not ask the system to repeat the announcement during the post delay period No branch block then the process completes at block .

A post delay may not be activated for the announcement control. If not No branch block then the process completes at block immediately after the announcement is played at block .

Activation of the announcement control may occur after an interruption at block . If an interruption occurs before the announcement control is activated and the announcement control earcon mode is set to play an earcon Always or After Interruption Always or After Interruption branch block then an earcon is played at block to alert the user that an announcement is forthcoming. The announcement is then played at block . If the earcon mode is set to Never Never branch block then the announcement is played at block without playing an earcon at block .

Thereafter a post delay may be implemented Yes branch block wherein the user may ask the system to repeat the announcement Yes branch block in which case the announcement is repeated at block . If a post delay is not implemented No branch block or if no response is received during a post delay period No branch block then the process concludes at block .

The command control is designed to easily attach command and control grammar to an application. The command control is used for user initiated speech. At a minimum the command control must perform two functions. First the command control must provide a way for an application to specify what grammar s the application is interested in listening to. Second the command control must communicate back to the application that a recognition has occurred. To accomplish these tasks the command control is made up of four objects.

Each of the four objects includes an interface the command manager object interface the grammar object interface the rule object interface and the recognition object interface . The interfaces of each object will be discussed separately in greater detail.

The command manager object interface has three properties Persistence ID Grammar ID and Grammar . The Persistence ID is used to identify the application for persistence purposes. The Persistence ID must be unique in the system. The Persistence ID may be blank if the associated grammar is not persistent. In one implementation the Persistence ID is a ProgID Microsoft WINDOWS implementation .

The Grammar ID is an identifier that is used by with interactions submitted to the interaction manager . As previously explained the Grammar ID is utilized to avoid latency problems inherent in the speech system . The Grammar property is a pointer to the Grammar Object that is associated with the Command Control .

The command manager object interface also includes several methods Create Grammar Persist Remove Grammar Start and Event Recognition . Create Grammar is a function that is used to create a new grammar object from a grammar file. A grammar file may be an XML extended markup language file or a compiled grammar file .cfg or NULL indicating that a new grammar is to be built. Parameters for Create Grammar include a path of a file to be opened or NULL for a new grammar file a value that indicates whether a grammar is static or dynamic Load Options a value that indicates whether a grammar is yielding or global Context Options and a pointer that receives the grammar object ppGrammar .

Persist is a method that indicates that a grammar is to be persisted. Persisted grammars recognize even if the application with which they are associated are not running. If a recognition occurs the application is launched. Persist includes two parameters the grammar under which the ID should be persisted Persistence ID and a complete path for an executable that will handle grammar recognitions Application Path .

Remove Grammar is a method that removes a grammar from the speech server . If the grammar is persistent Remove Grammar un persists the grammar. Start is a method that is called to let the speech server know that an application is ready to start handling events. Event Recognition is a method that is called by the speech server when a speech recognition occurs so that an appropriate application may be so notified.

A specific implementation of the command manager object interface is shown below. The implementation is specific to the WINDOWS family of operating systems by Microsoft Corp. Other interfaces may be added to make the command control and ActiveX control provided by the ATL wizard so that a developer can simply drop the control on a form and proceed.

The Grammar Object Interface has an Enabled property a Rule method a Create Rule method and a Commit method . The Enabled property is used to turn the entire grammar on or off. The Rule method selects a rule by ID or name and returns it to the caller. The Rule method includes a RuleID parameter that is either a numeric ID for the rule or a string for the rule name.

The Create Rule method creates a new rule in the grammar. The Create Rule method also utilizes the RuleID parameter which is a name or numeric identifier of the rule to be created. Other parameters used in the Create Rule method include Rule Level Rule State ppRule and Prop. Rule Level is an enumeration determines whether the rule is created as a top level rule or not. Rule State specifies whether the rule is to be created as dynamic. Dynamic rules can be modified after they are committed. ppRule is the rule object that is created. Prop is an optional PropID or PropName that a developer wants to associate with the rule.

A specific implementation of the grammar object interface is shown below. As with the command manager object interface shown above the implementation is specific to the WINDOWS family of operating systems by Microsoft Corp.

The Rule Class interface includes an enabled property and several methods Add Rule Add Phrase Add Alternate Rule and Add Alternate Phrase . Enabled when set indicates whether a rule is active or inactive. Add Rule appends a rule to an existing rule structure. For example if the rule looks like Rule Phrase Rule1 and Rule2 is added then a new structure results Rule Phrase Rule1 Rule2 .

In the WINDOWS specific implementation shown below Add Rule includes two parameters plrule which is a pointer to the rule object that will be added to the rule. Prop is an optional PROPID or PROPNAME that can be associated with the rule.

Add Phrase appends a phrase to an existing rule structure. In the implementation shown below the Add Phrase method includes parameters text and val. Text is the text that is to be added. Val is an optional val or valstr that may be associated with the phrase. For this to be set the rule must have been created with a property.

Add Alternate Rule places a new rule as an optional path for the previous rule structure. For example if the structure is Rule Phrase Rule 1 and then add alternative rule2 results in the new structure Rule Phrase Rule1 Rule2. Concatenation takes precedence over the or operator. Add Alternate Rule includes two parameters in the WINDOWS implementation shown below. plrule is a pointer to the rule object that will be added to the rule. prop is an optional PROPID or PROPNAME that may be associated with the rule.

Add Alternate Phrase places a new string as an optional path for the previous rule structure. If the structure is Rule Phrase Rule1 and alternative phrase Phrase2 is added the new structure is Rule Phrase Rul1 Rule2. Concatenation takes precedence over the or operator. In the WINDOWS implementation shown below Add Alternate Phrase includes two parameters. Text is the text to be added. Val is an optional VAL or VALSTR that is to be associated with the phrase. The rule must have been created with a property for this to be set.

A specific implementation of the Rule Object interface is shown below. As with the other interfaces shown above the implementation is specific to the WINDOWS family of operating systems by Microsoft Corp.

The Rule Object interface is designed for building grammars in a BNF Backus Naur Format format. The rule is composed of a Start component that is constructed of either rules or phrases. The Start component corresponds to a top level rule. For example 

There are four rules here S A B C . There are four phrases I like Candy Food and Orange is a great color. This grammar allows three phrases to be said by the user I like candy I like food or Orange is a great color. To construct this assume four rules have been created by a grammar object and then build the rules.

The word trainer control provides an easy way to implement a speech oriented work training interaction with a user in support of tasks that involve voice tags such as speed dial entries or radio station names. The entire word training process is implemented with a combination of the word trainer control and other GUI graphical user interface or SUI speech user interface controls. The word trainer primarily focuses on the process of adding the user s way of saying a phrase or verbally referencing an object in the recognizer s lexicon.

It is noted that the Word Trainer control wraps the word trainer API application programming interface provided by MICROSOFT CORP. The features discussed below are available on the word trainer control .

An example of a functional scenario for the word trainer control is a user initiating voice tag training to complete creating a speed dial entry for Mom. The system prompts the user to say the name of the called party. The user responds Mom. Training is then complete.

Another example of a functional scenario for the word trainer control is a user who wants to place a call via voice command but cannot remember the voice tag that was previously trained. The system helps the user using a question control Choose who you d like to call by repeating the name. or .

The following Tables Tables 3 5 illustrate possible word training sessions that are supported by the word training control .

Word Trainer is a control such as an ActiveX control that a developer can include in an application for the purpose of initiating and managing a training user interface process. All of the interfaces exposed by the Word Trainer API MICROSOFT CORP. 

Table 6 identifies word trainer control properties. It is noted that these properties are in addition to Word Trainer API MICROSOFT CORP. properties and methods wrapped by the word trainer control .

The word trainer control supports the Type property that can be used to determine the behavioral or content characteristics of the control. It is noted that it is the Type property that ultimately determines the style class and properties used in defining the control s behavior. The Type property s valid values are defined in the system s current speech theme.

The Interrupting property determines whether the control will interrupt other interactions in the interaction list of the interaction manager . If the Interrupting property has a value of True then the control immediately interrupts any other interaction in the interaction list . If the value is False then the control does not interrupt but places interactions at the end of the interaction list .

The Feedback property determines if the word trainer control will play feedback automatically after the system successfully records the user. If the Feedback property has no value or a value of none then the word trainer control doesn t play feedback when the user makes a choice. If the Feedback property has a value of Earcon then the word trainer control plays a completion earcon resource after a successful recording. If the value is Echo recording then the word trainer control plays a sound file of the user s recording.

The PassesRemaining property is a read only property that tells an application how many recording passes the engine requires before a usable voice tag exists. It is intended that as this number decrements the application user interface reflects course progress through the training process.

In addition to the foregoing the word trainer control includes a StartRecording method. The StartRecording method initiates the recording process for one pass. When recording completes successfully the PassesRemaining property decrements. It is noted that in the cases where the speech engine can accept additional recordings an application may call StartRecording even though PassesRemaining equals zero.

It is noted that other speech recognition grammars must be temporarily disabled when the speech engine is in a recording mode.

The various components and functionality described herein are implemented with a number of individual computers. shows components of typical example of such a computer referred by to reference numeral . The components shown in are only examples and are not intended to suggest any limitation as to the scope of the functionality of the invention the invention is not necessarily dependent on the features shown in .

Generally various different general purpose or special purpose computing system configurations can be used. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The functionality of the computers is embodied in many cases by computer executable instructions such as program modules that are executed by the computers. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Tasks might also be performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media.

The instructions and or program modules are stored at different times in the various computer readable media that are either part of the computer or that can be read by the computer. Programs are typically distributed for example on floppy disks CD ROMs DVD or some form of communication media such as a modulated signal. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable media when such media contain instructions programs and or modules for implementing the steps described below in conjunction with a microprocessor or other data processors. The invention also includes the computer itself when programmed according to the methods and techniques described below.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

With reference to the components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISAA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as the Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more if its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

The systems and methods as described thus provide a way to manage interactions from multiple applications even if two or more of the multiple applications use different grammars. Implementation of the systems and methods described herein provide orderly processing of interactions from multiple applications so a user can more easily communicate with the applications.

Although details of specific implementations and embodiments are described above such details are intended to satisfy statutory disclosure obligations rather than to limit the scope of the following claims. Thus the invention as defined by the claims is not limited to the specific features described above. Rather the invention is claimed in any of its forms or modifications that fall within the proper scope of the appended claims appropriately interpreted in accordance with the doctrine of equivalents.

