---

title: Abstract layer for automatic user interface testing
abstract: A method to provide automatic testing of a graphical user interface (GUI) having a plurality of GUI components includes maintaining an abstract layer configured to provide a uniform interface for accessing a plurality of user interface (UI) testing tools, each of which is configured to interact with one or more of the plurality of GUI components to perform automatic testing of the GUI. The method also includes receiving a test command, selecting one of the plurality of UI testing tools based on the test command, identifying the GUI component from the plurality of GUI components based on a first uniform identifier in the test command, and utilizing the uniform interface to communicate with the selected UI testing tool for interacting with the GUI component based on the test command.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465726&OS=09465726&RS=09465726
owner: VMware, Inc.
number: 09465726
owner_city: Palo Alto
owner_country: US
publication_date: 20130605
---
Automatic software testing refers to the process of testing software using an automatic testing tool. The automatic testing tool may control the execution of the software compare the actual behaviors of the software with the predicted outcomes and determine whether the software has any bugs or issues. To test a software s graphical user interface GUI the automatic testing tool may generate simulated user actions such as keystrokes and mouse clicks as inputs to the GUI observe the behavior of the GUI and validate whether the observed behavior is as predicted. Automatic software testing is an important procedure for improving the overall quality of software and is cost effective because the test cases may be repeatedly executed. Nonetheless implementing the test cases may require a large amount of upfront efforts and the test cases may not be portable to a different piece of software or a different automatic testing tool.

Since GUI software is designed for human access it is often hard to simulate all the user actions that can be performed on the GUI. Therefore the conventional GUI automatic testing tools are more focused on the displayed components in the GUI while ignoring the testing of structure and organization of the software. When software becomes more and more sophisticated and the GUI utilizes multiple technologies in multiple environments the number of test scenarios increases as well. As a result developing automatic test cases are often conducted by copy paste instead of code reuse. Also maintaining the test cases become a burden when the tightly coupled test code causes heavy code dependencies.

Systems and methods for providing automatic software testing of a graphical user interface are described. The system may contain a plurality of user interface UI testing tools executing on a computer system. Each of the plurality of UI testing tools may be configured to interact with one or more of the plurality of GUI components to perform automatic testing of the GUI. The system may contain an abstract layer coupled with the plurality of UI testing tools. The abstract layer may be configured to provide a uniform interface for accessing the plurality of UI testing tools. The system may further contain an automatic test platform coupled with the abstract layer and configured to issue a test command to the abstract layer simulating a user action performed on a GUI component of the plurality of GUI components. The abstract layer may be configured to identify the GUI component based on a first uniform identifier in the test command and utilize the first uniform identifier to communicate with one of the plurality of UI testing tools for interacting with the GUI component.

In the following detailed description reference is made to the accompanying drawings which form a part hereof. In the drawings similar symbols typically identify similar components unless context dictates otherwise. The illustrative embodiments described in the detailed description drawings and claims are not meant to be limiting. Other embodiments may be utilized and other changes may be made without departing from the spirit or scope of the subject matter presented here. It will be readily understood that the aspects of the present disclosure as generally described herein and illustrated in the Figures can be arranged substituted combined and designed in a wide variety of different configurations all of which are explicitly contemplated herein.

The present disclosure provides a framework for performing automatic user interface testing hereinafter automatic UI testing framework . The automatic UI testing framework may include automation tools abstraction layers design patterns and project blueprints. The automatic UI testing framework may create a friendly and intuitive development environment for the test developers allow natural mitigation of the common automation problems and has short on board time for new test developers with opportunities for gradual improvements.

In one embodiment the GUI may be an image based human computer interface of a software application executing in a desktop operating system e.g. Microsoft Windows MacOS or UNIX X etc or a mobile operating system e.g. Android Symbian Blackberry OS Palm iOS etc. . The GUI may also be an interface of a web based application displayed in a web browser such as Microsoft Internet Explorer Firefox etc. The GUI may contain windows menus icons and other image based components that can be used to interact with the software application. Specifically the GUI may contain one or more GUI components that are configured to display various types of data and may be manipulated using a mouse device and or a keyboard device. Examples of GUI components may include without limitation text image checkbox select box drop box button text field icon menu menu item outline field list field. The GUI may be developed based on one or more user interface technologies such as Java Apache Flex HTML C etc. The GUI may also adopt multiple GUI technologies and or operating on multiple environments.

In one embodiment the UI testing tools and or may be utilized to perform user interface testing functional testing internationalization e.g. I18N testing and or localization e.g. L10N testing. Further these UI testing tools may be utilized to perform regression tests or build acceptance tests to improve software development processes. The UI testing tools may be configured to simulate a user s actions in interacting with the GUI and its GUI components . Specifically these UI testing tools may utilize scripts and or high level programming language PL to define the user actions that can be performed on the GUI components . During testing these UI testing tools may simulate a user pressing a button or input a string into a text field by executing the scripts and or the high level PL codes.

In one embodiment each of the UI testing tools and may have its own tools scripting languages and programming languages and may support various UI technologies. The abstract layer may decouple the UI testing platform from these various UI testing tools and as well as these different UI technologies. For example the UI testing tool may be a script based testing tool configured to support web based user interfaces and the UI testing tool may be a high level PL based testing tool configured to test WINDOW based user interfaces. Thus the UI testing tools and may be standalone software applications executing independently and operating externally with respect to the abstract layer . And the abstract layer may be configured to provide a set of uniform services to the UI testing platform for interacting with each of the UI testing tools and via communication channels and . Each of the communication channels and may utilize one or more communication protocols such as without limitation HTML REST SOAP RMI etc.

In one embodiment the UI testing platform may be configured to build and maintain a test development environment and utilize the abstract layer for automatic testing of the GUI . The UI testing platform may employ the set of uniform services provided by the abstract layer to generate a common testing project regardless of which of the UI testing tools or is used to test the GUI or what type of UI technologies the GUI is implemented in. Thus the common testing project which may contain testing codes in scripts and or high level PL may stay substantially the same over time even when the UI testing tools are changed or the GUI are updated. Further the UI testing platform may reuse knowledge and codes obtained during the development of a first testing project for a second testing project thereby saving the time and efforts in developing the second testing project. Thus the abstract layer may allow the building of a higher level abstract testing platform which may achieve tested product independence.

In one embodiment the abstract layer may provide a uniform identifier service for identifying a specific GUI component . The abstract layer may provide an abstract test automation interface and uniform tool services for accessing and control any one of the UI testing tools and . Specifically the abstract layer may automatically route the calls received from the UI testing platform to the corresponding UI testing tools and or . The details of the abstract layer and its various services are further described below.

In one embodiment the UI testing platform and the abstract layer may be implemented by a computer system or software running on the computer system . The computer system may contain among other components a processor and memory . The UI testing platform and the abstract layer may be implemented as a set of non transitory machine executable instructions that can be stored in the memory and executed by the processor . Alternatively the UI testing platform and the abstract layer may be implemented as one or more hardware modules in the computer system .

In one embodiment the UI testing platform may be configured to adopt one or more uniform GUI models to represent a GUI and its associated GUI components the GUI and its GUI components are not shown in . The uniform GUI model may be deemed an abstract data object configured to describe the GUI and the GUI components. Further the UI testing platform may utilize the uniform GUI model to uniformly describe access and interact with the GUI and the GUI components that may be implemented using various UI technologies. When developing an automatic test application the UI testing platform may adopt a high level PL and construct the uniform GUI model using the same high level PL. Thus there is no need to create and use proxy classes that are directly tied to the structures and UI technologies of the GUI and the GUI components. Further when the GUI and its GUI components are changed the uniform GUI model used for accessing the GUI and the GUI components may remain the same. Therefore the uniform GUI model may bring script based advantages to a high level PL based UI testing platform in terms of data structure decoupling.

In one embodiment the goal of simplifying usage during test development and simplifying maintenance when the GUI and GUI components are changed may be achieved by using one or more uniform identifiers as the building blocks for the uniform GUI model and or the uniform page model . Similar to the utilizing of a conventional GUI model which has data structures that mirror the structures of the GUI and its GUI components to retrieve GUI properties and control GUI actions the UI testing platform may utilize the uniform identifiers to accomplish the same tasks. During automatic test development the UI testing platform may program the uniform identifiers with identification information. During run time the UI testing platform may request the uniform identifier service to generate the uniform identifiers and request the abstract test automation interface to locate the identified GUI components based on the uniform identifiers . Alternatively the UI testing platform may use the uniform GUI model and or the uniform page model as a resource to obtain additional uniform identifiers before calling the abstract test automation interface . The details about the uniform identifier and the uniform identifier service are further described below.

In one embodiment the UI testing platform may utilize the abstract automation interface to issue test commands to or obtain property values via the UI testing tools and . Specifically the abstract test automation interface may be implemented by grouping the functionalities of the UI testing tools and into functional sets including without limiting common tools customized tools and extension tools . The common tools may contain tools handling simple GUI component automations and common user input functionalities involving e.g. buttons labels mouse and or keyboard inputs. The customized tools may handle composite GUI components such as tables trees and or handle scrollable containers. The extension tools may include specialized tools that support the development and debugging of the automatic UI test codes in the UI testing platform . For example the extension tools may contain a tool that can record the structure and the component properties of a current GUI component. During automatic test case development such a tool may be called to collect a GUI component s identification data. During automatic test case execution such a tool may be invoked to obtain a particular GUI state for debugging purposes.

In one embodiment the functional sets in the abstract test automation interface may be supported by services provided by the uniform tool services . The uniform tool services may be configured with among other modules a component tracking module a component proxy module a user input module and other extension services modules which implement functionalities that support e.g. test design and debugging . To perform their respective functionalities the modules in the uniform tool services may collaborate with each other and may communicate with the external tool interface . For example to serve a test command request originated from the UI testing platform the uniform tool services may have a set of rules for selecting an appropriate tool adapter from the external tool interface . The uniform tool services may either statically configure or query at run time the external tool interface to determine which of the UI testing tools and and the corresponding tool adapters and should be utilized to perform the test command request.

In one embodiment the component tracking module of the uniform tool services may be configured to track a GUI component in the current screen rendering. That is given a uniform identifier other modules in the uniform tool services e.g. the component proxy module may utilize the component tracking module to determine which GUI components should be taken control of. The component proxy module of the uniform tool services may be configured to create one or more uniform proxies. Given a uniform identifier the component proxy module may facilitate GUI component interactions and cache some of the GUI component properties.

In one embodiment the user input service module may be configured to simulate user inputs from different devices such as keyboard mouse and or touch screen. For example the user input service module may receive a uniform identifier and utilize the component tracking module to locate the GUI component identified by the uniform identifier . Afterward the user input service module may transmit a simulated user input e.g. mouse interaction keyboard interaction clip board interaction to the identified GUI component. In another example the user input service module may receive a GUI component s screen location data and use the screen location data to direct the simulated user input. The user input service module may also simulate a user input designed for whichever GUI component in the GUI that has the focus during run time.

In one embodiment the UI tool adapters and may be configured to provide uniform access to the functionalities of the external UI testing tools and respectively. Each of the UI tool adapters and may include mechanisms to convert data and interpret commands both of which are received from other components in the abstract layer . Further the UI tool adapters and may be configured to convert response data returned from the UI testing tools and and transmit the converted response data to the other components in the abstract layer .

In one embodiment the abstract layer may provide stateless and atomic operation services to the UI testing platform . An atomic operation may contain a set of actions to be performed sequentially and or logically by the abstract layer as a whole. For example the abstract test automation interface may receive from the UI testing platform a first test command with optional data via a communication channel . The abstract test automation interface may transmit the first test command to the uniform tool services for further processing. Afterward the abstract test automation interface may transmit a first return message returned from the uniform tool services back to the UI testing platform as a response to the first test command. Thus the above sequence of actions may be deemed a first atomic operation. In a subsequent atomic operation the UI testing platform may transmit a second test command to the abstract test automation interface and forward a second return message from the abstract test automation interface back to the UI testing platform in response to the second command.

In one embodiment the abstract layer may maintain a stateless environment between the first atomic operation and the second atomic operation. In other words the abstract layer may not temporarily store in memory transactional data from the first atomic operation which may be used by the second atomic operation. Thus upon the completion of the first atomic operation the abstract layer may clear discard the transactional data associated with the first atomic operation and perform the subsequent second atomic operation as if the first atomic operation is never performed. In another embodiment the abstract layer may cache the GUI component properties in uniform proxies beyond the executing of an atomic operation. In this case the abstract layer may temporarily store transactional data from the first atomic operation which may be used by the second and or subsequent atomic operations.

In one embodiment the abstract layer may implement an atomic operation to ensure that no new screen rendering may be triggered by any other actions except the last action in the atomic operation. In other words the last action of the atomic operation may trigger a new screen rendering for the GUI but not the actions before the last action. In one embodiment the abstract layer may perform an atomic operation which contains no simulated user action. In another embodiment the abstract layer may implement an atomic operation with one simulated user action being at the end of a sequence of actions. In a further embodiment the abstract layer may implement an atomic operation with multiple data retrieving actions as long as none of these data retrieving actions trigger new screen rendering. Also the abstract layer may implement an atomic operation with multiple calls to the uniform tool services or with multiple invocations of more than one of the UI testing tools and .

In one embodiment the abstract layer may utilize the uniform identifier service to create and support the uniform identifier . For example when the UI testing platform requests a uniform identifier the uniform identifier service may be configured to construct an instance of the uniform identifier based on identification information supplied by the UI testing platform and transmit the instantiated uniform identifier to the UI testing platform via a communication channel . Afterward the UI testing platform may transmit the received uniform identifier with a test command to the abstract test automation interface which in turn may perform a corresponding atomic operation based on the test command. For example once a specific GUI component is identified based on the uniform identifier the abstract layer may perform an atomic operation to check whether the specific GUI component exists in the GUI to request for retrieval of a property of the specific GUI component or to invoke a mouse or keyboard action on the specific GUI component.

In one embodiment the uniform identifier may contain one or more property filters and or one or more relational filters . The property filter may be configured with a uniform property a filtering function and one or more filtering values . In many situations a GUI component may be modeled differently by different UI testing tools and . For example a GUI attribute e.g. a text string of a GUI component may be referred to as label caption or text by different UI testing tools. To decouple the UI testing platform from knowing these specific names used by the UI testing tools the abstract layer may define a common and uniform property for this GUI attribute. Thus the uniform property may be deemed defined and supported by the abstract layer .

In one embodiment the uniform property may be a value selected from a set of supported properties defined by the abstract layer . The set of supported properties may include without limitation TEXT VALUE X Y H W IMG ID and CLS . For example TEXT may represent a user visible text displayed by a GUI component having a label a caption or a label sub component. VALUE may represent a user changeable property of a GUI component which can be used to select set a value from a list box or a check box. X or Y may represent the x or y screen coordinate of the upper left corner of a GUI component. H or W may represent the height or width of a GUI component. IMG may represent a graphic image of a GUI component. ID may represent a non visible fixed unique property for a GUI component. And CLS may represent a non visible fixed property that is associated with the intrinsic class name of a GUI component.

In one embodiment the filtering function in the property filter may be based on a set of supported functions defined by the abstract layer . The supported functions may include without limitation mathematical comparisons such as 

In one embodiment once the UI testing platform populates the uniform propriety the filtering function and the filtering value of a specific uniform identifier the abstract layer may transmit the specific uniform identifier to the component tracking module and or the component proxy module to identify and take control of one or more GUI components in the GUI. When the UI testing platform supplies the uniform identifier with multiple property filters . The multiple property filters may be deemed having an AND relationship among themselves. For example a uniform identifier may have three property filters the first one describing a uniform property VISIBLE equaling true the second one indicating a uniform property TEXT containing deleted and the third one providing a uniform property X larger than . A GUI component may be identified when its properties satisfy the filtering conditions in these three property filters .

In one embodiment the uniform identifier may contain one or more relational filters . In some situations a second GUI component may be easier to identify from the perspective of a first GUI component than by using a property filter filtering the GUI component s property values. Thus the UI testing platform may first define a first uniform identifier capable of identifying the first GUI component and then define a second uniform identifier having a relational filter which describes a relationship between the first GUI component and the second GUI component. The UI testing platform may store the relationship in a relation function of the relational filter and store the first uniform identifier in the relational uniform identifier of the relational filter .

In one embodiment similar to the filtering function the relation function may be based on a set of supported functions e.g. isChildOf isInColumnOf isInsideOf isBelow defined by the abstract layer . For example a first uniform identifier may have a relational filter with a relation function being isChildOf and a relational uniform identifier referencing a second uniform identifier . Thus the component tracking module may search for a first GUI component which has a child parent relationship with a second GUI component identified by the relational uniform identifier . Similarly a uniform identifier may use a relation filter to identify a first GUI component positioned on the left of a second GUI component below a third GUI component or have properties relative to a fourth GUI component.

In one embodiment the component proxy module may be configured to manage a uniform proxy for caching information retrieved based on a uniform identifier having the same structure as the uniform identifier . The uniform proxy may serve as a bridge between the uniform identifier and a set of matching GUI components obtained from the current rendering GUI. In other words the matching components may be the GUI components that match the filtering conditions of the uniform identifier . After the uniform proxy is under the control of the component proxy module the abstract layer may offer convenient access to the uniform proxy throughout multiple atomic operations.

In one embodiment the UI testing platform and or the abstract layer may utilize the uniform proxy to check for the existence of matching components or a number of the matching components . Further the UI testing platform and or the abstract layer may access the property values of the matching components associated with the uniform identifier or invoke multiple user actions on the matching components . The uniform proxy may also cache a GUI component s property values in the matching components to improve the performance of the abstract layer .

In one embodiment the relational filter of a uniform identifier may be configured to associate a uniform proxy as its relational uniform identifier . In this case the component tracking module may convert the uniform proxy into an equivalent list of property filters for the uniform identifier . Specifically the component tracking module may retrieve property values from the matching components of the uniform proxy in order to construct the property filters .

Referring back to . In one embodiment once a uniform identifier is populated by the UI testing platform with identification information the UI testing platform may embedded the uniform identifier in a test command and transmit the test command to the abstract test automation interface . Based on the test command the abstract test automation interface may select a specific tool from the common tools the customized tools and or the extension tools . The specific tool may then extract the uniform identifier from the test command and transmit the uniform identifier to the uniform tool services . Specifically the specific tool may issue a get matching components list command to the component tracking module and or the component proxy module of the uniform tool services . The component tracking module and or the component proxy module may process the get matching components list command using the uniform identifier . Upon a complete execution of the get matching components list command if one or more GUI components are identified based on the uniform identifier the component tracking service and or the component proxy module may continue the processing of the test command based on the one or more GUI components.

In one embodiment the uniform identifier may contain one or more property filters but no relational filter. In this case The component tracking service may process the get matching components list function by performing one or more of the following steps A call a select UI tool adapter function to retrieve a UI tool adapter from the UI tool interface B call a request for candidates function based on one or more of the property filters in the uniform identifier to receive a candidate list C call a match property filter function by iterating through each candidate in the candidate list using the remaining property filters in the uniform identifier D remove candidates from the candidate list that do not match any one of the property filters in the uniform identifier and E return the final candidate list as a matching components list to the abstract test automation interface .

In one embodiment the uniform identifier may contain one or more property filters and one or more relational filters. In this case The component tracking service may execute the get matching components list function by performing one or more of the following steps A call a convert relational filter function to convert each of the relational filters in the uniform identifier to a property filter and consolidate the property filter into an extended property filter list B merge the extended property filter list with the property filters of the uniform identifier to generate a merged property filter list C call the uniform identifier service providing the merged property filter list to collect a new uniform identifier D issue a new get matching components list command with the new uniform identifier and collect the returned matching components list and E return the matching components list to the abstract test automation interface . The above mentioned functions may be further described below.

In one embodiment the uniform tool services may invoke the external tool interface to select a specific tool adapter and its associated UI testing tool for handling some of the get matching components list functions. Specifically the external UI tool interface may be configured to perform a select UI tool adapter function for dynamic selection of the UI tool adapter. The select UI tool adapter function may be based on one or more of the following criteria A a type of the command to be processed B the uniform identifier and its property filters C current runtime environment variables e.g. browser type version OS type version etc. D the available UI tool adapters that can handle the command processing and or E predefined static rules for prioritization. The select UI tool adapter function may finish its operations by either F returning a selected UI tool adapter or G throw exceptions for error situations.

In one embodiment once a tool adapter is selected the selected tool adapter may perform a request for candidates function using the uniform identifier . Specifically the selected tool adapter may be configured to perform the request for candidates function based on zero one or more property filters in the uniform identifier . The request for candidates function may include one or more of the following steps A choose a strategy for GUI components enumeration B iterate through the GUI components for potential candidate GUI components C for a current GUI component selected from the GUI components apply each of the property filters to the match property filter function D if all of the provided property filters yield true result then add the current GUI component to the candidate list E return empty list if no GUI component matched all property filters simultaneously and F return the accumulated candidate list. Thus upon its completion the request for candidates function may identify one or more GUI components that satisfy the one or more property filters. The match property filter function is further described below.

In one embodiment the selected tool adapter may be configured to perform a match property filter function on a current GUI component for each of the property filters in the uniform identifier. The match property filter function may include one or more of the following steps A invoke retrieve property value on the current GUI component using the uniform property in the property filter to collect the property value B compare the collected property value based on the filtering values and the filtering function in the property filter and C return true if comparison is successful or false if otherwise. The retrieve property value function is further described below.

In one embodiment the get matching components list function which may be implemented by the component tracking service and the request for candidates function which may be implemented by the selected tool adapter may selectively share the utilizations of the property filters in the uniform identifier in identifying GUI components. Specifically the selected tool adapter may pick one or some of the property filters from all the property filters in the uniform identifier based on its specific native knowledge about the UI test tool associated with the selected tool adapter. Afterward the selected tool adapter may perform the request for candidates function based on the picked one or some of the property filters and obtain a subset of GUI components. The component tracking service may then continue the get matching components list function and filter the subset of GUI component utilizing the rest of the property filters in the uniform identifier that are not picked by the selected tool adapter in order to obtain the matching components list result.

In one embodiment the get matching components list function may complement the request for candidates function in choosing the property filters. Since the selected tool adapter and its associated UI testing tool may have a higher efficiency in filtering the GUI components to improve performance the selected tool adapter may try to utilize as many property filters if not all in the uniform identifier as possible. Thus if the request for candidates function manages to apply all of the uniform identifier s property filters then the get matching components list function may not perform any additional filtering and may simply forward the list of GUI components received from the request for candidates function as the matching components list result. If the request for candidates function utilizes only part of the property filters the get matching components list function may then use its generic approach of extracting properties from each of the short listed candidates and applying the remaining property filters on them to complete the filtering process. Thus both functions may work together to maximize both performance and component access.

In one embodiment the selected tool adapter may be configured to perform a retrieve property value function on a current GUI component based on a uniform property. The retrieve property value function may include one or more of the following steps A call translate property function with the uniform property to receive a native property B retrieve the property value for the native property from the current GUI component C throw an exception when the retrieval fails and D return the property value. For example once a uniform property VISIBLE is translated to a native property visible for a button GUI component the retrieve property value function may extract a value true from the button GUI component. In one embodiment the selected tool adapter may invoke multiple retrieve property value functions as a group of actions within one atomic operation. The retrieve property function is further described below.

In one embodiment the selected tool adapter may be configured to perform a translate property function based on a uniform property. The translate property function may include one or more of the following steps A extract and evaluate the native types of the GUI components in the GUI B extract and evaluate current environment variables C extract and evaluate current GUI rendering values D consider the native properties supported by the associated UI testing tool E throw exception when translation is not supported and F return a native property that matches the provided uniform property. For example the translate property function may translate a uniform property TEXT to a native property text for a text edit GUI component or to a native property label for a list item GUI component.

In one embodiment the component tracking module may be configured to perform the convert relational filter function based on one relational filter. The convert relational filter function may include one or more of the following steps A extract the uniform identifier from the relational filter and call the get uniform proxy function using the uniform identifier to create a new uniform proxy for the related component B pass the uniform proxy of the related component to the relation function to collect a list of property filters and F return the list of property filters. The get uniform proxy function is further described below.

In one embodiment the component proxy module may be configured to perform a get uniform proxy function based on a uniform identifier . The get uniform proxy function may include one or more of the following steps A create a new uniform proxy B assign the provided uniform identifier to the new uniform proxy C call the get matching components list function providing the uniform identifier as parameter and collecting the matching components list D assign the matching components list to the created new uniform proxy and E return the new uniform proxy.

In one embodiment the component proxy module may be configured to perform a get restricted uniform proxy function based on an existent uniform proxy and one or more additional property filters. The get restricted uniform proxy function may include one or more of the following steps A create a new uniform proxy B retrieve an existent uniform identifier from the previously available uniform proxy C use the uniform identifier service to create a new uniform identifier from the existent uniform identifier and the additional filters provided as parameters D assign the new uniform identifier to the new uniform proxy E utilizing the matching components list function of the existent uniform proxy apply the new property filters provided as parameter and generate the new matching components list for the new uniform proxy and F return the new uniform proxy. In some situations as the existent uniform proxy may be cached there is little or no need to access any UI testing tool during the performing of the get restricted uniform proxy function. Thus the get restricted uniform proxy function may provide an efficient approach in the testing of composite GUI components such as grid tree etc.

In one embodiment the user input service module may request a selected tool adapter to simulate one or more mouse actions keyboard actions and or input device x actions . The selected tool adapter may be configured to handle a sequence of mouse actions on a current GUI component based on one or more mouse action parameters. A sequence of mouse actions may include without limitation one or more of the following steps A execute a mouse button action on the current GUI component B execute a mouse move action on a requested screen point C execute special keyboard actions to support a special mouse action. For example some mouse action commands may be configured to simulate a left click on a GUI component a pressing of a key Shift and the right mouse button and a drag n drop with the current GUI component.

In one embodiment the selected tool adapter may be configured to handle a sequence of keyboard actions on a current GUI component based on one or more keyboard action parameters. A sequence of keyboard actions may include without limitation one or more of the following steps A set the key typing focus to the current GUI component B type a sequence of keys C press and hold a special key to support a key combination D release the special key to complete the key combination E send text content to the system clipboard and F retrieve the text content from the system clipboard. For example some keyboard actions may be configured to simulate typing some text pressing a key combination Shift Alt z sending the text to the system clipboard and pressing key combination Ctrl v. 

In one embodiment the selected tool adapter may be configured to handle a sequence of input device x actions on a current GUI component based on one or more device x action parameters. The sequence of input device x actions may allow simulation of one or more user component interactions through the input device X . Examples of such input devices may include touch screens and 3D user interaction interfaces.

In one embodiment the uniform identifier may contain two property filters one describing a filtering condition for a uniform property IMG and the second one describing a filtering condition for a uniform property X. To identify the GUI component referenced by the uniform identifier a component tracking module of the abstract layer may invoke the get matching components list function with the uniform identifier . The component tracking module may then call the select UI tool adapter function with uniform identifier . In the select UI tool adapter function an external tool interface may recognize based on the IMG property filter that a UI testing tool having image recognition capability is needed and select an appropriate tool adapter accordingly. The selected tool adapter may call the request for candidates function with the IMG based property filter. The request for candidates function may return from a selected UI testing tool a candidate list with 6 entries of GUI components. Afterward the component tracking module may call the match property filter function using the selected tool adapter for each of the 6 candidate components passing the X 120 property filter as one parameter. As the right most candidate component may be the only GUI component that matches the X 120 property filter the other candidate components may be removed from the candidate list and a matching component list with the right most candidate component may be returned as a response to the get matching components list function. In other words the uniform identifier may be used to identify the right most graphic block in a progress bar.

In one embodiment the uniform identifier may use regular expression or mathematic function as filtering functions. For example the uniform identifier may have two property filters one property filter checking whether the uniform property CLS of the GUI component is equal to Button the other property filter evaluating whether the uniform property TEXT matches the regular expression of 10 . Thus if there is a button in the GUI which has 10 contained in its label then the button may be deemed to have been identified by the uniform identifier . Further the property filter may use approximation for number evaluation. For example a property filter may check whether the Y position of a GUI component is within proximity of a target position value.

In one embodiment the uniform identifier may have one property filter based on a uniform property IMG and one relational filter having a relation function inside of and a relational uniform identifier referring to the uniform identifier . The uniform identifier may have one property filter based on a uniform property CLS and one relational filter having a relation function below of and a relational uniform identifier referring to the uniform identifier . And the uniform identifier may have two property filters based on uniform properties CLS and TEXT .

To identify a GUI component using the uniform identifier the component tracking module may invoke the get matching components list function using the uniform identifier as a parameter expecting to receive a matching components list. The component tracking module may then invoke the convert relational filter function using the inside of relational filter from the uniform identifier expecting a first list of property filters. The component tracking module may further invoke the get uniform proxy function with the uniform identifier retrieved from the relational filter inside of as a parameter expecting a first uniform proxy. In one embodiment the component tracking module may then invoke the convert relational filter function using the below of relational filter from the uniform identifier expecting a second list of property filters. Likewise the component tracking module may further invoke the get uniform proxy function with the uniform identifier retrieved from the relational filter below of as a parameter expecting a second uniform proxy.

In one embodiment the component tracking module may invoke the get matching components list function with the uniform identifier as a parameter and collects a matching components list having one GUI component with a label Memory . A component proxy module may create a new uniform proxy and assign the uniform identifier and the collected matching components list to the new uniform proxy. The new uniform proxy may be deemed the second uniform proxy mentioned above. Afterward the component tracking module may utilize the new uniform proxy to retrieve the Y and the H property values e.g. and of the wrapped GUI component and construct a list of one property filter Y 212 . The list of property filters may be deemed the second list of property filters mentioned above.

In one embodiment the component tracking module may merge the property filter Y 212 and the property filter of uniform identifier CLS ProgBar into a merged property filter list. The merged property filter list may be passed to the uniform identifier service in order to generate a new temporary uniform identifier T1. The component tracking module may then invoke the get matching components list function with the temporary uniform identifier T1 as a parameter and generate a matching components list with one GUI component the progress bar below the Memory label . Afterward the component proxy module may create another new uniform proxy by assigning the temporary uniform identifier T1 and the matching components list generated above. The new uniform proxy may be deemed the first uniform proxy mentioned above.

In one embodiment the component tracking module may utilize the first uniform proxy to retrieve the X Y W and the H property values e.g. and of the wrapped GUI component and construct a list of two property filters X between  and  and Y between  and  . The list of two property filters may be deemed the first list of property filters mentioned above. Thus the component tracking module may merge the returned property filters X between  and  and Y between  and  with the property filter of uniform identifier IMG into a merged property filter list then passes this merged property filter list to the uniform identifier service in order to collect another temporary uniform identifier T2. Finally the component tracking module may invoke the get matching components list function with the uniform identifier T2 as a parameter and collects a matching components list with one GUI component the progress bar separator of the progress bar below the Memory label . This GUI component may be deemed identified by the uniform identifier .

In other words the above identification process based on the uniform identifier may be summarized into the following steps A use the uniform identifier to identify a first list of GUI components B generate the second uniform proxy based on the uniform identifier and the first list of GUI components C use the second uniform proxy to generate the property filter Y 212 D generate the temporary uniform identifier T1 with the property filters Y 212 and CLS ProgBar E use the temporary uniform identifier T1 to identify a second list of GUI components F generate the first uniform proxy based on the temporary uniform identifier T1 and the second list of GUI components G use the first uniform proxy to generate the list of two property filters X between  and  and Y between  and  H generate the temporary uniform identifier T2 with the property filters X between  and  and Y between  and  and IMG I use the temporary uniform identifier T2 to identify a third list of GUI components which contain the identified GUI component.

Thus the abstract layer may bring the advantages of script based UI tools to high level PL. By utilizing a high level PL the UI testing platform may be more reliable highly scalable and have high code reusability. The high level PL may also be better in handling complex algorithms and data structures as well as in supporting advanced UI technologies. Thus the high level PL is suitable for testing big and complex system implemented using multiple technologies. At the same time by utilizing the abstract layer the UI testing platform may enable code portability and code reusability which may reduce time and resource in providing reliable and repeatable test executions.

At block a UI testing platform of an automatic testing system may be configured to maintain an abstract layer for testing a GUI having a plurality of GUI components. Each of the UI testing tools may be configured to interact with one or more of the plurality of GUI components to perform automatic testing of the GUI.

At block the UI testing platform may issue a test command to the abstract layer for the testing of a GUI component selected from the plurality of GUI components in the GUI. The UI testing platform may obtain a first uniform identifier from the abstract layer and embed the first uniform identifier in the test command. The abstract layer may receive the test command which is configured to simulate a user action performed on a GUI component selected from the plurality of GUI components.

At block the abstract layer may extract the first uniform identifier from the test command and select a UI testing tool from the plurality of UI testing tools for interacting with the GUI component. The abstract layer may be configured to dynamically identify the GUI component from the plurality of GUI components based on the first uniform identifier.

In one embodiment the first uniform identifier may contain a first property filter having a corresponding filtering function and a corresponding filtering value. The abstract layer may obtain a first subset of GUI components that satisfy the first property filter by filtering the plurality of GUI components using the corresponding filtering function and the corresponding filtering value in the first property filter. The GUI component to be identified may be in the first subset of GUI components.

In one embodiment in additional to the first property filter the first uniform identifier may further contain a second property filter having a corresponding filtering function and a corresponding filtering value. In this case the abstract layer may obtain a second subset of GUI components that satisfy the second property filter by filtering the first subset of GUI components using the corresponding filtering function and the corresponding filtering value in the second property filter. Afterward the GUI component to be identified may be in the second subset of GUI components.

In one embodiment the first uniform identifier may include a first relational filter having a corresponding relation function and a corresponding relational uniform identifier. The abstract layer may convert the relational filter to a first property filter based on the corresponding relation function and the corresponding relational uniform identifier in the first relational filter. The abstract layer may then obtain the GUI component from the plurality of GUI components by filtering the plurality of GUI components using the first property filter.

In one embodiment in addition to the first relational filter the first uniform identifier may further contain a second property filter having a corresponding relation function and a corresponding relational uniform identifier. The abstract layer may generate a second uniform identifier based on the first property filter and the second property filter and identify the GUI component from the plurality of GUI components using the second uniform identifier.

In one embodiment the first uniform identifier may contain a first relational filter having a corresponding relation function and a corresponding relational uniform identifier. The abstract layer may generate a uniform proxy based on a second GUI component identified from the plurality of GUI components using the corresponding relational uniform identifier. The abstract layer may generate a second property filter based on a property value extracted from the uniform proxy. The abstract layer may then obtain the GUI component from the plurality of GUI components by filtering the plurality of GUI components using the second property filter.

At block the abstract layer may be configured to utilize a uniform interface to communicate with the selected UI testing tool for interacting with the GUI component based on the test command.

At block a UI testing platform in an automatic user interface testing system may be configured to maintain an abstract layer for testing a GUI. The GUI may contain a plurality of GUI components. At block the abstract layer may be configured to provide a uniform identifier to identify one of the plurality of GUI components. The UI testing platform may utilize the uniform identifier to issue test commands for the testing of the specific GUI component identified by the uniform identifier. At block the abstract layer may be configured to provide a uniform interface for access a plurality of user interface UI testing tools. Each of the plurality of UI testing tools may be configured to interact with one or more of the plurality of GUI components.

At block the UI testing platform may be configured to issue a test command for interacting with a GUI component selected from the plurality of GUI components. The test command may contain a specific uniform identifier for identifying the GUI component. Upon receiving the test command from the UI testing platform the abstract layer may be configured to extract the uniform identifier from the test command. At block the abstract layer may be configured to select a UI testing tool from the plurality of UI testing tools for handling the test command. The UI testing tool may then locate the GUI component from the GUI based on the uniform identifier and perform automatic testing operations on the GUI component.

One skilled in the art will appreciate that for this and other processes and methods disclosed herein the functions performed in the processes and methods may be implemented in differing order. Furthermore the outlined steps and operations are only provided as examples and some of the steps and operations may be optional combined into fewer steps and operations or expanded into additional steps and operations without detracting from the essence of the disclosed embodiments. Moreover one or more of the outlined steps and operations may be performed in parallel.

Systems and methods for managing code review have been disclosed. The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the disclosure may be useful machine operations. In addition one or more embodiments of the disclosure also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers virtual machines and the like.

One or more embodiments of the present disclosure may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable storage medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present disclosure have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the disclosure s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

