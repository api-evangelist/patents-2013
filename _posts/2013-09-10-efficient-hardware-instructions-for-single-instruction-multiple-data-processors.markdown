---

title: Efficient hardware instructions for single instruction multiple data processors
abstract: A method and apparatus for efficiently processing data in various formats in a single instruction multiple data (“SIMD”) architecture is presented. Specifically, a method to unpack a fixed-width bit values in a bit stream to a fixed width byte stream in a SIMD architecture is presented. A method to unpack variable-length byte packed values in a byte stream in a SIMD architecture is presented. A method to decompress a run length encoded compressed bit-vector in a SIMD architecture is presented. A method to return the offset of each bit set to one in a bit-vector in a SIMD architecture is presented. A method to fetch bits from a bit-vector at specified offsets relative to a base in a SIMD architecture is presented. A method to compare values stored in two SIMD registers is presented.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342314&OS=09342314&RS=09342314
owner: Oracle International Corporation
number: 09342314
owner_city: Redwood Shores
owner_country: US
publication_date: 20130910
---
This application claims the benefit of Provisional App. No. 61 801 207 filed Mar. 15 2013 under 35 U.S.C. 119 e . This application also claims the benefit of Provisional App. No. 61 709 142 filed Oct. 2 2012 under 35 U.S.C. 119 e . The application also claims benefit as a continuation in part of U.S. patent application Ser. No. 13 708 054 filed Dec. 7 2012 which in turn claims priority to Provisional App. No. 61 709 142 filed Oct. 2 2012 and of Provisional App. No. 61 568 644 filed Dec. 8 2011. The entire contents of each of these documents are hereby incorporated by reference as if fully set forth herein.

The present invention relates to single instruction multiple data instructions and more specifically to efficient hardware instructions for single instruction multiple data processors.

Data formats are designed to enable efficient processing and storage of a variety of different dataset characteristics. Algorithms that process data in these formats are critical. Unfortunately current processors are not always capable of working with particular data formats efficiently.

Processor designers have historically provided minimal direct support for application specific instructions. Thus software developers have relied on the increasing speed at which existing processors execute a set of instructions to increase performance of a particular algorithm.

The performance of typical processing units however is not increasing at the same rate. Thus software developers are not able to rely as much on increasing computer power to more quickly process particular data formats.

Single instruction multiple data SIMD processors perform the same operation on multiple data items simultaneously. SIMD processors exploit data level parallelism by executing a single instruction against data in multiple registers or subregisters. Thus the throughput per instruction may be increased accordingly. SIMD processors are typically used for graphic and other multimedia applications. Accordingly it may be difficult to use the SIMD architecture to process particular data formats efficiently.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

For purpose of explanation the following terms and conventions are used herein to describe embodiments of the invention 

The term byte herein describes number of contiguously stored bits. While the common usage implies eight bits the size of a byte may vary from implementation to implementation. For example a byte may refer to any size including but in no way limited to eight bits sixteen bits thirty two bits sixty four bits and so on.

The notation herein describes a vector of bits e.g. . Spaces may be added between bits merely to increase the ability to read the contents of the vector e.g. .

The notation J K herein describe a set of contiguous values where J is a first value and K is a second value which may be equal or different.

The notation 0x may be used to denote a hexadecimal number. For example 0x2C may be used to represent the number forty four. In some embodiments where bit representations may be unwieldy hexadecimal representations may be used to increase the ability to read and understand the description.

The term register is a register or subregister that may include one or more smaller subregisters. Unless otherwise specified a register may be a SIMD register or a register typically used in the scalar processor.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Several instructions are presented for processing particular data formats using SIMD architecture. Specifically instructions to unpack fixed width bit values unpack variable length byte values decompress run length encoded bit vectors find offsets for bits set to one in a bit vector gather particular bits from a bit vector and comparing two value vectors on a SIMD processor are described.

Many of the instructions presented may be particularly useful for performing operations on particular data formats in memory. The instructions may operate over memory registers or immediate operands. Furthermore instructions with memory operands may operate on data with different degrees of granularity such as a cache line or page sized chunk.

A SIMD instruction is an instruction that when processed may cause an operation to be performed multiple times simultaneously and or in parallel on multiple distinct data values. For the purpose of illustrating a clear example assume four integer values are to be incremented by one. Also assume that a SIMD processor receives a single SIMD Increment by One instruction. In response to receiving the single SIMD instruction the SIMD processor may increment each of the four integer values simultaneously.

In contrast a scalar instruction is an instruction that when processed may cause an operation to be performed once. Multiple scalar instructions may be processed serially within a scalar processor processing unit or processing core. Assume for purposes of illustrating a clear example the same four values in the previous example are to be incremented by one on a scalar processor. The scalar processor may execute a first scalar Increment by One instruction causing the first value to be incremented by one then the scalar processor may execute a second scalar Increment by One instruction causing the second value to be incremented by one and so on. Thus in this example the scalar processor must execute three more Increment by One instructions than the SIMD processor in the previous example. Furthermore assume that the scalar processor performs a scalar Increment by One instruction as quickly as the SIMD processor executes a SIMD Increment by One instruction. Because the scalar processor performs scalar instructions serially and the SIMD processor performs a SIMD instruction on multiple data objects in parallel the scalar processor may take four times longer to process all four values than the SIMD processor.

One approach for implementing a SIMD operation is to use one or more registers that are each capable of storing multiple distinct data values. Such registers are referred to herein as SIMD registers. Assume for purposes of illustrating a clear example that a SIMD register is capable of storing 256 bits. Accordingly the SIMD register is capable of storing eight distinct 32 bit values each in a 32 bit subregister four distinct 64 bit values each in a 64 bit subregister or two distinct 128 bit values each in a 128 bit subregister. Additionally or alternatively non power of two sized subregisters may be used.

A SIMD operation implemented in hardware and may take one or more machine cycles to execute. For example a scalar processor in response to receiving an Increment by One instruction may increment a value loaded into a register in a single cycle. Likewise a SIMD processor in response to receiving an Increment by One instruction may increment multiple values loaded into multiple SIMD registers or SIMD subregisters in parallel in a single cycle. Additionally or alternatively one or more SIMD instructions may take more than one cycle to execute.

A computer system that implements both SIMD and non SIMD instructions may include one or more SIMD registers and one or more non SIMD registers. Additionally or alternatively a register may be a SIMD register for purposes of executing SIMD instruction and a non SIMD register for purposes of executing a non SIMD instruction. Additionally or alternatively SIMD registers may be on a different hardware element for example a different coprocessor than the hardware element on which non SIMD registers reside.

A SIMD instruction fixed width bit unpack bunpk may be used to unpack fixed width bit values into fixed width bytes. To efficiently use some SIMD instructions each value in a register may be stored in and aligned with its own subregister. Accordingly this instruction may be used as an enabler for some subsequent SIMD processing by copying each bit packed value in a bit vector into and aligned with its own subregister.

Specifically executing this instruction stores values originally formatted as a series of contiguous bits in a SIMD register into separate contiguous subregisters. Furthermore each value may be shifted and aligned within the subregister that the value is stored in. For example the values three one and seven may each be represented as three bits and may be packed in a bit vector e.g. wherein the left bit is the least significant bit stored in a SIMD register. After performing the bunpk instruction on the SIMD register each value may be stored and aligned in its own separate subregister represented as and .

In an embodiment the instruction may take as operands a register or subregister that contains a series of fixed width bit values a register containing subregisters that will store the unpacked values and a register containing the bit width of each packed value. Alternatively the register containing the bit width of each packed value may be an immediate value. Furthermore a completer may be included which indicates the size of each subregister the unpacked values will be stored in. A completer is a value that may be part of the instruction. For example a completer may specify the size of SIMD subregister s used. An instruction may have one or more completers. In one embodiment where sz is the completer the bunpk instruction may be in the form of bunpksz s2 s1 r1

As a specific example using the form above bunpk2 s2 s1 r1 assuming the value stored in r1 is three and upon execution of the example 3 bit values stored contiguously in register s1 may be unpacked into the 2 byte subregisters in s2. Each subregister in s2 may be to be 2 bytes for this instruction because the completer in this example is 2 . For example assume is stored in register s1. Upon execution of this instruction the bits stored in the first subregister in s2 would be the bits stored in the second subregister in s2 would be and the bits stored in the third subregister in s2 would be .

Alternatively the second parameter s1 may be the immediate value that represents the packed bits. For example if 0x01CB is the hexadecimal representation of then bunpk2 s2 0x01CB r1 may yield the same result as the first example above in register s2.

In other embodiments other operands and completers may indicate how the unpacked values may be stored in each subregister. For example an operand may indicate whether unpacked values should be aligned right or left in a subregister or the endianness of the data in a register.

SIMD register comprises subregister subregister and subregister although subregister is discussed in the following example. The spaces in subregister have been included merely to make it easier to follow particular packed bit values. The subregisters in register may be any size however for purposes of giving a clear example and in following the examples above the subregisters in register are sixteen bits wide.

SIMD register comprises subregister subregister and subregister . The spaces in the subregisters of register have been included merely to make it easier to follow particular packed bit values. The subregisters in register may be any size however for purposes of giving a clear example and in following the examples above the subregisters in register are sixteen bits wide.

In step 0 Subregister is loaded to contain the packed bits about to be unpacked. Notice just as in the example above that that first three sets of bits are representing values three one and seven respectively. Each value will be unpacked into a corresponding subregister in register .

In step 1 A shuffle is performed to copy the packed values into corresponding subregisters to be unpacked. For example the entire contents of subregister which holds the first three values are copied and stored in subregister subregister and subregister which are subregisters in SIMD register . SIMD register comprises subregister and subregister . The subregisters in register may be any size however for purposes of giving a clear example and in following with the examples above the subregisters in register are sixteen bits wide.

In step 2 A shift is performed to align each unpacked value to its respective target subregister. Accordingly subregister is not shifted at all since is already aligned with the beginning of subregister . Subregister is shifted three bits such that is aligned with the beginning of subregister . Subregister is shifted six bits such that is aligned with the beginning of subregister . In the embodiment illustrated in the values are aligned to the left. In other embodiments alignment may be to the right. In still other embodiments alignment be byte aligned within the register but may not be aligned to the beginning of the subregister.

In step 3 A mask is applied to each subregister to clear artifacts from the shuffle in step 1. For example in subregister the last thirteen bits contain set bits which are artifacts from copying the entire subregister to subregister in step 1. Thus a mask is applied to register clearing the last thirteen bits in subregister . Subregister and subregister may be similarly masked.

Therefore at the end of step 3 and as illustrated in the first three fixed width bit values stored in register are unpacked in register such that each value is copied into and aligned with its own subregister.

The pseudo code below describes an embodiment of performing the bunpk instruction on a scalar processor. While the pseudo code below illustrates an embodiment other embodiments may omit add to reorder and or modify any portions described below.

In the pseudo code above the least significant bit is the right most bit and memory grows to the left. In the written description below however the least significant bit is the left most bit and memory grows to the right. As shown in the pseudo code above a serial process may be used to unpack a fixed width value bit vector to a fixed width value byte vector. According to an embodiment first for each value the bytes which the value spans may be retrieved. Second the bytes where the value is not byte aligned are shifted such that the bits that represent the value are shifted to the least significant bits. Third all bits that do not represent the value are masked or set to zero. Fourth if the value spans more than one byte the bytes may be joined.

As merely an example assume five values A B C D E each three bits wide are stored in two contiguous eight bit registers b1 and b2. By way of notation shall be the 3 bit representation of the value A. Accordingly in this example b1 contains and b2 contains . Accordingly the following exemplary process may be carried out in an embodiment. This example is in no way meant to be limiting. While this example discusses particular steps according to an embodiment other embodiments may omit add to reorder and or modify any of the steps below based at least in part on the employer candidates available and the particular methods used.

In step 1 An iterative loop is defined to iterate over each value in the bit vector. For example an iterative loop is defined such that an iteration value iter begins at zero and is iteratively incremented by three since each value is three bits in this example.

In step 2 A low byte is be determined. A low byte may be determined by integer dividing the current value of iter by the width of the destination byte in the byte vector. For example in the third iteration to unpack C represented by the last two bits in register b1 and the first bit in register b2 the low byte may be determined by integer dividing the current value of iter which in this example is six by the width of the destination byte which in this example is eight. Thus the low byte for value C in this example is zero since the integer division of six by eight equals zero.

In step 3 A high byte is determined. A high byte may be determined by summing the current value of iter with the width of the packed value and integer dividing the sum by the width of the destination byte in the byte vector. For example in the third iteration which unpacks C the high byte may be determined by summing of the current value of iter by the width of the bit value which in this example equals nine and integer dividing the sum by the width of the destination byte which in this example is eight. Thus the high byte in this example is one since the integer divide of nine by eight equals one.

In step 4 If the low byte is equal to the high byte then the whole value is stored within a single byte and the process proceeds to step 5. Alternatively if the low byte is less than the high byte then the value is partially represented in the low byte and partially represented in the high byte and proceeds to step 6.

In step 5 The value is unpacked from the low byte. For example if unpacking B from b1 to result register Res then the contents of b1 may be stored in Res. Thus Res would be . Res may then be left shifted by iter which in this example is three. Thus Res would be . A mask may then be created to remove the bits that do not represent B by performing a bitwise NOT of the quantity negative one right shifted by the size B which in this example is three. Thus the mask would be . Finally the mask may be applied to Res by performing a bitwise AND between Res and the mask. Thus Res would equal . Since the entire value was in the low byte control returns to process the next iteration.

In step 6 The value is unpacked. If the low byte and the high byte are the same byte the value may be extracted from the low byte alone. Alternatively the bits that represent the value in the low byte the high byte and the bytes between may be extracted and joined.

For example in the third iteration which unpacks C the low byte b1 is loaded in a temporary register TmpLow which in this example is presumed to be the same size as b1. Specifically TmpLow would contain . TmpLow is shifted left by iter modulo the width of Reg which in this case would be six bits. Thus TmpLow would be .

The length of the bits used from TmpLow denoted as TmpLowLength is computed by computing the difference between the width of TmpLow and number of bits shifted left. Thus TmpLowLength is equal to eight minus six which equals two.

TmpHighLength is computed by computing the difference between the widths of the packed bits which in this example is three and the TmpLowLength. Thus in this example TmpHighLength is equal to three minus two which equals one.

To unpack the bits in the high byte the high byte b2 is loaded in a temporary register TmpHigh which in this example is presumed to be the same size as b2. Specifically TmpHigh would contain .

A mask TmpHighMask is created by storing negative one in a register and right shifting TmpHighMask by TmpHighLength. Thus TmpHighMask would be .

The mask is applied to TmpHigh by performing a bitwise AND between TmpHigh and TmpHighMask. Thus TmpHigh would be .

The final result is stored in a result register Res by right shifting TmpHigh by TmpLowLength and performing a bitwise OR between TmpLow and TmpHigh. Since in this case TmpLowLength equals two after right shifting TmpHigh by TmpLowLength TmpHigh would be . Thus after performing the bitwise OR Res would be the product of OR which is .

A SIMD instruction variable length byte unpack vlbunpk may be used to unpack variable length byte values into fixed width bytes. To efficiently use some SIMD instructions each value in a register may be stored in fixed width bytes. Accordingly this instruction may be used as an enabler for some subsequent SIMD processing by storing each variable length byte value as a fixed width byte value.

Specifically executing this instruction stores each value originally packed in a series of variable length contiguous bytes in a SIMD register into contiguous fixed length subregisters in a SIMD register. For example the values 1555343273 59107 44 and 15937781 may be represented in four bytes two bytes one byte and three bytes respectively. For example 0x5CB4A7A9 0xE6E3 0x2C 0xF330F5 may be loaded in a first SIMD register. After performing the vlbunpk instruction on the first register each value may be represented in contiguous fixed width subregisters. For example 0x5CB4A7A9 0x0000E6E3 0x000000002C 0x00F330F5 such that each value is stored in a separate contiguous SIMD subregister.

Since the length of each value in the original packed representation is variable another register may contain a set of corresponding values that indicate the length of each variable length packed value. Continuing with the example above a separate register may contain four values e.g. 4 2 1 3 which are the byte lengths of each corresponding variable length value. The lengths for each of the values in this register may be defined or based on an operand or completer included with the instruction.

To ensure each of the packed variable length values may be represented within the unpacked fixed width representation each value is represented with same number of bytes as the greatest value in the packed variable length values. Thus as exemplified above the values 0x5CB4A7A9 0xE6E3 0x2C and 0xF330F5 may each be represented using four bytes after executing the vlbunpk instruction e.g. 0x5CB4A7A9 0x0000E6E3 0x000000002C and 0x00F330F5.

In an embodiment the instruction may take as operands a first register that the unpacked fixed length values will be stored in a second register containing the variable length byte values and a third register with corresponding values that represent the number of bytes used to represent each packed variable length value in the second register. Furthermore a completer may be included to define the length of the resulting unpacked fixed length values and the number of bits needed to represent each value in the third subregister. For example vlbunpk4 s2 s1 r1

In the example instruction above packed variable length contiguously stored values in s1 with corresponding length values stored in r1 may be unpacked into fixed width 4 byte representations stored in s2. For example assume the packed variable length representations of values 0x5CB4A7A9 0xE6E3 0x2C 0xF330F5 are stored in register s1 and corresponding lengths 4 2 1 3 are stored in register r1. Upon execution of this instruction 4 byte representations of each value are stored in register s2 such that each of the values in 0x5CB4A7A9 0x0000E6E3 0x000000002C 0x00F330F5 in s2 is stored in its own contiguous subregister. In other embodiments other operands and completers may indicate how the values are unpacked or stored in a register or memory.

In step 0 In preparation for the vlbunpk instruction the packed variable length values are loaded into register and the corresponding lengths are loaded into register . For example SIMD register contains four packed variable length values 0x5CB4A7A9 0xE6E3 0x2C 0xF330F5 .

SIMD register contains the corresponding lengths for each of the values stored in register . Specifically register includes 4 2 1 3 . In an embodiment the length of the values in register are based on the completer of the instruction. For example if the completer is set to four as in the example above then two bits may be used to describe all the possible lengths of each of the values in register . For example 4 2 1 3 may be represented as .

In step 1 The instruction is performed by storing the variable length byte values in register into register according to the values stored in register . For example register comprises subregister subregister subregister and subregister . The subregisters in register may be any size however for purposes of giving a clear example and in keeping with the examples above the subregisters in register are four bytes wide. A copy of the first four bytes of register based on the first two bits in register is stored in subregister . This copy is a perfect size match and so nothing further may be required. Accordingly subregister may contain 0x5CB4A7A9 which is a four byte representation of 0x5CB4A7A9.

A copy of next two bytes of register based on the next two bits in register are copied to subregister . However when the two bytes from register are copied to subregister the value is zero extended to fit in the target subregister . Thus subregister may contain 0x0000E6E3. Alternatively the value may be sign extended. In yet another alternative the bytes are merely copied into the first two bytes of subregister but subregister may have been previously cleared so as not to have any artifacts from previous values stored in subregister .

Likewise the next byte of register based on the next two bits in register is copied into subregister zero extended. Also likewise the next three bytes of register based on the next two bits in register is copied into subregister zero extended. Accordingly subregister and subregister may contain 0x000000002C 0x00F330F5 .

Accordingly after performing the instruction register may contain the unpacked fixed length values 0x5CB4A7A9 0x0000E6E3 0x000000002C 0x00F330F5 in contiguous subregisters through .

The pseudo code below describes an embodiment of performing the vlbunpk instruction on a scalar processor using the operands and completers defined in the sections above. While the pseudo code below illustrates an embodiment other embodiments may omit add to reorder and or modify any portions described below.

As merely an example to explain the pseudo code above in further detail the following description is given. The values and steps used are merely for purposes of illustrating a clear example and are in no way intended to be limiting.

Assume for purposes of example that s1 includes the variable length values A B C D . Furthermore assume that the lengths of each of the values in s1 is stored in r1 using a two bit representation e.g. representing 4 2 1 3 .

Starting at the beginning of the first iteration through the for loop First the length of the first packed value A is retrieved from r1 by masking all the bits except the first two. Second the value A is extracted from s1 using an offset into s1 which in the first iteration is set to zero and the two bit value retrieved from r1 which is and maps to four. Third the first four bytes of s1 are extracted and stored in s2 in a four byte chunk as designated by the completer sz in the set szbyte simd function.

The first iteration ends by preparing for the next iteration. Specifically the offset into s1 is incremented by the number of bytes extracted. Thus the offset is updated to four since four bytes were retrieved in the first iteration. Furthermore the two bits in r1 that represented the length of the first value in s1 are shifted out. Thus the next two bit value which corresponds to the second value in s1 sits at the front of r1 to be used in the next iteration.

Starting again at the beginning of the second iteration through the for loop First the length of the second packed value B is retrieved from r1 by masking all the bits except the first two. Second the value B is extracted from s1 using the offset into s1 which in this second iteration is set to four and the two bit value retrieved from r1 which is maps to two. Third the next two bytes of s1 are extracted and stored in s2 in a four byte as designated by the completer sz in the set szbyte simd function.

The second iteration ends by preparing for the next iteration. Specifically the offset into s1 is incremented by the number of bytes extracted. Thus the offset is updated to six since two more bytes were retrieved in the second iteration. Furthermore the two bits in r1 that represented the length of the second value in s1 is shifted out. Thus the next two bit value which corresponds to the third value in s1 sits at the front of r1 to be used in the next iteration.

The third and fourth iterations proceed similarly as described above in the first two iterations. After all four iterations the values A B C D are unpacked and stored A B C D in s2 in fixed length four byte format.

A SIMD instruction burst may be used to decompress a run length encoded RLE compressed bit vector. An RLE compressed bit vector is a bit vector with a corresponding run vector such that each bit in the bit vector has a corresponding run value in the run vector. Each run value in the run vector indicates how many bits the corresponding bit in the bit vector should be extended. For example if a compressed bit vector has a corresponding run vector 2 6 then in the decompressed bit vector may be .

This instruction may be complicated because depending on the run values writes into the result register or memory may be too large for a single instruction. Accordingly the execution of a burst instruction may also update the operands of the instruction to reflect the current state such that a subsequent execution of the burst instruction will resume where the previous execution left off.

In an embodiment the burst instruction may take the following form and may operate on a particular number of bytes each time the instruction is executed burst r1 r2 r3 r4

In the embodiment above r1 is a pointer into memory indicating the byte at which the resulting decompressed bit vector should be stored r4 is the offset within the byte pointed to by r1 at which the resulting decompressed bit vector should be stored. Furthermore r2 is a pointer into memory indicating the byte at which the compressed bit vector is stored. Further still r3 is a pointer into memory indicating the byte at which the run vector may be stored.

In step 1 X numbers of bits from a compressed bit vector are loaded and X numbers of bytes from a corresponding run vector are loaded. For example r2 contains the address of a compressed bit vector in memory and r3 may contain the address of a corresponding run vector in memory. Accordingly the first two bytes sixteen bits of the bit vector may be loaded into a first register and the first sixteen bytes of the run vector are loaded into a second register. For purposes of illustrating a clear example assume that is loaded into the first register and 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 3 is loaded in the second register.

In step 2 The loaded bit vector is decompressed based on the loaded corresponding run vector. For example the compressed bit vector in the first register is decompressed based on the corresponding run vector loaded in the second register. The resulting decompressed bit vector may be stored in a third register. Thus the third register may contain the decompressed bit vector .

In step 3 The decompressed bit vector is stored in memory. For example the value loaded in the third register is stored in memory at the byte r1 addresses offset by the value in r4.

In step 4 The operands are updated such that a subsequent execution of the burst instruction will automatically 1 load the next contiguously stored bits in the compressed bit vector 2 load the next contiguously stored corresponding run values in the run vector and 3 store the results contiguously with the results stored in step 3. The word automatically here means that the operands need not be updated before a subsequent burst instruction is executed. Thus continuing with the current example 1 r2 is incremented by two to point to the next contiguous bits in the compressed bit vector in memory 2 r3 is incremented by sixteen to point to the next contiguous corresponding run values in the run vector in memory and 3 r1 is incremented by five to point to the next contiguous location in memory that the next resulting decompressed bit vector should be stored r4 however remains unchanged since forty the number of bits in five bytes modulo eight is zero.

Accordingly the operands of the burst instruction will reflect the current state such that subsequent executions of the burst instruction will resume where the previous execution left off.

In an embodiment the burst instruction may take the following form and may process up to a particular number of bytes each time the instruction is executed burst r1 r2 s1 r4

In the embodiment above r1 is a pointer into memory indicating the byte at which the resulting decompressed bit vector should be stored r4 is the offset within the byte pointed to by r1 at which the resulting decompressed bit vector should be stored. Furthermore r2 is a register that contains the compressed bit vector. And s1 is a SIMD register holding the run values of the corresponding run vector.

The following process may take place each time the burst instruction embodied above is executed. However in this form it is not always guaranteed that the burst instruction will complete the decompression for the bit vector stored is r2. Accordingly the following process may take different steps than the process above in order to resume execution where the previous execution left off 

In step 1 The loaded bit vector is decompressed based on the loaded corresponding run vector. For purposes of illustrating a clear example assume that is loaded into r2 and 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 3 is loaded in s1. However assume for purposes of explanation that the result register is four bytes wide. Thus when the compressed bit vector in r2 is decompressed based on the corresponding run vector loaded in s1 a partial decompressed bit vector may be stored in the result register. In this example the full decompressed bit vector cannot be stored in the result register since in this example the result register is four bytes wide and the entire decompressed bit vector is five bytes wide. Thus the result register may contain the partially decompressed bit vector .

In step 2 The partially decompressed bit vector is stored in memory. For example the value loaded in s1 is stored in memory at the byte r1 addresses offset by the value in r4.

In step 3 The operands are updated such that a subsequent execution of the burst instruction will automatically 1 resume decompressing the bit vector in r2 based on the corresponding run vector in s1 and 2 the results will be stored contiguously with the results stored in step 2. The word automatically here means that the operands need not be updated before a subsequent burst instruction is executed to resume processing of the currently loaded compressed bit vector. Thus continuing with the current example 1 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2 3 is stored in s1 to reflect the compressed bits that were not fully decompressed and 2 r1 is incremented by four to point to the next contiguous location in memory that the next resulting decompressed bit vector should be stored r4 however remains unchanged since thirty two modulo eight is zero.

Accordingly the operands of the burst instruction will reflect the current state such that subsequent executions of the burst instruction will resume where the previous execution left off.

Register corresponds with register r2 and contains a compressed bit vector comprising one or more bits in step 1. Specifically register contains the compressed bit vector .

SIMD register corresponds to SIMD register s1 and contains the run vector stored in s1. SIMD register comprises a series of subregisters such that each subregister stores a run value in the run vector in step 1. Specifically register comprises subregister which contains the first run value two subregister which contains the second run value three subregister which contains the third run value two and subregister which contains the fourth run value three. As indicated register contains further subregisters not illustrated in .

Register corresponds to the result register and contains the partially decompressed bit vector at the end of step 1. Specifically register contains the first four bytes of the decompressed bit vector .

After performing the Burst instruction register may contain the decompressed bit vector. Alternatively the decompressed bit vector may be stored or partially stored in memory .

Memory may be on chip cache located on a processor. Alternatively memory may be off chip cache or main memory. Memory may store full or partial decompressed bit vectors stored register as described in step 2 above.

The pseudo code below describes an embodiment of performing the burst instruction on a scalar processor similarly using the operands and completers defined in the sections above as variables. While the pseudo code below illustrates an embodiment other embodiments may omit add to reorder and or modify any portions described below.

A SIMD instruction onesidx may be used to return the index of each bit set to one in a bit vector. For example if an operand contains the bit vector then upon successful completion of the onesidx a SIMD register may contain the index of each bit set to one in each subregister e.g. 0 5 9 10 11 .

This instruction may be complicated because depending on the number of bits set to one writes into the result register may be too large for a single instruction. Accordingly the execution of a onesidx instruction may also update the operands of the instruction to reflect the current state such that a subsequent execution of the onesidx instruction will resume where the previous execution left off.

In an embodiment the onesidx instruction may take the following form and may find up to a particular number of indexes each time the instruction is executed onesidxsz.btype s1 r1 r2 r3

In the embodiment above the register r1 may be the byte address in memory to begin searching a bit vector and r2 may be the offset with the byte r1 points to to begin searching.

The SIMD register s1 may include a series of subregisters each of which may store an index value. The byte size of each subregister in s1 may be defined by the sz completer. The register r3 may contain the number of indexes found during execution. The btype completer may be the upper bound on the number of bytes to be searched. For example cache may indicate that an entire cache line starting at the byte r1 points to should be searched. Similarly page may indicate that an entire page starting at the byte r1 points to should be searched. For example onesidx1.cache s1 r1 r2 r3 may instruct the processor to 1 search the bits in memory starting at the byte in memory that r1 addresses offset by the value stored in r2 through to the end of the cache line 2 store the index of each bit set to one in a one byte subregister located in s1 and 3 store the number of indexes found in r3. In other embodiment completer btype may be a number indicating the number of bytes to be searched.

In this embodiment execution of the onesidx instruction may terminate if either s1 is filled to capacity or the bits in the bit vector are searched. Thus it is not always guaranteed that the onesidx instruction will complete the search of the bit vector in memory. Accordingly the following process may take place each time the onesidx instruction embodied above may be executed 

In step 1 The bit vector is loaded from memory into a first register. For purposes of illustrating a clear example assume that is loaded into a first register based on the memory address stored in r1.

In step 2 The loaded bit vector is searched starting at the offset stored in r2 the indexes are stored in a SIMD register and the number of indexes found is updated. For purposes of explanation assume that r2 is set to zero the SIMD register s1 is one four bytes long and each subregister is one byte. As the bit vector in the first register is searched the index of each bit set to one is stored in a subregister in s1 until s1 is full. Furthermore each index stored in s1 increments the value in r3. Since s1 is not wide enough to hold all the index values step 2 terminates when 0 5 9 10 is stored in s1 and the value four is stored in r3.

In step 3 The operands r1 and r2 are updated such that a subsequent execution of the onesidx instruction automatically resumes indexing the bit vector in memory. Here automatically here means that that the operands need not be updated before a subsequent onesidx instruction is executed to resume processing of the bit vector stored in memory. Thus continuing with the example r1 is incremented by two in order to point to the byte where searching terminated. Furthermore r2 is set to three to indicate that the fourth bit where searching should be resumed.

Accordingly the operands of the onesidx instruction will reflect the current state such that subsequent execution of the onesidx instruction will resume where the previous execution left off.

In an embodiment an operand may indicate where in memory the indexes stored in s1 should be stored. Furthermore the operand may be updated in step 3 such that in subsequent executions the index values are contiguously stored automatically.

In another embodiment the bit vector may reside in r1. Accordingly the value stored in r2 may indicate which bit in r1 searching should begin. Furthermore at the end of step 3 r2 may be updated such that subsequent execution of the onesidx instruction will resume where the previous execution left off.

SIMD register may contain a bit vector comprising one or more bits loaded from memory. In keeping with the example above register includes the bit vector . As indicated register may contain more bits but those bits are not illustrated in this example.

SIMD register corresponds to s1 in the example above and may be series of subregisters such that the value stored in each subregister may be the offset of a bit set to one in register . Specifically register comprises subregister subregister subregister and subregister which are the offsets for the first four bits in register set to one respectively. In keeping with the example above after performing the onesidx instruction register may contain offset values 0 5 9 10 based of one or more bits set to one in register . Specifically the values 0 5 9 and 10 are stored in subregister subregister subregister and subregister respectively.

Memory may be on chip cache located on the SIMD processor. Alternatively memory may be off chip cache or main memory. Memory may contain the bit vector loaded into register as described in step 1 above.

The pseudo code below describes an embodiment of performing the onesidx instruction on a scalar processor using the similarly using the operands and completers defined in the sections above as variables. While the pseudo code below illustrates an embodiment other embodiments may omit add to reorder and or modify any portions described below.

A SIMD instruction gatherb may be used to fetch the value of bits stored in a bit vector indexed by an index vector. The results may be stored many different formats. For example the result could be a bit mask wherein each bit represents the value of the corresponding bit fetched in the bit vector and zero otherwise. Alternatively the result may be a series of subregisters where each subregister indicates the value of the corresponding bit fetched.

In one embodiment the gatherb instruction may include three operands. The first operand may contain an input bit vector. The second operand may contain an index vector. And the third operand may contain the result after the gatherb instruction has been executed.

In an embodiment upon execution of the gatherb instruction a bit mask may be stored which describes the values of the bits fetched. Furthermore the gatherb instruction may take the following form gatherbsz r2 s1 r1

Specifically in the embodiment above r1 may be a register that stores a bit vector. The register s1 may be a SIMD register which may contain the index vector such that each subregister in s1 may contain an index value. The completer sz may indicate the size of each subregister in s1. The resulting bit mask is stored in r2.

For example assume that the bit vector is loaded in r1 the index vector 1 5 10 13 is loaded in s1 and the size of each subregister in s1 is one byte and a bit mask is loaded in r2. Upon execution of gatherb1 r2 s1 r1 the values of the bits in the bit vector at the indexed locations are copied into the corresponding bits in r2. Thus r2 may contain the bit mask . In an embodiment r2 may be cleared as an initial step when executing the gatherb instruction such that artifacts from previously stored bits in r2 are cleared before storing copies of the indexed bits in r2.

In an embodiment upon execution of the gatherb instruction the bit values stored in the bit vector indexed by the index vector may be stored sign extended in a series of subregisters corresponding to each index value in the index vector. Furthermore the gatherb instruction may take the following form gatherb.cmb s2 s1 r1

Specifically in the embodiment above r1 may be a register that stores a bit vector. The register s1 may be a SIMD register which may contain the index vector such that each subregister in s1 may contain an index value. The register s2 may be a SIMD register which may contain a series of subregisters which each correspond to a subregister in s1. The completer cmb may specify both the length of the subregisters in s1 and s2. Thus the completer cmb may contain two numerals the first numeral indicating the size of s1 and the second numeral indicating the size of s2.

In one embodiment the numerals in the smb completer may be b w or d such that b may indicate a byte size of one w may indicate a byte size of two and d may indicate a byte size of four. Other numerals or formats may be used in other embodiments. For example gatherbwd s2 s1 r1 may indicate that the subregisters in s1 are each two bytes and the subregisters in s2 are each four bytes.

For purposes of illustrating a clear example assume that the bit vector is loaded in r1 the index vector 1 5 10 13 is loaded in s1. Upon execution of gatherbbb r2 s1 r1 the values of the bits at the indexed locations are copied into s2 sign extended. Thus s2 may contain such that each bit vector is stored in contiguous 1 byte subregisters in r2.

Register corresponds with register r1 and contains the bit vector stored in r1. Therefore in this example register contains the bit vector .

SIMD register corresponds to SIMD register s1 and contains the index vector stored in s1. SIMD register comprises a series of subregisters each one byte wide as indicated by the completer such that each subregister stores an index value in the index vector. Specifically register comprises subregister which contains the first index value one subregister which contains the second index value five subregister which contains the third index value ten and subregister which contains the fourth index value thirteen. As indicated register may contain further subregisters not illustrated in .

SIMD register corresponds to SIMD register s2 and contains the values stored in s2. SIMD register comprises a series of subregisters each one byte wide as indicated by the completer such that after the gatherb instruction has executed each subregister stores the sign extended value of the bit in register indexed by the respective index value in register . Specifically subregister contains the sign extended value of the second bit in register based on the corresponding index value in subregister . Subregister contains the sign extended value of the sixth bit in register based on the corresponding index value in subregister . Subregister contains the sign extended value of the eleventh bit in register based on the corresponding index value in subregister . Subregister contains the sign extended value of the fourteenth bit in register based on the corresponding index value in subregister . As indicated register may contain further subregisters not illustrated in .

Alternatively the following SIMD implementation may be used. The method below may take as input 1 a vector of codes and b a single SET where a SET may be a bit vector packed with contiguous values. For example for a bit vector of 5 bit codes each code may represent a bit in the SET. Therefore the SET may in an example contain 2 5 32 bits.

Specifically two based on the size of the SIMD register and the bit width of the codes either a first method Algorithm A may be performed or a second method Algorithm B may be performed 

1. Duplicate the set S which is of size 2 K into N 2 K partitions in a SIMD register for which thesplat operation may be used. Suppose that number is P i.e. P partitions are used in the register . So if K 5 bits and N 256 then P 256 32 8.

2. Load P K bit codes and store the codes in a SIMD register so that the codes are properly aligned within the respective partitions.

3. Use variable shift to shift each duplicated set by the K bit code to get the bit targeted in the little endian position.

3. Perform a GATHER instruction to fetch the bytes from the SET this operations fetches each byte in parallel.

4. Perform a MOD operation of values in step 1 to get the bit offset i.e. the bit position in the byte where the target bit we want is located.

And 6. MOVEMASK to take the eight 1 bit values in the 256 bit register computed from step 3 and copy to bit vector.

1 Splat the dictionary across 32 bit partitions in a 256 bit SIMD register wherein a splat copies a set of bits into each subregister. Since the SET is 32 bits wide eight copies of the SET are stored in the SIMD register. 2 Load eight 5 bit codes in a SIMD register so that each code is aligned on a 32 bit boundary in the 256 bit register and perform a SIMD LOAD b SHUFFLE to get the codes in 32 bit partitions c Variable Right Shift to shift each code to the right so that each code is aligned on the low end of the 32 bit partition and d AND mask out upper bits in each partition so that you re just left with the code. 3 Next apply variable shift using the SET register from step 1 with the index register from step 2 . The indexed bit is stored in the low end bit position of each 32 bit partition. 4 MOVEMASK to take the eight 1 bit values in the 256 bit register computed from step 3 and copy to the bit vector.

Alternatively for higher data widths e.g. 10 bit dictionary codes or more which may be wider than the size of the SIMD subregisters the following method may be performed 1 

Load the codes into a SIMD register similar to step 2 above. 2 Divide each partition by eight to get the byte offset where the bit is located in the SET. 3 Perform a GATHER instruction to fetch the bytes from the SET this operations fetches each byte in parallel. 4 Perform a MOD operation of values in step 1 to get the bit offset i.e. the bit position in the byte where the target bit we want is located. 5 Perform a variable shift using 4 and 3 to shift the bit to the low end position. And 6 MOVEMASK to take the eight 1 bit values in the 256 bit register computed from step 3 and copy to bit vector.

A SIMD instruction BitVecCmpRes may be used to compare two value vectors stored in two SIMD registers. Specifically each subregister in the first SIMD register is compared to the corresponding subregister in the second SIMD register. The output may be a space efficient bit vector stored in a result register.

In addition in an embodiment an offset may be included that indicates the offset within the result register the resulting bit vector should be stored. Having an offset may allow the results of several BitVecCmpRes executions to be saved in the same bit vector.

Specifically in the embodiment above the register s1 may be a SIMD register that contains a first value vector wherein the values in the first value vector are stored a series subregisters in s1. The register s2 may be a SIMD register that contains a second value vector wherein the values in the second value vector are stored a series subregisters in s2. Each subregister in s1 has a corresponding subregister in s2 and vice versa. The completer SZ may indicate the size of each subregister in s1 and s2. The register r1 may be a register that contains the resulting bit vector wherein each bit in the bit vector corresponds to corresponding subregisters is s1 and s2. Furthermore each bit in the bit vector is set to one if the values in the corresponding subregisters in s1 and s2 match and zero otherwise. The register r2 may contain the offset from which the resulting bit vector should be stored in r1.

For purposes of illustrating a clear example assume that the value vector in s1 contains 98 62 21 16 and the value vector in s2 contains 62 62 21 46 . Further assume that the value loaded in r2 is zero. Upon execution of the BitVecCmpRes1r1 s1 s2 r2 the resulting bit vector may be stored in r1.

Further assume that the values in s1 s2 and r2 are updated such that s1 contains 14 24 12 58 s2 contains 22 76 48 58 and r2 contains the value four. After BitVecCmpRes1r1 s1 s2 r2 is executed a second time r1 may contain the bit vector . The first four bits in the bit vector stored in r1 are not clobbered by the second execution because the resulting bits from the second execution were offset by four.

SIMD register corresponds to SIMD register s1 and contains the value vector stored in s1 before the first execution of the BitVecCmpRes instruction. SIMD register comprises a series of subregisters each of which is one byte as indicated by the completer such that each subregister stores a one value in the first value vector. Specifically register comprises subregister which contains the first value ninety eight subregister which contains the second value sixty two subregister which contains the third value twenty one and subregister which contains the fourth value sixteen. As indicated register may contain further subregisters not illustrated in .

SIMD register corresponds to SIMD register s2 and contains the value vector stored in s2 before the first execution of the BitVecCmpRes instruction. SIMD register comprises a series of subregisters each of which is one byte as indicated by the completer such that each subregister stores a one value in the second value vector. Specifically register comprises subregister which contains the first value sixty two subregister which contains the second value sixty two subregister which contains the third value twenty one and subregister which contains the fourth value forty six. As indicated register may contain further subregisters not illustrated in .

Register corresponds with register r1 and contains the bit vector stored in r1. Therefore in this example register contains the bit vector at the end of the first execution as discussed above.

Register corresponds with register r2 and contains the value stored in r2. Therefore in this example before the first execution of the BitVecCmpRes instruction register contains the value zero as discussed above.

In an alternative embodiment a completer may also designate the type of comparison made between corresponding subregisters. For example BitVecCmpResSZ.gt r1 s1 s2 r2 

In the example above the operands and SZ completer may be used similarly as discussed above. However in this example each bit in the bit vector is set to one if the values in the corresponding subregisters in s1 are greater than s2 and zero otherwise. Likewise any comparative operator may be used e.g. less than lt less than or equal to tle greater than or equal to gte equal to eq not equal to neq and so on.

Some of the embodiments illustrated above each subregister may be four eight or sixteen bits wide. Other embodiments may include other widths including but in no way limited to four bits eight bits thirty two bits sixty four bits.

In many examples subregisters may be one byte. However subregisters may be larger or smaller than one byte. Furthermore a default width an operand or a completer may be used to define the width of the subregisters for a particular instruction.

In some of the embodiments illustrated and discussed above the least significant bits were illustrated on the left side of registers or memory the sign bit was illustrated on the right side and bits or bytes were padded or shifted to one particular side. However the examples included above are not intended to be limiting. The instructions discussed above may be implemented on many various hardware configurations that are different than those illustrated.

While the methods described above may be focused on a SIMD architecture these methods may also be implemented on a scalar or other non SIMD processor. The methods may also be included as part of an application programming interface. Furthermore the methods may implemented as an intrinsic which may be a function a compiler recognizes and replaces with a particular block of assembly or machine code. Further still one or more instructions may be stored on one or more non transitory computer readable mediums which when executed by one or more processors may cause one or more of the methods described herein to be performed.

In many of the examples a SIMD register comprises four subregisters. This is not intended to be limiting in any way. SIMD registers may comprise more or fewer subregisters all of which may be varying widths.

In an embodiment memory grows is the address increases. In another embodiment memory grows as the address decrements. Accordingly any of the instructions may also include a completer or operand that indicates which direction memory is grows.

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

For example is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operation in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention and what is intended by the applicants to be the scope of the invention is the literal and equivalent scope of the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction.

