---

title: Systems and methods for application management of mobile device radio state promotion and demotion
abstract: Embodiments of the present disclosure include systems and methods for management of mobile device radio state. In some embodiments, a method, which can be implemented on a system, allows a network component (e.g., the policy and charging rules function in a UMTS network) to determine whether a mobile device is idle or active. Based on this determination, the network component may modify the behavior of a network element (e.g., a base station, eNode B or Node B) in relation to promotion or demotion of the mobile device's radio state. In some embodiments, the disclosed system can include a client side component on the mobile device which can determine criteria to be used by the network component to govern and optimize changes in mobile device radio state in a manner that conserves device and network resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09307493&OS=09307493&RS=09307493
owner: Seven Networks, LLC
number: 09307493
owner_city: San Carlos
owner_country: US
publication_date: 20130315
---
This application claims priority to and the benefit of the U.S. Provisional Application 61 740 392 entitled MANAGEMENT OF MOBILE DEVICE RADIO STATE PROMOTION AND DEMOTION BY BUFFER AND OR ACTIVITY MONITORING filed on Dec. 20 2012 the contents of which are all incorporated by reference herein.

This application is related to U.S. patent application Ser. No. 13 844 682 entitled MANAGEMENT OF MOBILE DEVICE RADIO STATE PROMOTION AND DEMOTION filed on Mar. 15 2013 the contents of which are all incorporated by reference herein.

Multiple factors may contribute to the proliferation of data on a mobile network the end user mobile devices wireless devices mobile applications and the network. As mobile devices evolve so may the various elements associated with the network such as availability applications user behavior location thus changing the way the network interacts with the device and the application.

Some mobile devices may have applications or other clients that create data e.g. background data background activity that appear active to the network when it is in fact idle or in a background state when the user is not using the device. This background data or signaling may cause the network to unnecessarily promote the mobile device from a lower powered radio state to a higher powered one causing unneeded or non optimal battery consumption and network resource consumption.

The following description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding of the disclosure. However in certain instances well known or conventional details are not described in order to avoid obscuring the description. References to one embodiment or an embodiment in the present disclosure can be but not necessarily are references to the same embodiment and such references mean at least one of the embodiments.

Reference in this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase In some embodiments in various places in the specification are not necessarily all referring to the same embodiment nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover various features are described which may be exhibited by some embodiments and not by others. Similarly various requirements are described which may be requirements for some embodiments but not other embodiments.

The terms used in this specification generally have their ordinary meanings in the art within the context of the disclosure and in the specific context where each term is used. Certain terms that are used to describe the disclosure are discussed below or elsewhere in the specification to provide additional guidance to the practitioner regarding the description of the disclosure. For convenience certain terms may be highlighted for example using italics and or quotation marks. The use of highlighting has no influence on the scope and meaning of a term the scope and meaning of a term is the same in the same context whether or not it is highlighted. It will be appreciated that same thing can be said in more than one way.

Consequently alternative language and synonyms may be used for any one or more of the terms discussed herein nor is any special significance to be placed upon whether or not a term is elaborated or discussed herein. Synonyms for certain terms are provided. A recital of one or more synonyms does not exclude the use of other synonyms. The use of examples anywhere in this specification including examples of any terms discussed herein is illustrative only and is not intended to further limit the scope and meaning of the disclosure or of any exemplified term. Likewise the disclosure is not limited to various embodiments given in this specification.

Without intent to limit the scope of the disclosure examples of instruments apparatus methods and their related results according to the embodiments of the present disclosure are given below. Note that titles or subtitles may be used in the examples for convenience of a reader which in no way should limit the scope of the disclosure. Unless otherwise defined all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this disclosure pertains. In the case of conflict the present document including definitions will control.

As used herein a module a manager a handler a detector an interface a controller a normalizer a generator an invalidator or an engine includes a general purpose dedicated or shared processor and typically firmware or software modules that are executed by the processor. Depending upon implementation specific or other considerations the module manager handler detector interface controller normalizer generator invalidator or engine can be centralized or its functionality distributed. The module manager handler detector interface controller normalizer generator invalidator or engine can include general or special purpose hardware firmware or software embodied in a computer readable storage medium for execution by the processor.

As used herein a computer readable medium or computer readable storage medium is intended to include all mediums that are statutory e.g. in the United States under 35 U.S.C. 101 and to specifically exclude all mediums that are non statutory in nature to the extent that the exclusion is necessary for a claim that includes the computer readable storage medium to be valid. Known statutory computer readable mediums include hardware e.g. registers random access memory RAM non volatile NV storage to name a few but may or may not be limited to hardware.

Certain of the embodiments disclose a comprehensive and end to end solution that is able to address each element for operators and devices manufacturers to support both the shift in mobile or wireless devices and the surge in data by leveraging the premise that mobile content has a definable or relevant freshness value. The freshness of mobile content can be determined either with certainty or with some heuristics having a tolerance within which the user experience is enhanced or not negatively impacted or negatively impacted but is either not perceptible to the user or within a tolerable threshold level.

Certain of the embodiments transparently determine such freshness by monitoring analyzing and applying rules which may be heuristically determined the transactions requests responses between applications e.g. mobile applications and the peers corresponding server or other clients . Moreover the technology is further able to effectively cache content which may be marked by its originating host server as being non cacheable and identify some freshness value which can then be used in implementing application specific caching. In general the freshness value has an approximate minimum value which is typically determined using the update interval e.g. interval with which requests are sent between the application and its corresponding server host.

One embodiment of the disclosed technology includes a system that optimizes multiple aspects of the connection with wired and wireless networks and devices through a comprehensive view of device and application activity including loading current application needs on a device controlling the type of access push vs. pull or hybrid location concentration of users in a single area time of day how often the user interacts with the application content or device and using this information to shape traffic to a cooperative client server or simultaneously mobile devices without a cooperative client. Because the disclosed server is not tied to any specific network provider it has visibility into the network performance across all service providers. This enables optimizations to be applied to devices regardless of the operator or service provider thereby enhancing the user experience and managing network utilization while roaming. Bandwidth has been considered a major issue in wireless networks today. More and more research has been done related to the need for additional bandwidth to solve access problems. Many of the performance enhancing solutions and next generation standards such as those commonly referred to as 3.5G Long Term Evolution LTE 4G and WiMax are focused on providing increased bandwidth. Although partially addressed by the standards a key problem that remains is lack of bandwidth on the signaling channel more so than the data channel and the standard does not address battery life very well.

Certain embodiments of the disclosed technology includes for example alignment of requests from multiple applications to minimize the need for several polling requests leverage specific content types to determine how to proxy manage a connection content and applying specific heuristics associated with device user behavioral patterns how often they interact with the device application and or network parameters.

Certain of the disclosed embodiments can further include moving recurring Hypertext Transfer Protocol HTTP polls performed by various widgets RSS readers etc. to remote network node e.g. Network Operation Center NOC thus considerably lowering device battery power consumption radio channel signaling and bandwidth usage. Additionally the offloading can be performed transparently so that existing applications do not need to be changed.

In some embodiments this can be implemented using a local proxy on the mobile device e.g. any wireless device which automatically detects recurring requests for the same content RSS feed Widget data set that matches a specific rule e.g. happens every 15 minutes . The local proxy can automatically cache the content on the mobile device while delegating the polling to the server e.g. a proxy server operated as an element of a communications network . The server can then notify the mobile client proxy if the content changes and if content has not changed or not changed sufficiently or in an identified manner or amount the mobile proxy provides the latest version in its cache to the user without need to utilize the radio at all . This way the mobile or wireless device e.g. a mobile phone smart phone M2M module MODEM or any other wireless devices etc. does not need to open e.g. thus powering on the radio or use a data connection if the request is for content that is monitored and that has been not flagged as new changed.

The logic for automatically adding content sources application servers e.g. including URLs content to be monitored can also check for various factors like how often the content is the same how often the same request is made is there a fixed interval pattern which application is requesting the data etc. Similar rules to decide between using the cache and request the data from the original source may also be implemented and executed by the local proxy and or server in certain embodiments.

For example when the request comes at an unscheduled unexpected time user initiated check or after every n consecutive times the response has been provided from the cache etc. or if the application is running in the background vs. in a more interactive mode of the foreground. As more and more mobile applications or wireless enabled applications base their features on resources available in the network this becomes increasingly important. In addition the disclosed technology allows elimination of unnecessary chatter from the network benefiting the operators trying to optimize the wireless spectrum usage.

In some embodiments the disclosed proxy system is able to establish policies for choosing traffic data content messages updates etc. to cache and or shape. Additionally by combining information from observing the application making the network requests getting explicit information from the application or knowing the network destination the application is reaching the disclosed technology can determine or infer what category the transmitted traffic belongs to.

For example In some embodiments mobile or wireless traffic can be categorized as a1 interactive traffic or a2 background traffic. The difference is that in a1 a user is actively waiting for a response while in a2 a user is not expecting a response. This categorization can be used in conjunction with or in lieu of a second type of categorization of traffic b1 immediate b2 low priority b3 immediate if the requesting application is in the foreground and active.

For example a new update message or email may be in the b1 category to be delivered immediately but it still is a2 background traffic a user is not actively waiting for it. A similar categorization applies to instant messages when they come outside of an active chat session. During an active chat session a user is expecting a response faster. Such user expectations are determined or inferred and factored into when optimizing network use and device resources in performing traffic categorization and policy implementation.

Some examples of the applications of the described categorization scheme include the following a1 interactive traffic can be categorized as b1 immediate but a2 background traffic may also be b2 or b3 . An example of a low priority transfer is email or message maintenance transaction such as deleting email or other messages or marking email as read at the mail or application server. Such a transfer can typically occur at the earlier of a timer exceeding a timeout value for example 2 minutes and b data being sent for other purposes.

An example of b3 is IM presence updates stock ticker updates weather updates status updates news feeds. When the UI of the application is in the foreground and or active for example as indicated by the backlight of the device phone being lit or as determined or inferred from the status of other sensors updates can be considered immediate whenever the server has something to push to the device. When the application is not in the foreground or not active such updates can be suppressed until the application comes to foreground and is active.

With some embodiments networks can be selected or optimized simultaneously for a1 interactive traffic and a2 background traffic.

In some embodiments as the wireless device or mobile device proxy separately or in conjunction with the server proxy is able to categorize the traffic as for example a1 interactive traffic or a2 background traffic it can apply different policies to different types of traffic. This means that it can internally operate differently for a1 and a2 traffic for example by allowing interactive traffic to go through to the network in whole or in part and apply stricter traffic control to background traffic or the device side only allows a request to activate the radio if it has received information from the server that the content at the host has been updated etc. .

When the request does require access over the wireless network the disclosed technology can request the radio layer to apply different network configurations to different traffic. Depending on the type of traffic and network this may be achieved by different means 

 2 Explicitly specifying network configuration for different data sets e.g. in terms of use of FACH forward access channel vs. DCH dedicated channel or otherwise requesting lower more network efficient data rates for background traffic or

 3 Utilizing different network access points for different data sets access points which would be configured to use network resources differently similar to 1 and 2 above .

Additionally 3GPP Fast Dormancy calls for improvements so that applications operating systems or the mobile device would have awareness of the traffic type to be more efficient in the future. Certain embodiments of the disclosed system having the knowledge of the traffic category and being able to utilize Fast Dormancy appropriately may solve the problem identified in Fast Dormancy. In this manner the mobile or broadband network does not need to be configured with a compromised configuration that adversely impacts both battery consumption and network signaling resources.

Detecting or determining a polling schedule allows the proxy server server side of the distributed cache system to be as close as possible with its polls to the application polls. Many applications employ scheduled interval polling e.g. every 4 hours or every 30 seconds at another time interval . The client side proxy can detect automatic polls based on time measurements and create an automatic polling profile for an application. As an example the local proxy attempts to detect the time interval between requests and after 2 3 4 or more polls determines an automatic rate if the time intervals are all within 1 second or another measure of relative closeness of each other. If not the client may collect data from a greater number of polling events e.g. 10 12 polls and apply a statistical analysis to determine compute or estimate a value for the average interval that is used. The polling profile is delivered to the server where it is used. If it is a frequent manual request the locally proxy can substitute it with a default interval for this application taken from a profile for non critical applications.

In some embodiments the local proxy e.g. device side proxy may keep monitoring the application client polls and update the polling interval. If it changes by more than 30 or another predetermined dynamic conditional value from the current value it is communicated to the proxy server e.g. server side proxy . This approach can be referred to as the scenario of lost interest. In some instances the local proxy can recognize requests made outside of this schedule consider them manual and treat them accordingly.

In some embodiments applications can be organized into three groups or modes of caching. Each mobile client application can be categorized to be treated as one of these modes or treated using multiple modes depending on one or more conditions.

A Fully cached local proxy updates e.g. sends application requests directly over the network to be serviced by the application server content host only when the proxy server tells the local proxy to update. In this mode the local proxy can ignore manual requests and the proxy server uses the detected automatic profile e.g. sports score applets Facebook every 10 15 30 or more polls to poll the application server content provider.

B Partially cached the local proxy uses the local or internal cache for automatic requests e.g. application automatic refreshes other scheduled requests but passes through some manual requests e.g. email download EBay or some Facebook requests and

C Never cached e.g. real time stock ticker sports scores statuses however in some instances 15 minutes delayed quotes can be safely placed on 30 seconds schedules B or even A .

The actual application or caching mode classification can be determined based on the rate of content change and critical character of data. Unclassified applications by default can be set as class C.

In some embodiments the local proxy starts by detecting the device backlight status. Requests made with the screen light off can be allowed to use the local cache if a request with identical signature is registered with the proxy server which is polling the original host server content server s to which the requests are directed. If the screen light is on further detection can be made to determine whether it is a background application or for other indicators that local cache entries can or cannot be used to satisfy the request. When identified the requests for which local entries can be used may be processed identically to the screen light off situation. Foreground requests can use the aforementioned application classification to assess when cached data is safe to use to process requests.

A standby state may include e.g. URA URA PCH or Cell PCH . In this state the network may be aware of the device but there may be no requirement for network resources to be consumed. In an idle state the network may be aware of the device but the device may be in sleep mode. In sleep mode the device may not really communicate with the network and may therefore require the least amount of network resources and consume the least power compared with the other states .

The mobile device may have applications or other clients that create data e.g. background data background activity that appear active to the network when it is in fact idle or in a background state when the user is not using the device. This background data or signaling may cause the network to unnecessarily promote the mobile device from a lower powered radio state to a higher powered one causing unneeded or non optimal battery consumption and network resource consumption.

Various of the disclosed embodiments include one or more of client side components in the local proxy as shown in the examples of and or server side components in the proxy server as shown in the examples of which can derive information from the mobile device about device usage to implicitly control radio state as dictated on the network side via network side throttling. For example the disclosed technology in the case of the 3 or 4 state Wideband Code Division Multiple Access WCDMA 3G model IDLE PCH FACH DCH can take advantage of knowing or determining the FACH consumption rate and byte buffers by keeping the radio in FACH for e.g. background data transfer until the buffer crosses a threshold predetermined or dynamically adjusted device dependent carrier dependent network condition dependent or when the device s backlight is off or until user activity lack thereof is determined detected or some other similar criteria.

The client side components in the local proxy can alone or in combination with the server side components in the proxy server more intelligently determine what user activity and or data activity should justify a radio state promotion and communicate the information to the network to be implemented as a single session multi session or global policy e.g. via a policy manager on the network side such as the Policy and Charging Rules Function PCRF node . This policy can be used to execute the appropriate level of throttling to prevent the radio from going to higher powered states when unjustified based on dynamic conditions e.g. network status traffic congestion user expectations and or user behavior other activity .

In some embodiments buffer size can be used as a trigger or indication of when to trigger radio state changes. The parameters related to the buffer e.g. threshold timer buffer sensitivity which are configured by the network to cause radio state changes may be dynamic based on the network conditions hardware software configuration and can differ based on network operator carrier.

Due to the predominantly dynamic nature of buffer parameters to use the buffer size in the disclosed technology for optimizing situations for radio state promotions and or demotions in some embodiments the client side components and or the server side components can be configured to include dynamic adaptive logic to discover network specific or condition specific values and adjust accordingly. In some instances static values for the buffer parameters can also be used. Some example of implementations include as follows 

The client side and server side components can be transparent and can receive a normal junk of bytes. In general the implementation may include logic which would keep the device radio in lower powered states such as PCH or FACH or inactive state for as long as possible to avoid over consumption of device and network resources so long as the user experience is not negatively impacted or noticeable by the user. This technology can provide signaling optimization in both WCDMA 3G networks as well as 4G LTE networks.

In some embodiments the disclosed system including the client side and or server side components e.g. the components shown in can be integrated with policy management nodes components of wireless networks e.g. the PCRF node in the RNS radio network system of an UMTS network . In some embodiments the PCRF through interoperation with the disclosed system can determine whether a given mobile device is in idle or active at a given moment. The PCRF can then govern or dictate the Radio Network Controller RNC in WCDMA 3G NodeB or eNodeB in LTE 4G policies that would for example allow or forbid a radio channel status upgrade into a higher powered state or lower the radio channel status to a lower powered state in a more intelligent and resource efficient manner. Note that UMTS networks via the PCRF can perform throttling and the disclosed system including client side and or server side components can provide the information to the network regarding what level of throttling should occur to trigger radio state changes to higher powered or lower powered states.

In a further embodiment the client side components e.g. as illustrated in can be configured to rate limit data transmission upon request for data to avoid triggering transition to higher powered radio states e.g. DCH in the state model for that particular transaction. In this example such data can be transmitted through or using a rate limiting proxy e.g. a rate limiting proxy as shown in the example of which can limit or adjust the rate of the response as requested specified by the client side components. The rate limiting proxy can be a component of the server side components e.g. internal to or it can be a separate entity external to the server side components . Note that the rate limit can include the speed of transmission or the buffer size after which the server will accumulate data for the client side components to acknowledge the transmission. The client side components can utilize various parameters including request and or anticipated response characteristics application device state e.g. screen off backlight status user activity user preferences behavior to determine specify whether to rate limit the response data and or the degree to which to rate limit the response data.

The client devices can be any system and or device and or any combination of devices systems that is able to establish a connection including wired wireless cellular connections with another device a server and or other systems such as host server and or application server content provider . Client devices will typically include a display and or other output functionalities to present information and data exchanged between among the devices and or the host server and or application server content provider . The application server content provider can by any server including third party servers or service content providers further including advertisement promotional content publication or electronic coupon servers or services. Similarly separate advertisement servers A promotional content servers B and or e Coupon servers C as application servers or content providers are illustrated by way of example.

For example the client devices can include mobile hand held or portable devices wireless devices or non portable devices and can be any of but not limited to a server desktop a desktop computer a computer cluster or portable devices including a notebook a laptop computer a handheld computer a palmtop computer a mobile phone a cell phone a smart phone a PDA a Blackberry device a Palm device a handheld tablet e.g. an iPad or any other tablet a hand held console a hand held gaming device or console any SuperPhone such as the iPhone and or any other portable mobile hand held devices or fixed wireless interface such as a M2M device etc. In some embodiments the client devices host server and application server are coupled via a network and or a network . In some embodiments the devices and host server may be directly connected to one another.

The input mechanism on client devices can include touch screen keypad including single touch multi touch gesture sensing in 2D or 3D etc. a physical keypad a mouse a pointer a track pad motion detector e.g. including 1 axis 2 axis 3 axis accelerometer etc. a light sensor capacitance sensor resistance sensor temperature sensor proximity sensor a piezoelectric device device orientation detector e.g. electronic compass tilt sensor rotation sensor gyroscope accelerometer or a combination of the above.

Signals received or detected indicating user activity at client devices through one or more of the above input mechanism or others can be used in the disclosed technology in acquiring context awareness at the client device . Context awareness at client devices generally may include by way of example but not limitation client device operation or state acknowledgement management user activity behavior interaction awareness detection sensing tracking trending and or application e.g. mobile applications type behavior activity operating state etc.

Context awareness in the present disclosure may also include knowledge and detection of network side contextual data and can include network information such as network capacity bandwidth traffic type of network connectivity and or any other operational state data. Network side contextual data can be received from and or queried from network service providers e.g. cell provider and or Internet service providers of the network and or network e.g. by the host server and or devices . In addition to application context awareness as determined from the client side the application context awareness may also be received from or obtained queried from the respective application service providers by the host and or client devices .

The host server can use for example contextual information obtained for client devices networks applications e.g. mobile applications application server provider or any combination of the above to manage the traffic in the system to satisfy data needs of the client devices e.g. to satisfy application or any other request including HTTP request . In some embodiments the traffic is managed by the host server to satisfy data requests made in response to explicit or non explicit user requests and or device application maintenance tasks. The traffic can be managed such that network consumption for example use of the cellular network is conserved for effective and efficient bandwidth utilization. In addition the host server can manage and coordinate such traffic in the system such that use of device side resources e.g. including but not limited to battery power consumption radio use processor memory use are optimized with a general philosophy for resource conservation while still optimizing performance and user experience.

For example in context of battery conservation the device can observe user activity for example by observing user keystrokes backlight status or other signals via one or more input mechanisms etc. and may alter device s behaviors in response. The device can also request that host server alter the behavior for network resource consumption based upon user activity or behavior.

In some embodiments the traffic management for resource conservation may be performed using a distributed system between the host server and client device . The distributed system can include proxy server and cache components on the server side and on the device client side for example as shown by the server cache on the server side and the local cache on the client side.

Functions and techniques disclosed for context aware traffic management for resource conservation in networks e.g. network and or and devices reside in a distributed proxy and cache system. The proxy and cache system can be distributed between and reside on a given client device in part or in whole and or host server in part or in whole. The distributed proxy and cache system are illustrated with further reference to the example diagram shown in . Functions and techniques performed by the proxy and cache components in the client device the host server and the related components therein are described respectively in detail with further reference to the examples of .

In some embodiments client devices may communicate with the host server and or the application server over network which can be a cellular network and or a broadband network. To facilitate overall traffic management between devices and various application servers content providers to implement network bandwidth utilization and device resource e.g. battery consumption the host server can communicate with the application server providers over the network which can include the Internet e.g. a broadband network .

In some embodiments the networks and or over which the client devices the host server and or application server communicate may be a cellular network a broadband network a telephonic network an open network such as the Internet or a private network such as an intranet and or the extranet or any combination thereof. For example the Internet can provide file transfer remote log in email news RSS cloud based services instant messaging visual voicemail push mail VoIP and other services through any known or convenient protocol such as but is not limited to the TCP IP protocol UDP HTTP DNS FTP UPnP NSF ISDN PDH RS 232 SDH SONET etc.

The networks and or can be any collection of distinct networks operating wholly or partially in conjunction to provide connectivity to the client devices and the host server and may appear as one or more networks to the serviced systems and devices. In some embodiments communications to and from the client devices can be achieved by an open network such as the Internet or a private network broadband network such as an intranet and or the extranet. In some embodiments communications can be achieved by a secure communications protocol such as secure sockets layer SSL or transport layer security TLS .

In addition communications can be achieved via one or more networks such as but are not limited to one or more of WiMax a Local Area Network LAN Wireless Local Area Network WLAN a Personal area network PAN a Campus area network CAN a Metropolitan area network MAN a Wide area network WAN a Wireless wide area network WWAN or any broadband network and further enabled with technologies such as by way of example Global System for Mobile Communications GSM Personal Communications Service PCS Bluetooth WiFi Fixed Wireless Data 2G 2.5G 3G 4G IMT Advanced pre 4G LTE Advanced mobile WiMax WiMax 2 WirelessMAN Advanced networks enhanced data rates for GSM evolution EDGE General packet radio service GPRS enhanced GPRS iBurst UMTS HSPDA HSUPA HSPA UMTS TDD 1 RTT EV DO messaging protocols such as TCP IP SMS MMS extensible messaging and presence protocol XMPP real time messaging protocol RTMP instant messaging and presence protocol IMPP instant messaging USSD IRC or any other wireless data networks broadband networks or messaging protocols.

The distributed proxy and cache system can include for example the proxy server e.g. remote proxy and the server cache components on the server side. The server side proxy and cache can as illustrated reside internal to the host server . In addition the proxy server and cache on the server side can be partially or wholly external to the host server and in communication via one or more of the networks and . For example the proxy server may be external to the host server and the server cache may be maintained at the host server . Alternatively the proxy server may be within the host server while the server cache is external to the host server . In addition each of the proxy server and the cache may be partially internal to the host server and partially external to the host server . The application server content provider can by any server including third party servers or service content providers further including advertisement promotional content publication or electronic coupon servers or services. Similarly separate advertisement servers A promotional content servers B and or e Coupon servers C as application servers or content providers are illustrated by way of example.

The distributed system can also include in some embodiments client side components including by way of example but not limitation a local proxy e.g. a mobile client on a mobile device and or a local cache which can as illustrated reside internal to the device e.g. a mobile device .

In addition the client side proxy and local cache can be partially or wholly external to the device and in communication via one or more of the networks and . For example the local proxy may be external to the device and the local cache may be maintained at the device . Alternatively the local proxy may be within the device while the local cache is external to the device . In addition each of the proxy and the cache may be partially internal to the host server and partially external to the host server .

In some embodiments the distributed system can include an optional caching proxy server . The caching proxy server can be a component which is operated by the application server content provider the host server or a network service provider and or any combination of the above to facilitate network traffic management for network and device resource conservation. Proxy server can be used for example for caching content to be provided to the device for example from one or more of the application server provider host server and or a network service provider . Content caching can also be entirely or partially performed by the remote proxy to satisfy application requests or other data requests at the device .

In context aware traffic management and optimization for resource conservation in a network e.g. cellular or other wireless networks characteristics of user activity behavior and or application behavior at a mobile device e.g. any wireless device can be tracked by the local proxy and communicated over the network to the proxy server component in the host server for example as connection metadata. The proxy server which in turn is coupled to the application server provider may provide content and data to satisfy requests made at the device .

In addition the local proxy can identify and retrieve mobile device properties including one or more of battery level network that the device is registered on radio state or whether the mobile device is being used e.g. interacted with by a user . In some instances the local proxy can delay expedite prefetch and or modify data prior to transmission to the proxy server when appropriate as will be further detailed with references to the description associated with the examples of .

The local database can be included in the local proxy or coupled to the local proxy and can be queried for a locally stored response to the data request prior to the data request being forwarded on to the proxy server . Locally cached responses can be used by the local proxy to satisfy certain application requests of the mobile device by retrieving cached content stored in the cache storage when the cached content is still valid.

Similarly the proxy server of the host server can also delay expedite or modify data from the local proxy prior to transmission to the content sources e.g. the application server content provider . In addition the proxy server uses device properties and connection metadata to generate rules for satisfying request of applications on the mobile device . The proxy server can gather real time traffic information about requests of applications for later use in optimizing similar connections with the mobile device or other mobile devices.

In some embodiments the local proxy and the proxy server are transparent to the multiple applications executing on the mobile device. The local proxy may be transparent to the operating system or platform of the mobile device and may or may not be specific to device manufacturers. In some instances the local proxy may be optionally customizable in part or in whole to be device specific. In some embodiments the local proxy may be bundled into a wireless model a firewall and or a router.

In some embodiments the host server can in some instances utilize the store and forward functions of a short message service center SMSC such as that provided by the network service provider in communicating with the device in achieving network traffic management. Note that can also utilize any other type of alternative channel including USSD or other network control mechanisms. As will be further described with reference to the example of the host server can forward content or HTTP responses to the SMSC such that it is automatically forwarded to the device if available and for subsequent forwarding if the device is not currently available.

In general the disclosed distributed proxy and cache system allows optimization of network usage for example by serving requests from the local cache the local proxy reduces the number of requests that need to be satisfied over the network . Further the local proxy and the proxy server may filter irrelevant data from the communicated data. In addition the local proxy and the proxy server can also accumulate low priority data and send it in batches to avoid the protocol overhead of sending individual data fragments. The local proxy and the proxy server can also compress or transcode the traffic reducing the amount of data sent over the network and or . The signaling traffic in the network and or can be reduced as the networks are now used less often and the network traffic can be synchronized among individual applications.

With respect to the battery life of the mobile device by serving application or content requests from the local cache the local proxy can reduce the number of times the radio module is powered up. The local proxy and the proxy server can work in conjunction to accumulate low priority data and send it in batches to reduce the number of times and or amount of time when the radio is powered up. The local proxy can synchronize the network use by performing the batched data transfer for all connections simultaneously.

The radio state management engine can include a response rate configuration engine having a data rate configurator a buffer size configurator and or a PCRF policy recommendation engine . The engine may also include a radio state change criteria manager having an FACH consumption rate and or buffer tracker a state change threshold configuration engine and or a state change trigger detector . Additional or less modules engines can be included.

The radio state management engine can include a rate limiting engine having a data rate configurator and or a buffer size configurator a PCRF interface engine a radio state change criteria manager having a 3 or 4 state CDMA radio state compatibility module a 2 state LTE 4G radio state compatibility module and or a radio state change trigger detector and processing engine . The radio state management engine can include or be coupled to a rate limiting proxy as illustrated . Additional or less modules engines can be included.

The various components of the radio state management engine and the radio state management engine can singularly or in any combination perform the management and or policy management of mobile device radio state promotion or demotion based on buffer activity or device e.g. idle or active state monitoring as described in conjunction with and . For example the radio state management engine can implicitly manage the radio state transition since the radio state is controlled by the network i.e. the network orders the device to a specific state . In one implementation the radio state transition is by managed by throttling the actual data flow through the network such that the device is able to affect how the network will order it to change its state.

In one embodiment for example the radio state management engine can gather and or determine information concerning the current state of the device and provide such information to the PCRF node to allow the PCRF node to understand the current state of the device in the network and control the radio state of the device by signaling the radio access network nodes such as RNC and eNodeB. In another embodiment for example the radio state management engine can determine whether the PCRF node can signal or control the radio access network nodes to change the radio state of the device. In one implementation if the PCRF to radio access network node communication or control is not feasible the radio state management engine can detect such condition and can obtain information from the PCRF node to control the radio state of the mobile device. For example in one implementation the radio state management engine can provide policy information and or the level of throttling needed to keep the radio on the mobile device from going to the higher powered states.

Referring to the radio state management engine can manage the radio state of a mobile device is a mobile network by monitoring a criteria associated with the mobile and determining whether to perform a radio status transition of the mobile device in the mobile network from a first state to a second state based at least in part upon the criteria. In one implementation the first state and the second state are distinguished from a higher powered state or a lower powered state. In one implementation the radio status transition includes one of a promotion or demotion.

The response rate configuration engine can include various options for configuring response rates such as data transmission rates buffer size PCRF policy recommendations and the like. In one implementation the response rates may be configured for various purposes such as to avoid triggering transition to higher powered radio states.

The data rate configurator in one implementation can be used to configure the data transmission rate. In one implementation data rate can be specified or configured for traffic based on or when one or more of the following is detected the application is not interacting with the user the application is running in the background on the mobile device or the data contained in the traffic is not time critical and the like. The buffer size configurator in one implementation can be used to configure the size or capacity of a buffer on the mobile device which can cause the server to accumulate data for the client to acknowledge the transmission. The PCRF policy recommendation engine in one implementation can communicate a plurality of rules to a network component such as a radio access network node e.g. RNC eNodeB and the like . In one implementation the rules determine a level of throttling.

The radio state change criteria manager in one implementation can monitor configure and or manage criteria for changing radio state. In one implementation the criteria can include but are not limited to a capacity of a buffer the buffer located on a mobile device a Forward Access Channel FACH consumption rate a backlight status of the mobile device one or more of behavior of applications running on the mobile device user activity at the mobile device and user preferences at the mobile device. In one implementation the radio state change criteria manager can monitor the criteria by applying logic to discover network specific or condition specific values associated with the buffer capacity. In one implementation the logic can be adaptive to network conditions and is dynamically adjustable. In some implementations the radio state change criteria manager can leverage other modules of the local proxy e.g. application behavior detector user activity module to manage criteria for radio state change. In one implementation the radio state change criteria manager can determine whether to perform radio channel status transition from a first state to a second state based on various information such as one or more of the criteria application and the like.

The FACH consumption rate and or buffer tracker can in one implementation can know track and or determine the FACH consumption rate and byte buffers by keeping the radio in FACH for e.g. background data transfer until the buffer crosses a threshold or when the device s backlight is off or until user activity lack thereof is determined detected or some other similar criteria. In one implementation the tracking of the buffer can be used to determine if the buffer exceeds a threshold. If the buffer exceeds the threshold the criteria for radio state change is determined as being met such that the radio state is promoted from a first state to the second state. In one implementation the second state can be a higher powered state than the first state.

The state change threshold configuration engine in one implementation can be used to configure the thresholds for causing or triggering radio state changes. For example buffer size can be configured for use as a trigger or indication of when to trigger radio state changes.

The state change trigger detector can detect the change of radio state such as promotion or a demotion. In one implementation the state change detector can also effect the change by changing the radio state. In another implementation the state change trigger detector can perform the radio status transition by adjusting a level of throttling.

In one embodiment the radio state management engine may also include a module for determining whether an application transmits a background data or foreground data over a wireless network. In one implementation background data can include but is not limited to data transmitted or generated by an application without a user interaction or a user request data transmitted or generated by the application for application maintenance or updating and the like. The foreground data can include but is not limited to data transmitted or generated as a result of a user interaction or a user request.

Referring to some of the components of the radio state management engine may perform functions similar to the components of the radio state management engine .

In one implementation the rate limiting proxy can limit or adjust the rate of the response as requested specified by the client side components. The rate limiting proxy can be a component of the radio state management engine or it can be a separate entity external to engine . The rate limiting proxy can for example be responsive to various parameters specified or requested by the client side including request and or anticipated response characteristics application device state e.g. screen off backlight status user activity user preferences behavior to determine specify whether to rate limit the response data and or the degree to which to rate limit the response data.

The rate limiting engine in one implementation can perform some or all of the functions of the rate limiting proxy . The rate limiting engine can for example limit the speed of transmission or the buffer size after which the server will accumulate data for the client side components to acknowledge the transmission.

The PCRF interface engine can in one implementation interface with the PCRF node. The interface engine can obtain policies from the PCRF node and or provide policies or enhanced policies to the PCRF node. For example via the interface engine the radio state management engine can provide information concerning when or what level of throttling should happen to keep the radio from transitioning to the higher powered states. The components in the UMTS network through PCRF can then perform the throttling and thereby manage the radio states.

The radio state change criteria manager can receive access obtain configure and or apply various criteria for managing radio state change in mobile devices. In one implementation for example the manager can monitor criteria associated with the mobile device network and or the like. In a further implementation such criteria may be specific to WCDMA or LTE 4G networks. The 3 or 4 state WCDMA radio state compatibility module may for example have its own set of criteria for when to trigger radio state change or the state to which the change can be triggered and the like. In one implementation in the case of 3 or 4 state WCDMA the module can take advantage of knowing or determining the FACH consumption rate and byte buffers by keeping the radio in FACH for e.g. background data transfer until the buffer crosses a threshold predetermined or dynamically adjusted device dependent carrier dependent network condition dependent or when the device s backlight is off or until user activity lack thereof is determined detected or some other similar criteria. The 2 state LTE 4G radio state compatibility module can similarly monitor criteria associated with LTE 4G network and the two states specific to the network to determine whether to perform a radio status transition and which state to transition to.

The radio state change trigger detector and processing engine in one implementation can detect a trigger to change the radio state of a mobile device e.g. from the radio state change criteria manager and can determine whether to perform a radio channel status transition based on the criteria and upon the application such as upon the application s behavior. In one implementation to perform the transition or cause the transition to be performed the radio state change trigger detector and processing engine can modify or provide rules to a PCRF network component via the PCRF interface engine. In one implementation PCRF can cause the transition at the appropriate time. In some implementation the radio state change trigger detector and processing engine can determine that rules which avoid a transition and maintain the current state as appropriate.

The device which can be a portable or mobile device e.g. any wireless device such as a portable phone generally includes for example a network interface an operating system a context Application Programming Interface API and mobile applications which may be proxy unaware or proxy aware . Note that the device is specifically illustrated in the example of as a mobile device such is not a limitation and that device may be any wireless broadband portable mobile or non portable device able to receive transmit signals to satisfy data requests over a network including wired or wireless networks e.g. WiFi cellular Bluetooth LAN WAN etc. .

The network interface can be a networking module that enables the device to mediate data in a network with an entity that is external to the host server through any known and or convenient communications protocol supported by the host and the external entity. The network interface can include one or more of a network adaptor card a wireless network interface card e.g. SMS interface WiFi interface interfaces for various generations of mobile communication standards including but not limited to 2G 3G 3.5G 4G LTE etc. Bluetooth or whether or not the connection is via a router an access point a wireless router a switch a multilayer switch a protocol converter a gateway a bridge a bridge router a hub a digital media receiver and or a repeater.

Device can further include client side components of the distributed proxy and cache system which can include a local proxy e.g. a mobile client of a mobile device and a cache . In some embodiments the local proxy includes a user activity module a proxy API a request transaction manager a caching policy manager having an application protocol module a traffic shaping engine and or a connection manager . The traffic shaping engine may further include an alignment module and or a batching module the connection manager may further include a radio controller . The request transaction manager can further include an application behavior detector and or a prioritization engine the application behavior detector may further include a pattern detector and or and application profile generator . Additional or less components modules engines can be included in the local proxy and each illustrated component.

In some embodiments a portion of the distributed proxy and cache system for network traffic management resides in or is in communication with device including local proxy mobile client and or cache . The local proxy can provide an interface on the device for users to access device applications and services including email IM voice mail visual voicemail feeds Internet games productivity tools or other applications etc.

The proxy is generally application independent and can be used by applications e.g. both proxy aware and proxy unaware applications and and other mobile applications to open TCP connections to a remote server e.g. the server in the examples of and or server proxy shown in the examples of and . In some instances the local proxy includes a proxy API which can be optionally used to interface with proxy aware applications or applications e.g. mobile applications on a mobile device e.g. any wireless device .

The applications and can generally include any user application widgets software HTTP based application web browsers video or other multimedia streaming or downloading application video games social network applications email clients RSS management applications application stores document management applications productivity enhancement applications etc. The applications can be provided with the device OS by the device manufacturer by the network service provider downloaded by the user or provided by others.

One embodiment of the local proxy includes or is coupled to a context API as shown. The context API may be a part of the operating system or device platform or independent of the operating system as illustrated. The operating system can include any operating system including but not limited to any previous current and or future versions releases of Windows Mobile iOS Android Symbian Palm OS Brew MP Java 2 Micro Edition J2ME Blackberry etc.

The context API may be a plug in to the operating system or a particular client application on the device . The context API can detect signals indicative of user or device activity for example sensing motion gesture device location changes in device location device backlight keystrokes clicks activated touch screen mouse click or detection of other pointer devices. The context API can be coupled to input devices or sensors on the device to identify these signals. Such signals can generally include input received in response to explicit user input at an input device mechanism at the device and or collected from ambient signals contextual cues detected at or in the vicinity of the device e.g. light motion piezoelectric etc. .

In some embodiments the user activity module interacts with the context API to identify determine infer detect compute predict and or anticipate characteristics of user activity on the device . Various inputs collected by the context API can be aggregated by the user activity module to generate a profile for characteristics of user activity. Such a profile can be generated by the user activity module with various temporal characteristics. For instance user activity profile can be generated in real time for a given instant to provide a view of what the user is doing or not doing at a given time e.g. defined by a time window in the last minute in the last 30 seconds etc. a user activity profile can also be generated for a session defined by an application or web page that describes the characteristics of user behavior with respect to a specific task they are engaged in on the device or for a specific time period e.g. for the last 2 hours for the last 5 hours .

Additionally characteristic profiles can be generated by the user activity module to depict a historical trend for user activity and behavior e.g. 1 week 1 mo. 2 mo. etc. . Such historical profiles can also be used to deduce trends of user behavior for example access frequency at different times of day trends for certain days of the week weekends or week days user activity trends based on location data e.g. IP address GPS or cell tower coordinate data or changes in location data e.g. user activity based on user location or user activity based on whether the user is on the go or traveling outside a home region etc. to obtain user activity characteristics.

In some embodiments user activity module can detect and track user activity with respect to applications documents files windows icons and folders on the device . For example the user activity module can detect when an application or window e.g. a web browser or any other type of application has been exited closed minimized maximized opened moved into the foreground or into the background multimedia content playback etc.

In some embodiments characteristics of the user activity on the device can be used to locally adjust behavior of the device e.g. mobile device or any wireless device to optimize its resource consumption such as battery power consumption and more generally consumption of other device resources including memory storage and processing power. In some embodiments the use of a radio on a device can be adjusted based on characteristics of user behavior e.g. by the radio controller of the connection manager coupled to the user activity module . For example the radio controller can turn the radio on or off based on characteristics of the user activity on the device . In addition the radio controller can adjust the power mode of the radio e.g. to be in a higher power mode or lower power mode depending on characteristics of user activity.

In some embodiments characteristics of the user activity on device can also be used to cause another device e.g. other computers a mobile device a wireless device or a non portable device or server e.g. host server and in the examples of and which can communicate e.g. via a cellular or other network with the device to modify its communication frequency with the mobile device . The local proxy can use the characteristics information of user behavior determined by the user activity module to instruct the remote device as to how to modulate its communication frequency e.g. decreasing communication frequency such as data push frequency if the user is idle requesting that the remote device notify the device if new data changed data or data of a certain level of importance becomes available etc. .

In some embodiments the user activity module can in response to determining that user activity characteristics indicate that a user is active after a period of inactivity request that a remote device e.g. server host server and in the examples of and send the data that was buffered as a result of the previously decreased communication frequency.

In addition or in alternative the local proxy can communicate the characteristics of user activity at the device to the remote device e.g. host server and in the examples of and and the remote device may determine how to alter its own communication frequency with the device for network resource conservation and conservation of device resources.

In some embodiments the local proxy further includes a request transaction manager which can detect identify intercept process manage data requests initiated on the device for example by applications and or and or directly indirectly by a user request. The request transaction manager can determine how and when to process a given request or transaction or a set of requests transactions based on transaction characteristics.

In some embodiments the request transaction manager can prioritize requests or transactions made by applications and or users at the device for example by the prioritization engine . Importance or priority of requests transactions can be determined by the request transaction manager by applying a rule set for example according to time sensitivity of the transaction time sensitivity of the content in the transaction time criticality of the transaction time criticality of the data transmitted in the transaction and or time criticality or importance of an application making the request.

In addition transaction characteristics can also depend on whether the transaction was a result of user interaction or other user initiated action on the device e.g. user interaction with an application e.g. a mobile application . In general a time critical transaction can include a transaction resulting from a user initiated data transfer and can be prioritized as such. Transaction characteristics can also depend on the amount of data that will be transferred or is anticipated to be transferred as a result of the requested transaction. For example the connection manager can adjust the radio mode e.g. high power or low power mode via the radio controller based on the amount of data that will need to be transferred.

In addition the radio controller connection manager can adjust the radio power mode high or low based on time criticality sensitivity of the transaction. The radio controller can trigger the use of high power radio mode when a time critical transaction e.g. a transaction resulting from a user initiated data transfer an application running in the foreground any other event meeting a certain criteria is initiated or detected.

In some embodiments the priorities can be set by default for example based on device platform device manufacturer operating system etc. Priorities can alternatively or in additionally be set by the particular application for example the Facebook application e.g. a mobile application can set its own priorities for various transactions e.g. a status update can be of higher priority than an add friend request or a poke request a message send request can be of higher priority than a message delete request for example an email client or IM chat client may have its own configurations for priority. The prioritization engine may include a set of rules for assigning priority.

In some embodiments the prioritization engine can also track network provider limitations or specifications on application or transaction priority in determining an overall priority status for a request transaction. Furthermore priority can in part or in whole be determined by user preferences either explicit or implicit. A user can in general set priorities at different tiers such as specific priorities for sessions or types or applications e.g. a browsing session a gaming session versus an IM chat session the user may set a gaming session to always have higher priority than an IM chat session which may have higher priority than web browsing session . A user can set application specific priorities e.g. a user may set Facebook related transactions to have a higher priority than LinkedIn related transactions for specific transaction types e.g. for all send message requests across all applications to have higher priority than message delete requests for all calendar related events to have a high priority etc. and or for specific folders.

In some embodiments the prioritization engine can track and resolve conflicts in priorities set by different entities. For example manual settings specified by the user may take precedence over device OS settings network provider parameters limitations e.g. set in default for a network service area geographic locale set for a specific time of day or set based on service fee type may limit any user specified settings and or application set priorities. In some instances a manual synchronization request received from a user can override some most or all priority settings in that the requested synchronization is performed when requested regardless of the individually assigned priority or an overall priority ranking for the requested action.

Priority can be specified and tracked internally in any known and or convenient manner including but not limited to a binary representation a multi valued representation a graded representation and all are considered to be within the scope of the disclosed technology.

Table I above shows for illustration purposes some examples of transactions with examples of assigned priorities in a binary representation scheme. Additional assignments are possible for additional types of events requests transactions and as previously described priority assignments can be made at more or less granular levels e.g. at the session level or at the application level etc.

As shown by way of example in the above table in general lower priority requests transactions can include updating message status as being read unread deleting of messages deletion of contacts higher priority requests transactions can in some instances include status updates new IM chat message new email calendar event update cancellation deletion an event in a mobile gaming session or other entertainment related events a purchase confirmation through a web purchase or online request to load additional or download content contact book related events a transaction to change a device setting location aware or location based events transactions or any other events request transactions initiated by a user or where the user is known to be expected to be or suspected to be waiting for a response etc.

Inbox pruning events e.g. email or any other types of messages are generally considered low priority and absent other impending events generally will not trigger use of the radio on the device . Specifically pruning events to remove old email or other content can be piggy backed with other communications if the radio is not otherwise on at the time of a scheduled pruning event. For example if the user has preferences set to keep messages for 7 days old then instead of powering on the device radio to initiate a message delete from the device the moment that the message has exceeded 7 days old the message is deleted when the radio is powered on next. If the radio is already on then pruning may occur as regularly scheduled.

The request transaction manager can use the priorities for requests e.g. by the prioritization engine to manage outgoing traffic from the device for resource optimization e.g. to utilize the device radio more efficiently for battery conservation . For example transactions requests below a certain priority ranking may not trigger use of the radio on the device if the radio is not already switched on as controlled by the connection manager . In contrast the radio controller can turn on the radio such a request can be sent when a request for a transaction is detected to be over a certain priority level.

In some embodiments priority assignments such as that determined by the local proxy or another device entity can be used cause a remote device to modify its communication with the frequency with the mobile device or wireless device. For example the remote device can be configured to send notifications to the device when data of higher importance is available to be sent to the mobile device or wireless device.

In some embodiments transaction priority can be used in conjunction with characteristics of user activity in shaping or managing traffic for example by the traffic shaping engine . For example the traffic shaping engine can in response to detecting that a user is dormant or inactive wait to send low priority transactions from the device for a period of time. In addition the traffic shaping engine can allow multiple low priority transactions to accumulate for batch transferring from the device e.g. via the batching module . In some embodiments the priorities can be set configured or readjusted by a user. For example content depicted in Table I in the same or similar form can be accessible in a user interface on the device and for example used by the user to adjust or view the priorities.

In some embodiments the batching module can initiate batch transfer based on certain criteria. For example batch transfer e.g. of multiple occurrences of events some of which occurred at different instances in time may occur after a certain number of low priority events have been detected or after an amount of time elapsed after the first of the low priority event was initiated. In addition the batching module can initiate batch transfer of the cumulated low priority events when a higher priority event is initiated or detected at the device . Batch transfer can otherwise be initiated when radio use is triggered for another reason e.g. to receive data from a remote device such as host server or . In some embodiments an impending pruning event pruning of an inbox or any other low priority events can be executed when a batch transfer occurs.

In general the batching capability can be disabled or enabled at the event transaction level application level or session level based on any one or combination of the following user configuration device limitations settings manufacturer specification network provider parameters limitations platform specific limitations settings device OS settings etc. In some embodiments batch transfer can be initiated when an application window file is closed out exited or moved into the background users can optionally be prompted before initiating a batch transfer users can also manually trigger batch transfers.

In some embodiments the local proxy locally adjusts radio use on the device by caching data in the cache . When requests or transactions from the device can be satisfied by content stored in the cache the radio controller need not activate the radio to send the request to a remote entity e.g. the host server as shown in and or a content provider application server such as the server provider shown in the examples of and . As such the local proxy can use the local cache and the cache policy manager to locally store data for satisfying data requests to eliminate or reduce the use of the device radio for conservation of network resources and device battery consumption.

In leveraging the local cache once the request transaction manager intercepts a data request by an application on the device the local repository can be queried to determine if there is any locally stored response and also determine whether the response is valid. When a valid response is available in the local cache the response can be provided to the application on the device without the device needing to access the cellular network or wireless broadband network.

If a valid response is not available the local proxy can query a remote proxy e.g. the server proxy of to determine whether a remotely stored response is valid. If so the remotely stored response e.g. which may be stored on the server cache or optional caching server shown in the example of can be provided to the mobile device possibly without the mobile device needing to access the cellular network thus relieving consumption of network resources.

If a valid cache response is not available or if cache responses are unavailable for the intercepted data request the local proxy for example the caching policy manager can send the data request to a remote proxy e.g. server proxy of which forwards the data request to a content source e.g. application server content provider of and a response from the content source can be provided through the remote proxy as will be further described in the description associated with the example host server of . The cache policy manager can manage or process requests that use a variety of protocols including but not limited to HTTP HTTPS IMAP POP SMTP XMPP and or ActiveSync. The caching policy manager can locally store responses for data requests in the local database as cache entries for subsequent use in satisfying same or similar data requests.

The caching policy manager can request that the remote proxy monitor responses for the data request and the remote proxy can notify the device when an unexpected response to the data request is detected. In such an event the cache policy manager can erase or replace the locally stored response s on the device when notified of the unexpected response e.g. new data changed data additional data etc. to the data request. In some embodiments the caching policy manager is able to detect or identify the protocol used for a specific request including but not limited to HTTP HTTPS IMAP POP SMTP XMPP and or ActiveSync. In some embodiments application specific handlers e.g. via the application protocol module of the caching policy manager on the local proxy allows for optimization of any protocol that can be port mapped to a handler in the distributed proxy e.g. port mapped on the proxy server in the example of .

In some embodiments the local proxy notifies the remote proxy such that the remote proxy can monitor responses received for the data request from the content source for changed results prior to returning the result to the device for example when the data request to the content source has yielded same results to be returned to the mobile device. In general the local proxy can simulate application server responses for applications on the device using locally cached content. This can prevent utilization of the cellular network for transactions where new changed data is not available thus freeing up network resources and preventing network congestion.

In some embodiments the local proxy includes an application behavior detector to track detect observe monitor applications e.g. proxy aware and or unaware applications and accessed or installed on the device . Application behaviors or patterns in detected behaviors e.g. via the pattern detector of one or more applications accessed on the device can be used by the local proxy to optimize traffic in a wireless network needed to satisfy the data needs of these applications.

For example based on detected behavior of multiple applications the traffic shaping engine can align content requests made by at least some of the applications over the network wireless network e.g. via the alignment module . The alignment module can delay or expedite some earlier received requests to achieve alignment. When requests are aligned the traffic shaping engine can utilize the connection manager to poll over the network to satisfy application data requests. Content requests for multiple applications can be aligned based on behavior patterns or rules settings including for example content types requested by the multiple applications audio video text etc. device e.g. mobile or wireless device parameters and or network parameters traffic conditions network service provider constraints specifications etc.

In some embodiments the pattern detector can detect recurrences in application requests made by the multiple applications for example by tracking patterns in application behavior. A tracked pattern can include detecting that certain applications as a background process poll an application server regularly at certain times of day on certain days of the week periodically in a predictable fashion with a certain frequency with a certain frequency in response to a certain type of event in response to a certain type user query frequency that requested content is the same frequency with which a same request is made interval between requests applications making a request or any combination of the above for example.

Such recurrences can be used by traffic shaping engine to offload polling of content from a content source e.g. from an application server content provider of that would result from the application requests that would be performed at the mobile device or wireless device to be performed instead by a proxy server e.g. proxy server of or proxy server of remote from the device . Traffic shaping engine can decide to offload the polling when the recurrences match a rule. For example there are multiple occurrences or requests for the same resource that have exactly the same content or returned value or based on detection of repeatable time periods between requests and responses such as a resource that is requested at specific times during the day. The offloading of the polling can decrease the amount of bandwidth consumption needed by the mobile device to establish a wireless cellular or other wireless broadband connection with the content source for repetitive content polls.

As a result of the offloading of the polling locally cached content stored in the local cache can be provided to satisfy data requests at the device when content change is not detected in the polling of the content sources. As such when data has not changed application data needs can be satisfied without needing to enable radio use or occupying cellular bandwidth in a wireless network. When data has changed and or new data has been received the remote entity to which polling is offloaded can notify the device . The remote entity may be the host server as shown in the example of .

In some embodiments the local proxy can mitigate the need use of periodic keep alive messages heartbeat messages to maintain TCP IP connections which can consume significant amounts of power thus having detrimental impacts on mobile device battery life. The connection manager in the local proxy e.g. the heartbeat manager can detect identify and intercept any or all heartbeat keep alive messages being sent from applications.

The heartbeat manager can prevent any or all of these heartbeat messages from being sent over the cellular or other network and instead rely on the server component of the distributed proxy system e.g. shown in to generate and send the heartbeat messages to maintain a connection with the backend e.g. application server provider in the example of .

The local proxy generally represents any one or a portion of the functions described for the individual managers modules and or engines. The local proxy and device can include additional or less components more or less functions can be included in whole or in part without deviating from the novel art of the disclosure.

In some embodiments the caching policy manager includes a metadata generator a cache look up engine a cache appropriateness decision engine a poll schedule generator an application protocol module a cache or connect selection engine and or a local cache invalidator . The cache appropriateness decision engine can further include a timing predictor content predictor a request analyzer and or a response analyzer and the cache or connect selection engine includes a response scheduler . The metadata generator and or the cache look up engine are coupled to the cache or local cache for modification or addition to cache entries or querying thereof.

The cache look up engine may further include an ID or URI filter the local cache invalidator may further include a TTL manager and the poll schedule generator may further include a schedule update engine and or a time adjustment engine . One embodiment of caching policy manager includes an application cache policy repository . In some embodiments the application behavior detector includes a pattern detector a poll interval detector an application profile generator and or a priority engine . The poll interval detector may further include a long poll detector having a response request tracking engine . The poll interval detector may further include a long poll hunting detector . The application profile generator can further include a response delay interval tracker

The pattern detector application profile generator and the priority engine were also described in association with the description of the pattern detector shown in the example of . One embodiment further includes an application profile repository which can be used by the local proxy to store information or metadata regarding application profiles e.g. behavior patterns type of HTTP requests etc. 

The cache appropriateness decision engine can detect assess or determine whether content from a content source e.g. application server content provider in the example of with which a mobile device interacts and has content that may be suitable for caching. For example the decision engine can use information about a request and or a response received for the request initiated at the mobile device to determine cacheability potential cacheability or non cacheability. In some instances the decision engine can initially verify whether a request is directed to a blacklisted destination or whether the request itself originates from a blacklisted client or application. If so additional processing and analysis may not be performed by the decision engine and the request may be allowed to be sent over the air to the server to satisfy the request. The black listed destinations or applications clients e.g. mobile applications can be maintained locally in the local proxy e.g. in the application profile repository or remotely e.g. in the proxy server or another entity .

In some embodiments the decision engine for example via the request analyzer collects information about an application or client request generated at the mobile device . The request information can include request characteristics information including for example request method. For example the request method can indicate the type of HTTP request generated by the mobile application or client. In some embodiments response to a request can be identified as cacheable or potentially cacheable if the request method is a GET request or POST request. Other types of requests e.g. OPTIONS HEAD PUT DELETE TRACE or CONNECT may or may not be cached. In general HTTP requests with uncacheable request methods will not be cached.

Request characteristics information can further include information regarding request size for example. Responses to requests e.g. HTTP requests with body size exceeding a certain size will not be cached. For example cacheability can be determined if the information about the request indicates that a request body size of the request does not exceed a certain size. In some instances the maximum cacheable request body size can be set to 8092 bytes. In other instances different values may be used dependent on network capacity or network operator specific settings for example.

In some instances content from a given application server content provider e.g. the server content provider of is determined to be suitable for caching based on a set of criteria for example criteria specifying time criticality of the content that is being requested from the content source. In some embodiments the local proxy e.g. the local proxy or of and applies a selection criteria to store the content from the host server which is requested by an application as cached elements in a local cache on the mobile device to satisfy subsequent requests made by the application.

The cache appropriateness decision engine further based on detected patterns of requests sent from the mobile device e.g. by a mobile application or other types of clients on the device and or patterns of received responses can detect predictability in requests and or responses. For example the request characteristics information collected by the decision engine e.g. the request analyzer can further include periodicity information between a request and other requests generated by a same client on the mobile device or other requests directed to the same host e.g. with similar or same identifier parameters .

Periodicity can be detected by the decision engine or the request analyzer when the request and the other requests generated by the same client occur at a fixed rate or nearly fixed rate or at a dynamic rate with some identifiable or partially or wholly reproducible changing pattern. If the requests are made with some identifiable pattern e.g. regular intervals intervals having a detectable pattern or trend e.g. increasing decreasing constant etc. the timing predictor can determine that the requests made by a given application on a device is predictable and identify it to be potentially appropriate for caching at least from a timing standpoint.

An identifiable pattern or trend can generally include any application or client behavior which may be simulated either locally for example on the local proxy on the mobile device or simulated remotely for example by the proxy server on the host or a combination of local and remote simulation to emulate application behavior.

In some embodiments the decision engine for example via the response analyzer can collect information about a response to an application or client request generated at the mobile device . The response is typically received from a server or the host of the application e.g. mobile application or client which sent the request at the mobile device . In some instances the mobile client or application can be the mobile version of an application e.g. social networking search travel management voicemail contact manager email or a web site accessed via a web browser or via a desktop client.

For example response characteristics information can include an indication of whether transfer encoding or chunked transfer encoding is used in sending the response. In some instances responses to HTTP requests with transfer encoding or chunked transfer encoding are not cached and therefore are also removed from further analysis. The rationale here is that chunked responses are usually large and non optimal for caching since the processing of these transactions may likely slow down the overall performance. Therefore In some embodiments cacheability or potential for cacheability can be determined when transfer encoding is not used in sending the response.

In addition the response characteristics information can include an associated status code of the response which can be identified by the response analyzer . In some instances HTTP responses with uncacheable status codes are typically not cached. The response analyzer can extract the status code from the response and determine whether it matches a status code which is cacheable or uncacheable. Some cacheable status codes include by way of example 200 OK 301 Redirect 302 Found 303 See other 304 Not Modified 307 Temporary Redirect or 500 Internal server error. Some uncacheable status codes can include for example 403 Forbidden or 404 Not found.

In some embodiments cacheability or potential for cacheability can be determined if the information about the response does not indicate an uncacheable status code or indicates a cacheable status code. If the response analyzer detects an uncacheable status code associated with a given response the specific transaction request response pair may be eliminated from further processing and determined to be uncacheable on a temporary basis a semi permanent or a permanent basis. If the status code indicates cacheability the transaction e.g. request and or response pair may be subject to further processing and analysis to confirm cacheability.

Response characteristics information can also include response size information. In general responses can be cached locally at the mobile device if the responses do not exceed a certain size. In some instances the default maximum cached response size is set to 115 KB. In other instances the max cacheable response size may be different and or dynamically adjusted based on operating conditions network conditions network capacity user preferences network operator requirements or other application specific user specific and or device specific reasons. In some embodiments the response analyzer can identify the size of the response and cacheability or potential for cacheability can be determined if a given threshold or max value is not exceeded by the response size.

Furthermore response characteristics information can include response body information for the response to the request and other response to other requests generated by a same client on the mobile device or directed to a same content host or application server. The response body information for the response and the other responses can be compared for example by the response analyzer to prevent the caching of dynamic content or responses with content that changes frequently and cannot be efficiently served with cache entries such as financial data stock quotes news feeds real time sporting event activities etc. such as content that would no longer be relevant or up to date if served from cached entries.

The cache appropriateness decision engine e.g. the content predictor can definitively identify repeatability or identify indications of repeatability potential repeatability or predictability in responses received from a content source e.g. the content host application server shown in the example of . Repeatability can be detected by for example tracking at least two responses received from the content source and determines if the two responses are the same. For example cacheability can be determined by the response analyzer if the response body information for the response and the other responses sent by the same mobile client or directed to the same host server are same or substantially the same. The two responses may or may not be responses sent in response to consecutive requests. In some embodiments hash values of the responses received for requests from a given application are used to determine repeatability of content with or without heuristics for the application in general and or for the specific request. Additional same responses may be required for some applications or under certain circumstances.

Repeatability in received content need not be 100 ascertained. For example responses can be determined to be repeatable if a certain number or a certain percentage of responses are the same or similar. The certain number or certain percentage of same similar responses can be tracked over a select period of time set by default or set based on the application generating the requests e.g. whether the application is highly dynamic with constant updates or less dynamic with infrequent updates . Any indicated predictability or repeatability or possible repeatability can be utilized by the distributed system in caching content to be provided to a requesting application or client on the mobile device .

In some embodiments for a long poll type request the local proxy can begin to cache responses on a third request when the response delay times for the first two responses are the same substantially the same or detected to be increasing in intervals. In general the received responses for the first two responses should be the same and upon verifying that the third response received for the third request is the same e.g. if R0 R1 R2 the third response can be locally cached on the mobile device. Less or more same responses may be required to begin caching depending on the type of application type of data type of content user preferences or carrier network operator specifications.

Increasing response delays with same responses for long polls can indicate a hunting period e.g. a period in which the application client on the mobile device is seeking the longest time between a request and response that a given network will allow as detected by the long poll hunting detector of the application behavior detector .

An example can be described below using T0 T1 T2 where T indicates the delay time between when a request is sent and when a response e.g. the response header is detected received for consecutive requests 0 Response0 Request0 180 s. tolerance 1 Response1 Request1 240 s. tolerance 2 Response2 Request2 500 s. tolerance 

As such the local proxy can specify information that can be extracted from the timing sequence shown above e.g. polling schedule polling interval polling type to the proxy server and begin caching and to request the proxy server to begin polling and monitoring the source e.g. using any of T0 T1 T2 as polling intervals but typically T2 or the largest detected interval without timing out and for which responses from the source is received will be sent to the proxy server of for use in polling the content source e.g. application server service provider .

However if the time intervals are detected to be getting shorter the application e.g. mobile application client may still be hunting for a time interval for which a response can be reliably received from the content source e.g. application server server provider or and as such caching typically should not begin until the request response intervals indicate the same time interval or an increasing time interval for example for a long poll type request.

An example of handling a detected decreasing delay can be described below using T0 T1 T2 T3 and T4 where T indicates the delay time between when a request is sent and when a response e.g. the response header is detected received for consecutive requests 0 Response0 Request0 160 s. tolerance 1 Response1 Request1 240 s. tolerance 2 Response2 Request2 500 s. tolerance 3 Time out at 700 s. tolerance 4 Response4 Request4 600 tolerance 

Note that the above description shows that caching can begin while long polls are in hunting mode in the event of detecting increasing response delays as long as responses are received and not timed out for a given request. This can be referred to as the optional accelerated caching during long poll hunting. Caching can also begin after the hunting mode e.g. after the poll requests have settled to a constant or near constant delay value has completed. Note that hunting may or may not occur for long polls and when hunting occurs the proxy can generally detect this and determine whether to begin to cache during the hunting period increasing intervals with same responses or wait until the hunt settles to a stable value.

In some embodiments the timing predictor of the cache appropriateness decision engine can track timing of responses received from outgoing requests from an application e.g. mobile application or client to detect any identifiable patterns which can be partially wholly reproducible such that locally cached responses can be provided to the requesting client on the mobile device in a manner that simulates content source e.g. application server content provider or behavior. For example the manner in which e.g. from a timing standpoint responses or content would be delivered to the requesting application client on the device . This ensures preservation of user experience when responses to application or mobile client requests are served from a local and or remote cache instead of being retrieved received directly from the content source e.g. application content provider or .

In some embodiments the decision engine or the timing predictor determines the timing characteristics a given application e.g. mobile application or client from for example the request response tracking engine and or the application profile generator e.g. the response delay interval tracker . Using the timing characteristics the timing predictor determines whether the content received in response to the requests are suitable or are potentially suitable for caching. For example poll request intervals between two consecutive requests from a given application can be used to determine whether request intervals are repeatable e.g. constant near constant increasing with a pattern decreasing with a pattern etc. and can be predicted and thus reproduced at least some of the times either exactly or approximated within a tolerance level.

In some instances the timing characteristics of a given request type for a specific application for multiple requests of an application or for multiple applications can be stored in the application profile repository . The application profile repository can generally store any type of information or metadata regarding application request response characteristics including timing patterns timing repeatability content repeatability etc.

The application profile repository can also store metadata indicating the type of request used by a given application e.g. long polls long held HTTP requests HTTP streaming push COMET push etc. Application profiles indicating request type by applications can be used when subsequent same similar requests are detected or when requests are detected from an application which has already been categorized. In this manner timing characteristics for the given request type or for requests of a specific application which has been tracked and or analyzed need not be reanalyzed.

Application profiles can be associated with a time to live e.g. or a default expiration time . The use of an expiration time for application profiles or for various aspects of an application or request s profile can be used on a case by case basis. The time to live or actual expiration time of application profile entries can be set to a default value or determined individually or a combination thereof. Application profiles can also be specific to wireless networks physical networks network operators or specific carriers.

One embodiment includes an application blacklist manager . The application blacklist manager can be coupled to the application cache policy repository and can be partially or wholly internal to local proxy or the caching policy manager . Similarly the blacklist manager can be partially or wholly internal to local proxy or the application behavior detector . The blacklist manager can aggregate track update manage adjust or dynamically monitor a list of destinations of servers host that are blacklisted or identified as not cached on a permanent or temporary basis. The blacklist of destinations when identified in a request can potentially be used to allow the request to be sent over the cellular network for servicing. Additional processing on the request may not be performed since it is detected to be directed to a blacklisted destination.

Blacklisted destinations can be identified in the application cache policy repository by address identifiers including specific URIs or patterns of identifiers including URI patterns. In general blacklisted destinations can be set by or modified for any reason by any party including the user owner user of mobile device operating system mobile platform of device the destination itself network operator of cellular network Internet service provider other third parties or according to a list of destinations for applications known to be uncacheable not suited for caching. Some entries in the blacklisted destinations may include destinations aggregated based on the analysis or processing performed by the local proxy e.g. cache appropriateness decision engine .

For example applications or mobile clients on the mobile device for which responses have been identified as non suitable for caching can be added to the blacklist. Their corresponding hosts servers may be added in addition to or in lieu of an identification of the requesting application client on the mobile device . Some or all of such clients identified by the proxy system can be added to the blacklist. For example for all application clients or applications that are temporarily identified as not being suitable for caching only those with certain detected characteristics based on timing periodicity frequency of response content change content predictability size etc. can be blacklisted.

The blacklisted entries may include a list of requesting applications or requesting clients on the mobile device rather than destinations such that when a request is detected from a given application or given client it may be sent through the network for a response since responses for blacklisted clients applications are in most circumstances not cached.

A given application profile may also be treated or processed differently e.g. different behavior of the local proxy and the remote proxy depending on the mobile account associated with a mobile device from which the application is being accessed. For example a higher paying account or a premier account may allow more frequent access of the wireless network or higher bandwidth allowance thus affecting the caching policies implemented between the local proxy and proxy server with an emphasis on better performance compared to conservation of resources. A given application profile may also be treated or processed differently under different wireless network conditions e.g. based on congestion or network outage etc. .

Note that cache appropriateness can be determined tracked and managed for multiple clients or applications on the mobile device . Cache appropriateness can also be determined for different requests or request types initiated by a given client or application on the mobile device . The caching policy manager along with the timing predictor and or the content predictor which heuristically determines or estimates predictability or potential predictability can track manage and store cacheability information for various application or various requests for a given application. Cacheability information may also include conditions e.g. an application can be cached at certain times of the day or certain days of the week or certain requests of a given application can be cached or all requests with a given destination address can be cached under which caching is appropriate which can be determined and or tracked by the cache appropriateness decision engine and stored and or updated when appropriate in the application cache policy repository coupled to the cache appropriateness decision engine .

The information in the application cache policy repository regarding cacheability of requests applications and or associated conditions can be used later on when same requests are detected. In this manner the decision engine and or the timing and content predictors need not track and reanalyze request response timing and content characteristics to make an assessment regarding cacheability. In addition the cacheability information can in some instances be shared with local proxies of other mobile devices by way of direct communication or via the host server e.g. proxy server of host server .

For example cacheability information detected by the local proxy on various mobile devices can be sent to a remote host server or a proxy server on the host server e.g. host server or proxy server shown in the example of host and proxy server in the example of . The remote host or proxy server can then distribute the information regarding application specific request specific cacheability information and or any associated conditions to various mobile devices or their local proxies in a wireless network or across multiple wireless networks same service provider or multiple wireless service providers for their use.

In general the selection criteria for caching can further include by way of example but not limitation the state of the mobile device indicating whether the mobile device is active or inactive network conditions and or radio coverage statistics. The cache appropriateness decision engine can in any one or any combination of the criteria and in any order identifying sources for which caching may be suitable.

Once application servers content providers having identified or detected content that is potentially suitable for local caching on the mobile device the cache policy manager can proceed to cache the associated content received from the identified sources by storing content received from the content source as cache elements in a local cache e.g. local cache or shown in the examples of and respectively on the mobile device .

The response can be stored in the cache e.g. also referred as the local cache as a cache entry. In addition to the response to a request the cached entry can include response metadata having additional information regarding caching of the response. The metadata may be generated by the metadata generator and can include for example timing data such as the access time of the cache entry or creation time of the cache entry. Metadata can include additional information such as any information suited for use in determining whether the response stored as the cached entry is used to satisfy the subsequent response. For example metadata information can further include request timing history e.g. including request time request start time request end time hash of the request and or response time intervals or changes in time intervals etc.

In some embodiments the cache entry is stored in the cache in association with a time to live TTL which for example may be assigned or determined by the TTL manager of the cache invalidator . The time to live of a cache entry is the amount of time the entry is persisted in the cache regardless of whether the response is still valid or relevant for a given request or client application on the mobile device . For example if the time to live of a given cache entry is set to 12 hours the cache entry is purged removed or otherwise indicated as having exceeded the time to live even if the response body contained in the cache entry is still current and applicable for the associated request.

A default time to live can be automatically used for all entries unless otherwise specified e.g. by the TTL manager or each cache entry can be created with its individual TTL e.g. determined by the TTL manager based on various dynamic or static criteria . Note that each entry can have a single time to live associated with both the response data and any associated metadata. In some instances the associated metadata may have a different time to live e.g. a longer time to live than the response data.

The content source having content for caching can in addition or in alternate be identified to a proxy server e.g. proxy server or shown in the examples of and respectively remote from and in wireless communication with the mobile device such that the proxy server can monitor the content source e.g. application server content provider for new or changed data. Similarly the local proxy e.g. the local proxy or of and respectively can identify to the proxy server that content received from a specific application server content provider is being stored as cached elements in the local cache .

Once content has been locally cached the cache policy manager upon receiving future polling requests to contact the application server content host e.g. or can retrieve the cached elements from the local cache to respond to the polling request made at the mobile device such that a radio of the mobile device is not activated to service the polling request. For example the cache look up engine can query the cache to identify the response to be served to a response. The response can be served from the cache in response to identifying a matching cache entry and also using any metadata stored with the response in the cache entry. The cache entries can be queried by the cache look up engine using a URI of the request or another type of identifier e.g. via the ID or URI filter . The cache lookup engine can further use the metadata e.g. extract any timing information or other relevant information stored with the matching cache entry to determine whether response is still suited for use in being served to a current request.

Note that the cache look up can be performed by the engine using one or more of various multiple strategies. In some embodiments multiple cook up strategies can be executed sequentially on each entry store din the cache until at least one strategy identifies a matching cache entry. The strategy employed to performing cache look up can include a strict matching criteria or a matching criteria which allows for non matching parameters.

For example the look up engine can perform a strict matching strategy which searches for an exact match between an identifier e.g. a URI for a host or resource referenced in a present request for which the proxy is attempting to identify a cache entry and an identifier stored with the cache entries. In the case where identifiers include URIs or URLs the matching algorithm for strict matching will search for a cache entry where all the parameters in the URLs match. For example 

Under the strict strategy outlined above a match will not be found since the URIs differ in the query parameter.

In another example strategy the look up engine looks for a cache entry with an identifier that partially matches the identifier references in a present request for which the proxy is attempting to identify a matching cache entry. For example the look up engine may look for a cache entry with an identifier which differs from the request identifier by a query parameter value. In utilizing this strategy the look up engine can collect information collected for multiple previous requests e.g. a list of arbitrary parameters in an identifier to be later checked with the detected arbitrary parameter in the current request. For example in the case where cache entries are stored with URI or URL identifiers the look up engine may search for a cache entry with a URI differing by a query parameter. If found the engine can examine the cache entry for information collected during previous requests e.g. a list of arbitrary parameters and checked whether the arbitrary parameter detected in or extracted from the current URI URL belongs to the arbitrary parameters list.

Match will not be found since current request contains sort parameter which is not marked as arbitrary in the cache entry.

Additional strategies for detecting cache hit may be employed. These strategies can be implemented singly or in any combination thereof. A cache hit can be determined when any one of these strategies determines a match. A cache miss may be indicated when the look up engine determines that the requested data cannot be served from the cache for any reason. For example a cache miss may be determined when no cache entries are identified for any or all utilized look up strategies.

Cache miss may also be determined when a matching cache entry exists but determined to be invalid or irrelevant for the current request. For example the look up engine may further analyze metadata e.g. which may include timing data of the cache entry associated with the matching cache entry to determine whether it is still suitable for use in responding to the present request.

When the look up engine has identified a cache hit e.g. an event indicating that the requested data can be served from the cache the stored response in the matching cache entry can be served from the cache to satisfy the request of an application client.

By servicing requests using cache entries stored in cache network bandwidth and other resources need not be used to request receive poll responses which may have not changed from a response that has already been received at the mobile device . Such servicing and fulfilling application e.g. mobile application requests locally via cache entries in the local cache allows for more efficient resource and mobile network traffic utilization and management since the request need not be sent over the wireless network further consuming bandwidth. In general the cache can be persisted between power on off of the mobile device and persisted across application client refreshes and restarts.

For example the local proxy upon receipt of an outgoing request from its mobile device or from an application or other type of client on the mobile device can intercept the request and determine whether a cached response is available in the local cache of the mobile device . If so the outgoing request is responded to by the local proxy using the cached response on the cache of the mobile device. As such the outgoing request can be filled or satisfied without a need to send the outgoing request over the wireless network thus conserving network resources and battery consumption.

In some embodiments the responding to the requesting application client on the device is timed to correspond to a manner in which the content server would have responded to the outgoing request over a persistent connection e.g. over the persistent connection or long held HTTP connection long poll type connection that would have been established absent interception by the local proxy . The timing of the response can be emulated or simulated by the local proxy to preserve application behavior such that end user experience is not affected or minimally affected by serving stored content from the local cache rather than fresh content received from the intended content source e.g. content host application server of . The timing can be replicated exactly or estimated within a tolerance parameter which may go unnoticed by the user or treated similarly by the application so as to not cause operation issues.

For example the outgoing request can be a request for a persistent connection intended for the content server e.g. application server content provider of examples of . In a persistent connection e.g. long poll COMET style push or any other push simulation in asynchronous HTTP requests long held HTTP request HTTP streaming or others with a content source server the connection is held for some time after a request is sent. The connection can typically be persisted between the mobile device and the server until content is available at the server to be sent to the mobile device. Thus there typically can be some delay in time between when a long poll request is sent and when a response is received from the content source. If a response is not provided by the content source for a certain amount of time the connection may also terminate due to network reasons e.g. socket closure if a response is not sent.

Thus to emulate a response from a content server sent over a persistent connection e.g. a long poll style connection the manner of response of the content server can be simulated by allowing a time interval to elapse before responding to the outgoing request with the cached response. The length of the time interval can be determined on a request by request basis or on an application by application client by client basis for example.

In some embodiments the time interval is determined based on request characteristics e.g. timing characteristics of an application on the mobile device from which the outgoing request originates. For example poll request intervals e.g. which can be tracked detected and determined by the long poll detector of the poll interval detector can be used to determine the time interval to wait before responding to a request with a local cache entry and managed by the response scheduler

Some embodiments of the cache policy manager includes a poll schedule generator which can generate a polling schedule for one or more applications on the mobile device . The polling schedule can specify a polling interval that can be employed by an entity which is physically distinct and or separate from the mobile device in monitoring the content source for one or more applications such that cached responses can be verified periodically by polling a host server host server or to which the request is directed on behalf of the mobile device. One example of such an external entity which can monitor the content at the source for the mobile device is a proxy server e.g. proxy server or shown in the examples of and .

The polling schedule e.g. including a rate frequency of polling can be determined for example based on the interval between the polling requests directed to the content source from the mobile device. The polling schedule or rate of polling may be determined at the mobile device by the local proxy . In some embodiments the poll interval detector of the application behavior detector can monitor polling requests directed to a content source from the mobile device in order to determine an interval between the polling requests made from any or all application e.g. mobile application .

For example the poll interval detector can track requests and responses for applications or clients on the device . In some embodiments consecutive requests are tracked prior to detection of an outgoing request initiated from the application e.g. mobile application on the mobile device by the same mobile client or application e.g. mobile application . The polling rate can be determined using request information collected for the request for which the response is cached. In some embodiments the rate is determined from averages of time intervals between previous requests generated by the same client which generated the request. For example a first interval may be computed between the current request and a previous request and a second interval can be computed between the two previous requests. The polling rate can be set from the average of the first interval and the second interval and sent to the proxy server in setting up the caching strategy.

Alternate intervals may be computed in generating an average for example multiple previous requests in addition to two previous requests may be used and more than two intervals may be used in computing an average. In general in computing intervals a given request need not have resulted in a response to be received from the host server content source in order to use it for interval computation. In other words the timing characteristics of a given request may be used in interval computation as long as the request has been detected even if the request failed in sending or if the response retrieval failed.

Some embodiments of the poll schedule generator includes a schedule update engine and or a time adjustment engine . The schedule update engine can determine a need to update a rate or polling interval with which a given application server content host from a previously set value based on a detected interval change in the actual requests generated from a client or application e.g. mobile application on the mobile device .

For example a request for which a monitoring rate was determined may now be sent from the application e.g. mobile application or client at a different request interval. The scheduled update engine can determine the updated polling interval of the actual requests and generate a new rate different from the previously set rate to poll the host at on behalf of the mobile device . The updated polling rate can be communicated to the remote proxy proxy server over the cellular network for the remote proxy to monitor the given host. In some instances the updated polling rate may be determined at the remote proxy or remote entity which monitors the host.

In some embodiments the time adjustment engine can further optimize the poll schedule generated to monitor the application server content source or . For example the time adjustment engine can optionally specify a time to start polling to the proxy server. For example in addition to setting the polling interval at which the proxy server is to monitor the application server content host can also specify the time at which an actual request was generated at the mobile client application.

However in some cases due to inherent transmission delay or added network delays or other types of latencies the remote proxy server receives the poll setup from the local proxy with some delay e.g. a few minutes or a few seconds . This has the effect of detecting response change at the source after a request is generated by the mobile client application causing the invalidate of the cached response to occur after it has once again been served to the application after the response is no longer current or valid.

To resolve this non optimal result of serving the out dated content once again before invalidating it the time adjustment engine can specify the time t0 at which polling should begin in addition to the rate where the specified initial time t0 can be specified to the proxy server as a time that is less than the actual time when the request was generated by the mobile app client. This way the server polls the resource slightly before the generation of an actual request by the mobile client such that any content change can be detected prior to an actual application request. This prevents invalid or irrelevant out dated content response from being served once again before fresh content is served.

In some embodiments an outgoing request from a mobile device is detected to be for a persistent connection e.g. a long poll COMET style push and long held HTTP request based on timing characteristics of prior requests from the same application or client on the mobile device . For example requests and or corresponding responses can be tracked by the request response tracking engine of the long poll detector of the poll interval detector .

The timing characteristics of the consecutive requests can be determined to set up a polling schedule for the application or client. The polling schedule can be used to monitor the content source content source application server for content changes such that cached content stored on the local cache in the mobile device can be appropriately managed e.g. updated or discarded . In some embodiments the timing characteristics can include for example a response delay time D and or an idle time IT .

In some embodiments the response request tracking engine can track requests and responses to determine compute and or estimate the timing diagrams for applicant or client requests.

For example the response request tracking engine detects a first request Request 0 initiated by a client on the mobile device and a second request Request 1 initiated by the client on the mobile device after a response is received at the mobile device responsive to the first request. The second request is one that is subsequent to the first request.

In some embodiments the response request tracking engine can track requests and responses to determine compute and or estimate the timing diagrams for applicant or client requests. The response request tracking engine can detect a first request initiated by a client on the mobile device and a second request initiated by the client on the mobile device after a response is received at the mobile device responsive to the first request. The second request is one that is subsequent to the first request.

The response request tracking engine further determines relative timings between the first second requests and the response received in response to the first request. In general the relative timings can be used by the long poll detector to determine whether requests generated by the application are long poll requests.

Note that in general the first and second requests that are used by the response request tracking engine in computing the relative timings are selected for use after a long poll hunting period has settled or in the event when long poll hunting does not occur. Timing characteristics that are typical of a long poll hunting period can be for example detected by the long poll hunting detector . In other words the requests tracked by the response request tracking engine and used for determining whether a given request is a long poll occurs after the long poll has settled.

In some embodiments the long poll hunting detector can identify or detect hunting mode by identifying increasing request intervals e.g. increasing delays . The long poll hunting detector can also detect hunting mode by detecting increasing request intervals followed by a request with no response e.g. connection timed out or by detecting increasing request intervals followed by a decrease in the interval. In addition the long poll hunting detector can apply a filter value or a threshold value to request response time delay value e.g. an absolute value above which the detected delay can be considered to be a long poll request response delay. The filter value can be any suitable value characteristic of long polls and or network conditions e.g. 2 s 5 s 10 s 15 s 20 s. etc. and can be used as a filter or threshold value.

The response delay time D refers to the start time to receive a response after a request has been sent and the idle refers to time to send a subsequent request after the response has been received. In some embodiments the outgoing request is detected to be for a persistent connection based on a comparison e.g. performed by the tracking engine of the response delay time relative D or average of D e.g. any average over any period of time to the idle time IT for example by the long poll detector . The number of averages used can be fixed dynamically adjusted or changed over a longer period of time. For example the requests initiated by the client are determined to be long poll requests if the response delay time interval is greater than the idle time interval D IT or D IT . In some embodiments the tracking engine of the long poll detector computes determines or estimates the response delay time interval as the amount of time elapsed between time of the first request and initial detection or full receipt of the response.

In some embodiments a request is detected to be for a persistent connection when the idle time IT is short since persistent connections established in response to long poll requests or long poll HTTP requests for example can also be characterized in detecting immediate or near immediate issuance of a subsequent request after receipt of a response to a previous request e.g. IT 0 . As such the idle time IT can also be used to detect such immediate or near immediate re request to identify long poll requests. The absolute or relative timings determined by the tracking engine are used to determine whether the second request is immediately or near immediately re requested after the response to the first request is received. For example a request may be categorized as a long poll request if D RT IT D RT since IT is small for this to hold true. IT may be determined to be small if it is less than a threshold value. Note that the threshold value could be fixed or calculated over a limited time period a session a day a month etc. or calculated over a longer time period e.g. several months or the life of the analysis . For example for every request the average IT can be determined and the threshold can be determined using this average IT e.g. the average IT less a certain percentage may be used as the threshold . This can allow the threshold to automatically adapt over time to network conditions and changes in server capability resource availability or server response. A fixed threshold can take upon any value including by way of example but not limitation e.g. 1 s. 2 s. 3 s . . . . etc. .

In some embodiments the long poll detector can compare the relative timings e.g. determined by the tracker engine to request response timing characteristics for other applications to determine whether the requests of the application are long poll requests. For example the requests initiated by a client or application can be determined to be long poll requests if the response delay interval time D or the average response delay interval time e.g. averaged over x number of requests or any number of delay interval times averaged over x amount of time is greater than a threshold value.

The threshold value can be determined using response delay interval times for requests generated by other clients for example by the request response tracking engine and or by the application profile generator e.g. the response delay interval tracker . The other clients may reside on the same mobile device and the threshold value is determined locally by components on the mobile device. The threshold value can be determined for all requests over all resources server over all networks for example. The threshold value can be set to a specific constant value e.g. 30 seconds for example to be used for all requests or any request which does not have an applicable threshold value e.g. long poll is detected if D 30 seconds .

In some instances the other clients reside on different mobile devices and the threshold can be determined by a proxy server e.g. proxy server of the host shown in the example of which is external to the mobile device and able to communicate over a wireless network with the multiple different mobile devices as will be further described with reference to .

In some embodiments the cache policy manager sends the polling schedule to the proxy server e.g. proxy server or shown in the examples of and and can be used by the proxy server in monitoring the content source for example for changed or new content updated response different from the cached response associated with a request or application . A polling schedule sent to the proxy can include multiple timing parameters including but not limited to interval time from request 1 to request 2 or a time out interval time to wait for response used in long polls for example . Referring to the timing diagram of a request response timing sequence timing intervals RI D RT and or IT or some statistical manipulation of the above values e.g. average standard deviation etc. may all or in part be sent to the proxy server.

For example in the case when the local proxy detects a long poll the various timing intervals in a request response timing sequence e.g. D RT and or IT can be sent to the proxy server for use in polling the content source e.g. application server content host . The local proxy can also identify to the proxy server that a given application or request to be monitored is a long poll request e.g. instructing the proxy server to set a long poll flag for example . In addition the proxy server uses the various timing intervals to determine when to send keep alive indications on behalf of mobile devices.

The local cache invalidator of the caching policy manager can invalidate cache elements in the local cache e.g. cache or when new or changed data e.g. updated response is detected from the application server content source for a given request. The cached response can be determined to be invalid for the outgoing request based on a notification received from the proxy server e.g. proxy or the host server . The source which provides responses to requests of the mobile client can be monitored to determine relevancy of the cached response stored in the cache of the mobile device for the request. For example the cache invalidator can further remove delete the cached response from the cache of the mobile device when the cached response is no longer valid for a given request or a given application.

In some embodiments the cached response is removed from the cache after it is provided once again to an application which generated the outgoing request after determining that the cached response is no longer valid. The cached response can be provided again without waiting for the time interval or provided again after waiting for a time interval e.g. the time interval determined to be specific to emulate the response delay in a long poll . In some embodiments the time interval is the response delay D or an average value of the response delay D over two or more values.

The new or changed data can be for example detected by the proxy server e.g. proxy server or shown in the examples of and . When a cache entry for a given request poll has been invalidated the use of the radio on the mobile device can be enabled e.g. by the local proxy or the cache policy manager to satisfy the subsequent polling requests.

Some embodiments of the cache policy manager include a cache or connect selection engine which can decide whether to use a locally cached entry to satisfy a poll content request generated at the mobile device by an application or widget. For example the local proxy or the cache policy manger can intercept a polling request made by an application e.g. mobile application on the mobile device to contact the application server content provider. The selection engine can determine whether the content received for the intercepted request has been locally stored as cache elements for deciding whether the radio of the mobile device needs to be activated to satisfy the request made by the application e.g. mobile application and also determine whether the cached response is still valid for the outgoing request prior to responding to the outgoing request using the cached response.

In some embodiments the local proxy in response to determining that relevant cached content exists and is still valid can retrieve the cached elements from the local cache to provide a response to the application e.g. mobile application which made the polling request such that a radio of the mobile device is not activated to provide the response to the application e.g. mobile application . In general the local proxy continues to provide the cached response each time the outgoing request is received until the updated response different from the cached response is detected.

When it is determined that the cached response is no longer valid a new request for a given request is transmitted over the wireless network for an updated response. The request can be transmitted to the application server content provider e.g. server host or the proxy server on the host server e.g. proxy on the host for a new and updated response. In some embodiments the cached response can be provided again as a response to the outgoing request if a new response is not received within the time interval prior to removal of the cached response from the cache on the mobile device.

In this embodiment of the local proxy the user activity module further includes one or more of a user activity tracker a user activity prediction engine and or a user expectation manager . The application behavior detect can further include a prioritization engine a time criticality detection engine an application state categorizer and or an application traffic categorizer . The local proxy can further include a backlight detector and or a network configuration selection engine . The network configuration selection engine can further include one or more of a wireless generation standard selector a data rate specifier an access channel selection engine and or an access point selector.

In some embodiments the application behavior detector is able to detect determined identify or infer the activity state of an application on the mobile device to which traffic has originated from or is directed to for example via the application state categorizer and or the traffic categorizer . The activity state can be determined by whether the application is in a foreground or background state on the mobile device via the application state categorizer since the traffic for a foreground application vs. a background application may be handled differently.

In some embodiments the activity state can be determined detected identified or inferred with a level of certainty of heuristics based on the backlight status of the mobile device e.g. by the backlight detector or other software agents or hardware sensors on the mobile device including but not limited to resistive sensors capacitive sensors ambient light sensors motion sensors touch sensors etc. In general if the backlight is on the traffic can be treated as being or determined to be generated from an application that is active or in the foreground or the traffic is interactive. In addition if the backlight is on the traffic can be treated as being or determined to be traffic from user interaction or user activity or traffic containing data that the user is expecting within some time frame.

In some embodiments the activity state is determined based on whether the traffic is interactive traffic or maintenance traffic. Interactive traffic can include transactions from responses and requests generated directly from user activity interaction with an application and can include content or data that a user is waiting or expecting to receive. Maintenance traffic may be used to support the functionality of an application which is not directly detected by a user. Maintenance traffic can also include actions or transactions that may take place in response to a user action but the user is not actively waiting for or expecting a response.

For example a mail or message delete action at a mobile device generates a request to delete the corresponding mail or message at the server but the user typically is not waiting for a response. Thus such a request may be categorized as maintenance traffic or traffic having a lower priority e.g. by the prioritization engine and or is not time critical e.g. by the time criticality detection engine .

Contrastingly a mail read or message read request initiated by a user a the mobile device can be categorized as interactive traffic since the user generally is waiting to access content or data when they request to read a message or mail. Similarly such a request can be categorized as having higher priority e.g. by the prioritization engine and or as being time critical time sensitive e.g. by the time criticality detection engine .

The time criticality detection engine can generally determine identify infer the time sensitivity of data contained in traffic sent from the mobile device or to the mobile device from a host server e.g. host or application server e.g. app server content source . For example time sensitive data can include status updates stock information updates IM presence information email messages or other messages actions generated from mobile gaming applications webpage requests location updates etc. Data that is not time sensitive or time critical by nature of the content or request can include requests to delete messages mark as read or edited actions application specific actions such as an add friend or delete friend request certain types of messages or other information which does not frequently changing by nature etc. In some instances when the data is not time critical the timing with which to allow the traffic to pass through is set based on when additional data needs to be sent from the mobile device . For example traffic shaping engine can align the traffic with one or more subsequent transactions to be sent together in a single power on event of the mobile device radio e.g. using the alignment module and or the batching module . The alignment module can also align polling requests occurring close in time directed to the same host server since these request are likely to be responded to with the same data.

In the alternate or in combination the activity state can be determined from assessing determining evaluating inferring identifying user activity at the mobile device e.g. via the user activity module . For example user activity can be directly detected and tracked using the user activity tracker . The traffic resulting therefrom can then be categorized appropriately for subsequent processing to determine the policy for handling. Furthermore user activity can be predicted or anticipated by the user activity prediction engine . By predicting user activity or anticipating user activity the traffic thus occurring after the prediction can be treated as resulting from user activity and categorized appropriately to determine the transmission policy.

In addition the user activity module can also manage user expectations e.g. via the user expectation manager and or in conjunction with the activity tracker and or the prediction engine to ensure that traffic is categorized appropriately such that user expectations are generally met. For example a user initiated action should be analyzed e.g. by the expectation manager to determine or infer whether the user would be waiting for a response. If so such traffic should be handled under a policy such that the user does not experience an unpleasant delay in receiving such a response or action.

In some embodiments an advanced generation wireless standard network is selected for use in sending traffic between a mobile device and a host server in the wireless network based on the activity state of the application on the mobile device for which traffic is originated from or directed to. An advanced technology standards such as the 3G 3.5G 3G 4G or LTE network can be selected for handling traffic generated as a result of user interaction user activity or traffic containing data that the user is expecting or waiting for. Advanced generation wireless standard network can also be selected for to transmit data contained in traffic directed to the mobile device which responds to foreground activities.

In categorizing traffic and defining a transmission policy for mobile traffic a network configuration can be selected for use e.g. by the network configuration selection engine on the mobile device in sending traffic between the mobile device and a proxy server and or an application server e.g. app server host . The network configuration that is selected can be determined based on information gathered by the application behavior module regarding application activity state e.g. background or foreground traffic application traffic category e.g. interactive or maintenance traffic any priorities of the data content time sensitivity criticality.

The network configuration selection engine can select or specify one or more of a generation standard e.g. via wireless generation standard selector a data rate e.g. via data rate specifier an access channel e.g. access channel selection engine and or an access point e.g. via the access point selector in any combination.

For example a more advanced generation e.g. 3G LTE or 4G or later can be selected or specified for traffic when the activity state is in interaction with a user or in a foreground on the mobile device. Contrastingly an older generation standard e.g. 2G 2.5G or 3G or older can be specified for traffic when one or more of the following is detected the application is not interacting with the user the application is running in the background on the mobile device or the data contained in the traffic is not time critical or is otherwise determined to have lower priority.

Similarly a network configuration with a slower data rate can be specified for traffic when one or more of the following is detected the application is not interacting with the user the application is running in the background on the mobile device or the data contained in the traffic is not time critical. The access channel e.g. Forward access channel or dedicated channel can be specified.

The host server generally includes for example a network interface and or one or more repositories and . Note that server may be any portable mobile or non portable device server cluster of computers and or other types of processing units e.g. any number of a machine shown in the example of able to receive or transmit signals to satisfy data requests over a network including any wired or wireless networks e.g. WiFi cellular Bluetooth etc. .

The network interface can include networking module s or devices s that enable the server to mediate data in a network with an entity that is external to the host server through any known and or convenient communications protocol supported by the host and the external entity. Specifically the network interface allows the server to communicate with multiple devices including mobile phone devices and or one or more application servers content providers .

The host server can store information about connections e.g. network characteristics conditions types of connections etc. with devices in the connection metadata repository . Additionally any information about third party application or content providers can also be stored in the repository . The host server can store information about devices e.g. hardware capability properties device settings device language network capability manufacturer device model OS OS version etc. in the device information repository . Additionally the host server can store information about network providers and the various network service areas in the network service provider repository .

The communication enabled by network interface allows for simultaneous connections e.g. including cellular connections with devices and or connections e.g. including wired wireless HTTP Internet connections LAN WiFi etc. with content servers providers to manage the traffic between devices and content providers for optimizing network resource utilization and or to conserver power battery consumption on the serviced devices . The host server can communicate with mobile devices serviced by different network service providers and or in the same different network service areas. The host server can operate and is compatible with devices with varying types or levels of mobile capabilities including by way of example but not limitation 1G 2G 2G transitional 2.5G 2.75G 3G IMT 2000 3G transitional 3.5G 3.75G 3.9G 4G IMT advanced etc.

In general the network interface can include one or more of a network adaptor card a wireless network interface card e.g. SMS interface WiFi interface interfaces for various generations of mobile communication standards including but not limited to 1G 2G 3G 3.5G 4G type networks such as LTE WiMAX etc. Bluetooth WiFi or any other network whether or not connected via a router an access point a wireless router a switch a multilayer switch a protocol converter a gateway a bridge a bridge router a hub a digital media receiver and or a repeater.

The host server can further include server side components of the distributed proxy and cache system which can include a proxy server and a server cache . In some embodiments the proxy server can include an HTTP access engine a caching policy manager a proxy controller a traffic shaping engine a new data detector and or a connection manager .

The HTTP access engine may further include a heartbeat manager the proxy controller may further include a data invalidator module the traffic shaping engine may further include a control protocol and a batching module . Additional or less components modules engines can be included in the proxy server and each illustrated component.

As used herein a module a manager a handler a detector an interface a controller a normalizer a generator an invalidator or an engine includes a general purpose dedicated or shared processor and typically firmware or software modules that are executed by the processor. Depending upon implementation specific or other considerations the module manager handler detector interface controller normalizer generator invalidator or engine can be centralized or its functionality distributed. The module manager handler detector interface controller normalizer generator invalidator or engine can include general or special purpose hardware firmware or software embodied in a computer readable storage medium for execution by the processor. As used herein a computer readable medium or computer readable storage medium is intended to include all mediums that are statutory e.g. in the United States under 35 U.S.C. 101 and to specifically exclude all mediums that are non statutory in nature to the extent that the exclusion is necessary for a claim that includes the computer readable storage medium to be valid. Known statutory computer readable mediums include hardware e.g. registers random access memory RAM non volatile NV storage to name a few but may or may not be limited to hardware.

In the example of a device e.g. mobile device making an application or content request to an application server or content provider the request may be intercepted and routed to the proxy server which is coupled to the device and the application server content provider . Specifically the proxy server is able to communicate with the local proxy e.g. proxy and of the examples of and respectively of the mobile device the local proxy forwards the data request to the proxy server in some instances for further processing and if needed for transmission to the application server content server for a response to the data request.

In such a configuration the host or the proxy server in the host server can utilize intelligent information provided by the local proxy in adjusting its communication with the device in such a manner that optimizes use of network and device resources. For example the proxy server can identify characteristics of user activity on the device to modify its communication frequency. The characteristics of user activity can be determined by for example the activity behavior awareness module in the proxy controller via information collected by the local proxy on the device .

In some embodiments communication frequency can be controlled by the connection manager of the proxy server for example to adjust push frequency of content or updates to the device . For instance push frequency can be decreased by the connection manager when characteristics of the user activity indicate that the user is inactive. In some embodiments when the characteristics of the user activity indicate that the user is subsequently active after a period of inactivity the connection manager can adjust the communication frequency with the device to send data that was buffered as a result of decreased communication frequency to the device .

In addition the proxy server includes priority awareness of various requests transactions sessions applications and or specific events. Such awareness can be determined by the local proxy on the device and provided to the proxy server . The priority awareness module of the proxy server can generally assess the priority e.g. including time criticality time sensitivity etc. of various events or applications additionally the priority awareness module can track priorities determined by local proxies of devices .

In some embodiments through priority awareness the connection manager can further modify communication frequency e.g. use or radio as controlled by the radio controller of the server with the devices . For example the server can notify the device thus requesting use of the radio if it is not already in use when data or updates of an importance priority level which meets a criteria becomes available to be sent.

In some embodiments the proxy server can detect multiple occurrences of events e.g. transactions content data received from server provider and allow the events to accumulate for batch transfer to device . Batch transfer can be cumulated and transfer of events can be delayed based on priority awareness and or user activity application behavior awareness as tracked by modules and or . For example batch transfer of multiple events of a lower priority to the device can be initiated by the batching module when an event of a higher priority meeting a threshold or criteria is detected at the server . In addition batch transfer from the server can be triggered when the server receives data from the device indicating that the device radio is already in use and is thus on. In some embodiments the proxy server can order the each messages packets in a batch for transmission based on event transaction priority such that higher priority content can be sent first in case connection is lost or the battery dies etc.

In some embodiments the server caches data e.g. as managed by the caching policy manager such that communication frequency over a network e.g. cellular network with the device can be modified e.g. decreased . The data can be cached for example in the server cache for subsequent retrieval or batch sending to the device to potentially decrease the need to turn on the device radio. The server cache can be partially or wholly internal to the host server although in the example of it is shown as being external to the host . In some instances the server cache may be the same as and or integrated in part or in whole with another cache managed by another entity e.g. the optional caching proxy server shown in the example of such as being managed by an application server content provider a network service provider or another third party.

In some embodiments content caching is performed locally on the device with the assistance of host server . For example proxy server in the host server can query the application server provider with requests and monitor changes in responses. When changed or new responses are detected e.g. by the new data detector the proxy server can notify the mobile device such that the local proxy on the device can make the decision to invalidate e.g. indicated as out dated the relevant cache entries stored as any responses in its local cache. Alternatively the data invalidator module can automatically instruct the local proxy of the device to invalidate certain cached data based on received responses from the application server provider . The cached data is marked as invalid and can get replaced or deleted when new content is received from the content server .

Note that data change can be detected by the detector in one or more ways. For example the server provider can notify the host server upon a change. The change can also be detected at the host server in response to a direct poll of the source server provider . In some instances the proxy server can in addition pre load the local cache on the device with the new updated data. This can be performed when the host server detects that the radio on the mobile device is already in use or when the server has additional content data to be sent to the device .

One or more the above mechanisms can be implemented simultaneously or adjusted configured based on application e.g. different policies for different servers providers . In some instances the source provider server may notify the host for certain types of events e.g. events meeting a priority threshold level . In addition the provider server may be configured to notify the host at specific time intervals regardless of event priority.

In some embodiments the proxy server of the host can monitor track responses received for the data request from the content source for changed results prior to returning the result to the mobile device such monitoring may be suitable when data request to the content source has yielded same results to be returned to the mobile device thus preventing network power consumption from being used when no new changes are made to a particular requested. The local proxy of the device can instruct the proxy server to perform such monitoring or the proxy server can automatically initiate such a process upon receiving a certain number of the same responses e.g. or a number of the same responses in a period of time for a particular request.

In some embodiments the server through the activity behavior awareness module is able to identify or detect user activity at a device that is separate from the mobile device . For example the module may detect that a user s message inbox e.g. email or types of inbox is being accessed. This can indicate that the user is interacting with his her application using a device other than the mobile device and may not need frequent updates if at all.

The server in this instance can thus decrease the frequency with which new or updated content is sent to the mobile device or eliminate all communication for as long as the user is detected to be using another device for access. Such frequency decrease may be application specific e.g. for the application with which the user is interacting with on another device or it may be a general frequency decrease E.g. since the user is detected to be interacting with one server or one application via another device he she could also use it to access other services to the mobile device .

In some embodiments the host server is able to poll content sources on behalf of devices to conserve power or battery consumption on devices . For example certain applications on the mobile device can poll its respective server in a predictable recurring fashion. Such recurrence or other types of application behaviors can be tracked by the activity behavior module in the proxy controller . The host server can thus poll content sources for applications on the mobile device that would otherwise be performed by the device through a wireless e.g. including cellular connectivity . The host server can poll the sources for new or changed data by way of the HTTP access engine to establish HTTP connection or by way of radio controller to connect to the source over the cellular network. When new or changed data is detected the new data detector can notify the device that such data is available and or provide the new changed data to the device .

In some embodiments the connection manager determines that the mobile device is unavailable e.g. the radio is turned off and utilizes SMS to transmit content to the device for instance via the SMSC shown in the example of . SMS is used to transmit invalidation messages batches of invalidation messages or even content in the case where the content is small enough to fit into just a few usually one or two SMS messages. This avoids the need to access the radio channel to send overhead information. The host server can use SMS for certain transactions or responses having a priority level above a threshold or otherwise meeting a criteria. The server can also utilize SMS as an out of band trigger to maintain or wake up an IP connection as an alternative to maintaining an always on IP connection.

In some embodiments the connection manager in the proxy server e.g. the heartbeat manager can generate and or transmit heartbeat messages on behalf of connected devices to maintain a backend connection with a provider for applications running on devices .

For example in the distributed proxy system local cache on the device can prevent any or all heartbeat messages needed to maintain TCP IP connections required for applications from being sent over the cellular or other network and instead rely on the proxy server on the host server to generate and or send the heartbeat messages to maintain a connection with the backend e.g. application server provider in the example of . The proxy server can generate the keep alive heartbeat messages independent of the operations of the local proxy on the mobile device.

The repositories and or can additionally store software descriptive data images system information drivers and or any other data item utilized by other components of the host server and or any other servers for operation. The repositories may be managed by a database management system DBMS for example which may be but is not limited to Oracle DB2 Microsoft Access Microsoft SQL Server PostgreSQL MySQL FileMaker etc.

The repositories can be implemented via object oriented technology and or via text files and can be managed by a distributed database management system an object oriented database management system OODBMS e.g. ConceptBase FastDB Main Memory Database Management System JDOInstruments ObjectDB etc. an object relational database management system ORDBMS e.g. Informix OpenLink Virtuoso VMDS etc. a file system and or any other convenient or known database management package.

The caching policy manager In some embodiments can further include a metadata generator a cache look up engine an application protocol module a content source monitoring engine having a poll schedule manager a response analyzer and or an updated or new content detector . In some embodiments the poll schedule manager further includes a host timing simulator a long poll request detector manager a schedule update engine and or a time adjustment engine . The metadata generator and or the cache look up engine can be coupled to the cache or server cache for modification or addition to cache entries or querying thereof.

In some embodiments the proxy server e.g. the proxy server or of the examples of and can monitor a content source for new or changed data via the monitoring engine . The proxy server as shown is an entity external to the mobile device of . The content source e.g. application server content provider of can be one that has been identified to the proxy server e.g. by the local proxy as having content that is being locally cached on a mobile device e.g. mobile device or . The content source can be monitored for example by the monitoring engine at a frequency that is based on polling frequency of the content source at the mobile device. The poll schedule can be generated for example by the local proxy and sent to the proxy server. The poll frequency can be tracked and or managed by the poll schedule manager .

For example the proxy server can poll the host e.g. content provider application server on behalf of the mobile device and simulate the polling behavior of the client to the host via the host timing simulator . The polling behavior can be simulated to include characteristics of a long poll request response sequences experienced in a persistent connection with the host e.g. by the long poll request detector manager . Note that once a polling interval behavior is set the local proxy on the device side and or the proxy server on the server side can verify whether application and application server content host behavior match or can be represented by this predicted pattern. In general the local proxy and or the proxy server can detect deviations and when appropriate re evaluate and compute determine or estimate another polling interval.

In some embodiments the caching policy manager on the server side of the distribute proxy can in conjunction with or independent of the proxy server on the mobile device identify or detect long poll requests. For example the caching policy manager can determine a threshold value to be used in comparison with a response delay interval time in a request response sequence for an application request to identify or detect long poll requests possible long poll requests e.g. requests for a persistent connection with a host with which the client communicates including but not limited to a long held HTTP request a persistent connection enabling COMET style push request for HTTP streaming etc. or other requests which can otherwise be treated as a long poll request.

For example the threshold value can be determined by the proxy using response delay interval times for requests generated by clients applications across mobile devices which may be serviced by multiple different cellular or wireless networks. Since the proxy resides on host is able to communicate with multiple mobile devices via multiple networks the caching policy manager has access to application client information at a global level which can be used in setting threshold values to categorize and detect long polls.

By tracking response delay interval times across applications across devices over different or same networks the caching policy manager can set one or more threshold values to be used in comparison with response delay interval times for long poll detection. Threshold values set by the proxy server can be static or dynamic and can be associated with conditions and or a time to live an expiration time date in relative or absolute terms .

In addition the caching policy manager of the proxy can further determine the threshold value in whole or in part based on network delays of a given wireless network networks serviced by a given carrier service provider or multiple wireless networks. The proxy can also determine the threshold value for identification of long poll requests based on delays of one or more application server content provider e.g. to which application e.g. mobile application or mobile client requests are directed.

The proxy server can detect new or changed data at a monitored content source and transmits a message to the mobile device notifying it of such a change such that the mobile device or the local proxy on the mobile device can take appropriate action e.g. to invalidate the cache elements in the local cache . In some instances the proxy server e.g. the caching policy manager upon detecting new or changed data can also store the new or changed data in its cache e.g. the server cache or of the examples of and respectively . The new updated data stored in the server cache can be used in some instances to satisfy content requests at the mobile device for example it can be used after the proxy server has notified the mobile device of the new changed content and that the locally cached content has been invalidated.

The metadata generator similar to the metadata generator shown in the example of can generate metadata for responses cached for requests at the mobile device . The metadata generator can generate metadata for cache entries stored in the server cache . Similarly the cache look up engine can include the same or similar functions are those described for the cache look up engine shown in the example of .

The response analyzer can perform any or all of the functionalities related to analyzing responses received for requests generated at the mobile device in the same or similar fashion to the response analyzer of the local proxy shown in the example of . Since the proxy server is able to receive responses from the application server content source directed to the mobile device the proxy server e.g. the response analyzer can perform similar response analysis steps to determine cacheability as described for the response analyzer of the local proxy. The responses can be analyzed in addition to or in lieu of the analysis that can be performed at the local proxy on the mobile device .

Furthermore the schedule update engine can update the polling interval of a given application server content host based on application request interval changes of the application at the mobile device as described for the schedule update engine in the local proxy . The time adjustment engine can set an initial time at which polls of the application server content host is to begin to prevent the serving of out of date content once again before serving fresh content as described for the schedule update engine in the local proxy . Both the schedule updating and the time adjustment algorithms can be performed in conjunction with or in lieu of the similar processes performed at the local proxy on the mobile device .

In some embodiments of the proxy server the traffic shaping engine is further coupled to a traffic analyzer for categorizing mobile traffic for policy definition and implementation for mobile traffic and transactions directed to one or more mobile devices e.g. mobile device of or to an application server content host e.g. 110 of . In general the proxy server is remote from the mobile devices and remote from the host server as shown in the examples of . The proxy server or the host server can monitor the traffic for multiple mobile devices and is capable of categorizing traffic and devising traffic policies for different mobile devices.

In addition the proxy server or host server can operate with multiple carriers or network operators and can implement carrier specific policies relating to categorization of traffic and implementation of traffic policies for the various categories. For example the traffic analyzer of the proxy server or host server can include one or more of a prioritization engine a time criticality detection engine an application state categorizer and or an application traffic categorizer

Each of these engines or modules can track different criterion for what is considered priority time critical background foreground or interactive maintenance based on different wireless carriers. Different criterion may also exist for different mobile device types e.g. device model manufacturer operating system etc. . In some instances the user of the mobile devices can adjust the settings or criterion regarding traffic category and the proxy server is able to track and implement these user adjusted configured settings.

In some embodiments the traffic analyzer is able to detect determined identify or infer the activity state of an application on one or more mobile devices e.g. mobile device or which traffic has originated from or is directed to for example via the application state categorizer and or the traffic categorizer . The activity state can be determined based on whether the application is in a foreground or background state on one or more of the mobile devices via the application state categorizer since the traffic for a foreground application vs. a background application may be handled differently to optimize network use.

In the alternate or in combination the activity state of an application can be determined by the wirelessly connected mobile devices e.g. via the application behavior detectors in the local proxies and communicated to the proxy server . For example the activity state can be determined detected identified or inferred with a level of certainty of heuristics based on the backlight status at mobile devices e.g. by a backlight detector or other software agents or hardware sensors on the mobile device including but not limited to resistive sensors capacitive sensors ambient light sensors motion sensors touch sensors etc. In general if the backlight is on the traffic can be treated as being or determined to be generated from an application that is active or in the foreground or the traffic is interactive. In addition if the backlight is on the traffic can be treated as being or determined to be traffic from user interaction or user activity or traffic containing data that the user is expecting within some time frame.

The activity state can be determined from assessing determining evaluating inferring identifying user activity at the mobile device e.g. via the user activity module and communicated to the proxy server . In some embodiments the activity state is determined based on whether the traffic is interactive traffic or maintenance traffic. Interactive traffic can include transactions from responses and requests generated directly from user activity interaction with an application and can include content or data that a user is waiting or expecting to receive. Maintenance traffic may be used to support the functionality of an application which is not directly detected by a user. Maintenance traffic can also include actions or transactions that may take place in response to a user action but the user is not actively waiting for or expecting a response.

The time criticality detection engine can generally determine identify infer the time sensitivity of data contained in traffic sent from the mobile device or to the mobile device from the host server or proxy server or the application server e.g. app server content source . For example time sensitive data can include status updates stock information updates IM presence information email messages or other messages actions generated from mobile gaming applications webpage requests location updates etc.

Data that is not time sensitive or time critical by nature of the content or request can include requests to delete messages mark as read or edited actions application specific actions such as an add friend or delete friend request certain types of messages or other information which does not frequently changing by nature etc. In some instances when the data is not time critical the timing with which to allow the traffic to be sent to a mobile device is based on when there is additional data that needs to the sent to the same mobile device. For example traffic shaping engine can align the traffic with one or more subsequent transactions to be sent together in a single power on event of the mobile device radio e.g. using the alignment module and or the batching module . The alignment module can also align polling requests occurring close in time directed to the same host server since these request are likely to be responded to with the same data.

In general whether new or changed data is sent from a host server to a mobile device can be determined based on whether an application on the mobile device to which the new or changed data is relevant is running in a foreground e.g. by the application state categorizer or the priority or time criticality of the new or changed data. The proxy server can send the new or changed data to the mobile device if the application is in the foreground on the mobile device or if the application is in the foreground and in an active state interacting with a user on the mobile device and or whether a user is waiting for a response that would be provided in the new or changed data. The proxy server or traffic shaping engine can send the new or changed data that is of a high priority or is time critical.

Similarly the proxy server or the traffic shaping engine can suppressing the sending of the new or changed data if the application is in the background on the mobile device. The proxy server can also suppress the sending of the new or changed data if the user is not waiting for the response provided in the new or changed data wherein the suppressing is performed by a proxy server coupled to the host server and able to wirelessly connect to the mobile device.

In general if data including new or change data is of a low priority or is not time critical the proxy server can waiting to transfer the data until after a time period or until there is additional data to be sent e.g. via the alignment module and or the batching module .

In is a flow diagram depicting steps in a process for assessing background data and performing a radio status transition as implemented in some embodiments. At step the system can monitor criteria associated with a mobile device e.g. using a local proxy. As discussed above the criteria may include a capacity of a buffer the state of a backlight on the device a FACH consumption rate user activity at the device user preferences or other criteria indicative of the mobile device s status. In some embodiments the buffer may not be monitored directly but may instead be modeled to avoid the need for heavy computations. Certain of the criteria may be combined into a group of criteria. For example the system may determine that data transmitted received is background data based on the buffer exceeding a threshold when the backlight is off.

In some embodiments the monitored criteria may not be a size of the data sent but rather the speed with which the data is sent. For example data sent or received at a rate exceeding a threshold during an inactive state of the mobile device may be indicative of background data. In some embodiments the system may apply dynamic adaptive logic to discover network specific or condition specific values associated with the criteria. In some embodiments the system may detect background data transmissions by monitoring the draw on a battery at the mobile device.

At step the system may determine whether to perform a radio status transition based at least in part on the criteria. As discussed above in some embodiments the radio status transition may be performed by communicating rules to a PCRF component in a network. A local proxy on the mobile device may determine a plurality of rules e.g. rules used at a PCRF based on the monitoring and may communicate the rules to a network component so as to adjust a level of throttling. In one implementation the PCRF may request the network component to change the radio status.

In the example of the computer system includes a processor memory non volatile memory and an interface device. Various common components e.g. cache memory are omitted for illustrative simplicity. The computer system is intended to illustrate a hardware device on which any of the components depicted in the example of C and any other components described in this specification can be implemented. The computer system can be of any applicable known or convenient type. The components of the computer system can be coupled together via a bus or through some other known or convenient device.

The processor may be for example a conventional microprocessor such as an Intel Pentium microprocessor or Motorola power PC microprocessor. One of skill in the relevant art will recognize that the terms machine readable storage medium or computer readable storage medium include any type of device that is accessible by the processor.

The memory is coupled to the processor by for example a bus. The memory can include by way of example but not limitation random access memory RAM such as dynamic RAM DRAM and static RAM SRAM . The memory can be local remote or distributed.

The bus also couples the processor to the non volatile memory and drive unit. The non volatile memory is often a magnetic floppy or hard disk a magnetic optical disk an optical disk a read only memory ROM such as a CD ROM EPROM or EEPROM a magnetic or optical card or another form of storage for large amounts of data. Some of this data is often written by a direct memory access process into memory during execution of software in the computer . The non volatile storage can be local remote or distributed. The non volatile memory is optional because systems can be created with all applicable data available in memory. A typical computer system will usually include at least a processor memory and a device e.g. a bus coupling the memory to the processor.

Software is typically stored in the non volatile memory and or the drive unit. Indeed for large programs it may not even be possible to store the entire program in the memory. Nevertheless it should be understood that for software to run if necessary it is moved to a computer readable location appropriate for processing and for illustrative purposes that location is referred to as the memory in this paper. Even when software is moved to the memory for execution the processor will typically make use of hardware registers to store values associated with the software and local cache that ideally serves to speed up execution. As used herein a software program is assumed to be stored at any known or convenient location from non volatile storage to hardware registers when the software program is referred to as implemented in a computer readable medium. A processor is considered to be configured to execute a program when at least one value associated with the program is stored in a register readable by the processor.

The bus also couples the processor to the network interface device. The interface can include one or more of a modem or network interface. It will be appreciated that a modem or network interface can be considered to be part of the computer system. The interface can include an analog modem isdn modem cable modem token ring interface satellite transmission interface e.g. direct PC or other interfaces for coupling a computer system to other computer systems. The interface can include one or more input and or output devices. The I O devices can include by way of example but not limitation a keyboard a mouse or other pointing device disk drives printers a scanner and other input and or output devices including a display device. The display device can include by way of example but not limitation a cathode ray tube CRT liquid crystal display LCD or some other applicable known or convenient display device. For simplicity it is assumed that controllers of any devices not depicted in the example of reside in the interface.

In operation the computer system can be controlled by operating system software that includes a file management system such as a disk operating system. One example of operating system software with associated file management system software is the family of operating systems known as Windows from Microsoft Corporation of Redmond Wash. and their associated file management systems. Another example of operating system software with its associated file management system software is the Linux operating system and its associated file management system. The file management system is typically stored in the non volatile memory and or drive unit and causes the processor to execute the various acts required by the operating system to input and output data and to store data in the memory including storing files on the non volatile memory and or drive unit.

Some portions of the detailed description may be presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the methods of some embodiments. The required structure for a variety of these systems will appear from the description below. In addition the techniques are not described with reference to any particular programming language and various embodiments may thus be implemented using a variety of programming languages.

In alternative embodiments the machine operates as a standalone device or may be connected e.g. networked to other machines. In a networked deployment the machine may operate in the capacity of a server or a client machine in a client server network environment or as a peer machine in a peer to peer or distributed network environment.

The machine may be a server computer a client computer a personal computer PC a user device a tablet PC a laptop computer a set top box STB a personal digital assistant PDA a cellular telephone an iPhone an iPad a Blackberry a processor a telephone a web appliance a network router switch or bridge a console a hand held console a hand held gaming device a music player any portable mobile hand held device or any machine capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine.

While the machine readable medium or machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable medium and machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium and machine readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the presently disclosed technique and innovation.

In general the routines executed to implement the embodiments of the disclosure may be implemented as part of an operating system or a specific application component program object module or sequence of instructions referred to as computer programs. The computer programs typically comprise one or more instructions set at various times in various memory and storage devices in a computer that when read and executed by one or more processing units or processors in a computer cause the computer to perform operations to execute elements involving the various aspects of the disclosure.

Moreover while embodiments have been described in the context of fully functioning computers and computer systems those skilled in the art will appreciate that the various embodiments are capable of being distributed as a program product in a variety of forms and that the disclosure applies equally regardless of the particular type of machine or computer readable media used to actually effect the distribution.

Further examples of machine readable storage media machine readable media or computer readable storage media include but are not limited to recordable type media such as volatile and non volatile memory devices floppy and other removable disks hard disk drives optical disks e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. among others and transmission type media such as digital and analog communication links.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense that is to say in the sense of including but not limited to. As used herein the terms connected coupled or any variant thereof means any connection or coupling either direct or indirect between two or more elements the coupling of connection between the elements can be physical logical or a combination thereof. Additionally the words herein above below and words of similar import when used in this application shall refer to this application as a whole and not to any particular portions of this application. Where the context permits words in the above Detailed Description using the singular or plural number may also include the plural or singular number respectively. The word or in reference to a list of two or more items covers all of the following interpretations of the word any of the items in the list all of the items in the list and any combination of the items in the list.

The above detailed description of embodiments of the disclosure is not intended to be exhaustive or to limit the teachings to the precise form disclosed above. While specific embodiments of and examples for the disclosure are described above for illustrative purposes various equivalent modifications are possible within the scope of the disclosure as those skilled in the relevant art will recognize. For example while processes or blocks are presented in a given order alternative embodiments may perform routines having steps or employ systems having blocks in a different order and some processes or blocks may be deleted moved added subdivided combined and or modified to provide alternative or sub combinations. Each of these processes or blocks may be implemented in a variety of different ways. Also while processes or blocks are at times shown as being performed in series these processes or blocks may instead be performed in parallel or may be performed at different times. Further any specific numbers noted herein are only examples alternative implementations may employ differing values or ranges.

The teachings of the disclosure provided herein can be applied to other systems not necessarily the system described above. The elements and acts of the various embodiments described above can be combined to provide further embodiments.

Any patents and applications and other references noted above including any that may be listed in accompanying filing papers are incorporated herein by reference. Aspects of the disclosure can be modified if necessary to employ the systems functions and concepts of the various references described above to provide yet further embodiments of the disclosure.

These and other changes can be made to the disclosure in light of the above Detailed Description. While the above description describes certain embodiments of the disclosure and describes the best mode contemplated no matter how detailed the above appears in text the teachings can be practiced in many ways. Details of the system may vary considerably in its implementation details while still being encompassed by the subject matter disclosed herein. As noted above particular terminology used when describing certain features or aspects of the disclosure should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics features or aspects of the disclosure with which that terminology is associated. In general the terms used in the following claims should not be construed to limit the disclosure to the specific embodiments disclosed in the specification unless the above Detailed Description section explicitly defines such terms. Accordingly the actual scope of the disclosure encompasses not only the disclosed embodiments but also all equivalent ways of practicing or implementing the disclosure under the claims.

While certain aspects of the disclosure are presented below in certain claim forms the inventors contemplate the various aspects of the disclosure in any number of claim forms. For example while only one aspect of the disclosure is recited as a means plus function claim under 35 U.S.C. 112 6 other aspects may likewise be embodied as a means plus function claim or in other forms such as being embodied in a computer readable medium. Any claims intended to be treated under 35 U.S.C. 112 6 will begin with the words means for. Accordingly the applicant reserves the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the disclosure.

