---

title: Updating software on dormant disks
abstract: In a method of updating software on a dormant disk, exposed files are accessed. The exposed files are exposed by mounting the dormant disk. The exposed files are scanned to determine the status of software residing on the dormant disk. The scanning is achieved without requiring booting of the dormant disk. It is determined whether an update is available for the software residing on the dormant disk.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08949817&OS=08949817&RS=08949817
owner: VMware, Inc.
number: 08949817
owner_city: Palo Alto
owner_country: US
publication_date: 20130826
---
This application is a continuation application of and claims the benefit of co pending U.S. patent application Ser. No. 11 396 060 now U.S. Pat. No. 8 522 228 filed on Mar. 31 2006 entitled Updating Software on Dormant Disks by Bich Cau Le et al. assigned to the assignee of the present application which is hereby incorporated by reference in its entirety herein.

This Application is related to U.S. Pat. No. 7 823 145 filed on Mar. 31 2006 entitled Updating Software on Dormant Disks by Bich Cau Le et al. assigned to the assignee of the present application.

Embodiments of the present invention relate to the field of computer software and mechanisms for keeping computer software up to date. More specifically embodiments of the present invention are directed to a technology for updating software on dormant disks.

The advantages of virtual machine technology have become widely recognized. Among these advantages is the ability to run multiple virtual machines on a single host platform. This can make better use of the capacity of the hardware while still ensuring that each user enjoys the features of a complete computer. An additional benefit of virtualization in some implementations is greater security. For instance virtualization increases security by isolating potentially unstable or unsafe software so that it cannot adversely affect the hardware state or system files required for running the physical as opposed to virtual hardware.

As is well known in the field of computer science a virtual machine VM is a software abstraction or virtualization of an actual physical computer system. shows one possible arrangement of a computer system that implements virtualization. shows a plurality of virtual machines VMs and a plurality of virtual machine monitors VMMs coupled to an exemplary system hardware platform . An optional kernel used in non hosted systems is also shown. Additionally an operating system with applications is shown with optional couplings to system hardware and VMMs 

In a virtual machine VM which in this system is a guest is installed on a host platform or simply host which includes system hardware and one or more layers or co resident components comprising system level software such as OS or similar kernel VMMs or some combination of these. As software the code defining VM will ultimately execute on the actual system hardware .

As in almost all computers this system hardware will typically include one or more CPUs some form of memory volatile and or non volatile one or more storage devices such as one or more disks and one or more devices which may be integral or separate and removable. In many existing virtualized systems the hardware processor s are the same as in a non virtualized computer with the same platform for example the Intel x 86 platform. Because of the advantages of virtualization however some hardware vendors have proposed and are presumably developing hardware processors that include specific hardware support for virtualization.

Each VM will typically mimic the general structure of a physical computer and as such will usually have both virtual system hardware and guest system software . The virtual system hardware typically includes at least one virtual CPU virtual memory at least one storage device such as virtual disk and one or more virtual devices . Note that virtual disk and physical disk are also devices but are shown separately in because of the important roles they play. All of the virtual hardware components of VM may be implemented in software to emulate corresponding physical components. The guest system software typically includes a guest operating system OS and drivers as needed for example for the various virtual devices .

To permit computer systems to scale to larger numbers of concurrent threads systems with multiple CPUs physical or logical or a combination have been developed. One example is a symmetric multi processor SMP system which is available as an extension of the PC platform and from other vendors. Essentially an SMP system is a hardware platform that connects multiple processors to a shared main memory and shared I O devices. Yet another configuration is found in a so called multi core architecture in which more than one physical CPU is fabricated on a single chip with its own set of functional units such as a floating point unit and an arithmetic logic unit ALU and can execute threads independently multi core processors typically share only very limited resources for example some cache. Still another technique that provides for simultaneous execution of multiple threads is referred to as simultaneous multi threading in which more than one logical CPU hardware thread operates simultaneously on a single chip but in which the logical CPUs flexibly share not only one or more caches but also some functional unit s and sometimes also the translation lookaside buffer TLB .

Similarly a single VM may but need not be configured with more than one virtualized physical and or logical processor. By way of example illustrates multiple virtual processors . . . VCPU0 VCPU1 . . . VCPUm within the VM . Each virtualized processor in VM may also be multi core or multi threaded or both depending on the virtualization. This invention may be used to advantage regardless of the number of processors the VMs are configured to have.

If VM is properly designed applications running on VM will function as they would if run on a real computer. This occurs even though the applications are running at least partially indirectly that is via the guest OS and virtual processor s . Executable files will be accessed by guest OS from virtual disk or virtual memory which will be portions of the actual physical disk or physical memory allocated to VM . Applications may be installed within VM in a conventional manner using guest OS . Guest OS retrieves files required for the execution of such installed applications from virtual disk in a conventional manner.

Some interface is generally required between the guest software within a VM and the various hardware components and devices in the underlying hardware platform. This interface referred to in this text as virtualization software may include one or more software components and or layers possibly including one or more of the software components known in the field of virtual machine technology as virtual machine monitors VMMs hypervisors or virtualization kernels. Because virtualization terminology has evolved over time and has not yet become fully standardized these terms do not always provide clear distinctions between the software layers and components to which they refer. For example hypervisor is often used to describe both a VMM and a kernel together either as separate but cooperating components or with one or more VMMs incorporated wholly or partially into the kernel itself however hypervisor is sometimes used instead to mean some variant of a VMM alone which interfaces with some other software layer s or component s to support the virtualization. Moreover in some systems some virtualization code is included in at least one superior VM to facilitate the operations of other VMs. Furthermore specific software support for VMs is sometimes included in the host OS itself.

Unless otherwise indicated the invention described below may be used in virtualized computer systems having any type or configuration of virtualization software. Moreover the invention is described and illustrated below primarily as including one or more virtual machine monitors that appear as separate entities from other components of the virtualization software. This is only for the sake of simplicity and clarity and by way of illustration as mentioned above the distinctions are not always so clear cut. Again unless otherwise indicated or apparent from the description it is to be assumed that the invention can be implemented anywhere within the overall structure of the virtualization software.

As illustrates a virtualized computer system may and usually will have more than one VM each of which may be running on its own VMM . The various virtualized hardware components in VM such as virtual CPU virtual memory virtual disk and virtual device s are shown as being part of VM for the sake of conceptual simplicity. In actuality these components are often implemented as software device emulators included in VMM . One advantage of such an arrangement is that VMM may but need not be set up to expose generic devices. Exposing generic devices facilitates for example migration of VM from one hardware platform to another.

In contrast another concept which has yet to achieve a universally accepted definition is that of para virtualization. As the name implies a para virtualized system is not fully virtualized but rather the guest is configured in some way to provide certain features that facilitate virtualization. For example the guest in some para virtualized systems is designed to avoid hard to virtualize operations and configurations such as by avoiding certain privileged instructions certain memory address ranges etc. As another example many para virtualized systems include an interface within the guest that enables explicit calls to other components of the virtualization software. For some para virtualization implies that the guest OS in particular its kernel is specifically designed to support such an interface. According to this view having for example an off the shelf version of Microsoft Windows XP as the guest OS would not be consistent with the notion of para virtualization. Others define para virtualization more broadly to include any guest OS with any code that is specifically intended to provide information directly to the other virtualization software. According to this view loading a module such as a driver designed to communicate with other virtualization components renders the system para virtualized even if the guest OS as such is an off the shelf commercially available OS not specifically designed to support a virtualized computer system.

Unless otherwise indicated or apparent this invention is not restricted to use in systems with any particular degree of virtualization and is not to be limited to any particular notion of full or partial para virtualization.

In addition to the distinction between full and partial virtualization two configurations of intermediate system level software layer s hosted and non hosted are in general use. In a hosted virtualized computer system an existing general purpose operating system forms a host OS that is used to perform certain input output I O operations alongside and sometimes at the request and direction of the VMM . The optional coupling between OS and VMM provides one conduit for such communication. In a hosted system optional kernel is not utilized and VMM is instead coupled directly to system hardware . The host OS in OS and VMM are both able to directly access at least some of the same system hardware resources with conflicts being avoided by a context switching mechanism. The Workstation product of VMware Inc. of Palo Alto Calif. is an example of a hosted virtualized computer system which is also explained in U.S. Pat. No. 6 496 847 Bugnion et al. System and Method for Virtualizing Computer Systems 17 Dec. 2002 .

In a non hosted system VMM is deployed on top of an optional software layer called a hypervisor or kernel . Kernel is constructed specifically to provide efficient support for VM . Compared with a hosted system in which VMM runs directly on the hardware platform use of kernel offers greater modularity. Use of kernel also facilitates provision of services such as resource management that extend across multiple VMs. As contrasted with a hosted environment where kernel is not used a non hosted environment may offer greater performance because kernel can be co developed with VMM . Co development enables optimization of the characteristics of a workload consisting primarily of VMs VMMs. Additionally in a non hosted system operating system does not utilize the optional coupling shown between OS and VMM .

As a generalization some form of virtualization software executes between system hardware and one or more VMs . The virtualization software uses the resources of the system hardware and emulates virtual system hardware on which guest system software and guest applications appear to execute. Thus virtualization software typically comprises one or more device emulators that either include or execute in conjunction with some form of system software for accessing and controlling the system hardware . As previously described the virtualization software may provide full virtualization or partial virtualization. In the non hosted virtual computer system the virtualization software primarily comprises VMM and may include some portions of kernel . Similarly in the hosted virtual computer system the virtualization software primarily comprises VMM . Various other configurations for virtualization software and system software are also possible.

Independent of virtualizing the entire operating system of a computer is the concept of virtualizing only the files and storage devices for a computer. Only a few years ago many computers were required to have local disk storage. However today it is also possible to boot a physical computer or a virtual machine from a virtual disk or from an image that is stored on a server. The increased use of physical computers and of virtual machines which allow easy proliferation of numerous virtual disks has lead to a dramatic increase in the number of disks in use. Likewise many companies and individuals use templates images or backups that are static and then applied to machines for booting machines or to configuring machines. Additionally physical and virtual computers may still use local or remote physical disks or other physical or logical storage elements that are decoupled from the physical computer via a storage area network SAN or internet small computer system interface iSCSI . Thus the concept of disks includes but is not limited to real disks virtual disks logical disks suspended disks disk snapshots images templates storage area networks local storage remote storage and backup storage.

In an environment that allows so many disk configurations to be created so easily many of the configurations will often go unused or dormant for some extended period of time such as days weeks or longer. A dormant disk can be defined as a disk that is not in use. Essentially any file that can be booted or booted from can be considered a dormant disk when it is not in use. A dormant disk typically becomes active when it is booted. However a dormant disk can become active when it or its contents is attached to a computer real or virtual and the computer is powered on.

When unused dormant disks often go out of date because they do not incorporate the latest updates such as software and virus related revisions and patches. Starting up such a dormant disk without the latest updates risks exposure to viruses and worms. Additionally starting up such a dormant disk without the latest updates can cause the computer to attempt to use software which is out of date. Even if updates are installed immediately after booting the previously dormant disk there is still a window of risk of virus infection attack or software malfunction. That is the risks associated with out of date disks exist until the out of date disk is brought up to date. Additionally a rapid increase in the number of dormant disks is occurring due in part to the trend towards separating storage from computing resources the rise of disk imaging software and the growing popularity of virtual machine technology all of which contribute to a proliferation of dormant disks. This increase in dormant disks simply expands the previously described risks.

It should be understood that conventional technologies are only able to update active disks. That is in order to scan and or update the software of an active disk existing solutions depend on the existence of a computer that has booted from the disk. Existing solutions also depend on having the disk s software especially the operating system loaded into a computer s memory. These dependencies arise because the existing solutions interact with the loaded operating system in order to coordinate the scan and or update process for the disk. In an agent based scanning updating model the loaded software includes an agent which interacts with the loaded operating system. While in an agentless scanning updating model an external update server interacts with the operating system over a network. In either model the loaded software typically participates in its own update by writing a newer version of itself onto the activated disk such that the next time the disk is booted the newer version will be loaded.

These existing solutions are unable to update a dormant disk since by definition no computer has booted from a dormant disk. Instead these existing brute force methods rely on first booting the dormant disk using a computer to make the disk active. Once the disk is active the existing scan and or update processes can then be run. However booting a disk to perform scans and or updates creates several problems.

One problem associated with booting dormant disks to perform scans and or updates is decreased efficiency. The only resource used by a dormant disk is storage space. However powering on a computer to scan and or update a dormant disk costs CPU computer processing unit cycles and memory. CPU cycles and memory can be scarce resources in a computing environment especially if the number of dormant disks is large compared to the number of computing resources.

Another problem is rooted in the existing solutions reliance on a functioning internet protocol. The internet protocol is used to retrieve and deliver the actual updates patches revisions new software versions virus signatures and etc. to the computer that has booted from the disk being updated. If for any reason the network is down when the computer is booted the computer and its disk cannot be scanned and software updates cannot be delivered to that computer for local installation.

Yet another problem exists because the software to be updated may be required to participate in its own update. For example consider an update that installs a newer version of the operating system OS . Suppose that this newer OS version contains a fix to a bug that allows an external network virus to attack and infiltrate the OS. Since the update process temporarily involves running the old version of the OS booting a dormant disk in order to update it offers a window of vulnerability in which the disk may be compromised infected or attacked before the update is installed.

As yet another drawback in one existing method of scanning and or updating an out of date disk the out of date disk is scanned and or updated in a quarantined environment. In such an approach a disk is isolated from a network. The disk is then made active and the scanning and or updating process is started. At this point a user somehow determines what updates are available and goes about acquiring them. For example a user can copy all of the updates to a CD ROM Compact Disk Read Only Memory or DVD ROM Digital Versatile Disk Read Only Memory using another computer system. These updates are then copied to the quarantined disk so that they can be applied. As this process is done without a network connection to the quarantined disk it is cumbersome inconvenient time consuming prone to error and requires extensive human interaction.

With the proliferation of easily created virtual disks and virtual machines as described above some systems may contain many thousands of potentially dormant disks. Thus the amount of time spent updating a single dormant disk is multiplied many times for a system or entity that has multiple dormant disks. Hence the inefficiencies and tedious nature of rendering dormant disks active in order to perform scans and or updates thereon is a significant problem in today s computing environment.

In a method of updating software on a dormant disk exposed files are accessed. The exposed files are exposed by mounting the dormant disk. The exposed files are scanned to determine the status of software residing on the dormant disk. The scanning is achieved without requiring booting of the dormant disk. It is determined whether an update is available for the software residing on the dormant disk such that if an update is available embodiments of the present invention provide various methods for applying the update to the dormant disk in ways that do not require booting of the dormant disk.

Furthermore in a computer readable medium having computer readable code embodied therein for causing a computer system to perform a method of updating software on a dormant disks exposed files are accessed. The exposed files are exposed by mounting the dormant disk. The exposed files are scanned to determine the status of software residing on the dormant disk. The scanning is achieved without requiring booting of the dormant disk. It is determined whether an update is available for the software residing on the dormant disk such that if an update is available embodiments of the present invention provide various methods for applying the update to the dormant disk in ways that do not require booting of the dormant disk.

In another embodiment a system for updating software on a dormant disk comprises a controller configured to couple to a file system interface. The controller is for coordinating system actions performed on the dormant disk. A utility package is coupled to the controller. The utility package is for performing tasks related to the dormant disk. A software repository is coupled to the controller. In this embodiment the scanning and updating operations are performed without requiring booting of the dormant disk.

In yet another embodiment a system for updating software on a dormant disk comprises a controller configured to couple to a file system interface. The controller is for coordinating system actions performed on the dormant disk. A utility package is coupled to the controller. The utility package is for performing tasks related to the dormant disk. A virtual environment is configured to couple between the file system interface and a software repository. The virtual environment is also configured to interact with components of the software repository to achieve scanning and updating operations on the dormant disk. In this embodiment the scanning and updating operations are performed without requiring booting of the dormant disk.

Reference will now be made in detail to embodiments of the present technology for updating software on dormant disks examples of which are illustrated in the accompanying drawings. While the technology for updating software on dormant disks will be described in conjunction with various embodiments it will be understood that they are not intended to limit the present invention to these embodiments. On the contrary the technology for updating software on dormant disks is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope the various embodiments as defined by the appended claims. Furthermore in the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the present invention. However the present invention may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail as not to unnecessarily obscure aspects of the present embodiments.

Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present detailed description discussions utilizing terms such as accessing scanning determining applying generating utilizing storing causing coupling employing performing providing interfacing detecting creating coordinating scanning scheduling and updating or the like refer to the actions and processes of a computer system or similar electronic computing device. The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices. The present invention is also well suited to the use of other computer systems such as for example optical and mechanical computers. Additionally it should be understood that in embodiments of the invention one or more of the steps can be performed manually.

As an overview one embodiment of the present invention is directed toward a method of updating software on dormant disks. In one embodiment of this method a dormant disk is mounted and the files exposed by mounting the disk are accessed. The exposed files on the dormant disk are scanned to determine the status of software residing on the dormant disk. The scanning is done without requiring the booting of the dormant disk. The scanning is performed utilizing either a direct or an indirect scanning approach as described in embodiments of the present invention. It is determined whether an update is available for the software residing on the dormant disk such as for software that is out of date infected in need of installation or in need of a virus patch. In one embodiment a notification is generated to indicate that the dormant disk is in need of an update.

In one embodiment an update is applied immediately to the software residing on the dormant disk without requiring the disk to be booted. This is done with either a direct or an indirect approach as described in embodiments of the present invention. In another embodiment the dormant disk is prepared for a subsequent self update. In such a self update embodiment an update file and a control script are stored on the dormant disk without requiring the dormant disk to be booted. Storing of the update file can be performed with either a direct or an indirect approach as described in embodiments of the present invention. When the dormant disk is next booted the control script executes and directs updates from the update file stored on the dormant disk. Additionally in various embodiments one or more processes of this method such as accessing files scanning or applying updates is performed at a scheduled time.

With reference now to a diagram of one embodiment of the present system for updating software on dormant disks is shown. The following discussion will begin with a description of the physical structure of the present system for updating software on dormant disks. This discussion will then be followed with a description of the operation of specific components of system . Discussion will then proceed to descriptions of exemplary methods for using system to scan and update software on a dormant disk.

With respect to the physical structure system is comprised of a controller a utility package a vulnerabilities database a direct software repository a virtual environment and a bus . Though shown in direct software repository and vulnerabilities database are only necessary in a system that is configured to utilize a direct scanning and or updating approach. The direct scanning and or updating approach will be described in detail below. Similarly though shown in virtual environment is only necessary in a system that is configured to utilize an indirect scanning and or updating approach. The indirect scanning and or updating approach will be described in detail below. Bus couples controller to utility package direct software repository and virtual environment . Bus also provides a coupling to various components of a computing environment that system is configured to couple with such as existing infrastructure management file system interface and server operating system .

In one embodiment utilities package is comprised of configuration database script creator software detector and disk mount manager all of which are coupled to bus . Direct software repository when included is coupled to vulnerabilities database to an external patch installer repository and to file system interface through bus . Virtual environment when included is coupled to a legacy software repository and to file system interface through bus . Legacy software repository is coupled to patch installer repository and to vulnerabilities database . Additionally as shown in server operating system is coupled to bus . Server operating system is also coupled to one or more dormant disks . As will be described in detail below system is used to scan and or update dormant disks .

Controller is configured to indirectly access and or control elements of the computing environment through the services of existing management infrastructure . In the present invention the computing environment comprises discoverable devices such as servers operating systems software real and virtual computers and real and virtual disks that controller can discover and couple to. In one embodiment existing management infrastructure comprises software applications such as systems management applications storage management applications virtual machine monitors and disk image managers. Such existing management applications provide a built in means for discovering and managing computers networks software storage devices storage networks virtual machines virtual disks disk images and other devices systems and configurations that exist in the computing environment. Controller is illustrated and described separately in the present application for purposes of clarity. However it is appreciated that in many embodiments controller is integrated into one of the infrastructure management applications such as a virtual machine monitor.

Control interface provides setup and management interfaces for interacting with system to update software on a dormant disk such as dormant disk . Control interface allows a human administrator or program to set up manage and interact with system and controller . This setup management and interaction are facilitated by use of interfaces such as a Graphical User Interface GUI a Command Line Interface CLI an Application Programming Interface API or some combination of these interfaces or the like. A GUI can be implemented on the same computer that is hosting system or on a different computer. When implemented on a different computer the GUI communicates with system over a network software interface such as hypertext transfer protocol. A CLI allows a user to write or run a script or program to control system . This is useful for instance to automate repetitive tasks. An API allows a user to write a program that controls system for automation or integration purposes.

Through the use of control interface a human a program or a script interacts with controller to configure settings for controller and system . These settings are stored in configuration database . Settings include items such as what type of existing infrastructure management tools are to be interacted with policies for performing scans and updates on dormant disks and schedules for scanning and updating one or more disks at predefined times. A policy for instance controls how system alerts the consumer when a disk in need of updating is found. A policy also controls whether a disk in need of updating should be automatically updated. A policy also controls how different types of active and dormant disks should be treated. A policy can also specify a list of software products that must be present on a computer disk. As will be described below in various embodiments of the present invention if a disk is found without a specified product during a scan the missing product can automatically be added during an update.

Discoverer is configured for interfacing with an existing management infrastructure . Discover is configured for scanning a computing environment to enumerate devices coupled to controller and system within the computing environment. The enumeration takes place in conjunction with a discovery process performed in the computing environment that system is coupled to. In the discovery process devices in the computing environment such as operating systems servers computers and disks are enumerated. Discoverer also determines how the enumerated disks are configured what devices they are hosted on and what computers if any they are attached to. Discoverer obtains information by querying management applications by scanning the computing environment directly by drawing information from data manually entered by a user or program through control interface or by a combination of these sources. Information obtained by discoverer is stored in configuration database .

Discoverer also probes hardware devices directly. Discoverer uses methods such as network probing to discover hardware devices and map out their topology. The discovered topology is stored in configuration database and updated periodically as the computing environment changes. In one embodiment discoverer explicitly identifies a disk by using conventions such as a disk array identifier a SCSI small computer system interface a device number a logical unit number or other known conventions. In one embodiment discoverer also identifies a disk through the computer that uses it. For example when a computer real or virtual is specified discoverer queries the existing infrastructure management to obtain a mapping between the computer and its disk or disks. Mappings of identified computers and disks are stored in configuration database and updated periodically as the computing environment changes.

Discoverer also queries existing infrastructure management to determine which mapped disks are dormant and which mapped disks are active. A disk is identified as dormant if it is associated with no physical or virtual computer or else is associated with a physical or virtual computer that is currently dormant. Information received regarding dormant and active disks is stored in configuration database and updated periodically as the computing environment changes. Such a mapping is useful in determining which disks to scan and or update. Additionally such a mapping is useful to automatically perform scheduled scans and or updates of dormant disks in the computing environment of system .

Information collected by discoverer is utilized by system to determine which disks are dormant what method to use for accessing a particular dormant disk which software products to scan for on a dormant disk and what methods should to use when performing scans and or updates on a particular dormant disk. Thus information collected by discoverer is beneficially utilized by controller to coordinate the actions of dormant disk scanning and updating that are described in detail below.

Scheduler is for scheduling tasks related to scans and updates of the software residing on a dormant disk such as dormant disk . Scheduler is utilized in conjunction with control interface to configure a schedule for scanning and or updating dormant disks enumerated by discoverer . For example for each enumerated dormant disk a schedule can be set to specify the time and or frequency with which the dormant disk should be scanned and updated. As will be explained further below embodiments of the present invention lend themselves to several types of scanning and updating. Scheduler is also utilized to configure and schedule the type of scan and or update to be performed on a dormant disk. Schedule information is stored and maintained in configuration database in one embodiment of the present invention.

Scheduler provides a means for efficiently allocating resources of the scanning and updating methods that are described in detail below. For instance scheduler can be used to solve resource constraint problems by scheduling scans and or updates of dormant disks when computing resources such as servers have lower work loads. Thus use of scheduler is beneficial to a method and system for updating dormant disks as scheduler allows controller to efficiently utilize a single server to perform scans and or updates on a large number of dormant disks without overtaxing the server.

Referring again to utility package is coupled to controller and provides utilities for performing tasks related to a dormant disk such as dormant disk . In one embodiment of the present invention utility package is comprised of a configuration database utility a script creator utility a software detector utility and a disk mount manager utility. In other embodiments of the present invention utility package is comprised of more utilities or less utilities than shown in .

Configuration database is for storing and providing access to schedule information configuration information enumerated devices and policies. Configuration database contains the settings necessary for system to perform its work and interact with enumerated devices in its environment. Configuration database also contains information about the computing environment that system operates in. This computing environment information allows controller and other components of system to interact with elements of the environment such as computers disks networks and other software programs.

In addition configuration database also stores a list of software products supported by system . For each supported software product configuration database also contains specifications for how the software product is to be scanned and updated if found on a dormant disk such as dormant disk . Such specifications indicate whether a particular product or disk is to be scanned with a direct or indirect scanning approach. Additionally such specifications indicate whether updates to a particular product or disk are to be applied immediately or in a delayed manner self update . If done immediately the update is installed immediately onto the dormant disk using either the direct or indirect approach. If using a self update method an update file or patch is immediately stored on the dormant disk but is installed at some later time. Another specification indicates whether scan and update tasks are to be conducted separately or in combination for a particular dormant disk. The contents of configuration database can be stored for example on disk using well known technologies. Information in configuration database is populated as described above and can also be populated from an external source through the use of control interface .

Script creator is for creating an executable control script for storing on a dormant disk such as dormant disk . Script creator is utilized in self update embodiments of the present invention that require dormant disk to be booted to fully apply updates. In such self update embodiments update files to perform necessary updates are also stored on a mounted volume of dormant disk . Script creator receives information from controller regarding the type of operating system on dormant disk software products to be updated and a list of updates to be applied. Script creator utilizes this information to create an executable or self executing script. Script creator passes the script to controller for storing on dormant disk . The script is stored in the executable volume of the primary operating system volume of mounted dormant disk . The script contains a sequence of instructions that coordinate the update process for software products found to be out of date as a result of a scan performed on a dormant disk. The script includes instructions for accessing and executing any update files that are stored on dormant disk in conjunction with the script. In some embodiments the script also includes instructions to reboot the operating system on the disk after installation of the updates.

Script creator tailors the script based on the operating system of dormant disk . Script creator also configures the operating system stored on dormant disk to run the stored script. This is done in different ways depending on the operating system family that the script is configured for use with. For instance in one embodiment an entry that references the stored script is added to a startup configuration file. In another embodiment the script is placed in a special folder designed to hold boot time programs. Script creator also includes information in a script to prevent it from executing more than once. Such info can comprise instructions for a script to erase itself or hide itself after it has been executed.

Software detector is for detecting software configurations on a mounted dormant disk such as dormant disk . Software configurations comprise configurations of software products such as operating systems and applications. The software inventory is optionally stored for instance in a memory cache or in configuration database to improve performance. Software detector is configured to couple to and utilize file system interface to analyze the file system contents of a mounted dormant disk in order to discover installed software products. A result of the analysis is the generation of a software inventory. Software detector compares the generated software inventory against the software product configuration information stored in configuration database . Based on this comparison software detector determines which products on mounted dormant disk are eligible for scanning and or updating. Although software is inventoried and compared against a stored configuration prior to scanning dormant disk for out of date status this comparison is not necessary prior to scanning software on dormant disk for virus disinfection purposes.

Software detector also analyzes a dormant disk such as dormant disk and detects software configurations. Software configurations comprise information about the type of operating system the system volume and the system folder residing on dormant disk . With respect to operating systems a bootable disk contains at least one operating system. If the bootable disk contains more than one operating system one of the operating systems is designated as the primary operating system that will be loaded into memory during a boot process if no special user actions are taken. The files of the primary operating system are typically stored in a system folder residing within the file system of a system volume on dormant disk .

Software detector detects operating systems by inspecting well known data blocks and or files on dormant disk where this information is stored. For example a disk containing an operating system from Microsoft Corporation typically has a volume containing a boot.ini file which software detector interacts with. The boot.ini file contains a list of volumes and operating systems. Each stored operating system specifies whether it is the default operating system the volume on which it resides and the location of its system folder within that volume. In this example software detector gathers detailed information about the operating system by inspecting files within the system folder. For example software detector determines the type and version of the operating system from the existence name and version of certain known files.

Software detector utilizes a similar process to detect installed applications residing on dormant disk . For instance a specific application is typically determined by the presence of known files associated with the application. Installed applications are also detected in some embodiments by inspecting the contents of certain operating system configuration files that reside on dormant disk . For instance in one embodiment a Windows Registry file a on a Microsoft Corporation operating system is inspected by software detector to detect installed applications.

Disk mount manager is for mounting and unmounting a dormant disk such as dormant disk . Disk mount manager exposes the file systems of dormant disk by logically connecting mounting dormant disk to server operating system through one of several mechanisms. Importantly it should be noted that even though files are exposed when mounting a dormant disk the dormant disk stays dormant i.e. the dormant disk is not booted. Different mechanisms are utilized to mount different types of dormant disks such as physical disks virtual disks or disk images. Mounting dormant disk causes the disk to become accessible to software running on a server in particular server operating system . Dismounting dormant disk is essentially the reverse of mounting. Dismounting dormant disk from a mounted state disconnects it from server operating system . Dismounting also causes dormant disk to become inaccessible to the software that was able to access files while dormant disk was mounted.

One mechanism for mounting a dormant physical disk involves a configuration where a physical disk resides on a device attached to a storage area network SAN . If the server running system is also attached to the same SAN through a host bus adapter HBA the dormant physical disk can be mounted by enabling a data path between the HBA and the dormant disk. This typically involves programming SAN devices such as switches and disk arrays. Controller enables the data path by sending control commands to the SAN devices directly via the SAN or via an internetwork protocol IP network. In one embodiment controller can also send commands to the SAN devices indirectly. Commands are sent indirectly by sending requests to a storage management application that resides in existing infrastructure management .

Another mechanism for mounting a dormant physical disk is used if the dormant physical disk is hosted by a device residing on the IP network. If this is the case the dormant physical disk is connected to a server though a network adapter using a protocol such as internet small computer system interface iSCSI . Controller enables the data path by sending control commands to the iSCSI devices directly. Controller can also enable the data path indirectly by sending requests to a storage management application residing in existing infrastructure management .

Virtual disks and disk images are files representing a disk. Mounting a dormant virtual disk or dormant disk image exposes an interface allowing software to access the contents of the virtual disk or disk image as a linear array of data blocks. A dormant virtual disk or dormant disk image can be logically connected mounted to the server running system through use of a virtual disk driver. The virtual disk driver makes a dormant virtual disk or dormant disk image appear as a physical disk device from the perspective of server operating system and other operating systems. This allows software including applications and subsystems of server operating system to access the volumes and file systems contained within the dormant virtual disk or dormant disk image. Virtual disk drivers are implemented by controller and by other techniques known to those skilled in the art of operating system software development.

Controller and system can be utilized to perform scans and or updates on one or more disks based on settings configurations schedules and policies. The scans and or updates can be initiated by a user a program a schedule or some combination of these means of initiation.

The following discussion sets forth in detail the operation of the present technology for updating software on dormant disks. With reference to flowchart illustrates a flow diagram of a method for updating software on dormant computer disks according to one embodiment of the present invention. Flowchart includes processes that in various embodiments are carried out by a processor under the control of computer readable and computer executable instructions. The computer readable and computer executable instructions reside for example in data storage features such as a portable diskette a computer usable volatile memory computer usable non volatile memory and or data storage unit of . The computer readable and computer executable instructions are used to control or operate in conjunction with for example processor A and or processors A B and C of . Although specific steps are disclosed in flowchart such steps are exemplary. That is embodiments are well suited to performing various other steps or variations of the steps recited in flowchart . It is appreciated that the steps in flowchart may be performed in an order different than presented and that not all of the steps in flow chart may be performed.

Referring now to and to flowchart of at the present technology for identifying updating software on dormant disks accesses exposed files on a dormant disk. The exposed files are exposed by mounting of a dormant disk. In one embodiment the direction to access exposed files on dormant disk is triggered at a scheduled time according to a schedule stored in configuration database . In another embodiment direction to access exposed files on dormant disk is based on a user input or program input received through control interface .

In one embodiment in response to a direction to access exposed files controller invokes disk mount manger to mount the volumes of a dormant disk such as dormant disk onto a server computer to which system has access. Disk mount manager notifies server operating system of the presence of dormant disk once dormant disk is accessible. Server operating system then typically employs a logical volume manager driver to analyze the disk and find one or more volumes. The logical volume manager then exposes every volume detected to one or more file system drivers. Each file system driver checks to see if the volume is formatted with a file system format known to the driver. If so the volume is called a file system and is available for mounting.

Server operating system or an alternative means is used to expose one of many known interfaces on dormant disk . Controller utilizes the exposed interface to direct a query of the accessible file systems on dormant disk . Controller then mounts a chosen file system of dormant disk to an arbitrary mount point in the file and directory name space of server operating system . After the chosen file system is mounted utilities and programs such as scanners and updaters of system can access the exposed files and directories within the mounted file system. Access of this mount point is achieved by utilizing software operations defined by the file system programming interface of server operating system . This combination of file system programming interface and server operating system form file system interface shown in .

Once dormant disk is mounted controller instructs software detector to access the exposed files on the dormant disk through file system interface . Software detector enumerates the exposed files and any software products installed on mounted dormant disk . Information regarding the enumerated files and software products is compared to stored product information maintained in configuration database . The comparison is used to determine which of the enumerated software products are supported by available scanners and updaters. Controller also consults policies and schedules to determine if any software products need to be installed or removed from the configuration that presently exists on dormant disk .

Referring again to at of flowchart the exposed files are scanned to determine the status of software residing on dormant disk . The scanning is achieved without requiring booting of dormant disk . In other words the exposed files are on dormant disk are scanned while dormant disk remains in a dormant state.

Embodiments of the present system for scanning and updating software on dormant disks employ either a direct approach or an indirect approach to perform scanning and updating of dormant disks. In the direct approach system utilizes direct software repository and vulnerabilities database to perform scanning and or updating. In the indirect approach system utilizes virtual environment to perform scanning and or updating through a coupling to a legacy software repository and its associated vulnerabilities database . The direct approach will be discussed first followed by the indirect approach.

In many embodiments scanning and or updating of dormant disk is performed immediately upon direction by controller through the use of the direct approach described below. In the direct approach scanning as described at of flowchart is performed by software residing in direct software repository .

In one embodiment software repository comprises a direct scanner updater that consolidates functions of scanning and updating into one piece of software. In other embodiments the scanning and updating functions are performed by distinct separable software components such as direct scanner and direct updater . In an embodiment utilizing distinct components direct scanner updater may comprise only direct scanner only direct updater or both. In an embodiment utilizing both scan output represents an output of direct scanner that is coupled as an input to direct updater . In one embodiment scan output is also coupled to controller via bus .

Scanner updater direct scanner and direct updater in direct software repository are specifically designed to work directly with a dormant disk such as dormant disk without requiring the dormant disk to be booted. Scanner updater direct scanner and direct updater are all parameterized. This means that each piece of software in software repository determines what type of disk it is operating with such as a dormant disk or a particular type of dormant disk. After the type of disk is determined software within direct software repository interacts with the particular disk type in a manner that is supported by the particular disk type.

In of embodiments in accordance with the present perform scanning of files on dormant disk in a specialized manner when utilizing a direct scanning approach. When scanning an active disk a normal scanner performs scanning operations by issuing any type of system call needed such as general purpose system calls or file system calls. However many general purpose system calls cannot be answered by dormant disk and thus a direct scanner only makes file system calls that can easily be redirected to dormant disk . To execute this restricted set of system calls direct scanner couples to file system interface which is exposed by the volume mounting process. Direct scanner then directly scans the appropriate exposed file s on dormant disk to retrieve the information needed. For instance to find the version number of a piece of software on an active disk a normal scanner would simply make a system call such as API call GetVersion to the operating system running on the active disk. However when interacting with dormant disk this method of scanning would require booting the dormant disk. In embodiments of the present invention instead of booting dormant disk to find a version number of a piece of software direct scanner utilizes file system interface to look up the registry file on dormant disk . Direct scanner will then issue a command to controller to mount the registry file. Direct scanner will then determine the version number of a piece of software on dormant disk by scanning the mounted registry file. This specialized nature of interaction with dormant disk allows direct scanner to achieve scanning software residing on dormant disk without requiring booting of dormant disk . In other words the exposed software files on dormant disk are scanned via the direct approach while dormant disk remains in a dormant state.

In of embodiments in accordance with the present invention determine whether an update is available for the software residing on dormant disk . In the direct approach this determining is done by direct scanner by comparing the status of scanned files with known vulnerabilities. Known vulnerabilities are typically cached in a vulnerabilities database such as vulnerabilities database . In other embodiments vulnerabilities database can also comprise a pointer to a cached database of vulnerabilities. Direct scanner determines whether updates such as patches new versions new software etc. are needed for any scanned dormant disk. Direct scanner determines what updates are needed by referencing vulnerabilities database and information provided from policies stored in configuration database .

If an update is determined to be needed direct scanner the lists the determined update in scan output . Scan output also identifies software and disks needing updates. Scan output is coupled to direct updater and to controller .

In of embodiments in accordance with the present invention apply an update to the software residing on dormant disk . In some embodiments this update is applied to dormant disk while dormant disk remains in a dormant state. In one embodiment the update is applied automatically after the scanning. In another embodiment the update is performed at a scheduled time in response to an update schedule or policy maintained in configuration database . In one embodiment using the direct approach this update is applied to dormant disk by utilizing direct updater . Direct updater is coupled to file system interface and is configured to interact directly with dormant disk in a similar specialized manner as previously described with direct scanner .

Direct updater couples to patch installer repository . As represented in patch repository is a global repository that is also accessible by other files. In addition to patches and updates patch installer repository may contain full installers capable of installing a complete software product. The structure of a patch installer repository such as patch installer repository is known in the art. Direct updater retrieves update files as needed per scan output from patch installer repository .

In one embodiment of of an update is applied to software residing on dormant disk by utilizing a direct updating approach to install an update file on dormant disk . The update file is installed without requiring booting of dormant disk . The update file comprises information needed to perform an update that was identified through the process of scanning dormant disk . In this direct updating approach direct updater couples directly with file system interface . Software to be updated on dormant disk is accessed and under direction from controller update files are installed on dormant disk without requiring booting of dormant disk .

In of embodiments in accordance with the present invention generate a notification to indicate that dormant disk is in need of an update. In one embodiment controller utilizes information from scan output to generate a notification to indicate that dormant disk is in need of an update. In one embodiment such a notification is generated when a dormant disk needs updates but the updates cannot be safely or reliably applied while the disk is in a dormant state. The notification contains enough information to allow a consumer human user or software program to identify the dormant disk that needs updating. This notification can be displayed for user viewing for instance in control interface . This notification can also be stored in configuration database supplied as an input to another software program or stored on dormant disk for future reference. The notification can be generated using a known technique such as a network packet a callback procedure a function return code or an asynchronous message.

In another embodiment of of referred to as a self update method direct updater stores an update file on dormant disk . The update file is then installed on dormant disk at some later time when dormant disk is next booted. The self update method requires very little intrusion onto dormant disk . The self update method also minimizes exposure of dormant disk to vulnerability upon booting because updates begin installing immediately without requiring a connection to the internet. The update file comprises information needed to install an identified update to software residing on dormant disk . The update file is stored on dormant disk with direction from controller and the storing is done without requiring booting of dormant disk . In other words the update file is stored on dormant disk while dormant disk remains in a dormant state. Controller also directs script creator to create a self executing control script as previously described . The script is also stored on dormant disk with direction from controller . The script is also stored on dormant disk while dormant disk remains in a dormant state. The script automatically runs the next time dormant disk is booted. When the script runs it executes instructions that cause the update file to be installed on dormant disk . In some embodiments the stored update file is self executing. In other embodiments the script utilizes information in the stored update file to perform the required update.

In one embodiment of of after the update file and script are installed controller can issue a command to boot dormant disk so that the update file will be installed. The booting command is issued for instance in accordance with a policy maintained in configuration database . In one embodiment controller issues the boot command immediately after the update file and script are stored on dormant disk . In another embodiment controller issues the boot command at a scheduled time for instance in the middle of the night when more computer resources may be available to perform the booting. In yet another embodiment controller causes the booting of dormant disk to be performed in an isolated environment that is not coupled to an internet connection. Script creator can do this for instance by inserting information into the script to disable network interface cards prior to the update with additional information to re enable network interface cards after the update is complete. After the update is installed controller returns dormant disk to a dormant state.

Thus in accordance with the above descriptions embodiments of the present invention utilize a direct approach to scan and or update software on a dormant disk. Embodiments utilizing the direct approach perform scanning and or updating of software on a dormant disk without requiring booting of the dormant disk.

Referring again to of embodiments in accordance with the present invention access exposed files the files being exposed by mounting of a dormant disk such as disk . This accessing has been previously described and is performed in the same manner in the indirect approach with an exception being that when system is configured for utilizing an indirect approach virtual environment is also capable of accessing exposed files on dormant disk . In many embodiments scanning and or updating of dormant disk is performed immediately upon direction by controller through the use of the indirect approach described below.

With reference to of embodiments in accordance with the present invention scan the exposed files to determine the status of software residing on dormant disk . In the indirect approach the scanning is achieved without requiring booting of dormant disk . In other words the exposed files are scanned via the indirect approach while dormant disk remains in a dormant state. In one embodiment of of utilizing an indirect scanning approach this scanning is performed by employing virtual environment in conjunction with legacy software such as legacy scanner of legacy software repository to achieve scanning of software on dormant disk .

In when utilizing the indirect approach virtual environment plays a central role. shows a block diagram of an exemplary virtual environment used in a system for updating software on dormant disks according to one embodiment of the present invention. Virtual environment is configured to couple between to file system interface and legacy software repository . Virtual environment configured to coordinate and emulate communications between said file system interface and legacy software repository . Virtual environment is also configured to interact with components of legacy software repository to achieve scanning and or updating operations on dormant disk .

In of embodiments according to the present invention determine whether an update is available for the software residing on dormant disk . In one embodiment utilizing the indirect approach this determining is done by legacy scanner which operates through virtual environment to compare the status of scanned files with known vulnerabilities. Virtual environment then intercepts redirects and emulates actions and responses to system calls from legacy scanner . Known vulnerabilities are typically cached in a vulnerabilities database such as vulnerabilities database . In other embodiments vulnerabilities database can also comprise a pointer to a cached database of vulnerabilities. Legacy scanner determines whether updates such as patches new versions new software etc. are needed for any scanned dormant disk. Legacy scanner determines what updates are needed by referencing vulnerabilities database and in some embodiments information provided from policies stored in configuration database .

In one embodiment if an update is determined to be needed legacy scanner the lists the determined update in scan output . Scan output also identifies software and disks needing updates. Scan output is coupled to legacy updater . In some embodiments controller is also configured to couple to legacy updater and or legacy scanner through virtual environment .

In of embodiments in accordance with the present invention apply an update to the software residing on dormant disk . In some embodiments this update is applied to dormant disk while dormant disk remains in a dormant state. In one embodiment the update is applied automatically after the scanning. In another embodiment the updating is performed at a scheduled time in response to an update schedule or policy maintained in configuration database .

In one embodiment of of utilizing the indirect approach this update is applied to dormant disk by utilizing legacy updater running through virtual environment . Legacy updater interacts with virtual environment as described above to achieve file operations on dormant disk . Legacy updater couples to patch installer repository . As represented in patch repository is a global repository that is also accessible by other files. In addition to patches and updates patch installer repository may contain full installers capable of installing a complete software product. The structure of a patch installer repository such as patch installer repository is known in the art. Legacy updater retrieves update files as needed per scan output from patch installer repository .

According to one embodiment of of an update is applied to software residing on dormant disk by utilizing an indirect updating approach to install an update file on dormant disk . The update file is installed without requiring booting of dormant disk . In this indirect updating approach virtual environment is employed to achieve installation of the update file. Legacy updater is coupled with virtual environment . Virtual environment then intercepts redirects and emulates actions and responses to system calls from legacy updater .

Consider an example where several old files on dormant disk need to be overwritten with new files. Virtual environment collects all the new files sent from legacy updater and temporarily stores them. Virtual environment emulates an appropriate response to legacy updater to indicate that the update files have been properly installed on dormant disk . Virtual environment then translates the files into a format that will allow them to be applied to dormant disk . Depending upon the situation applying the updates to disk can comprise either storing or installing the translated update files on dormant disk . Thus through virtual environment software to be updated on dormant disk is accessed and update files are installed on dormant disk without requiring booting of dormant disk .

In of embodiments in accordance with the present invention generate a notification to indicate that dormant disk is in need of an update. In one embodiment controller utilizes information from scan output to generate a notification to indicate dormant disk is in need of an update. In one embodiment such a notification is generated when a dormant disk needs updates but the updates cannot be safely or reliably applied while the disk is in a dormant state. The notification contains enough information to allow a consumer human user or software program to identify the disk that needs updating. This notification can be displayed for user viewing for instance in control interface . This notification can also be stored in configuration database supplied as an input to another software program or stored on dormant disk for future reference. The notification can be generated using a known technique such as a network packet a callback procedure a function return code or an asynchronous message.

According to another embodiment of of referred to as a self update method virtual environment receives an update file from legacy updater . The update file comprises information needed to install an identified update to software residing on dormant disk . Virtual environment is employed to carry out operations with direction from controller to translate if necessary and store the update file on dormant disk . The storing is done without requiring booting of dormant disk . In other words this update file is stored on dormant disk while dormant disk remains in a dormant state. Controller also directs script creator to create a self executing control script as previously described . The script is also stored on dormant disk with direction from controller . The script is also stored on dormant disk while dormant disk remains in a dormant state. The script automatically runs the next time dormant disk is booted. When the script runs it executes instructions that cause the update file to be installed on dormant disk . In some embodiments the stored update file is self executing. In other embodiments the script utilizes information in the stored update file to perform the required update. Thus the update file is then installed on dormant disk at some later time when dormant disk is next booted. The self update method requires very little intrusion onto dormant disk . The self update method also minimizes exposure of dormant disk to vulnerability upon booting because updates begin installing immediately without requiring a connection to the internet.

In one self update embodiment of of after the update file and script are installed controller can issue a command to boot dormant disk so that the update file will be installed. The booting command is issued for instance in accordance with a policy maintained in configuration database . In one embodiment controller issues the boot command immediately after the update file and script are stored on dormant disk . In one embodiment controller issues the boot command at a scheduled time for instance in the middle of the night when more computer resources may be available to perform the booting. In yet another embodiment controller causes the booting of dormant disk to be performed in an isolated environment that is not coupled to an internet connection. Script creator can do this for instance by inserting information into the script to disable network interface cards prior to the update with additional information to re enable network interface cards after the update is complete. After the update is installed controller returns dormant disk to a dormant state.

Virtual environment is central to the indirect approach for scanning and updating software on a dormant disk. A detailed discussion of the operation of virtual environment within system is therefore warranted.

Virtual environment is a program or code module that virtualizes the local or remote operating software interface that is expected by a legacy scanner legacy updater or combined legacy scanner updater. As shown in virtual environment is comprised of an operating system interface emulator and a re director which are coupled to one another. Operating system interface emulator and re director are coupled to legacy software repository . Operating system interface emulator is also coupled to file system interface via bus . Virtual environment allows system to trick legacy scanning and or legacy updating software into thinking that it is communicating with an operating system booted from dormant disk . In reality the legacy scanning and or legacy updating software runs on operating system interface emulator which in turn runs on server operating system .

Virtual environment accomplishes this task by creating an operating system interface that emulates or mimics the local or remote operating system interfaces that legacy software repository expects of an active operating system. System calls requiring interaction with virtual disk are then redirected to operating system interface emulator .

System call re director is configured for redirecting system calls from legacy software repository . System call re director is used to handle mapping of system calls that should be redirected to operating system interface emulator and those that should simply be passed through to server operating system . A common way for a piece of software to send system calls to an operating system is to route all system calls through a table or library of pointers. Each pointer points to functions or application program interfaces that will handle a system call. In one embodiment re director patches this library in any scanning or updating software that resides in legacy software repository . The patching causes all system calls requiring interaction with dormant disk to be redirected to operating system interface emulator for fulfillment. In another embodiment re director accomplishes the same result by dynamically substituting a different library of pointers for the library normally utilized by a piece of software in legacy software repository .

Operating system interface emulator is configured for interacting with legacy software repository . Operating system interface emulator is further configured to emulate responses to system calls and interact with dormant disk . Operating system interface emulator receives redirected system calls from legacy software repository carries out actions to fulfill them and emulates any expected responses to legacy software repository .

Operating system interface emulator only emulates the subset of the operating system interface that a legacy tool expects to interact with. Specifically operating system interface emulator emulates only the system procedures invoked by system calls from legacy software repository to perform scans updates or other actions on dormant disk . This subset of system procedures can be determined by monitoring the actions of legacy scanning and updating tools as they operate in a real operating system environment on an active computer and an active disk.

Most system calls intercepted by operating system interface emulator are translated into data queries or data modifications to files or portions of files on dormant disk . These queries and modifications are then sent to file system interface or server operating system to be carried out as file operations on the mounted volumes of dormant disk . Specific examples illustrated below help explain how virtual environment handles file access requests configuration management requests state change operations and other system calls received from tools in legacy software repository .

For file access legacy scanners and updaters typically use file related system calls to read and write files of the computer or disk being scanned or updated. The system call typically identifies the file to be accessed by a file name and a path. In system the volumes of dormant disk are mounted in the file name space of server operating system . This allows operating system interface emulator to emulate those legacy system calls from legacy software repository by performing a simple path translation and then forwarding the system call to the server operating system with the translated path.

For example consider what happens when legacy scanner updater wishes to call a hypothetical OpenFile procedure on a file with path etc hosts within a volume of dormant disk that contains a Unix family operating system. This path identifies the file hosts in the directory etc . This path would be correct if legacy scanner were communicating with an active operating system booted from dormant disk . However since disk is dormant its operating system is also dormant and therefore not active. For purposes of this example suppose disk mount manager has mounted the volume of dormant disk onto mount point dormant 100 in the file name space of server operating system . When operating system interface emulator of virtual environment receives the OpenFile etc hosts request it translates it to OpenFile dormant 100 etc hosts . Operating system interface emulator then forwards the translated request to the server operating system through its file system interface . The net effect of this interposition of virtual environment is that legacy scanner is indirectly allowed to open the file it actually desires. Without the path translation the forwarded OpenFile etc hosts system call would cause legacy scanner updater to open a non existent file or worse the etc hosts file of server operating system .

A legacy scanner or legacy updater often calls procedures for obtaining configuration information about an operating system and installed applications. For instance in the Windows family of operating systems a legacy scanner can call GetVersion to obtain the major and minor version numbers of the operating system. Under normal circumstances with an active disk the operating system has its own version numbers cached in memory and simply returns them to the calling program. However when system runs legacy scanner in virtual environment to scan dormant disk the primary operating system of the dormant disk does not exist anywhere in memory.

Fortunately a computer s operating system is usually loaded from files on the disk. Therefore configuration information about the primary operating system of dormant disk can typically be obtained from program and configuration files residing in the system folder that is located by the software detector after dormant disk is mounted. In the example above the system call from legacy scanner is redirected to operating system interface emulator . Operating system interface emulator obtains the version numbers of the operating system by reading specific entries in the Windows registry database that is stored in a set of files in the system folder of dormant disk . Operating system interface emulator then supplies this version information in an expected format to legacy scanner to fulfill the system call request.

In another example legacy updater can make system calls intended to change the run time state of the operating system running a disk. For example legacy updater can request a reboot of dormant disk . If the operation involves changing the run time state or memory state of an operating system virtual environment can usually ignore the operation since dormant disk is not booted. Virtual environment simply emulates an expected response to the state change system call but makes no state changing operations with regard to dormant disk . The emulated response typically comprises returning an appropriate status code to legacy updater to indicate a successful result to the system call even though no run time state operation has been performed on dormant disk .

As previously indicated certain system calls made by a software tool in legacy software repository can be forwarded to server operating system without any translation. For example a legacy updater interacting with a Windows family operating system can call GetSystemTime to query the current date. A system call such as this can be safely forwarded without translation through virtual environment and on to server operating system . This is because the concept of current time is universal and is therefore independent of the operating system reporting it. Likewise other similar system calls can generally be safely forwarded without translation.

Thus in accordance with the above descriptions embodiments of the present invention utilize an indirect approach to scan and or update software on a dormant disk. Embodiments utilizing the indirect approach perform scanning and or updating of software on a dormant disk without requiring booting of the dormant disk.

For purposes of simplicity the components and methods utilized in the direct approach and indirect approach have been described separately. However it is appreciated that numerous combinations of the separately described direct and indirect approaches are anticipated. For instance one embodiment of the present invention utilizes a direct scanning approach. An indirect updating approach is then utilized to store an update file on a dormant disk. A self executing script is also stored on the disk. The dormant disk then performs a self update immediately after it is next booted. Thus such an embodiment exemplifies a combination of direct scanning indirect updating and a self executing script. It should be understood that various other combination of approaches in accordance with the present invention can be utilized.

It should be additionally noted that all components necessary for implementing either the direct or indirect approaches are shown in or coupled to system of . It is appreciated however that in an embodiment of system employing only a subset of these possible approaches for scanning and or updating only the components necessary for the particular approach or approaches need be included in system . For instance in an embodiment of system that employs a direct approach for scanning and updating software on a dormant disk virtual environment and couplings to legacy software repository and vulnerabilities database are not required. Likewise in an embodiment of system that employs an indirect approach for scanning and updating software on a dormant disk direct software repository and vulnerabilities database are not necessary. Similarly an embodiment that does not utilize a self update approach will not require inclusion of script creator .

With reference now to portions of the present invention are composed of computer readable and computer executable instructions that reside for example in computer usable media of a computer system. That is illustrates one example of a type of a computer that can be used to implement embodiments of the present invention which are discussed below. illustrates an exemplary computer system that can be implemented from physical components virtual components or some combination thereof. It is appreciated that system of is exemplary only and that the present invention can operate on or within a number of different computer systems including general purpose networked computer systems embedded computer systems routers switches server devices client devices various intermediate devices nodes stand alone computer systems physical computer systems virtual computer systems and the like.

Computer system of is well adapted to having peripheral computer readable media such as for example a floppy disk a compact disc a virtual disk and the like coupled thereto. System of includes an address data bus for communicating information and a processor A coupled to bus for processing information and instructions. As depicted in system is also well suited to a multi processor environment in which a plurality of processors A B and C are present. Conversely system is also well suited to having a single processor such as for example processor A. Processors A B and C may be any of various types of microprocessors.

System also includes data storage features such as a computer usable volatile memory e.g. random access memory RAM coupled to bus for storing information and instructions for processors A B and C. System also includes computer usable non volatile memory e.g. read only memory ROM coupled to bus for storing static information and instructions for processors A B and C. Also present in system is a data storage unit e.g. a magnetic optical disk etc. coupled to bus for storing information and instructions. System also includes an optional alphanumeric input device including alphanumeric and function keys coupled to bus for communicating information and command selections to processor A or processors A B and C. System also includes an optional cursor control device coupled to bus for communicating user input information and command selections to processor A or processors A B and C. System of the present embodiment also includes an optional display device coupled to bus for displaying information.

Referring still to optional display device may be a liquid crystal device cathode ray tube plasma display device or other display device suitable for creating graphic images and alphanumeric characters recognizable to a user. Optional cursor control device allows the computer user to dynamically signal the movement of a visible symbol cursor on a display screen of display device . Many implementations of cursor control device are known in the art including a trackball mouse touch pad joystick or special keys on alpha numeric input device capable of signaling movement of a given direction or manner of displacement. Alternatively it will be appreciated that a cursor can be directed and or activated via input from alpha numeric input device using special keys and key sequence commands. System is also well suited to having a cursor directed by other means such as for example voice commands. System also includes an I O device for coupling system with external entities. For example in one embodiment I O device is a modem for enabling wired or wireless communications between system and an external network such as but not limited to the Internet. A more detailed discussion of the present technology for identifying design issues in electronic forms is found below.

In various other components are depicted for system . Specifically when present an operating system applications modules and data are shown as typically residing in one or some combination of computer usable volatile memory e.g. random access memory RAM and data storage unit . In one embodiment the present technology for identifying design issues in electronic forms for example is stored as an application or module in memory locations within RAM and memory areas within data storage unit .

Although the subject matter has been described in a language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

