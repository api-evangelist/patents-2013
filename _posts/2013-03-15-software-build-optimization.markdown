---

title: Software build optimization
abstract: A method for optimization of a software build includes collecting first data representative of inputs for a build process obtained by a set of data accessing operations implemented during a first execution of the build process, the set including a file accessing operation and a non-file accessing operation. A redirection routine embedded within the build process captures the inputs. The first data is compared with second data representative of the inputs obtained in connection with a second execution of the build process. If the first and second data do not match, the second data is recorded in a data store and output data generated by the second execution of the build process is stored. If the first and second data match, output data generated by the first execution of the build process is used as an output for the second execution of the build process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09286043&OS=09286043&RS=09286043
owner: Microsoft Technology Licensing, LLC
number: 09286043
owner_city: Redmond
owner_country: US
publication_date: 20130315
---
Computers accomplish tasks by processing sets of instructions derived from software source code. Source code is typically written by a software developer using one or more programming languages. Most programming languages have a source code compiler to compile the source code into computer readable binary data files or binaries.

A software build is the process of creating the binaries for a software application. Builds are done periodically during software development to provide binaries to support further work by the software development teams. Software builds involve executing many build tools in addition to the compiler to process the source code files and other input data for the software application. The execution of the build tools is often time intensive as some software development projects may involve thousands or even hundreds of thousands of source code files having a complex dependency structure.

Methods systems and computer program products are directed to optimizing a software build. Data representative of inputs for a build process is compared with data representative of the inputs for a previous execution of the build process. When a data match occurs output data generated by the previous execution is used to optimize the software build.

In accordance with one aspect of the disclosure data representative of inputs obtained by data accessing operations implemented during a first execution of a build process is collected. The inputs are captured via a redirection routine embedded in the build process for execution upon invocation of both file and non file accessing operations of the build process. The collected data is compared with data representative of the inputs obtained in connection with a second execution of the build process to determine whether output data generated by the first execution may be used for build optimization.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

While the disclosed systems and methods are susceptible of embodiments in various forms specific embodiments are illustrated in the drawing and are hereafter described with the understanding that the disclosure is intended to be illustrative and is not intended to limit the invention to the specific embodiments described and illustrated herein.

Methods systems and computer program products are described for optimization of a software build such as a source code build. The optimization is achieved using output data generated by previous executions of build processes of the source code build. Such use of previous output data may be appropriate if inputs to a build process have not changed from the previous execution. An incremental build involving only a fraction of the build processes may thus be implemented to optimize the source code build. Such optimization may result in a more efficient build in which the output or results of the build are available more quickly. The type of optimization provided by relying on previous build results to avoid unnecessary execution of build processes may be referred to as build memorization or trimming of the build processes.

A build may be tracked as an event graph or sequence of processes that take in a set of inputs and produce a set of outputs. Using data representative of the inputs at each level stage or event of the build a decision may be made whether to execute the process or use a previously cached archived or otherwise stored output result instead. With each new build if the inputs to a build process are the same as a previous execution of the build process the archived data is copied or used instead of running or proceeding with the execution of the build process. Use of such archived data may result in improved build speeds of up to about 60 .

The disclosed embodiments collect data representative of the inputs and implement a comparison with data representative of the inputs for the previous execution of the build process. The inputs are captured via a redirection routine embedded in the build processes. The redirection routine is executed upon invocation of each data accessing operation implemented during execution of the build process. The redirection routine may enable the disclosed embodiments to implement instructions configured to record the inputs gathered by data accessing operations implemented during execution of the build process. In some embodiments an invocation of a build process is compared with an identity of the build process e.g. identifiers of the build process and all inputs thereto . If the build process does not match the identities of any previous executions of the build process the build process is executed the identity is recorded and any outputs are stored.

The redirection routine may be inserted automatically into child processes invoked by a root or top build process. The data indicative of the inputs may thus be collected for each build process invoked either directly or indirectly as part of the build. The redirection routine and other aspects of the disclosed embodiments may allow the optimization to be achieved in connection with pre existing build systems. The disclosed embodiments are not limited to a particular type of build system. The optimizer and or other components of the disclosed embodiments may be integrated with a variety of different build systems.

The disclosed embodiments are configured to capture various types of inputs obtained by data accessing operations e.g. function calls implemented during execution the build process. The data accessing operations include both file accessing operations and non file accessing operations. The disclosed embodiments are configured to capture the inputs obtained by both of these types of data accessing operations. The disclosed embodiments are thus not limited to comparing source code and other file inputs to the build process. Instead other inputs to the build process may also be compared including for instance variables or parameters indicative of the computing or build environment in which the build process is executed. The disclosed embodiments may capture the inputs obtained via the non file accessing operations of the build process despite the varying nature source and other characteristics of such inputs.

The comparisons with previous build results of the disclosed embodiments are not limited to determining whether input files such as source code files are changed. The disclosed embodiments thus address the possibility that data accessing operations of a build process that obtain data from non file sources may change the output of the build process. By including such data in the comparison the decision whether to execute a particular build process may thus be more accurate.

The disclosed embodiments may be configured to address challenges arising from comparison of data from non file accessing operations. While collecting data representative of inputs for non file accessing operations may support a more accurate and useful comparison the use of such data may result in unnecessary execution of build processes. For example some environment variables such as a folder or file path or other data location may be indicative of a user name or a name assigned to a computer. While such variables may change the output of the build process use of the output of a previous execution of the build process may nonetheless be appropriate. The disclosed embodiments may be configured to address such environment variables by generating for example machine agnostic or machine independent representations of one or more inputs. Such machine independent representations may then be compared with the similarly converted representations of such inputs from previous builds.

The use of such machine independent representations may allow environment variables to be considered in the comparison without unduly restricting the use of previous outputs. For example the output data from previous builds may thus be used by multiple developers. The builds by a team of developers may thus contribute to and later use a common cache of output data the inputs for which are no longer indicative of the specific developer or machine from which the output data was generated. The disclosed embodiments may thus be configured to support multiple developer environments for a given software product by allowing any number of developers to utilize the data cached from previous builds.

In some embodiments a configuration file or other configuration data is accessed to determine whether to attempt to optimize a particular build process. Optimization may be especially useful in connection with time intensive build processes. In contrast some build processes may execute so quickly that the process of copying archived results from a previous execution of the build process may take as long as or longer than the execution time of the build process. The configuration data may be relied upon to exclude these and other build processes such as those processes that do not behave deterministically. Deterministic processes are considered to be those processes that generate the same output each time the process is given the same set of inputs. However some non deterministic processes may be optimized by the disclosed embodiments. For example certain types of output differences that are insignificant and or non substantive may be ignored in some cases including for instance timestamps and globally unique identifiers GUIDs .

Notwithstanding references herein to various build processes or tools the disclosed embodiments are not limited to any particular type of build build process or build tool. For instance builds in addition to source code builds may be optimized by the disclosed embodiments. For example builds that perform a transformation of e.g. binary files may be optimized. The build optimization provided by the disclosed embodiments is not limited to a particular build engine or build framework. The disclosed embodiments are not limited to any specific operating system environment platform or computing infrastructure. The nature of the software products processed via the disclosed embodiments may vary. For example a software product need not involve a full or complete software application such as an integrated software build released to production. Instead the software product may involve a branch or other component of a software application or system. The disclosed embodiments may be used to build various types of software products which are not limited to any particular operating system operating or computing environment or platform or source code language.

The disclosed embodiments are not limited to a particular type of build or build context. The data collected by the disclosed embodiments may in fact compare data indicative of the type of build or build context to more accurately determine whether to use the output of a previous build.

The build system or any component thereof may include a computer or computing system examples of which are described below in connection with . The computer or computing system may be integrated with any one or more local repositories or data stores to any desired extent. The computer or computing system may include one or more processors or a processing system configured by instructions of one or more engines tools modules or other units of the build system .

The build system includes a build engine having a number of build tools configured to compile and otherwise process the source code and other input data to generate and package the binaries. The build tools may be directed to a variety of different functions including for instance source code compilation resource compilation linking and resource generation. Any build engine software tool and or infrastructure may be used in the build system . In one example the build system utilizes the MSBuild build platform from Microsoft Corporation which may be available via or in conjunction with the Microsoft Visual Studio integrated development environment. Other build systems and or integrated development environments may be used. For example the build system may be provided or supported via a cloud or other networked computing arrangement such as cloud based system described in U.S. Patent Publication No. 2013 0055253 Cloud based Build Service the entire disclosure of which is hereby incorporated by reference.

The build tools are provided via execution of a number of build processes . Each build process may provide one or more build tools. Each build process may include or be provided by an executable program to be run during the build. Examples of build processes include native code compilers e.g. cl.exe linkers e.g. link.exe assemblers e.g. ml.exe and ml64.exe model generation processes e.g. instancetool.exe build engines e.g. msbuild.exe compilers of managed code e.g. csc.exe resource generators e.g. rsgen.exe and resource compilers e.g. cvtres.exe . Additional fewer or alternative build tools may be provided by the build processes . A build may thus involve executing any number of such build processes . The build processes may vary based on various characteristics of the environment including for instance the operating system the source code language s and various characteristics of the processor s or processing system of the environment such as the processor architecture e.g. 32 bit or 64 bit architectures . One or more of the above referenced examples of build processes is configured for operation in an environment running one of the Microsoft Windows operating systems and processing source code written in for instance the C or C programming languages. Other build processes may be used to provide such tools for other environments.

Some of the build processes may be called or invoked by other build processes . For example the compilation process csc.exe is often called as a descendant or child process of the process msbuild.exe. The build processes may thus be executed in accordance with a tree or other dependency graph as shown in . A root or top level process of a build may call any number of child processes each of which may in turn call other child processes. The dependency graph may thus have any number of levels. A build may have any number of root or top level build processes. The dependency graph may vary between builds. For instance in some cases a build process may be executed on its own in one build and as a child process in another build. The disclosed embodiments are not limited to a particular arrangement of build processes and are configured to implement a recording algorithm that automatically propagates through the arrangement to support optimization at each level as described below.

Each build process includes data access operations to obtain inputs. The inputs provide data to be processed by the build process . The respective instructions of each build process may specify any number of data access operations of varying types. The data access operations may include or involve an application programming interface API operation or routine invoked during execution of the build process to obtain input data. For example one API operation directed to obtaining input files in a Microsoft Windows environment is the OpenFile API. One API operation directed to obtaining non file input data is GetEnvironmentVariable to obtain current user or other environment variables or RegOpenKeyEx to read from registry. The build processes may invoke non API operations to access data to be processed such as reading from an input pipe or accessing configuration data.

The API or other data access operations invoked by the build processes may be configured to obtain different types of input data. Some of the data access operations are file accessing operations configured to obtain one or more input files. The input files may be source code files in the source code repository but other types of input files may be obtained such as binaries and resource files. The input files may include any type of data arranged in any type of language structure or framework. The location of the inputs may thus vary. For example some inputs may be located in a registry.

Some of the data access operations invoked by the build processes are non file accessing operations. Non file accessing operations are configured to obtain non file input data e.g. data provided in forms other than files. In the embodiment of such non file input data includes data representative of one or more parameters of the environment data representative of one or more configuration parameters of the build system and data presented to the build engine as for instance arguments via a command line or other user interface of the build system or otherwise presented by the environment . The parameters of the environment may be indicative of a wide variety of characteristics of the environment including for example a network location of the computer or computing system of the environment . The configuration parameters of the build system may be directed to customizing the operation of the build system for a particular type of build e.g. a debug build or a release build . The command line may be used to specify any arguments or other parameters for one or more of the build processes . The arguments may be specified in connection with a command to initiate the build initiate the execution of one or more of the build processes and or configure one or more aspects of the build the build engine and or the build processes. In some cases one or more of the configuration parameters are specified via the command line but may be specified or established in a variety of other ways.

Additional fewer or alternative types of non file input data may be obtained via the non file accessing operations of the build processes . For example the non file data may indicative of a user name. The non file input data may also or alternatively include data representative of the name of a file or folder path a directory or other storage location within or relative to the environment . For example the non file input data may be representative of a file path and or a directory of the source code repository but other storage locations may be specified.

The non file accessing operations may be configured to obtain various types of input data for the build processes . The input data may include one or more variables parameters codes or other data elements. The arrangement format or other characteristics of the data elements may vary. For example the data elements may be encoded. The configuration parameters may include one or more codes representative of the build context the type of build or a development stage of the build e.g. a debug build or a release build .

Execution of the build processes by the build engine generates a number of binary files for the software product. In this example the binary files are stored in a build repository of the environment . The results of a build may include output data in addition to the binary files .

The output data of a build may vary based on the inputs obtained by either the file accessing operations or the non file accessing operations. The inputs obtained by these operations are thus collected and processed by an optimizer of the build system to support the possible re use of past or previous output data in future builds. In this embodiment the optimizer is configured as a discrete component of the build system but may be integrated with one or more other components or units of the build system to any desired extent including for example the build engine .

The optimizer is operative to execute build optimizer instructions for each build process . The build optimizer instructions are configured to direct the collection of data representative of the inputs obtained by the data accessing operations implemented during execution of the build process . The build optimizer instructions are further configured to direct a comparison of such data with data representative of the inputs obtained in connection with a subsequent execution of the build process . The optimizer is configured to utilize a redirection tool configured to embed or incorporate a hook or other redirection routine into each build process for execution upon invocation of each data access operation within the build process . Each time the build process attempts to obtain an input e.g. via a file accessing operation or via a non file accessing operation the redirection tool implements the redirection routine to allow the input to be captured by the optimizer .

In some embodiments the redirection tool may use the Microsoft Detours software tool from Microsoft Corporation. The Detours software tool includes a library for instrumenting various functions on computers or computing systems running one of the Microsoft Windows operating system. The Detours software tool may intercept the functions by re writing target function images. The Detours software tool may be used to hook file access and non file access API and other operations to track what the functions do. The Detours software tool may provide a technique for inserting the collection functionality of the optimizer between the build process and the operating system. Other software tools may be used to implement the redirection tool including for example the Drawbridge and other virtualization tools available from Microsoft Corporation and described at http research.microsoft.com en us projects drawbridge and http www.microsoft.com en us windows enterprise products and technologies virtualization app v.aspx. Further details regarding the use of a tracking tool such as the Detours software tool during a build are set forth in U.S. Pat. No. 7 721 272 Tracking File Access Patterns During a Software Build and U.S. Patent Publication No. 2012 0260240 Software Build Optimization the entire disclosures of which are hereby incorporated by reference.

The optimizer may include or access one or more units instructions or modules configured to generate or determine an identification code or other identifier for the captured inputs. The identifier may then be used to more efficiently perform the comparison with the input data obtained during a previous execution of the build process . In the embodiment of the optimizer includes a hash calculator to determine a hash code for each respective captured input. The hash code is generated based on the content data of the input. For example the entire contents of a file are read and fed into the hash calculator . If the content data changes between executions of the build process the changes are reflected in different hash codes.

A variety of different hash algorithms may be used by the hash calculator . In some embodiments the SHA 1 hashing algorithm is used. Other embodiments may use the MD5 hashing algorithm.

The identification code of each input may correspond with the hash code or the hash code in combination with other data. For example the hash code may be combined with file path data to form an identifier for each file input. Other types of data may be combined with the hash code.

The hash calculator may also be used to generate a hash code to serve as an identifier for each build process . The optimizer may use such identifiers to more efficiently determine whether a particular one of the build processes has been previously executed and thus has had input data recorded and output data stored to support a comparison as described below.

Alternatively or additionally the optimizer may rely on a file system tool to determine an identifier for the captured inputs. In some cases the file system tool is provided as a component of the file system and or operating system of the environment . The file system tool is configured to generate a versioning string that uniquely identifies each version of a file stored within the file system. The optimizer may access the file system to determine an identifier based on the versioning string and then use the identifier in a comparison with the identifiers of previous executions. In some cases the file system tool may be or include a journaling feature of the file system or operating system such as the journaling tool of the NTFS file system of the Microsoft Windows operating systems. Such journaling tools provide a unique sequence number USN for each file. In some embodiments the file system may provide the USN as well as a hash or other identifier of each file.

The USN or other identifier generated by the file system tool may be used in combination with the hash calculator . For example the optimizer may check to see if the USN value of an input has changed and only calculate a hash code if the USN does not match one of the previous USN values. A database or other table may be accessed that maps the USN values to the hash codes examples of which are described below.

In some embodiments identifiers are determined for each captured input. Alternatively identifiers are determined for each file input while non file input data may be represented by other data such as the non file input data itself or other metadata representative of the non file input data.

The determination of the identifiers may include a conversion or preprocessing of the input data before for instance calculation of the hash code. In the embodiment of the optimizer includes a converter to determine a machine agnostic or machine independent representation of one or more of the inputs. The machine independent representation may then be processed by the hash calculator or other code determination module unit or instructions. In a non file input example in which the input data is representative of an environment variable such as a path name the converter is configured as or includes a path converter to remove the portion of the path specific to the computer or machine of the environment thereby leaving those portions of the path name that are generic to each installation of the build system . The converter may be configured as or include other types of converters or other normalization units directed to generalizing genericizing or otherwise normalizing other environment variables or build configuration parameters. Such normalization may also be used to remove non deterministic aspects of the output data including randomization as described below. The data conversion may thus vary from the path based example described above. Other example conversions may involve the removal of user names machine names build versions e.g. if the build version is automatically incremented and temporary file names which may be replaced with machine invocation agnostic tokens .

The machine independent representations may be useful in supporting development teams in which multiple users and thus multiple computers are initiating builds of the software product. Without the conversion of the input data to a machine independent representation the comparison of the input data of the current and previous executions of the build process would indicate that the input data is different. The build process would then be executed despite that the non substantive difference in the input data. Instead with the conversion of the input data the builds may thus be optimized via the disclosed embodiments regardless of which developer or computer or machine or instance of the build system or the environment initiates the build. The machine independent representation data and other data recorded and stored by the optimizer may be provided to a networked data store accessible by and in communication with the entire development team.

In the embodiment of the optimizer includes a control unit or controller to implement the comparison and subsequent decision logic to determine whether the build process is re run in connection with a subsequent request to execute the build process. The redirection tool may include a function call or other reference to the controller to direct the controller to process the input data captured during the execution of the build process . Alternatively or additionally the comparison and or the decision logic of the controller is incorporated into or handled by the code of the redirection tool . Either way the comparison and the decision logic are implemented in connection with the request for the execution of the build process . The request may be user initiated or automatically initiated e.g. via a call or other reference to any build process involved within the build such as within another build process .

The controller may also be configured to obtain the input data for the build process without relying on the redirection tool once the inputs for the build process are known. Given the identifier of the build process the controller may determine the inputs to be used for the comparison based on the data previously recorded for the build process . In other embodiments any other unit module or instructions of the optimizer may be used to determine and obtain the inputs for the build process when known.

The controller compares the identification code identifier or other data representative of the inputs captured via the redirection tool e.g. the current input identifier data with the data representative of the inputs obtained in connection with one or more previous executions of the build process e.g. the past input identifier data . If the current input identifier data does not match any instance of the past input identifier data the build process is executed. The resulting output data generated by the build process based on the current set of inputs is archived cached or otherwise stored for possible re use in a future execution of the build process. Such storage may be in addition to storage in the build repository as an output of the build process . The controller also directs a recorder to record the current input identifier data in a data store . The current input identifier data may be stored in association with the hash code or other identifier of the build process . The identifier of the build process may be used as an index to the past input identifier data.

The output data may also be stored by the controller and or the recorder in the data store . For example the output data may be stored in a table in association with the current input identifier data. Alternatively the output data is archived in a data store separate from the data store such as the build repository . The output data may include data other than binaries or binary files. For example the build processes may generate return codes output streams and other types of output data. Such non file outputs may be stored in the database of the data store within the identity record of the current execution of the build process as metadata of the current execution.

If the current input identifier data matches an instance of the past input identifier data the output data generated by the previous execution of the build process i.e. in response to the matching past input identifier data is used as an output of the build process and the build in lieu of re running or re executing or otherwise proceeding with the execution of the build process. In the embodiment of the controller may access the data store or other data store in which the past output data is archived or otherwise stored to obtain the past output data. The past output data may then be copied by the controller to the appropriate location in the build repository e.g. the location into which the build process would otherwise have stored the output data during execution .

The data store may be a local data store of the environment for a particular instance of the build system . For example the data store may include a database configured for access by the build system but other configurations data structures and arrangements may be used. For example non database stores may be used including for instance local storage next to the source code and or non database systems such as the Windows Azure Tables storage system. The identifiers e.g. hash codes of the build process and its inputs may be stored as metadata in the database. Such metadata may thus be stored separately from the output data e.g. binaries and return codes . In other embodiments the metadata and the output data are stored in a common data store. The recorder or other component of the optimizer may include or utilize the Microsoft SQL Server database management system from Microsoft Corporation but other database management systems may be used. For example the SQL Azure database management system from Microsoft Corporation may be used but other database management systems or data store architectures may be used. Hosted services other than the Windows Azure hosted service may alternatively be used.

To support comparisons with the past input identifier data of multiple developers or multiple build machines the database of the data store may be replicated to a cloud data store or other networked data store via an internet or other network connection . The replication may be directed or implemented by the recorder or other component of the optimizer . Alternatively the data store may be configured for automated replication. The cloud data store may use the Windows Azure hosted service but other services may be used.

To support the capture and comparison of input data for multiple levels of build processes the redirection tool or other redirection tool instructions are injected into each child process called by the build process during execution of the build process . The modules units or other instructions of the optimizer may thus be recursively implemented to cover a tree or dependency graph group of build processes . The redirection tool instructions may be added to the root or top level node of the tree e.g. during an initial pre build configuration and be operative for replication in each child process invoked therein.

The recorder may be configured to aggregate the input identifier data for each tree of build processes so that the comparison may be a collective comparison. The inputs for which identifier data is compared may thus correspond with the union of all external inputs of the individual build processes invoked in the tree. The aggregation of the input identifier data may include the exclusion of any intermediate or non external inputs. For example an output of one of the build processes in the tree may constitute an input to another one of the build processes . Such shared input output data may be excluded from the aggregation. In cases where one of the external inputs is modified during the execution of the tree the recorder may be configured to capture the initial state of such inputs and disregard the modified state. In these and other cases the recorder may capture data indicative of the order or rough order in which the build processes of the tree are executed.

In some embodiments the build system is configured such that the above described optimization is implemented for only some of the build processes . Only a subset of the root or top level nodes of a tree of build processes may be suitable for optimization. For example because a root of one tree may correspond with just a node or portion of another larger tree an intermediate or partial optimization may involve the smaller tree rather than the entire larger tree. Other partial optimizations may target the build processes deemed to be sufficiently costly e.g. in execution time to warrant the application of the optimization technique. For example certain types of compilation and linking processes may be sufficiently time intensive to warrant the above described archiving and subsequent comparisons. On the other hand a developer may elect not to optimize other build processes having a relatively quick execution time. For example some build processes that mainly involve a file copy operation may be more quickly executed than the optimization routine which may also involve a file copy . These build processes may be excluded from processing for possible optimization by a configuration list . For example the configuration list may set forth the excluded processes in an extensive markup language XML document. Other data structures or files may be used. The configuration list may alternatively or additionally identify build processes to be included. The entries in the configuration list may be based on historical or empirical data collected in previous builds.

The configuration list may be accessed by the optimizer during operation. For example the optimizer may consult the configuration list to determine whether to check the data store or the data store to see whether data has been stored for the current build process . As a result a child process within a tree may be excluded from the processing. Alternatively or additionally the redirection tool or other redirection or optimizer instructions may be configured to consult the configuration list prior to injecting the redirection instructions into a child process.

The configuration list may also be used to exclude non deterministic processes. For example processes that introduce randomization into the build output data may be excluded. The configuration list may rely on or incorporate expert knowledge or other information regarding how the randomization introduced by one build process may lead to further randomization of outputs from other build processes. In an alternative embodiment the disclosed embodiments may include one or more normalization tools to remove such randomization in an input conversion and or via a normalization of the output. Other types of build processes may also be excluded including for instance those utilizing input output pipes and others not well suited for the above referenced redirection techniques.

The method may begin with one or more acts related to receipt of a request to initiate a build of a software product or to execute a build process. For example a user may access a user interface generated by the build system to submit the request. Alternatively the method may be initiated or triggered automatically by an event such as a check in of one or more source code files. The method need not be initiated by a user request. For example the method may be initiated by a service or other computing system. In some embodiments a number of the acts described below may be implemented before the initiation of the build. For example an invocation of a CreateProcess process may be redirected to implement one or more acts of the method including for instance the acts described below in connection injection of redirection routine code exclusion analysis and identification of the build process es .

In the embodiment of the method begins with an act in which redirection routine code or instructions are injected or otherwise incorporated into a build process. The build process may be a root or top level node of a tree of build processes. In other cases the root build process is already configured with the redirection routine code. Once the redirection instructions are present in the root node the implementation of the method may be repeated for any number of build process trees.

In an act a determination is made as to whether the current build process is excluded from the memorization or optimization. The determination may be made based on configuration data such as the data provided via the configuration list . The act may not be implemented in some cases e.g. the root node of the tree. Even if the current process is excluded one or more child processes invoked by the current build process may not be excluded. So the exclusion of the current process may involve continuing the implementation of the method so that the recursion functionality described below in connection with the act is implemented to process e.g. inject redirection code implement comparison etc. any child processes.

If the current build process is not excluded or is otherwise subject to optimization an identifier for the build process may be determined in an act . The identifier may be a hash or other identification code generated in an act based on the content e.g. binary data of the build process. The act may be implemented before initiation of the build. The hash or other identifier may be used as a preliminary check to determine whether the current build process has been executed yet and thus whether any past build output data may be available for re use.

In some cases the act may alternatively or additionally implement another preliminary check to determine whether any past build output data may be available. In the embodiment of the act includes accessing or identifying a branch or other set of source code files to be processed by the build process. The branch of a software product may be specified via a command line or other input argument or configuration parameter of the build. The identification of the branch may be used to determine whether any of the build processes have been executed yet. The preliminary check may be used in some embodiments to avoid implementation of the hash algorithm for one or more build processes. For example once the preliminary check indicates that the branch has yet to be processed the method may proceed to a recording mode for all build processes invoked in the build. In an alternative embodiment the act may be configured to consider two or more branches collectively if for instance the different branches contain similar code. The disclosed embodiments may thus be applied across multiple branches in some cases.

For known e.g. previously executed build processes the inputs for the data accessing operations of the build process may be determined and obtained in an act . During a first execution of the build process the inputs may not yet be known due to for instance a number of data accessing operations implemented in child processes invoked by the current build process or because the current build process was recently started.

The identifier of the current build process may then be compared in a decision block with the data stored in a database or other recorded data such as the data store to determine whether any data is available from one or more past executions of the build process. If the build process is being executed for the first time then data will have yet to be recorded. Alternatively or additionally the decision block may determine whether any data has been recorded for the branch or other set of source code being processed.

If data has yet to be recorded for either the build process then control passes to an act in which the current build process is executed and the output is stored for possible subsequent use. The output data may be stored locally in e.g. a data store such as the data store and or a remote data store such as the cloud data store . During the execution of the build process the inputs for the build process are captured via a redirection routine as described above. The nature of the data accessing operations to obtain the inputs may vary as described above. The inputs for both file and non file accessing operations are captured. The data indicative of each captured input may then be processed as described above to generate an identifier to be used in subsequent comparisons. For example in some cases a hash or other identification code is calculated or determined as described above. Such calculations may be preceded by a conversion in an act to generate a machine independent representation of the input data as described above.

As child processes are invoked during execution of the build process the method may be recursively implemented in accordance with an act . For each child process invoked or otherwise called during execution of the build process redirection instructions are injected or incorporated into the child process in connection with the act . The redirection instructions include instructions for such automated incorporation. The redirection instructions may thus support the processing of an entire dependency graph or tree of build processes based on the addition of code to only the root or top level node of the tree. As the method is implemented for each level of the tree the input identifiers for the input data are aggregated in an act for each child process and the build process. The input identifiers for the build process may thus be representative of a collective set of inputs for the build process and any child processes invoked thereby. In other cases one or more child processes are not deterministic or otherwise excluded in which case the collective set of inputs does not cover every one of the child processes.

If data has been recorded for the build process and the particular branch of source code then control passes to an act in which identifier data is collected for the inputs of the build process. The input collection may include data capture via the redirection tool as described above. Alternatively the inputs may be obtained by determining which inputs are used by the build process. In some cases the determination has already been made in connection with the act . The determination may include a database query to identify the inputs for the build process. Once the input data is collected or otherwise obtained conversions to machine independent representations of the input data may be implemented in an act and hash codes or other identifiers determined in an act . In some cases a conversion from specific e.g. local representations to machine independent representations may be implemented for the current execution of the build process. Another conversion in the opposite direction e.g. from a generic path to a specific local path may be implemented on the past input data to support for example finding the input files for the current execution.

A database such as the data store is then accessed in an act to support the comparison of the identifiers with those of previous executions of the build process. Alternatively or additionally the act includes obtaining data from a remote or networked data store such as the cloud data store . Such data may include the output data generated from additional executions of the build process initiated by for instance other users or build machines. The data from the networked data store may be synchronized pre populated e.g. before initiation of the build or otherwise incorporated into the data store for use in the comparison. In some cases such synchronization or incorporation may be implemented earlier including for instance before the initiation of the build or as an initial step of the method . The database may be queried to determine whether a record or entry exists that matches the identifiers. If a match is not found then a decision block passes control to the act for execution of the build process and recordation of the input identifiers as described above. The input identifiers including e.g. hash codes may already be determined in connection with the act . If a match is found control passes to an act in which the output data generated by the previous execution of the build process is used as the output of the current execution of the build process. Because the inputs for the previous execution match those of the current execution the previous outputs may be used in lieu of re running or re executing or otherwise proceeding with the execution of the build process. The previous outputs may match the outputs that would have been generated if the build process were allowed to execute. In some embodiments a process may be provided to generate an exit code for the current execution of the build process. The exit code may mimic the exit code of the matched previous execution of the build process and may satisfy an expectation from a parent process that called the current process.

The method may include one or more acts directed to recording an indication of those files that were not found despite an attempt to access such files. For example if the attempt to access the recorded identifier data in the act fails the record subsequently created by virtue of the execution of the build process in the act may include an indication that certain files were not found or accessible.

The order of the acts of the method may vary from the example shown. For example in some embodiments a hash algorithm is implemented for the build processes source code files or other inputs before initiating the execution of the build. Such pre calculation of the hash codes may improve the performance of the optimizer. In some embodiments the pre calculation may be implemented as part of a synchronization procedure in which for example source code binaries or other inputs are retrieved from a local repository. The synchronization procedure may alternatively or additionally include the retrieval of data from a networked data store such as the cloud data store to update or provide data stored locally.

With reference to an exemplary computing environment may be used to implement one or more aspects or elements of the above described methods and or systems. The computing environment may be used by incorporated into or correspond with the environment or one or more elements thereof. For example the computing environment may be used to implement the build system the build engine the optimizer or other component of the build system . The computing environment may be used or included as a client network server application server or database management system or other data store manager of any of the aforementioned elements or system components. The computing environment may be used to implement one or more of the acts described in connection with .

The computing environment includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus. The units components and other hardware of computer may vary from the example shown.

Computer typically includes a variety of computer readable storage media configured to store instructions and other data. Such computer readable storage media may be any available media that may be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. Such computer readable storage media may include computer storage media as distinguished from communication media. Computer storage media may include both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which may be used to store the desired information and which may accessed by computer .

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data . For example one or more of the application programs may be directed to implementing one or more modules or other components of the build system the build engine the optimizer and or any instruction sets of the systems and methods described above. In this or another example any one or more the instruction sets in the above described memories or data storage devices may be stored as program data .

Any one or more of the operating system the application programs the other program modules and the program data may be stored on and implemented via a system on a chip SOC . Any of the above described modules may be implemented via one or more SOC devices. The extent to which the above described modules are integrated in a SOC or other device may vary.

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that may be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . For example hard disk drive is illustrated as storing operating system application programs other program modules and program data . These components may either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. In some cases a user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone e.g. for voice control touchscreen e.g. for touch based gestures and other movements ranger sensor or other camera e.g. for gestures and other movements joystick game pad satellite dish and scanner. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . In some cases a monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as printer and speakers which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. illustrates remote application programs as residing on memory device . The network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

The computing environment of is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the technology herein. Neither should the computing environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment .

The technology described herein is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the technology herein include but are not limited to personal computers server computers including server client architectures hand held or laptop devices mobile phones or devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The technology herein may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. The technology herein may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

While the present invention has been described with reference to specific examples which are intended to be illustrative only and not to be limiting of the invention it will be apparent to those of ordinary skill in the art that changes additions and or deletions may be made to the disclosed embodiments without departing from the spirit and scope of the invention.

The foregoing description is given for clearness of understanding only and no unnecessary limitations should be understood therefrom as modifications within the scope of the invention may be apparent to those having ordinary skill in the art.

