---

title: Analytics for application programming interfaces
abstract: API analytics systems and methods are provided. Frequently occurring API usage patterns may be determined from API call data collected from across an API ecosystem. Alternatively or in addition, a classification structure, such as a decision tree, may be generated from the API usage patterns. A type of activity that resulted in a set of API calls being invoked may be determined from the classification structure. A similarity or difference between the set of API calls and the frequently occurring API usage patterns may also be determined and/or identified.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09146787&OS=09146787&RS=09146787
owner: Accenture Global Services Limited
number: 09146787
owner_city: Dublin
owner_country: IE
publication_date: 20131107
---
This application relates to Application Programming Interfaces and in particular to analytics for Application Programming Interfaces.

Cloud based services web services and other types of services publish Application Programming Interfaces APIs through which software may access the services. For some services such as SOAP Simple Object Access Protocol and REST Representational State Transfer based services an API may be in the form of a specification of calls exposed to consumers or users of the API. For example a web API may be a programmatic interface to a request response message system in which the requests may be expressed in a text format such as JSON JavaScript Object Notation or XML eXtensible Markup Language and which the programmatic interface is exposed via a network such as the Internet. Alternatively an API may be in the form of a library that includes specifications for routines data structures object classes and or variables.

A method may be provided that determines an activity type of an activity that resulted in an API Application Programming Interface workflow pattern. A first API call data may be retrieved that identifies sets of API calls detected during performance of use cases. Each one of the sets of API calls resulted from a performance of a respective one of the use cases. A truncated API call data may be generated from the first API call data by consolidating duplicated API calls in each of the sets of API calls. An API usage pattern may be detected in the truncated API call data. The API usage pattern may identify a series of truncated API calls that is repeated within and or across at least one of the sets of API calls. A second API call data may be retrieved that identifies a set of API calls that are invoked during an unknown activity. Based on the second API call data and the API usage pattern a type of activity that resulted in the set of API calls identified in the second API call data may be determined.

An application programming interface API analytics system may be provided. The system may include a memory and a usage identification module. The memory may include API call data that identifies a set of API calls invoked in response to an unknown activity and predetermined API usage patterns that each identifies a series of API calls performed as a result of a corresponding use case. The usage identification module may form truncated API call data in which duplicated API calls in the set of API calls are consolidated in the truncated set of API calls. The usage identification module may determine a type of the unknown activity based on the truncated API call data and on a classification structure determined from the predetermined API usage patterns.

A computer readable storage medium may also be provided for application programming interface API analytics. The computer readable storage medium may comprise computer executable instructions executable by a processor. The instructions may be executable to retrieve API call data that identifies sets of API calls invoked as a result of performance of a use case. API requests that invoked API calls in each one of the sets of API calls may share a corresponding common context. The instructions may be executable to generate a first truncated API call data from the API call data where duplicated API calls in each of the sets of API calls are consolidated in the first truncated API call data. The instructions may be executable to identify API usage patterns in the first truncated API call data that occur above a threshold frequency. The instructions may be executable to identify a similarity between the identified API usage patterns and a second truncated API call data that identifies API calls invoked during an unknown activity.

By way of introduction an application programming interface API analytics system may be provided. The system may include a memory and a usage identification module. The memory may include API call data that identifies a set of API calls invoked in response to an unknown activity and predetermined API usage patterns. For example each API call in the set of API calls may be a respective programmatic procedure included in an API. Each predetermined API usage pattern may identify a series of API calls performed or invoked as a result of a corresponding use case. The use case may be for example browsing a products catalog API or any other type of activity.

The usage identification module may form truncated API call data in which duplicated API calls in the set of API calls are consolidated in the truncated set of API calls. The usage identification module may determine a type of the unknown activity based on the truncated API call data and the predetermined API usage patterns.

In a first example the system may include a pattern classification module that generates a classification structure such as a decision tree from the predetermined API usage patterns. The usage identification module may determine the type of the unknown activity through an application of the truncated API call data to the classification structure. In a second example the usage identification module may determine that one of the predetermined API usage patterns matches the truncated API call data. The usage identification module may identify any difference and or similarity between one or more of the predetermined API usage patterns. In some examples the usage identification module may determine the type of the unknown activity to be a type of activity characterized by the corresponding use case of the predetermined API usage pattern that matches the truncated API call data.

One technical advantage of the systems and methods described below is that API monitoring and pattern detection in API usage may occur in real time. Another technical advantage of the systems and methods described below is that API calls are analyzed across transactions or sessions. Yet another technical advantage of the system and methods described below is scalability despite the presence of a significant amount of API traffic. Still another technical advantage may be an ability to classify activity types based on a similarity to predetermined API usage patterns as opposed to exact matches to predetermined API usage patterns.

The API ecosystem may be any system comprising one or more components that implement expose manage and or consume one or more APIs. For example the API ecosystem may comprise a backend service an API management gateway an external service and one or more applications such as a mobile app or a web application .

Each of the applications may be any component that consumes or calls one or more APIs. The mobile app may be an application that executes on a mobile device such as a smart phone a cell phone a tablet computer a personal digital assistant or a customized device. The web application may be any application that executes in a web browser or in a web application server.

The API management gateway may be any component that exposes an API such as a service API . For example the API management gateway may be a component that receives API requests from the applications and directs the API requests to an endpoint such as the backend service . The API gateway may manage API traffic by load balancing rate limiting authentication or performing any other management activity. Examples of the API management gateway may include a gateway from APIGEE a registered trademark of Apigee Corporation of Palo Alto Calif. a gateway from LAYER 7 a registered trademark of CA Inc. of Islandia N.Y. a gateway from WSO2 a registered trademark of WSO2 Inc. of Palo Alto Calif. a web server an application server a proxy server a CORBA server and or an HTTP Server.

The service API may be any API. The service API may provide access to data and or functionality. The backend service may be any component that implements the service API exposed by the API management gateway . The backend service may be any type of service that implements functionality accessible via the service API .

The external service may be any service that is external to an organization and that is managed by a third party. The external service may expose and or implement an API such as an external API . Examples of the external service may include a payment service a mapping service an authentication service or any other type of service.

Any API such as the service API or the external API may be in the form of a specification of one or more programmatic procedures exposed to consumers or users of the API or . Each of the programmatic procedures has a name. Any programmatic procedure may have zero one or more parameters. The programmatic procedure may return a data result in some examples. In other examples the programmatic procedure may not return a data result. The programmatic procedure may return a status code result as part of an Internet protocol in some example where the status code indicates that the API request was received and indicates whether or not the API request was processed correctly. A web API may be a programmatic interface to a request response message system in which a request may be expressed in a text format such as JSON JavaScript Object Notation or XML eXtensible Markup Language and which the programmatic interface is exposed via a network such as the Internet. The web API may be accessible via SOAP Simple Object Access Protocol and REST Representational State Transfer . In some examples an API may be in the form of a library that includes specifications for routines data structures object classes and or variables.

The API analytics module may be a component that analyzes API usage in the API ecosystem . The API analytics module may include an API monitor a pattern recognition module a pattern classification module and a usage identification module .

The API monitor may be any component that monitors API usage in the API ecosystem and collects API call data . The API call data may inter alia identify programmatic procedures parameters passed to programmatic procedures and an order in which the programmatic procedures were called. In some examples the API call data may identify a series of programmatic procedures in the API that were invoked at an interface over time. For example the API call data may identify API Name API Name and API Name indicating that API Name was invoked at the interface first then API Name was invoked at the interface and finally API Name was invoked at the interface.

The pattern recognition module may be a component that identifies API usage patterns in the API call data monitored by the API monitor during an initialization phase. The API usage patterns may identify a structure of API calls that generalizes a behavior of a series of API calls that are performed as a result of users or scripts completing a use case and or a set of functionalities. For example the API usage patterns may include a pattern of API calls that are invoked when a user searches or browses through products on an online store. The pattern of API calls may specify a call structure for example in which a first programmatic procedure may be called any number of times followed by a second programmatic procedure. In other words if two monitored API calls sets in the API call data only vary based on a number of times the first programmatic procedure was called then the two monitored API call sets may map to the same API usage pattern . The API usage patterns may also be referred to as API workflow patterns. The API usage patterns may include frequent API usage patterns detected using a frequent subgraph mining algorithm.

The pattern classification module may be a component that generates a classification structure such as a classification decision tree based on the API usage patterns generated by the pattern recognition module . The classification structure may be any data structure such as a classification decision tree from which a classification may be determined. As described in detail below the decision tree may be pre populated by performing predetermined use cases for the pattern recognition module to generate the API usage patterns from the API call data where the API usage patterns are fed to the pattern classification module during the initialization phase. Accordingly the pattern classification module may be a component that generates the classification structure based on the API call data .

The usage identification module may be a component that analyzes the API call data gathered by the API monitor during an activity identification phase. As described in detail below the usage identification module may truncate the API call data to determine a structure of API calls that are identified in the API call data and determine a type of activity that resulted in the API call data based on the classification structure generated by the pattern classification module . Alternatively or in addition the usage identification module may determine a similarity between the API call data gathered during the activity identification phase and the API usage patterns determined during the initialization phase.

The applications may be in communication with the API management gateway the backend service and or the external service over a network . The API analytics module may also be in communication with the API management gateway the backend service and or the external service over the network . The network may include a local area network LAN a wireless local area network WLAN a WI FI a registered trademark of Wireless Ethernet Compatibility Alliance Inc. of Austin Tex. network a personal area network PAN a wide area network WAN the Internet an Internet Protocol IP network any other communications network or any combination thereof.

Alternatively or in addition the applications and or the API analytics module may be in communication with the API management gateway the backend service and or the external service via an inter process protocol such as named pipes. Alternatively or in addition one or more of the applications may execute in a same process as the API management gateway and or the backend service .

During operation of the system the API usage in the API ecosystem may be monitored and analyzed. For example operations such as those illustrated in may be performed. The operations may be executed in a different order than illustrated in . The operations performed may include additional different or fewer operations.

Operations may be performed during an initialization phase and during an activity identification phase . The initialization phase may be a timeframe in which the API usage patterns and or the classification structure are generated from the API call data while the activities of the applications are controlled and or known. In contrast the activity identification phase may be a timeframe in which an activity of one or more of the applications may be uncontrolled or initially unknown. During the activity identification phase the type of activity or activities being performed by the application or applications may be determined based on the API usage patterns and or the classification structure . The phases and may be repeated any number of times. In some examples operation of the system may take place during phases other than the initialization phase and the activity identification phase .

During the initialization phase the API usage in the API ecosystem may be monitored while the activities of the applications are controlled and or known. The applications may have been instrumented to transmit information regarding API usage to the API monitor . For example application developers may have been provided with a software development kit SDK when the applications were developed. Components of the SDK built into the applications may transmit statistics such as delay errors logs API request context or any other information related to API calls to the API monitor during the initialization phase and or the activity identification phase . The API calls may be to the service API the external API and or any other API.

The API management gateway may have direct access to the API requests received from the applications and to responses received from the backend service . Accordingly the API management gateway may provide information regarding usage of the service API to the API monitor . In particular the API management gateway may transmit the service API usage information to the API monitor . Alternatively or in addition the API management gateway may log the service API usage information and another component may read the log and transmit the information to the API monitor . Alternatively the API monitor may read the log directly. In some examples the API management gateway may provide an API usage service through which the API monitor may obtain information regarding usage of the service API . One example of such a service is APIGEE a registered trademark of Apigee Corporation of Palo Alto Calif.

The backend service which may implement the service API may directly impact API performance. A monitoring tool such as system monitoring tool may provide information related to the performance of the backend service to the API monitor . The information related to the performance of the backend service may be related to the performance of the service API . The performance of the service API may depend on network latency such as latency between the application and the API management gateway or between the API management gateway and the backend service performance of the API management gateway as well as performance of the backend services . If there is a delay in an API response it may be desirable to pinpoint to a performance bottleneck. By monitoring the backend service with the monitoring tool a bottleneck caused by the backend service may be identified and eliminated in some cases. In particular resource usage such as CPU usage memory usage storage usage and I O bandwidth usage of a server running the backend service may be continuously monitored by the monitoring tool . If the CPU usage of the server is over a threshold value such as 95 then the server may be overloaded and may therefore impact performance of the service API . Such resource usage information may be obtained using system monitoring tools such as iostat. Therefore with the backend service performance monitoring a determination may be made whether a performance issue of the service API is caused by the backend service . Accordingly appropriate action may be taken to remedy the performance issue. For example backend resources may be scaled up.

The external service may transmit information regarding usage of the external API to the API monitor . Arrangements may be made with a provider of the external service to provide such information. Alternatively or in addition the information regarding the usage of the external API may be gathered by the API monitor from a directory service of online APIs such as PROGRAMMABLEWEB a registered trademark of John Musser of Seattle Wash. or MASHAPE a registered trademark of Mashape Inc. of San Francisco Calif. Alternatively or in addition an API platform that acts as an intermediary between the applications and the services and may provide the information regarding the applications usage of the external API to the API monitor . APIGEE provides one such API platform. The applications may be developed with an SDK provided by APIGEE that wraps calls to the external service . A mobile analytics features available in the APIGEE platform may provide the information regarding the applications usage of the external API to the API monitor .

As described above the API monitor may collect the API usage information from the ecosystem . The API monitor may extract the API call data from the API usage information if necessary and store the API call data in the memory . In some examples the API monitor may include an end to end API correlation module that correlates API calls to each other. For example the end to end API correlation module may correlate the API calls originating from the same conversation between one of the applications and the backend service . Alternatively or in addition the end to end API correlation module may correlate the API calls made within a transaction and or the API calls made within a request response message. Each of the API requests may include a context such as an API key a session identifier a user identifier a transaction identifier and or any other object that provides context for the API request or otherwise identifies the API request. The end to end API correlation module may correlate two or more of the API requests based on the context being shared by the API requests . In one example the identifier may be assigned by one of the components in the API ecosystem such as the application the API management gateway or the backend service and then propagated by other components in the API call chain.

The API usage information transmitted to the API monitor may be transmitted at a selected frequency. The frequency may be selected so that gathering the API usage information is light weight and does not impart significant overhead on the performance of the applications the API management gateway or any other component of the API ecosystem . A determination of what metrics to collect in the API usage information and or the API call data may also be determined. The frequency at which the API usage information is collected may determine how much overhead is imposed on the API analytics system . If sampled at a high frequency a substantial amount of data for analytics may be collected. However sampling at the high frequency may cause non negligible overhead. On the other hand collecting data at a low frequency may lead to inaccurate analysis due to lack of data. For example a change in the monitoring data may be missed that could be an important indicator for API performance. The sampling frequency may be determined through experiments and may be a parameter which can be adjusted. In the experiments various values of the sampling frequency may be selected. For each selected frequency the time to collect all the monitoring data as well as the change in the data between rounds may be recorded. API related data such as the response time transition time may be recorded for every API call. Backend service resource usage data may be collected every 5 seconds or some other interval. In some examples all of the monitoring metrics that are available may be collected.

While the API monitor collects the API usage information from the ecosystem predetermined use cases may be performed . For example the application may be scripted or manually controlled to perform one or more use cases. Each use case may include any activity relevant to the application . Examples use cases may include browsing an product catalogue submitting a purchase order scanning a data service with a script and generating an online report.

Each of the use cases may be associated with the context such as the user identifier and the transaction identifier and a message identifier that identifies a corresponding sequence of API calls in the API call data . The inclusion of the context and or other identifier in the API requests provides a mechanism by which the API analytics system may associate the use cases to activities that resulted in the sets of API calls . Given that performance of multiple use cases from various applications and users may result in the API requests passing through the API management gateway the context may identify at the API management gateway the API calls that occur as part of a specific use case such as the API calls made from a particular user from a particular application and or within a particular transaction. Such identifiers may be appended as part of a design of the API calls. For example an identifier received from the backend service may be included in the context that is carried through all API calls that are associated with a particular transaction. Alternatively or in addition a user identifier may be included in the context for the API requests made on behalf of a user identified by the user identifier. Alternatively or in addition an identifier may be collected from the API management gateway such as an API key that is used to authenticate the API requests and which may identify the applications and or app developers. Alternatively or in addition when one of the API requests is submitted to the API management gateway the API request may be assigned a unique identifier. Similarly the application which made the API request as well as the user who is using the application may be assigned corresponding unique identifiers. Therefore the API requested may be identified using the key the application identifier and or the user identifier.

After the use cases are performed and the API usage is monitored then the API call data may identify multiple sets of API calls that were detected during performance of the use cases. illustrates an example of the API call data . Each respective one of the sets of API calls may be formed by grouping API calls that resulted from the API requests according to the context of the API requests or according to another identifier associated with a use case. Accordingly each one of the sets of API calls may have resulted from performance of a respective use case and be associated with the respective use case in the memory . In some cases more than one of the multiple sets of the API calls may be associated in the memory with a single one of the use cases . Each one of the sets of API calls may identify a series of API calls that were invoked in the order that the API calls are listed in the series. Accordingly for each respective one of the sets of API calls the context of the API requests that invoked each of the API calls identified in the series of API calls may be common to the API calls in the respective one of the sets of API calls .

Referring back to the API usage patterns may be identified from the API call data . In particular the API usage patterns may be patterns frequently found in and or across the sets of API calls. Patterns may be considered frequent if the patterns occur above a threshold number such as above a percentage or ratio. For example a number p may represent the threshold number as a percentage. If the threshold number p is 0.5 for example then a pattern should appear in at least 50 percent of the sets of API calls in order to be considered frequent. The threshold number p may be a tunable parameter.

To identify the API usage patterns the pattern recognition module may reduce or consolidate sequentially repeated API calls in each of the sets of API calls to form truncated API call data. In the truncated API call data comparisons of the sets of API calls may result in a match if the only difference between the sets is in how many times one or more of the API calls is sequentially called. By way of example consider the series of API calls A B B B C in which programmatic procedure A is called then programmatic procedure B is repeatedly called three times and finally programmatic procedure C is called. The series of API calls A B B B C may match the series of API calls A B B B B B B B B B B B B B C in the truncated API call data because the only difference between the sets is in how many times programmatic procedure B is sequentially called. A repetition threshold r may indicate the number of times that the API call must be repeated before it is reduced. In one example where the repetition threshold r equals three the series of API calls A B B C will not be truncated and will be considered different from the series of API calls A B B B C . Generating the truncated API call data may result in performance improvements when finding the API usage patterns .

The API usage patterns that are frequent may be identified from the API call data by the pattern recognition module using a Deterministic Finite Automation DFA graph. In one example each set of API calls may first be represented as a string S where each element of the string identifies a corresponding API call in the series of API calls such as the string A B B B C having elements A B B B and C . Any delimiter such as a comma or a space character may separate each element of the string S.

Each string Smay be encoded by reducing sequentially repeated elements. For example a sequence of k calls to A may be encoded as A k if k is less than r the repetition threshold or A  otherwise. Consider an example where the repetition threshold r is four. The string A A A A A for example may be encoded as A  and the string A A A may be encoded as A  . The resulting encoded stings may represent the truncated call data.

The pattern recognition module may create a directed DFA graph to represent each encoded string S. The DFA may be created such that a node in the DFA is created for each element of the encoded string and a directed edge connects the nodes corresponding to elements adjacent to each other in the encoded string. The direction of the edge indicates an order of the corresponding elements in the encoded string. For example the DFA for the string . . . API API . . . may include among others a node APIand a node API which are connected by an edge directed from APIto API. As another example the DFA for the string API API   API may be API API  API The DFA need not be created for encoded string S if a DFA was already created for a matching encoded string S. In other words multiple encoded strings may share the same DFA.

Having created the directed graphs DFAs to represent the encoded strings the pattern recognition module may use a frequent subgraph mining algorithm to find the API usage patterns . The frequent subgraph mining algorithm may discover subgraphs that occur frequently over the sets of the DFAs that correspond to the sets of API calls . The pseudocode for one such algorithm the FSG algorithm by Michihiro Kuramochi and George Karypis may include 

The set of frequent subgraphs S may be expanded to remove the encoding. For example the single node subgraph A  may be expanded to become the two node subgraph A A . The subgraph A  may be expanded to become subgraph A A A when the repetition threshold is three where node A has a self loop which is an edge that extends from a node back to the node.

The pattern recognition module may determine whether each of the DFAs in the set of expanded frequent subgraphs is a subgraph of another subgraph in the set of expanded frequent subgraphs. If not then the respective DFA in the set of expanded frequent subgraphs may be added to the API usage patterns . Otherwise the respective DFA may not be added to the API usage patterns .

The pattern recognition module may include additional information in the API usage patterns . illustrate two examples of the API usage patterns . illustrates an example API usage pattern that results from a script that accesses a catalogue data service searching for products and details about the products. illustrates an example API usage pattern that results from a person browsing a product catalogue service. In addition to identifying programmatic procedure names in the API or the API usage patterns may for example include procedure information that identifies information regarding the programmatic procedures such as an average execution time and a standard deviation in the execution time of each programmatic procedure. Alternatively or in addition the API usage patterns may include transition information that identifies information regarding transitions between API calls such as between a first programmatic procedure and a second programmatic procedure. Examples of the transition information may include an average time between execution of the first and second programmatic procedures a standard deviation of the average time between execution of the first and second programmatic procedures and a probability or a likelihood that the transition from the first programmatic procedure to the second programmatic procedure will occur instead of a transition from the first programmatic procedure to any other programmatic procedure.

Referring back to the classification structure may be generated from the API usage patterns . The classification structure may be generated by providing the API usage patterns to a machine learning algorithm implementation such as WEKA a registered trademark of WaikatoLink Limited of Hamilton New Zealand.

The classification structure may be a decision tree such as the decision tree illustrated in . The decision tree may be a flow chart like structure in which each internal node may represent a test on an attribute of an element of one or more of the API usage patterns each branch may represent an outcome of a test and each leaf node may represent a decision indicating a type of activity. The type of activity may be considered a classification of the activity. Examples of the classifications or the type of activities may include normal alert scripting IT admin unkown or any other type of activity. In some examples internal nodes may represent events that may have occurred in the API ecosystem . Examples of such events may include an upgrade of an API to a determined version or other change. Such events may be correlated to API performance which may vary depending on whether what events may have occurred in the API ecosystem .

Referring again to the API usage in the API ecosystem may be monitored during the activity identification phase . In contrast to the initialization phase the activity of one or more of the applications may be initially unknown during the activity identification phase . The API call data during the activity identification phase may represent call data that resulted when the unknown activity was performed.

An API usage pattern may be extracted by usage identification module from one or more of the sets of API calls in the API call data during the activity identification phase . Each one of the sets of API calls in the API call data may be the source of a corresponding extracted API usage pattern. As explained in more detail below the API usage patterns extracted during the activity identification phase may include truncated call data but frequent API usage patterns in the API call data need not be determined during the activity identification phase .

To generate the extracted API usage pattern during the activity identification phase the usage identification module may reduce sequentially repeated API calls in each of the sets of API calls to form encoded or truncated API call data. In one example each set of API calls may be represented as a string S where each element of the string identifies a corresponding API call in the series of API calls such as the string A B B B C having elements A B B B and C . Any delimiter such as a comma or a space character may separate each element of the string S. Each string Smay be encoded by reducing sequentially repeated elements. Consider an example where the repetition threshold r is four. The string A A A A A for example may be encoded as A  and the string A A A may be encoded as A  . The resulting encoded stings may represent the truncated call data.

The usage identification module may create a directed DFA graph to represent each encoded string S of the truncated API call data. The DFA may be created such that a node in the DFA is created for each element of the encoded string and a directed edge connects the nodes corresponding to elements adjacent to each other in the encoded string. The direction of the edge indicates an order of the corresponding elements in the encoded string. For example the DFA for the string . . . API API . . . may include among others a node APIand a node API which are connected by an edge directed from APIto API. As another example the DFA for the string API API   API may be API API  API . The DFA need not be created for encoded string S if a DFA was already created for a matching encoded string S. In other words multiple encoded strings may share the same DFA. For example API call sequences API API API API and API API API API API API API may share the same DFA when the repetition threshold r is one or two.

The set of DFAs may be expanded to remove the encoding. For example the single node subgraph A  may be expanded to become the two node subgraph A . The subgraph A  may be expanded to become subgraph A A A when the repetition threshold is three where node A has a self loop. The expanded set of DFAs may represent the truncated call data and the extracted API usage pattern.

In an alternative example the truncated API call data may be generated without encoding and decoding strings in the API call data . Instead the nodes of the DFAs may be created for each of the API calls in the series of API calls unless a sequentially repeated API call is repeated more than the repetition threshold r. The sequentially repeated API call that exceeds the repetition threshold may be represented in the DFA as one node with a self loop edge. Each of the resulting DFAs may represent the truncated call data and the extracted API usage pattern for a corresponding one of the series of API calls in the API call data .

The usage identification module may identify any difference or similarity between the extracted API usage pattern and one or more of the predetermined API usage patterns . The one or more of the predetermined API usage patterns may be selected for comparison with the extracted API usage pattern by matching the extracted API usage pattern with the predetermined API usage patterns . In some examples the usage identification module may determine the type of activity or activities by matching the extracted usage pattern with one of the predetermined API usage patterns .

In order to match the extracted API usage pattern the extracted API usage pattern may be compared with the predetermined API usage patterns . Any suitable matching algorithm may be used. For example the Knuth Morris Pratt algorithm may be applied to find a subset in each of the API usage patterns that is a match with the extracted API usage pattern and a corresponding score. For example the extracted API usage pattern A A A B C may have a match with a predetermined API usage pattern A A A B D C and have a score of 4 5 0.8 because A A A B is included within the predetermined API usage pattern. The predetermined API usage pattern having the highest score of the API usage patterns may be considered the closest match to the extracted API usage pattern.

The predetermined API usage pattern having the highest score of the API usage patterns may be associated with a corresponding one of the use cases . In some examples the activity type of the corresponding use case may be inferred to be the type of activity that resulted in the extracted API usage pattern.

The usage identification module may identify any difference and or similarity between the extracted API usage pattern and the API usage patterns that match the extracted API usage pattern. The differences and or similarities may be communicated to an end user through a graphical user interface.

The type of activity that resulted in the extracted API usage pattern may be determined by classifying the extracted usage pattern with the classification structure . For example the decision tree may predict a label for the extracted usage pattern by applying procedure information and transition information in the extracted usage pattern to the tests indicated by the internal nodes of the decision tree . illustrates an application of attributes of an extracted API usage pattern to the decision tree to obtain a classification of the extracted API usage pattern . One of the attributes of the extracted API usage pattern illustrated in is that a programmatic procedure getltemDetails was sequentially called times in a row. The decision tree indicates that the extracted API usage pattern is a result of machine scripting.

Through the determination of the type of activity the API analytics system may identify behaviors that are deemed harmful. For example the system may distinguish between real people browsing a product catalogue and a script crawling a data service for product pricing information by identifying timing between API calls. The system may distinguish between a person checking product availability and a script checking the product availability by determining whether a product availability check is constantly performed or randomly performed. The system may identify data exposure by detecting that a substantial or threshold number of applications are accessing a particular set of data. By raising an alert to a person such as an API product manager or IT administrator a determination may be made as to whether the data exposure is a result of denial of service attack or whether the particular set of data is merely popular and thus can be monetized.

Through the determination of the type of activity the API analytics system may detect supersets. In one example an API provider such as an online retailer may introduce an API. The API provider may wish to know how application developers respond to the newly introduced API. For example the new API called sendPromotion may be an API that when executed checks whether the contents of a shopping cart qualifies for a promotion before order submission where order submission is accomplished through another API called submitOrder. The API analytics system may aid in determining whether developers adopt the new API and if so a rate at which developers adopt the new API. The API analytics system may monitor how many of the sets of API calls include a call to sendPromotion before submitOrder. Each of the sets of API calls may correspond to a use case. Prior to introducing the sendPromotion API all of the set of API calls include a call to submitOrder without a call to sendPromotion. However after the sendPromotion API is added a percentage of the sets of API calls may include an invocation of sendPromotions before submitOrder. Such groupings of the sets of API calls or use cases may be referred to as supersets. Furthermore the API analytics system may identify which applications and or which user identifiers are associated with the corresponding supersets in order to better understand why some use cases may or may not use the new API. For example the API analytics system may determine whether the use of the new API is related to particular users and or to particular applications that the users use. For example are mobile applications more likely to use the new API or are web applications Alternatively or in addition the API analytics system may determine whether the use of the new API is related to items that the users are purchasing. Furthermore the API analytics system may identify any error experienced when the new API is called. A particular use case API pattern may indicate that an application developer first adopted the new API and then subsequently stop using the new API.

Through the determination of the type of activity the API analytics system may detect abnormal activities. In one example the service API may include a validateAddress procedure a processCreditCard procedure and a selectShipping procedure. The validateAddress procedure should be called before the processCreditCard and or selectShipping procedure. If the order of the procedures was improper or one of a set of mandatory programmatic procedures is missing during the activity identification phase then the system may highlight the difference in the set of API calls when the closest match with the extracted API usage pattern has the proper order. If the classification structure identifies an improper use of the service API as a common mistake then the improper use of the service API may be a result of widespread developer confusion rather than a one off mistake.

Behaviors that are bad and or abnormal may be identified by the system . The system may produce an alert. For example a visual indication may be displayed in a graphical user interface a message may be sent over the network an event may be logged in an event log or any other suitable alert may be produced.

The system may be implemented with additional different or fewer components. For example the system may include just the API analytics module . In another example the system may not include web applications and or the external service . illustrates yet another example of the system that includes server hardware external server hardware and one or more client devices . The server hardware and the external server hardware may include any type of processing device such as a rack mounted server a desktop machine or a laptop. The client device and or devices may include any mobile device or desktop computer.

The server hardware may include a memory and a processor . The processor may be in communication with the memory . In one example the processor may also be in communication with additional elements such as a display and a network interface. The processor may be a general processor a central processing unit a microcontroller an application specific integrated circuit ASIC a digital signal processor a field programmable gate array FPGA a digital circuit an analog circuit or any combination of processors.

The processor may be one or more devices operable to execute logic. The logic may include computer executable instructions or computer code embodied in the memory or in other memory that when executed by the processor cause the processor to perform the features of the components. The computer code may include instructions executable with the processor . The computer code may include embedded logic. The computer code may be written in any computer language now known or later discovered such as C C Java Pascal Visual Basic Pen HyperText Markup Language HTML JavaScript assembly language shell script or any combination thereof. The computer code may include source code and or compiled code.

The memory may include modules such as the backend service the API management gateway and the API analytics module . The memory may include data such as the API call data the classification structure and the API usage patterns .

The external server hardware may include the external service . The client device may include one or more of the applications .

Each component may include additional different or fewer components. For example the API analytics module may include the pattern recognition module the pattern classification module the API monitor and the usage identification module . In a different example the API analytics module may include just the usage identification module or the pattern recognition module . In another example the memory in the server hardware may not include the backend service or the API management gateway .

The system may be implemented in many different ways. Each module such as the pattern recognition module the pattern classification module the API monitor and the usage identification module may be hardware or a combination of hardware and software. For example each module may include an application specific integrated circuit ASIC a Field Programmable Gate Array FPGA a circuit a digital logic circuit an analog circuit a combination of discrete circuits gates or any other type of hardware or combination thereof. Alternatively or in addition each module may include memory hardware such as a portion of the memory for example that comprises instructions executable with the processor or other processor to implement one or more of the features of the module. When any one of the modules includes the portion of the memory that comprises instructions executable with the processor the module may or may not include the processor. In some examples each module may just be the portion of the memory or other physical memory that comprises instructions executable with the processor or other processor to implement the features of the corresponding module without the module including any other hardware. Because each module includes at least some hardware even when the included hardware comprises software each module may be interchangeably referred to as a hardware module such as the pattern recognition hardware module the pattern classification hardware module and the usage identification hardware module.

Some features are shown stored in a computer readable storage medium for example as logic implemented as computer executable instructions or as data structures in memory . All or part of the system and its logic and data structures may be stored on distributed across or read from one or more types of computer readable storage media. Examples of the computer readable storage medium may include a hard disk a floppy disk a CD ROM a flash drive a cache volatile memory non volatile memory RAM flash memory or any other type of computer readable storage medium or storage media. The computer readable storage medium may include any type of non transitory computer readable medium such as a CD ROM a volatile memory a non volatile memory ROM RAM or any other suitable storage device.

The processing capability of the system may be distributed among multiple entities such as among multiple processors and memories optionally including multiple distributed processing systems. Parameters databases and other data structures may be separately stored and managed may be incorporated into a single memory or database may be logically and physically organized in many different ways and may implemented with different types of data structures such as linked lists hash tables or implicit storage mechanisms. Logic such as programs or circuitry may be combined or split among multiple programs distributed across several memories and processors and may be implemented in a library such as a shared library for example a dynamic link library DLL .

All of the discussion regardless of the particular implementation described is exemplary in nature rather than limiting. For example although selected aspects features or components of the implementations are depicted as being stored in memories all or part of systems and methods consistent with the innovations may be stored on distributed across or read from other computer readable storage media for example secondary storage devices such as hard disks flash memory drives floppy disks and CD ROMs. Moreover the various modules and screen display functionality is but one example of such functionality and any other configurations encompassing similar functionality are possible.

The respective logic software or instructions for implementing the processes methods and or techniques discussed above may be provided on computer readable storage media. The functions acts or tasks illustrated in the figures or described herein may be executed in response to one or more sets of logic or instructions stored in or on computer readable media. The functions acts or tasks are independent of the particular type of instructions set storage media processor or processing strategy and may be performed by software hardware integrated circuits firmware micro code and the like operating alone or in combination. Likewise processing strategies may include multiprocessing multitasking parallel processing and the like. In one embodiment the instructions are stored on a removable media device for reading by local or remote systems. In other embodiments the logic or instructions are stored in a remote location for transfer through a computer network or over telephone lines. In yet other embodiments the logic or instructions are stored within a given computer central processing unit CPU graphics processing unit GPU or system.

Furthermore although specific components are described above methods systems and articles of manufacture consistent with the innovation may include additional fewer or different components. For example a processor may be implemented as a microprocessor microcontroller application specific integrated circuit ASIC discrete logic or a combination of other type of circuits or logic. Similarly memories may be DRAM SRAM Flash or any other type of memory. Flags data databases tables entities and other data structures may be separately stored and managed may be incorporated into a single memory or database may be distributed or may be logically and physically organized in many different ways. The components may operate independently or be part of a same program or apparatus. The components may be resident on separate hardware such as separate removable circuit boards or share common hardware such as a same memory and processor for implementing instructions from the memory. Programs may be parts of a single program separate programs or distributed across several memories and processors.

To clarify the use of and to hereby provide notice to the public the phrases at least one of . . . and or at least one of or combinations thereof or . . . and or are defined by the Applicant in the broadest sense superseding any other implied definitions hereinbefore or hereinafter unless expressly asserted by the Applicant to the contrary to mean one or more elements selected from the group comprising A B . . . and N. In other words the phrases mean any combination of one or more of the elements A B . . . or N including any one element alone or the one element in combination with one or more of the other elements which may also include in combination additional elements not listed.

While various embodiments of the innovation have been described it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the innovation. Accordingly the innovation is not to be restricted except in light of the attached claims and their equivalents.

