---

title: Request-response operation for asynchronous messaging
abstract: Disclosed are methods, systems, and computer programs for facilitating communication between a client application and a server application. A client application initiates an asynchronous communication with the server application by sending a request via a communication manager. The communication manager sends the request synchronously to the server application. Responsive to the communication manager not having received a final response from the server application, the communication manager responds to the client application that the sending the request was unsuccessful. Responsive to the communication manager having received a final response from the server application, the communication manager retains the response from the server application and responds to the client application that the sending a request was successful. The client application requests a final response from the communication manager and the communication manager provides the previously retained response.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09350797&OS=09350797&RS=09350797
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09350797
owner_city: Armonk
owner_country: US
publication_date: 20131014
---
This application claims priority to Great Britain Patent Application No. 1218445.3 filed 15 Oct. 2012 and all the benefits accruing therefrom under 35 U.S.C. 119 the contents of which in its entirety are herein incorporated by reference.

There are several problems with optimal use of asynchronous messaging solutions Java Message Service JMS providers native IBM WebSphere MQ WMQ and similar to access applications through the request response pattern. Java and all Java based trademarks and logos are trademarks or registered trademarks of Oracle and or its affiliates IBM and WebSphere are trademarks of International Business Machines Corporation registered in many jurisdictions worldwide. 

In spite of these problems the asynchronous messaging model embodied in APIs such as the MQI and JMS remains popular and it would be highly desirable to provide an implementation where this style of coding actually works. There are a variety of reasons for this including the asynchronous model put send a message get receive a message is particularly simple and intuitive in an application or suite of applications that already uses asynchronous messaging it can be beneficial to use the same APIs programming skills and so on for request response and if an installation is already using a messaging provider such as Websphere MQ then using the same provider for request response allows uniform management resource allocation security management and so on .

Embodiments disclosed herein include a method for facilitating communication between a client application and a server application. One such method includes the client application initiating an asynchronous communication with the server application by sending a request via a communication manager. The method also includes the communication manager sending said request synchronously to the server application. The method also includes in response to the communication manager not having received a final response from the server application the communication manager responding to the client application that said sending the request was unsuccessful. The method also includes in response to the communication manager having received a final response from the server application the communication manager retaining the response from the server application and responding to the client application that the sending a request was successful The method also includes the client application requesting a final response from the communication manager and the communication manager providing the previously retained response.

Embodiments disclosed herein include an apparatus for facilitating communication between a client application and a server application. One such apparatus includes a communication manager with which the client application initiates an asynchronous communication with the server application by sending a request via a communication manager. The communication manager sends the request synchronously to the server application. Responsive to the communication manager not having received a final response from the server application the communication manager responds to the client application that said sending the request was unsuccessful. Responsive to the communication manager having received a final response from the server application the communication manager retains the response from the server application and responds to the client application that the sending a request was successful. The communication manager responds to the client application requesting a final response from the communication manager by providing the previously retained response.

Embodiments disclosed herein include a computer program product for facilitating communication between a client application and a server application. One such computer program product includes a computer readable storage medium having computer readable program code embodied therewith. The computer readable program code is adapted to perform one of the methods described herein when said program is run on a computer.

Embodiments disclosed herein relate to the field of asynchronous messaging solutions which access server applications through a request response pattern and more particularly to the handling of slow responses from server applications during such accesses.

Some contemporary asynchronous messaging solutions Java Message Service JMS providers native IBM WebSphere MQ WMQ and similar access applications through the request response pattern. This request response pattern can lead to slow response times as will now be discussed with reference to . In client application prepares a message the request and issues a PUT verb MQPUT JMS send or the like to send the message to request queue .

In accordance with asynchronous messaging practices client queue manager first places the message on its transmit xmit queue . The client queue manager then transmits the message from its xmit queue to the request queue which is hosted on server queue manager . Server application issues a GET verb MQGET JMS receive or the like to retrieve the message from the request queue processes the message that is performs the requested service and issues a PUT verb to send a response message back to the reply to queue which was specified in the request message. To do this the server queue manager first places the response message onto its xmit queue and then transmits the message to the reply to queue . The client application issues a GET verb to get the response message from the reply to queue .

In most cases client application cannot wait forever for the response message and so uses a receiving GET verb that times out. Client application has a problem if the receiving GET verb does time out because in that case client application does not know whether server application performed the requested action or not. All that client application knows is that the receiving GET verb timed out. It cannot differentiate between the situation where the server application completed the request but the communication of the response message back to the client application failed and the situation where the server application failed to complete the request and the communication of that failure back to the client application failed.

Reliable messaging further complicates the situation since it allows the PUT verb sending the request message to complete even if the server application cannot be contacted because of communication problems or because it is not running. Either the request message will be delivered eventually to server application or it will expire if an expiry time is specified for the PUT verb or in the worst case the request message will remain indefinitely in the messaging system for example in the client queue manager s xmit queue .

Similarly when server application receives the request message it may successfully issue its sending PUT verb for the response message even if the client application is no longer contactable. In a similar manner to the request message either the response message will be delivered eventually to client application or it will expire if an expiry time is specified for the PUT verb or in the worst case the response message will remain indefinitely in the messaging system for example in the server queue manager s xmit queue .

Setting expiry times for request and response messages can alleviate the consequences of the problem somewhat at least by preventing messages from remaining on queues indefinitely but many messaging systems don t guarantee to expire messages in a timely fashion. In any case client application has a problem if the response message fails to arrive quickly enough whether or not it expires .

A contemporary technique to alleviate the consequences of the problem involves the following sequence. Responsive to a client application initiating a synchronous communication with a server application by sending a request via an asynchronous communication manager one or more checks are performed to identify a cause of any failure to provide a response to the client application satisfying synchronous communication criteria. The results of one or more checks are used to determine whether to back out any data updates performed by on behalf of the server application in response to that request.

As another example of how the request response pattern can lead to slow response times reference is made to where client application invokes server application by preparing a message the request and issuing a PUT verb MQPUT JMS send or the like to result in the sending of the message to request queue . Client application does not itself receive the returned response message. Instead response processor is configured so that the response message wakes up response processor which then processes the response message by issuing a GET verb to get the response message from the reply to queue . In a Java Enterprise Edition environment response processor is typically a message driven bean. The response processor may be a thread started whenever a message appears on the reply to queue . The response processor may be other code that is configured to do a GET WAIT on the reply to queue . Typically the client application exits after sending the request having left information accessible to the response processor as to how the response should be handled such as what the request was why it was sent and what is supposed to happen next. As it is likely that more than one request will have been sent the client application may include a correlation ID in the request message which the server application returns in the response message.

This second example of is generally considered superior to the first example of . The embodiment can be configured in a way that ensures neither the request message nor the response message if any goes missing or remains indefinitely. However the embodiment is not suitable for applications where the requestor client application or a user of client application needs to know the outcome of the request to server application within a reasonable time.

Contemporary asynchronous messaging solutions may also experience the transaction problem as will now be discussed with reference to where the functions desired to be achieved by a naive programmer are shown. Client application wishes to invoke server application by sending a request message and receiving the response message. Client application wants to treat the function provided by server application as part of a single transaction that includes other actions requested by client application . For example client application may perform some database updates as well as invoking server application . These or other updates may be carried out at any or all of blocks or in .

Although the client application wishes to invoke server application by sending a request message and receiving the response message and wants to treat the function provided by server application as part of a single transaction that includes other actions requested by client application the example of does not work.

The client queue manager does not send the request message from the xmit queue to the request queue until the client application commits the transaction at block . The GET verb issued by the client application must fail because there cannot be a response message on the reply to queue . There cannot be a response message on the reply to queue because the server application has not yet received the request message from the client queue manager . As explained above the server application will not receive the request message because the client queue manager does not send the request until the client application commits the transaction at block .

The client application is unlikely to commit the transaction. When the GET verb times out because no reply message has been received the client application determines that there has been no response to the request message. The client application correctly deduces that the request was not actioned. The client application backs out the transaction. Backing out the transaction includes backing out the issuing of the PUT verb to send the request message. So the request message never gets sent at all.

In some embodiments disclosed herein a communication manager only respond to the client application that the sending a request was successful if the server application has received the request and the communication manager has received its response message. This means that the client application is not left in a state of uncertainty regarding the outcome of the request. Once the communication manager responds to the client application that the sending a request was successful the client application can assume that the outcome of the request will be available without an unpredictable delay for the response. This overcomes the problems described above with reference to the first and second examples.

In some embodiments disclosed herein the communication manager includes a client application s queue manager.

In some embodiments disclosed herein the server application is provided with a predetermined amount of time in which to process the client application s request and transmit its response message to the client application s queue manager.

In still another embodiment the functionality of the client application sending a request via a communication manager is completed inside a transaction. The functionality of the client application requesting a final response from the communication manager is completed inside this transaction. The client application completes other processing between one or more of the transaction beginning and the asynchronous communication manager responding to the client application that the sending a request was successful. The asynchronous communication manager responds to the client application that the sending a request was successful and the client application requesting a final response from the communication manager. The client application requests a final response from the communication manager and the transaction being committed.

Such techniques allow the simple and intuitive asynchronous messaging model to be employed but still to have the request together with other processing included in a transaction.

In some embodiments the client application sends said request message to a queue name which represents the server application and the communication manager uses configuration information for said queue name to locate and communicate with the server application.

Referring to the request response interaction in a first embodiment includes the following functionality.

The client application starts at block . Blocks to can be found in other reference numerals are found in . The client application prepares a message the request and issues a PUT verb MQPUT JMS send or the like to send the request message to the server application . If an MQPUT is used then a send to queue is specified and if a JMS send is used then a send to destination is specified. Other implementations may use something equivalent to a send to queue or a send to destination. The client application issues the PUT verb outside of syncpoint which is equivalent to autocommit in database terminology the PUT verb is executed in its own transaction that is implicitly committed and cannot be rolled back.

In a variation of this first embodiment the client queue manager sends the request message to a queue name which represents the server application . This queue name will appear to the client queue manager as if it were a request queue such as that shown in . The queue name actually identifies configuration information that specifies how the client queue manager should communicate with the server application . This configuration information may include a queue name for use by the client application and a queue location for use by the client queue manager together with other attributes associated with the queue name. In this variation of the first embodiment those attributes may include a protocol or protocols to use and a network address.

Server application processes the request message that is performs the requested service and sends a response message back to the client queue manager .

The client queue manager receives the response message indicates that the PUT operation of the request was successfully completed. The client queue manager also PUTs the response message on the client reply to queue . The client application can optionally perform other processing . The client queue manager does not indicate that the PUT operation of the request message was successfully completed until after the client queue manager has received the response message from the server application indicating that the request has been completed. The client queue manager returns control to the client application .

At some time convenient to the client application it issues a GET verb MQGET JMS receive or the like to receive the response message. The client application issues the GET verb outside of syncpoint the GET will be executed in its own transaction that is explicitly committed and cannot be rolled back. Because the response message is already on the reply to queue the client queue manager delivers the response message immediately. The client application can optionally perform other processing after receiving the response message. The client application processing stops at block .

If the client queue manager does not receive any response message from the server application then the client queue manager responds to the client application that the PUT operation was not successful. The client application does not attempt to GET the response message. The client application can optionally perform other processing . The client application processing stops at block .

The blocks described above mean that the client application uses the simple intuitive and familiar services of asynchronous messaging.

As can be seen from the embodiments described above this relieves the client application of responsibility for dealing with an unresponsive or excessively slow server application . Such problems are detected by the messaging software for example by using RPC style time outs which informs the client application by means of an error in the PUT operation MQPUT send or the like . The client application can deal with such errors in the same way as it deals with send time errors in true asynchronous messaging. Response messages that do arrive including error response messages are also handled by the client application in the same way as with true asynchronous messaging.

If an existing or new server application supports RPC invocation then in embodiments disclosed herein its services become available at no extra cost to client applications that prefer for whatever reason to use the asynchronous messaging method of invocation. Client applications can use existing messaging Application Programming Interfaces MQI JMS and the like to invoke existing or new RPC server applications with no changes or additions required to those server applications .

In a preferred embodiment transactional RPC server applications can be invoked using the call pattern described in the third example in the Background section.

In this example the client application only interacts directly with the client queue manager of the messaging software. The client application uses a single phase commit 1PC protocol with the client queue manager . The messaging software itself uses transactional RPC protocols to interact with the server application . In order to present ACID 1PC transaction semantics to its client application the messaging software uses two phase commit 2PC protocols internally.

In this example the client application uses one phase commit 1PC with a single resource manager RM which is the client queue manager . The client queue manager receives an explicit or implicit start transaction request from the client application for example the WebSphere MQ application programming interface includes both i an explicit start transaction MQBEGIN and ii an implicit start transaction in the first in syncpoint MQPUT MQGET or similar. At this time the messaging software starts its own inner two phase commit 2PC transaction possibly by invoking an external transaction manager TM . The messaging software performs subsequent recoverable actions on behalf of the client application including interaction with the transactional server application as part of this inner 2PC transaction. When the messaging software receives an explicit or implicit commit or roll back it commits or rolls back the inner transaction.

In a second embodiment the client application uses 2PC. In this embodiment the client application may also interact with another resource manager. For example the client application may use the client queue manager to interact with the server application and may also interact with a DB2 database server for SQL requests DB2 is a trademark of International Business Machines Corporation registered in many jurisdictions worldwide . In this example the client application needs to use 2PC. However from the viewpoint of the client queue manager this embodiment is simpler than the prior art embodiment since the client application the client queue manager and the transactional server application enroll in the 2PC transaction in the usual way.

Referring to the client application starts at block and may now BEGIN a transaction that will include optional blocks of other processing as well as the PUT operation and the GET operation . The client application issues a PUT verb as described above with reference to . The PUT verb is issued by the client queue manager to deliver the request message without waiting for an explicit COMMIT action in the client application . This means that the problem highlighted in the third example above is avoided. This allows the use of the simple and intuitive asynchronous model whilst allowing the operations to be incorporated into a transaction.

Server application processes the request message that is performs the requested service and sends a response message back to the client queue manager .

Again as described above with reference to the client queue manager indicates that the PUT operation of the request was successfully completed. The client application can optionally perform other processing . The client queue manager also PUTs the response message on the client reply to queue . The client queue manager does not indicate that the PUT operation of the request message was successfully completed until after the client queue manager has received the response message from the server application indicating that the request has been completed. The client queue manager returns control to the client application . The client application can optionally perform other processing .

If at block the PUT request was not successful then the client application may BACKOUT the transaction the transaction including the optional blocks of other processing . The BACKOUT request is propagated to the server application either by the client queue manager or if there is one by the external transaction manager the server application and in the 2PC case all the other resource managers roll back the transaction and the client application s BACKOUT completes. In all cases the client application processing stops at block .

If at block the PUT request was successful then at some time convenient to the client application it issues a GET verb MQGET JMS receive or the like to receive the response message.

At block if the response indicates that the request was completed successfully then the client application may now COMMIT the transaction the transaction including the processing performed by the server application the optional blocks of other processing and the GET operation . The COMMIT request is propagated to the server application either by the client queue manager or if there is one by an external transaction manager. In accordance with established transactional behavior the server application or in the 2PC case any of the other resource managers can report that it is unable to COMMIT. In this case the server application and in the 2PC case all the other resource managers roll back the transaction and the client application s COMMIT completes with an error return. Unlike conventional roll back for asynchronous messaging in the described embodiments the roll back does not restore the response message to the reply to queue. This avoids the undesired effect of the response message continuing to exist after the request is rolled back. In all cases the client application processing stops at block .

At block if the response indicates that the request was not completed successfully then the client application may BACKOUT the transaction the transaction including the optional blocks of other processing . The BACKOUT request is propagated to the server application either by the client queue manager or if there is one by the external transaction manager the server application and in the 2PC case all the other resource managers roll back the transaction and the client application s BACKOUT completes. Unlike conventional roll back for asynchronous messaging in the described embodiments the roll back does not restore the response message to the reply to queue. This avoids the undesired effect of the response message continuing to exist after the request is rolled back. In all cases the client application processing stops at block .

Embodiments disclosed herein can take the form of a computer program accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD RW and DVD.

