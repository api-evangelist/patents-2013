---

title: Modification indication implementation based on internal model
abstract: The subject disclosure is generally directed towards caching property values in a sparse cache for use in translating notifications to contain previous and source property values, e.g., for use in SMI-S compliant notifications (modification indications). When a modification indication that needs a previous instance and source instance, but only the source instance is available, a cache is accessed to obtain the previous property value. The modification indication is translated to contain the previous and source instance, and output, e.g., to a client subscriber. The cache is updated with the property values of the source instance in anticipation of being needed for a subsequent modification indication of that property.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09652434&OS=09652434&RS=09652434
owner: EMC Corporation
number: 09652434
owner_city: Hopkinton
owner_country: US
publication_date: 20131213
---
The Storage Management Initiative Specification SMI S provides a standard for information technology IT clients to follow when managing the storage devices and the like of any SMI S compliant storage vendors. Among its many requirements the SMI S standard specifies some mandatory modification indication filters on specific properties also referred to as attributes herein of specific classes comprising Common Information Model CIM classes. When certain ones of these properties change an event notification referred to as a modification indication in SMI S needs to be sent to client subscribers.

For example SMI S requires that a management server send out a modification indication per client side subscription whenever an instance of class CIM StorageVolume has its OperationalStatus property changed. According to the specification the modification indication needs to include two property values namely SourceInstance which in this example contains the changed now current OperationalStatus property value for the CIM StorageVolume instance and PreviousInstance for the previous OperationalStatus property value before the change occurred .

The underlying indication framework does not support sending the PreviousInstance value. Redesigning and implementing the framework to provide the PreviousInstance is possible but would take an extremely significant amount of effort and would be very risky with respect to being likely to introduce regressions. Another solution is to have a full cache containing all of the possibly needed information and then use a polling thread to periodically detect the change by comparison against the current data. Such a solution is highly inefficient in performance including in terms of memory and CPU usage particularly when the number of instances is on the order of tens of thousands.

Various aspects of the technology described herein are generally directed towards providing modification indications to client subscribers that include previous property attribute values. The technology is based upon lightweight caching configured on top of legacy components that are incapable of providing the previous attribute values.

In one or more aspects a sparse cache is maintained by the SMI S API layer for the previous attribute values. When an original modification indication containing the source instance is received for sending to client subscribers the previous one or more values are obtained from the cache and the modification indication is translated to include the previous property value before sending to the client subscribers. The sparse cache is then updated with the source attribute value s for use as the previous value s for any future modification indication.

It should be understood that any of the examples herein are non limiting. For instance one or more examples used herein show the SMI S layer containing the modification handling logic and the sparse cache however these components may be external to the layer and communicate with be accessed by the SMI S layer. Also the properties attributes described herein as being cached and used in modification indications may vary from those described be extended and so forth. Moreover SMI S is only one scenario that may benefit from the technology described herein. As such the present invention is not limited to any particular embodiments aspects concepts structures functionalities or examples described herein. Rather any of the embodiments aspects concepts structures functionalities or examples described herein are non limiting and the present invention may be used various ways that provide benefits and advantages in computing and notification communication in general.

Example layers wrappers for interfacing clients to the UI services include a graphical user interface layer a command Line Interface layer a REST API layer and SMI S API layer and a VASA vSphere APIs for Storage Awareness layer . As can be readily appreciated these are examples and not all such layers need be present or more may be present in a given implementation.

As shown in and exemplified in more detail in in one or more embodiments the SMI S API layer contains modification implementation logic MIL components or the like as described herein. In this is shown as modification indication handling logic and pre populate query logic along with a sparse cache .

In general when the system starts up the pre populate query logic queries the UI services to obtain the current property values for those in which the previous instance needs to be sent with the source instance in certain indications. That is SMI S only defines a limited number of indication filters only part of attributes of some classes need be handled in previous instance 

Indications in SMI S are used to model events to which SMI S clients may subscribe using an indication filter. In general an SMI S server sends an indication to notify the client when the subscribed event occurs. By way of example of subscribing for an indication 

As described herein the UIS Layer can only send a modification notification with SourceInstance but without PreviousInstance. This is represented in by the Original Modification Indication including a SRC property value. Through a combination of sparse caching and indication translation the PreviousInstance PRE is placed into a translated modification indication . This is shown in in which the modification indication handling logic accesses the sparse cache e.g. a lookup table key value pair for the appropriate value. Once no longer needed e.g. when sent to the client subscribers the modification indication handling logic also accesses the sparse cache to change the former value to the SourceInstance value which thus becomes the previous value for any subsequent change.

Later when a UIS modification indication is sent from the UIS layer and received by the SMI S layer implementation step the modification indication handling logic is able to apply the cached value or values as needed on a copy of the source instance. Step reads the cached value or values.

Step represents evaluating whether a translation is needed based upon the value s and step checks for whether the change is one that matters to clients e.g. the SRC indication may be received for a change to any attribute of the underlying UIS object but the change may not be of interest to any potential SMI S client . If translation is needed for an attribute of interest step performs the translation to produce the corresponding PreviousInstance so as to send step an SMI S compliant modification indication.

At step the SMI S implementation also updates the value in cache which will be used by the process on the next corresponding modification indication. Note that the sending operation may occur before during or after the cache updating in one or more implementations.

As can be seen no redesign is needed in components below the SMI S layer avoiding the significant effort and risks of any such redesign. This also facilitates isolation between SMI S layer and existing components.

At the same time only the needed values e.g. according to the specification are cached which is efficient in terms of memory storage usage. This leverages the fact that there are many classes but only a few of them need a modification indication for example some instances may have on the order of tens of properties and an SMI S indication may only need one or two among them. No periodic full polling is needed which is efficient in terms of CPU usage.

The techniques described herein can be applied to any device or set of devices capable of running programs and processes such as the any of the layered components of . It can be understood therefore that handheld portable and other computing devices and computing objects of all kinds including cell phones tablet slate computers and the like are contemplated for use in connection with the various embodiments. Accordingly the below general purpose remote computer described below in is but one example of a computing device.

Embodiments can partly be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates to perform one or more functional aspects of the various embodiments described herein. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Those skilled in the art will appreciate that computer systems have a variety of configurations and protocols that can be used to communicate data and thus no particular configuration or protocol is considered limiting.

With reference to an example device for implementing one or more embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit .

Computer typically includes a variety of machine computer readable media and can be any available media that can be accessed by computer . The system memory may include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM and hard drive media optical storage media flash media and so forth. By way of example and not limitation system memory may also include an operating system application programs other program modules and program data.

A user can enter commands and information into the computer through input devices . A monitor or other type of display device is also connected to the system bus via an interface such as output interface . In addition to a monitor computers can also include other peripheral output devices such as speakers and a printer which may be connected through output interface .

The computer may operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and may include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such as a local area network LAN or a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

As mentioned above while example embodiments have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any network system and any computing device or system in which it is desirable to improve efficiency of resource usage.

Also there are multiple ways to implement the same or similar functionality e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to take advantage of the techniques provided herein. Thus embodiments herein are contemplated from the standpoint of an API or other software object as well as from a software or hardware object that implements one or more embodiments as described herein. Thus various embodiments described herein can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

The word example is used herein to mean serving as an example instance or illustration. For the avoidance of doubt the subject matter disclosed herein is not limited by such examples. In addition any aspect or design described herein as example is not necessarily to be construed as preferred or advantageous over other aspects or designs nor is it meant to preclude equivalent example structures and techniques known to those of ordinary skill in the art. Furthermore to the extent that the terms includes has contains and other similar words are used for the avoidance of doubt such terms are intended to be inclusive in a manner similar to the term comprising as an open transition word without precluding any additional or other elements when employed in a claim.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. As used herein the terms component module system and the like are likewise intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub components some of the specified components or sub components and or additional components and according to various permutations and combinations of the foregoing. Sub components can also be implemented as components communicatively coupled to other components rather than included within parent components hierarchical . Additionally it can be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub components and that any one or more middle layers such as a management layer may be provided to communicatively couple to such sub components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.

In view of the example systems described herein methodologies that may be implemented in accordance with the described subject matter can also be appreciated with reference to the flowcharts of the various figures. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the various embodiments are not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Where non sequential or branched flow is illustrated via flowchart it can be appreciated that various other branches flow paths and orders of the blocks may be implemented which achieve the same or a similar result. Moreover some illustrated blocks are optional in implementing the methodologies described hereinafter.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

In addition to the various embodiments described herein it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment s for performing the same or equivalent function of the corresponding embodiment s without deviating therefrom. Still further multiple processing chips or multiple devices can share the performance of one or more functions described herein and similarly storage can be effected across a plurality of devices. Accordingly the invention is not to be limited to any single embodiment but rather is to be construed in breadth spirit and scope in accordance with the appended claims.

