---

title: GPU-accelerated path rendering
abstract: A graphics processing unit (GPU) comprises a memory, and at least one processor configured to: receive a primitive type buffer comprising a plurality of primitive type entries, wherein each of a plurality of vertices of a vertex buffer of the GPU are associated with one or more of the plurality of primitive type entries, determine primitives based on the plurality of vertices and the associated one or more primitive type entries, and rendering, by the GPU, the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483862&OS=09483862&RS=09483862
owner: QUALCOMM Incorporated
number: 09483862
owner_city: San Diego
owner_country: US
publication_date: 20131220
---
This disclosure relates to graphics processing and more particularly to techniques for path rendering.

Path rendering may refer to the rendering of two dimensional 2D vector graphics paths alternatively referred to herein as paths each of which may include one or more path segments. When a path includes two or more path segments the individual path segments may be of the same type or of different types. The types of path segments may include for example a line an elliptic arc a quadratic B zier curve and a cubic B zier curve. In some examples the path segment types may be defined in accordance with a standard vector graphics application programming interface API such as e.g. the Open Vector Graphics OpenVG API.

Graphics processing units GPUs typically implement a three dimensional 3D graphics pipeline that is designed to be compliant with one or more 3D graphics APIs. Because the prevailing 3D graphics APIs in use today do not require that compliant devices support path rendering commands modern GPUs often provide little to no hardware acceleration for path rendering commands. For example a typical 3D graphics pipeline implemented in a modern GPU may include a rasterizer that is designed to rasterize low order non curved 3D graphics primitives such as e.g. points lines and triangles but is not capable of directly rendering curved primitives such as e.g. elliptic arcs and B zier curves .

In some examples this disclosure describes a graphics processing unit GPU that includes hardware that improves the performance of hardware accelerated path rendering in a 3D graphics pipeline. In other examples the techniques of this disclosure include hardware and methods for implementing graphics application programming interface API functions that enable a GPU to process vertex buffers having a plurality of different path rendering primitive types. This disclosure also describes 3D graphics rendering pipeline hardware that supports vertex buffers capable of storing a plurality of different path rendering primitive types within a single buffer as well as an additional primitive type buffer capable of storing values indicative of the primitive types of corresponding vertices of the vertex buffer. By supporting different type of primitives within a single vertex buffer the techniques methods hardware and devices of this disclosure may improve the performance of GPU accelerated path based rendering.

One example method of this disclosure e.g. an API function call may include a new type of draw call. The draw call receives as input a vertex buffer which may include vertices of a plurality of different path rendering primitive types. The draw call may also receive as input another buffer that indicates the primitive types corresponding to the vertices of the vertex buffer. The GPU pipeline may include modifications to various stages of the pipeline such as the input assembler the hull shader and the domain shader to support processing different path rendering primitive types from the vertex buffer.

In one example this disclosure describes a method performed by a graphics processing unit GPU comprising receiving by the GPU a primitive type buffer comprising a plurality of primitive type entries wherein each of a plurality of vertices of a vertex buffer of the GPU are associated with one or more of the plurality of primitive type entries determining by the GPU primitives based on the plurality of vertices and the associated one or more primitive type entries and rendering by the GPU the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.

In another example this disclosure describes a graphics processing unit GPU comprising a memory and at least one processor. The at least one processor is configured receive a primitive type buffer comprising a plurality of primitive type entries wherein each of a plurality of vertices of a vertex buffer of the GPU are associated with one or more of the plurality of primitive type entries. The at least one processor is further configured to determine primitives based on the plurality of vertices and the associated one or more primitive type entries and render the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.

In another example this disclosure describes a graphics processing unit GPU that includes means for receiving a primitive type buffer comprising a plurality of primitive type entries wherein each of a plurality of vertices of a vertex buffer of the GPU are associated with one or more of the plurality of primitive type entries. The GPU further includes means for determining primitives based on the plurality of vertices and the associated one or more primitive type entries and means for rendering the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.

In another examples this disclosure describes a non transitory computer readable storage medium comprising instructions stored thereon that when executed cause at least one processor to receive a primitive type buffer comprising a plurality of primitive type entries wherein each of a plurality of vertices of a vertex buffer of the GPU are associated with one or more of the plurality of primitive type entries. The non transitory computer readable storage medium further includes instructions that when executed cause the at least one processor to determine primitives based on the plurality of vertices and the associated one or more primitive type entries and render the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.

The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

This disclosure is directed to techniques for performing GPU accelerated path rendering. Path rendering may refer to the rendering of two dimensional 2D vector graphics paths alternatively referred to herein as paths each of which may include one or more path segments. When a path includes two or more path segments the individual path segments may be of the same type or of different types also referred to as primitive types. The primitive types of path segments may include for example a line an elliptic arc a quadratic B zier curve and a cubic B zier curve and the like. In some examples the path segment types may be defined in accordance with a standard vector graphics application programming interface API such as e.g. the Open Vector Graphics OpenVG API.

Graphics processing units GPUs may be configured to implement a three dimensional 3D graphics pipeline that is designed to be compliant with one or more 3D graphics APIs. Because the prevailing 3D graphics APIs in use today do not require that compliant devices e.g. GPUs support path rendering commands modern GPUs often provide little to no hardware acceleration for path rendering commands. For example a typical 3D graphics pipeline implemented in a modern GPU may include a rasterizer that is designed to rasterize low order non curved 3D graphics primitives such as e.g. points lines and triangles but may not be capable of directly rendering curved path rendering primitives such as e.g. elliptic arcs and B zier curves .

One approach for path rendering may involve using a 3D GPU pipeline to provide partial GPU hardware acceleration for the execution of path rendering commands. This approach involves preprocessing a path segment with another processor e.g. a central processing unit CPU in order to convert the path segment into one or more low order non curved graphics primitives that can be rasterized by the GPU. In order to specify the graphics primitives an application may call one or more functions of a graphics API referred to as draw calls. 

A draw call may include as an argument a vertex buffer. The vertex buffer includes one or more vertices. The vertices of a vertex buffer specified in a draw call are generally limited to a single primitive type and vertices associated with different primitive types must be specified in additional subsequent draw calls. Because draw calls traditionally require the vertex buffer vertices to be of the same primitive type a GPU may more easily determine to which primitive each of the vertices belong. For example if the GPU determines that each quadratic B zier curve quad has three vertices and that each of the vertices of a particular vertex buffer specified by a draw call belong to a quad the GPU may infer that every third vertex marks the starts of a new quad primitive.

However there is significant overhead associated with executing a different draw call corresponding to each of the primitive types to be rendered for example when performing path rendering. Each draw call requires the allocation of a separate vertex buffer which requires processing time and memory to allocate. And in some examples a CPU may allocate memory for the vertex buffer and transfer the vertex buffer data to the GPU. Each CPU to GPU transfer may results in large amounts of latency which may reduce the performance of performing path based rendering when executing draw calls corresponding to each of a plurality of different path rendering types.

In some examples the GPU may be able to tessellate and render a path segment using a graphics architecture that is specified by a particular 3D graphics API such as e.g. Microsoft s DirectX 11 API. As described in more detail below the techniques described in this disclosure describe possible modifications to the graphics hardware and in particular the input assembler hull shader domain shader and geometry shader stages to perform path rendering. In this manner the techniques described in this disclosure allow for graphics hardware of the DirectX 11 architecture to perform path rendering using a vertex buffer that includes vertices associated with multiple different primitive types.

Techniques in accordance with this disclosure allow a GPU to receive a vertex buffer of vertices corresponding to a plurality of different primitive types. When executing an application that performs graphics rendering a CPU or another processing unit may allocate a buffer in system memory to store vertex data i.e. vertices . The CPU may generate vertices data based on instructions of the executing application and store the vertices into memory allocated to the vertex buffer. Once a number of vertices have been stored to the vertex buffer by the CPU the CPU may transfer the vertex buffer stored in system memory to the GPU. The GPU then receives and stores the vertices of the vertex buffer e.g. in a memory of the GPU.

In order to support a single vertex buffer having vertices corresponding to different primitive types the techniques of this disclosure include a new draw call. The new draw call includes as an argument to the call a vertex buffer having vertices capable of being associated with multiple primitive types. The new draw also includes as an argument an additional primitive type buffer primtype buffer . The values of the primtype buffer may comprise one or more primitive type entries that indicate primitive types with which one or more vertices of the vertex buffer are associated. Based on the values stored in the primtype buffer the GPU may determine the primitive type associated with each of the vertex buffer vertices and store a representation of each primitive that includes the vertices associated with each primitive.

Example techniques of this disclosure also include modifications to the graphics pipeline to support vertex buffer vertices of multiple different primitive types. The techniques of this disclosure include an input assembler that is capable of interpreting the vertex buffer and primtype buffer values a hull shader stage that may generate control points for the multiple primitives based in part on primitive type state values received from the input assembler stage. The graphics pipeline of this disclosure also includes a tessellator stage that produces domain coordinates based on control points generated by the hull shader and a domain shader that generates vertex data based on the domain coordinates generated by the tessellator and the primitive type state values received from the input assembler. The techniques of this disclosure further include a geometry shader stage that is configured to output 3D vertex coordinates based on the primitive state generated by the input assembler.

Path rendering may be divided into two main operations 1 filling a path segment and 2 stroking a path segment. In some examples one or both of the filling and stroking operations may be performed to completely render a path. Conceptually the filling operation may correspond to filling the interior region of a path segment with a specified fill color.

The stroking operation may conceptually correspond to widening the edges of a path segment using a straight line pen held perpendicularly to the path. In addition to the main operations path rendering may also involve applying various types of dashing end caps to the ends of a path applying various types of joins between the endpoints of interior path segments of a path and handling cusps using re tessellation.

A GPU may tessellate e.g. divide a primitive or a path segment using a tessellation stage also referred to as a tessellation unit or a tessellator. After the GPU tessellates the path segment the GPU may be configured to generate 3D geometry based on domain coordinates that the tessellator stage determines and outputs to subsequent stages in the GPU graphics rendering pipeline. The subsequent stages of the graphics pipeline may generate vertex coordinates based on the output of the tessellator stage.

As illustrated in the example of computing device includes a user interface a CPU a memory controller a memory a graphics processing unit GPU a GPU cache a display interface a display and bus . User interface CPU memory controller GPU and display interface may communicate with each other using bus . It should be noted that the specific configuration of buses and communication interfaces between the different components shown in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include for example an operating system a word processor application an email application a spreadsheet application a media player application a video game application a graphical user interface application or another program. The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct GPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API a DirectX API a RenderMan API a WebGL API OpenVG or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include one or more vertex buffers. A vertex buffer is a list of graphics primitives e.g. points lines triangles quadrilaterals triangle strips patches etc. In further examples the vertex buffer graphics data to be rendered may include one or more path rendering primitives such as e.g. line segments elliptic arcs quadratic B zier curves and cubic B zier curves.

Memory controller facilitates the transfer of data going into and out of memory . For example memory controller may receive memory read requests and memory write requests from CPU and or GPU and service such requests with respect to memory in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to memory . Although memory controller is illustrated in the example computing device of as being a processing module that is separate from each of CPU GPU and memory in other examples some or all of the functionality of memory controller may be implemented on one or more of CPU GPU and memory .

Memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example memory may store user applications and graphics data associated with the applications. Memory may also store information for use by and or generated by other components of computing device . For example memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example memory may store any combination of path data path segment data surfaces texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like. In addition memory may store command streams for processing by GPU . For example memory may store path rendering commands 3D graphics rendering commands and or general purpose GPU GPGPU computing commands. Memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM synchronous dynamic random access memory SDRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

GPU may be configured to execute commands that are issued to GPU by CPU . The commands executed by GPU may include graphics commands draw call commands in accordance with the techniques of this disclosure GPU state programming commands memory transfer commands general purpose computing commands kernel execution commands tessellation commands etc.

In some examples GPU may be configured to perform graphics operations to render one or more graphics primitives to display . In such examples when one of the software applications executing on CPU requires graphics processing CPU may provide graphics data to GPU for rendering to display and issue one or more graphics commands to GPU . The graphics commands may include e.g. draw call commands GPU state programming commands conditional commands memory transfer commands blitting block transfer or BLT commands tessellation commands etc. The graphics data may include vertex data texture data surface data etc. In some examples CPU may provide the commands and graphics data to GPU by writing the commands and graphics data to memory which may be accessed by GPU .

In accordance with the techniques of this disclosure CPU may provide graphics data to GPU using a draw call. The draw call may receive a vertex buffer or a pointer to a vertex buffer that includes vertices of multiple different vertex types as an argument. The draw call may also receive a primtype buffer as an argument. The values also referred to as entries of the primtype buffer may indicate a corresponding primitive type associated with one or more vertices included in the vertex buffer. The draw call may also receive a pointer to the vertex buffer and the primtype buffer as arguments in some examples. The vertex buffer and the primtype buffer are stored in memory .

CPU may allocate a portion of memory for the vertex and primtype buffers. CPU may generate the vertex data for the vertex buffer and transfer the vertices to the allocated portion of memory using bus e.g. via a draw call. When a program causes CPU to call the draw call CPU may cause memory controller to transfer the vertex buffer and primtype buffer data to GPU using bus . GPU may store the vertex buffer and primtype buffer data in a memory of the GPU.

GPU maybe built with a highly parallel structure that provides more efficient processing of graphics operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices control points pixels and or other data in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to render graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than rendering the images using CPU . In addition the highly parallel nature of GPU may allow GPU to process certain types of vector and matrix operations for general purposed computing applications more quickly than CPU .

In accordance with the techniques of this disclosure as will be described in more detail below GPU may be configured to receive a single vertex buffer comprising vertices of different primitive types. As described above GPU may receive a vertex buffer of vertex buffers from system memory via a memory transfer initiated by CPU . GPU may also be configured to receive a primtype buffer that indicates the primitive types of the vertex buffer vertices. As one example according to this disclosure GPU may be configured receive a primitive type buffer comprising a plurality of primitive type entries wherein each of a plurality of vertices of a vertex buffer of GPU are associated with one or more of the plurality of primitive type entries. GPU may determine primitives based on the plurality of vertices and the associated one or more primitive type entries and render the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.

GPU may in some examples be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . In further instances GPU may be located on the same microchip as CPU forming a system on a chip SoC . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

In some examples GPU may be directly coupled to GPU cache . Thus GPU may read data from and write data to GPU cache without necessarily using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however GPU may not include a separate cache but instead utilize memory via bus . GPU cache may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

CPU and or GPU may store rendered image data in a frame buffer that is allocated within memory . The rendered image data may include rendered fill areas and stroke areas for a path segment to be rendered. Display interface may retrieve the data from the frame buffer and configure display to display the image represented by the rendered image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing.

Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone handset or a tablet computer. Alternatively display may be a stand alone device coupled to computer device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

Bus may be implemented using any combination of bus structures and bus protocols including first second and third generation bus structures and protocols shared bus structures and protocols point to point bus structures and protocols unidirectional bus structures and protocols and bidirectional bus structures and protocols. Examples of different bus structures and protocols that may be used to implement bus include e.g. a HyperTransport bus an InfiniBand bus an Advanced Graphics Port AGP bus a Peripheral Component Interconnect PCI bus a PCI Express bus an Advanced Microcontroller Bus Architecture AMBA Advanced High performance Bus AHB an AMBA Advanced Peripheral Bus APB and an AMBA Advanced eXentisible Interface AXI bus. Other types of bus structures and protocols may also be used.

In some examples GPU may determine domain coordinates for caps and joins and or dashing patterns and may divide a primitive into sub segments. GPU may also perform graphical operations based on the dashing pattern such as keeping or dropping segments based on the pattern. A subsequent stage such as a domain shader stage may receive the domain coordinates as input and may determine vertex coordinates based on the domain coordinates.

As part of the stroking operation and to generate one or more primitives e.g. triangle primitives that spatially correspond to a stroke area of a line segment GPU may receive a primitive which may be defined by an equation e.g. a parametric equation etc. GPU may divide the received primitive into one or more line segments utilizing the tessellation unit.

The path rendering techniques described in this disclosure may be implemented in any of the components of computing device illustrated in including e.g. CPU GPU and memory . In some examples all or almost all of the path rendering techniques may be implemented in GPU e.g. in a graphics pipeline of GPU . In additional examples CPU may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU that performs the path rendering techniques of this disclosure. In further examples CPU may be configured to place data indicative of a path to be rendered into one or more buffers e.g. one or more vertex buffers and primtype buffers that may be accessed by GPU to render one or more paths.

CPU is configured to execute software application a graphics application processing interface API a GPU driver and an operating system . Software application may include one or more instructions that cause graphics images to be displayed and or one or more instructions that cause a non graphics task e.g. a general purposed computing task to be performed on GPU . Software application may issue instructions to graphics API . Graphics API may be a runtime service that translates the instructions received from software application into a format that is consumable by GPU driver . GPU driver receives the instructions from software application via graphics API and controls the operation of GPU to service the instructions. For example GPU driver may formulate one or more commands place the commands into memory and instruct GPU to execute the commands . In some examples GPU driver may place the commands into memory and communicate with GPU via operating system e.g. via one or more system calls.

GPU includes a command engine and one or more processing units . In some examples the one or more processing units may form and or implement a 3D graphics rendering pipeline e.g. a DX 11 graphics rendering pipeline i.e. a 3D graphics pipeline that is compliant with the DX 11 graphics API .

Command engine is configured to receive commands from CPU e.g. via memory and to cause GPU to execute the commands. In response to receiving a state command command engine may be configured to set one or more state registers in GPU to particular values based on the state command and or to configure one or more of the fixed function processing units based on the state command. In response to receiving a draw call command command engine may be configured to cause processing units to render the geometry represented by the vertices in memory based on data indicative of the type of path to be rendered which may be contained in vertices of the vertex buffers to be rendered as well as data indicative of the primitive type of the vertex buffer vertices of primtype buffers . Command engine may also receive shader program binding commands and load particular shader programs into one or more of the programmable processing units based on the shader program binding commands.

Processing units may include one or more processing units each of which may be a programmable processing unit or a fixed function processing unit. A programmable processing unit may include for example a programmable shader unit that is configured to execute one or more shader programs that are downloaded onto GPU from CPU . A shader program in some examples may be a compiled version of a program written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc. In some examples a programmable shader unit may include a plurality of processing units that are configured to operate in parallel e.g. an SIMD pipeline. A programmable shader unit may have a program memory that stores shader program instructions and an execution state register e.g. a program counter register that indicates the current instruction in the program memory being executed or the next instruction to be fetched. The programmable shader units in processing units may include for example vertex shader units pixel shader units geometry shader units hull shader units domain shader units compute shader units and or unified shader units.

A fixed function processing unit may include hardware that is hard wired to perform certain functions. Although the fixed function hardware may be configurable via one or more control signals for example to perform different functions the fixed function hardware typically does not include a program memory that is capable of receiving user compiled programs. In some examples the fixed function processing units in processing units may include for example processing units that perform raster operations such as e.g. depth testing scissors testing alpha blending etc. as well as

Memory may store path data and one or more commands . In some examples path data may be stored as a plurality of vertices or control points in one or more of vertex buffers allocated in memory . Path data may also comprise one or more primtype buffers . Each of primtype buffers includes data indicative of primitype types corresponding to one or more vertices of one of vertex buffers . In some examples the path data may be stored in a patch list data structure e.g. a four control point patch list . Commands may be stored in one or more command buffers e.g. a ring buffer . CPU e.g. GPU driver via operating system may place path data and commands into memory for consumption by GPU . GPU e.g. command engine may retrieve and execute commands stored in memory .

In examples where path data is stored as vertices the vertices of vertex buffers may include one or more attributes that geometrically define one or more primitives of a path to be rendered. For example for a line the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line e.g. x0 y0 and x1 y1 . For a cubic B zier curve the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve e.g. x0 y0 x1 y1 x2 y2 x3 y3 . For a quadratic B zier curve the vertices in the patch control list may include data indicative of coordinates for three control points instead of four control points. For elliptic arcs the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc.

Vertex buffers may also include vertices of different primitive types within a single one of vertex buffers . For example one of vertex buffers may include two vertices that geometrically define a line e.g. x0 y0 and x1 y1 and three vertices that define a quadratic B zier curve e.g. x2 y2 x3 y3 and x4 y4 . The vertex buffer that include vertices of the line and the quadratic B zier curve may thus include values x0 y0 x1 y1 x2 y2 x3 y3 and x4 y4 . In some examples vertices may be shared amongst two vertices. For example x1 y1 may be the endpoint of a first line that also includes x0 y0 and the starting point of a second line the endpoint of which is x2 y2 .

For each of vertex buffers one of primtype buffers includes data indicative of the primitype type of the one or more vertices of one of vertex buffers . Primtype buffers may generally comprise constant integer values e.g. 32 bit unsigned integer values that indicate the primitive type of one or more vertices of one of vertex buffers . The values of primtype buffers may be assigned or structured in a manner similar to enum types of the C programming language as an example.

In the example of a vertex buffer that includes multiple path rendering primitive types i.e. a line and a quad bezier curve the primtype buffer may include a constant value that indicates the first two coordinates pairs of the vertex buffer i.e. x0 y0 and x1 y1 are of a line primitive type and a second value that indicates the third fourth and fifth coordinate pairs i.e. x2 y2 x3 y3 and x4 y4 are of the quad B zier curve primitive type. Thus in a simple example the primtype buffer may include values LINE QUAD where LINE and QUAD are constants corresponding to a line and quad bezier curve primitive type respectively.

In addition to constant values that indicate the primtiype types of one or more vertices primtype buffers may also include constant values that indicate whether the start and or end of a primitive marks the beginning of a new subpath as well as a constant value that indicates whether the first and last vertices of a primitive also referred to as a subpath are connected. The primtype buffer constant value that indicates the start of a new subpath is an open reset denoted as OR. The primtype value that indicates that the first and last vertices of a subpath are connected is referred to as a closed reset denoted as CR. In some examples the different path types may correspond to a set of path types that are defined by the OpenVG API. The primtype values and subpaths are described in greater detail below with respect to .

Commands may comprise one or more state commands and or one or more draw call commands. A state command may instruct GPU to change one or more of the state variables in GPU such as e.g. the draw color the fill color the stroke color etc. In some examples the state commands may include path rendering state commands that are configured to set one or more state variables associated with rendering a path. For example the state commands may include a paint mode command that is configured to indicate whether a path to be rendered is to be filled stroked or both. As another example the state commands may include a fill color command that specifies a color to be used for filling operations and or a stroke color command that specifies a color to be used for stroking operations. As a further example the state commands may specify one or more parameters for the stroke operation such as e.g. a stroke width an end cap style e.g. butt round square a line join style e.g. miter round bevel a miter limit etc. In some examples in addition to or in lieu of using a state command to set one or more state parameters one or more of the state parameters may be set by using a draw call command or by placing state indicators into a vertex buffer that contains path data .

A draw call command may instruct GPU to render the geometry defined by a group of one or more vertices e.g. defined in a vertex buffer stored in memory . In some examples the draw call command may invoke GPU to render all of the vertices and primitives stored in a defined section e.g. vertex buffers of path data of memory . In other words once GPU receives the draw call command control is passed to GPU for rendering the geometry and primitives represented by the vertices in the defined section e.g. vertex buffer or path data of memory . In accordance with the techniques of this disclosure GPU may receive a draw call command that includes a vertex buffer and a primtype buffer as arguments.

The draw call commands may include one or both of 3D draw call commands and path rendering draw call commands. For 3D rendering draw call commands the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more 3D graphics primitives to be rendered e.g. points lines triangles quadrilaterals triangle strips patches etc. and the 3D rendering draw call command may instruct GPU to render the one or more 3D graphics primitives. For path rendering draw call commands the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more path primitives to be rendered e.g. line segments elliptic arcs quadratic B zier curves and cubic B zier curves etc. and the path rendering draw call command may instruct GPU to render the one or more path primitives.

The draw call may also specify one or more tessellation commands which utilize fixed function and programmable units that may include a hull shader tessellator and a domain shader. The hull shader may specify a domain that is to be tessellated. In some examples a domain to be tessellated may comprise one of an isoline triangle tri or quad quadrilateral domain. The tessellator operates on the specified domain and outputs domain coordinates based on which the domain shader may determine vertex coordinates.

In some examples the path rendering techniques described in this disclosure may be implemented in any of the components shown in including e.g. graphics API GPU driver command engine and processing units . In some examples all or almost all of the path rendering techniques may be implemented in a graphics pipeline in GPU formed by processing units . For instance the tessellation unit may be a unit of processing units . In additional examples software application graphics API and or GPU driver of CPU may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU that performs the path rendering techniques of this disclosure. In further examples software application graphics API and or GPU driver of CPU may be configured to place data indicative of a path to be rendered into one or more buffers e.g. one or more vertex buffers and primtype buffers that may be accessed by GPU to render one or more paths.

In accordance with the techniques of this disclosure GPU may be configured to receive a single vertex buffer comprising vertices of different primitive types. GPU may also be configured to receive a primtype buffer that indicates the primitive types of the vertex buffer vertices. As one example according to this disclosure GPU may be configured receive a primitive type buffer comprising a plurality of primitive type entries wherein each of a plurality of vertices of a vertex buffer of GPU are associated with one or more of the plurality of primitive type entries. GPU may determine primitives based on the plurality of vertices and the associated one or more primitive type entries and render the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.

Resources block may correspond to one or more memory resources used by graphics pipeline such as e.g. one or more textures and or one or more buffers. Resources block may store input data to be processed by one or more of the processing stages in graphics pipeline and or output data from one or more of the processing stages in graphics pipeline . As an example resources block may store a frame buffer that holds a rasterized version of a fill area for a path segment and or a rasterized version of a stroke area for a path segment as described in this disclosure. In some examples the memory resources that form resources block may reside in memory and or GPU cache of computing device .

The processing stages depicted in with straight corners represent fixed function processing stages and the processing stages depicted in with rounded corners represent programmable processing stages. For example as shown in input assembler tessellator rasterizer and output merger may be fixed function processing stages and vertex shader hull shader domain shader geometry shader and pixel shader may be programmable processing stages. Each of the programmable stages may be configured to execute a shader program of a particular type. For example vertex shader may be configured to execute a vertex shader program hull shader may be configured to execute a hull shader program etc. Each of the different types of shader programs may execute either on a common shader unit of the GPU or on one or more dedicated shader units that are dedicated to executing shader programs of one or more particular types.

As shown in input assembler vertex shader hull shader domain shader geometry shader pixel shader and output merger are communicatively coupled to resources block . Input assembler vertex shader hull shader domain shader geometry shader pixel shader and output merger are configured to retrieve and or to receive input data from resources block . Geometry shader and output merger are configured to write output data to resources block . The above described configuration of communication between the processing stages in graphics pipeline and resources block is merely one example of how the communication may be configured between the processing stages of graphics pipeline and resources block . In other examples more or less uni directional and or bi directional communication channels may be provided between the processing stages of graphics pipeline and resources block .

Further information regarding the general operation of the DirectX 11 graphics pipeline may be found in Zink et al. Practical Rendering Computation with Direct3D 11 CRC Press 2011 the entire content of which is incorporated herein by reference.

As discussed above the two main path rendering operations are 1 filling a path segment and 2 stroking a path segment. Solutions for performing stroking operations with graphics rendering pipeline e.g. the DirectX 11 graphics pipeline will now be described.

In accordance with the techniques of this disclosure CPU may place vertices indicative of one or more primitives into a vertex buffer. CPU may also place one or more primitive type values into a primtype buffer. In some examples the vertex buffer may correspond to one of vertex buffers of path data shown in . The primitive topology for the vertices in the vertex buffer may be in some examples a patch control list. For a line the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line e.g. x0 y0 and x1 y1 . For a cubic B zier curve the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve e.g. x0 y0 x1 y1 x2 y2 x3 y3 . For a quadratic B zier curve the vertices in the patch control list may include data indicative of coordinates for three control points that define the curve instead of four control points. For elliptic arcs the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc. The primtype buffer may include values corresponding to the primitive types associated with the vertices in the vertex buffer when the vertices in the vertex buffer are associated with primitives of different types. In some examples CPU may also place data indicative of the type of path to be rendered into an otherwise unused vertex attribute of the patch control list.

To perform the path stroking operation input assembler obtains path data from memory and passes the path data onto subsequent stages of graphics pipeline to render the path segments e.g. path primitives specified by vertex buffers and primtype buffers . For example input assembler may obtain a plurality of vertices from vertex buffers stored in memory . Based on the entries of primitive data of primtype buffers input assembler may parse the vertices stored in the vertex buffer into individual primitives. Input assembler may assign each individual primitive a primitive identifier primID and may store each primitive along with its associated primID in to a cache such as a level 2 L2 cache for later reuse. The L2 cache may be part of resources block . In some examples input assembler may assign the primID values in a monotonically increasing or decreasing order.

In addition to storing each primitive input assembler may also generate primitive type state variables. The variables denoted as sv curr primtype sv prev primtype and sv next primtype indicate the current previous and next primitive types relative to the primitive that is currently in the process of being rendered. Input assembler passes the primitive type state variables to subsequent stages in the graphics pipeline including domain shader stage geometry shader stage and hull shader .

Once input assembler has generated the vertices vertex shader processes the generated vertices. In some examples input assembler may pass the vertices to be processed directly to vertex shader . In additional examples input assembler may direct vertex shader to retrieve particular vertices for processing from one of vertex buffers in resources block e.g. based on the primID associated with the vertices.

Vertex shader is configured to process vertices received from input assembler and or resources block and to generate an output vertex for each input vertex processed by vertex shader . For example for each input vertex vertex shader may execute an instance of a vertex shader program on a shader unit of GPU . The input vertices received by vertex shader and the output vertices generated by vertex shader may be alternatively referred to as input control points and output control points respectively.

In further examples vertex shader may generate one or more output attributes for an output vertex that are not identical to the input attributes of a corresponding input vertex. For example vertex shader may perform substantive processing on one or more of the attributes of the input vertices to generate one or more attributes for the output vertices. As another example vertex shader may add and or delete attributes from the set of input attributes to generate a set of output attributes for an output vertex.

Tessellation stages i.e. hull shader tessellator and domain shader may tessellate the path segment defined by the input path data into a plurality of line segments. In some examples tessellation stages may receive a plurality of vertices that form a primitive e.g. from vertex shader . In some examples four vertices may comprise the primitive. Tessellation stages may determine one or more domain coordinates based on the received primitive. The determined domain coordinates may approximate the curvature of the path to be rendered.

In general hull shader may pass the control points received from vertex shader to domain shader for further processing and provide configuration data such as a domain type to tessellator . Hull shader may also determine the control points based on the primitive state variables generated by input assembler i.e. sv curr primtype sv prev primtype and sv next primtype . Hull shader may also generate one or more tessellation factors based on the primitive state variables and pass the generated tessellation factors to tessellator .

Tessellator may determine domain coordinates at which one or more parametric equations that represent a particular type of path segment or primitive should be evaluated. For the purposes of example tessellator is illustrated as one fixed function unit. Subsequent stages of graphics pipeline may also utilize the domain coordinates determined by tessellator .

Domain shader may evaluate the parametric equations at domain coordinates values determined by tessellator and output a vertex for each evaluation. In some examples each of the vertices output by domain shader may include one or more attributes that are indicative of the position of the vertex. In additional examples each of the vertices output by domain shader may include one or more attributes that are indicative of the type of path rendering primitive associated with the vertex.

More specifically hull shader may process the control points received from vertex shader and or resources block and may generate an output control for each instance of the hull shader program executed by hull shader . For example for each output control point to be generated by hull shader vertex shader may execute an instance of a hull shader program on a shader unit of GPU .

In further examples hull shader may generate one or more output attributes for an output control point that are not identical to the input attributes of a respective one of the input control points. For example hull shader may perform substantive processing on one or more of the attributes of the input control points to generate one or more attributes for the output control points. As another example hull shader may add and or delete attributes from a set of input attributes to generate the set of output attributes for an output vertex. In some examples if GPU receives path data for an elliptical arc that is in the form of an endpoint parameterization hull shader may convert the endpoint parameterization of the elliptical arc into a center parameterization for the elliptical arc as described in further detail below.

In further examples hull shader may drop primitives that are not to be rendered for a particular rendering operation. Dropping a primitive may refer to the process of causing data corresponding to the primitive to not be passed on to further stages of graphics pipeline thereby effectively causing such a primitive to not be rendered by the remainder of the pipeline. For example when graphics pipeline is performing a filling operation hull shader may drop join primitives and cap primitives.

Hull shader may also execute an instance of a patch constant function for each path segment. The patch constant function may determine and provide configuration parameters to tessellator to be used by tessellator when generating output values. In accordance with the techniques of this disclosure the patch constant function may dependent partially on the primitive state variables which hull shader may receive from input assembler . For example the patch constant function may cause hull shader to provide tessellation factors to tessellator . The tessellation factors may specify a degree of tessellation that tessellator is to apply to a particular tessellation domain e.g. how finely the domain should be subdivided and or the number of smaller objects into which the domain should be subdivided . In accordance with the techniques of this disclosure hull shader may take into account the primitive state variables when determining the tessellation factors provided to tessellator .

As another example the patch constant function may cause hull shader to provide a tessellation domain to tessellator . A tessellation domain may refer to an object that is used by tessellator to generate a plurality of coordinates for use by tessellator . Conceptually the tessellation domain may correspond to an object that is subdivided by tessellator into a plurality of smaller objects. The positional coordinates of the vertices of the smaller objects are then sent to domain shader for further processing. In some examples the tessellation domain may be selected to be one of a quad a tri and an isoline. The smaller objects into which the domain is subdivided in some examples may correspond to triangles line segments or points. In some examples hull shader may specify an isoline tessellation domain and specify that tessellator should subdivide the isoline domain into line segments.

In some examples tessellator may be configured to perform two pass tessellation. In two pass tessellation hull shader may receive input from geometry shader for example from a streamout buffer within GPU cache or memory . In some examples the input from geometry shader may comprise primitive type data. Based on this input hull shader generates tessellation factors for tessellation unit to be used in a second tessellation pass. This second pass receives tessellation factors generated by tessellator in a first pass.

Tessellator may generate a plurality of output values for each path segment processed by tessellation stages . The output values may determine the values at which one or more parametric equations that represent a particular type of path segment should be evaluated by domain shader . In some examples tessellator may generate the plurality of output values based on one or more tessellation factors and or a tessellation domain provided to tessellator by hull shader . For example tessellator may subdivide an isoline into a plurality of line segments and generate an output value for each endpoint of the plurality of line segments in a normalized coordinate system. In accordance with the techniques of this disclosure tessellator may also generate primitive type data and pass the primitive type data to geometry shader .

Domain shader may receive domain coordinates and information indicative of one or more graphical features from tessellator and the control points for a path segment tessellation factors and a starting normal of the subsequent primitive from hull shader . Domain shader may also receive the primitive state values from input assembler . Based on these inputs domain shader generates output vertex coordinates and endpoint normals that correspond to the vertex represented by the coordinates.

For example for each output value received from tessellator domain shader may execute an instance of a domain shader program on a shader unit of GPU . The domain shader program may cause domain shader to evaluate one or more parametric equations at a particular value that is determined based on the particular value received from tessellator and to generate coordinates for an output vertex based on the evaluations as well as the graphical feature associated with each vertex coordinate. One or more of the coefficients of the parametric equations used to generate the output vertex coordinates may be defined based on one or more of the control points received from hull shader . Each output vertex may correspond to an endpoint of one of the plurality of tessellated line segments. Two consecutive output vertices may correspond to the endpoints of a single tessellated line segment. In additional examples the domain shader program may cause domain shader to evaluate one or more additional parametric equations at a particular value that is determined based on the particular value received from tessellator in order to generate normal coordinates for each output vertex.

Domain shader may output the vertices in an ordered sequence where each set of adjacent vertices represents a tessellated line segment. The line segments may collectively approximate the path segment that was defined in the vertex buffer and the primtype buffer. For example domain shader may output the following set of vertices 0 1 2 3 4 5 that define the following line segments 0 1 1 2 2 3 3 4 4 5. In additional examples domain shader may output the following set of vertices 0 1 1 2 2 3 3 4 4 5 that may define the same line segments as listed in the previous example.

In some examples tessellator and domain shader may be configured to uniformly tessellate a path segment into a plurality of line segments according to the following technique. Specifically tessellator may output coordinates for parametric evaluation e.g. t 0 T 1 T 2 T . . . T T where T is the tessellation factor . Depending on the type of primitive domain shader may evaluate one or more parametric equations at the values that are output by tessellator .

For a line T may in some examples be always equal to 1. In such examples domain shader may not necessarily need to perform any evaluation to generate vertices that correspond to the line path segment.

For a cubic B zier curve domain shader may evaluate the curve and generate output vertices according to the following parametric equation 0 1 1 3 1 2 3 1 3 1 where t corresponds to an output value provided by tessellator V t corresponds to an output vertex that is generated for a particular output value i.e. t and C0 C1 C2 C3 correspond to the control points for the cubic B zier curve.

Alternatively for the cubic B zier curve domain shader may evaluate the curve and generate output vertices according to the following parametric equations 0 1 1 3 1 2 3 1 3 2 0 1 1 3 1 2 3 1 3 3 where t corresponds to an output value provided by tessellator x t corresponds to the x coordinate of an output vertex that is generated for a particular output value i.e. t y t corresponds to the y coordinate of the output vertex that is generated for the particular output value i.e. t and X0 Y0 X1 Y1 X2 Y2 X3 Y3 correspond to the control points for the cubic B zier curve.

For a quadratic B zier curve domain shader may evaluate the curve and generate output vertices according to the following parametric equation 0 1 1 2 1 2 4 where t corresponds to an output value provided by tessellator V t corresponds to an output vertex that is generated for a particular output value i.e. t and C0 C1 C2 correspond to the control points for the quadratic B zier curve.

Alternatively for the quadratic B zier curve domain shader may evaluate the curve and generate output vertices according to the following parametric equations 0 1 1 1 2 5 0 1 1 1 2 6 where t corresponds to an output value provided by tessellator x t corresponds to the x coordinate of an output vertex that is generated for a particular output value i.e. t y t corresponds to the y coordinate of the output vertex that is generated for the particular output value i.e. t and X0 Y0 X1 Y1 X2 Y2 correspond to control points for the quadratic B zier curve.

For an elliptic arc path segment domain shader may evaluate the curve and generate output vertices according to the following parametric equations CenterCos cos angle Sin sin angle 7 CenterSin cos angle Cos sin angle 8 where the parameterization angle angleis determined from tessellator output t x corresponds to the x coordinate of an output vertex that is generated for a particular parameterization angle i.e. angle y corresponds to the y coordinate of the output vertex that is generated for the parameterization angle i.e. angle rh represents the horizontal radius of the unrotated ellipse ry represents the vertical radius of the unrotated ellipse rv Cos rv Sin rh Cos and rh Sin represent ry Cos angle ry Sin angle rh Cos angle and rh Sin angle respectively and angle represents the counter clockwise angle of the ellipse relative to the x axis measured prior to scaling by rh rv . In some examples hull shader may be configured to determine e.g. precompute cos angle and sin angle and or to determine e.g. precompute the rv Cos rv Sin rh Cos and rh Sin values and to provide these values to domain shader for use in evaluating the above recited parametric equations for elliptic arcs.

As discussed above with respect to elliptic arcs the vertices in the patch control list in some examples may include data indicative of an endpoint parameterization for the elliptic arc. In such examples hull shader e.g. a hull shader program executing on a shader unit of GPU may be used to convert the data indicative of an endpoint parameterization of the elliptic arc to data indicative of a center parameterization of the elliptic arc.

An example technique for finding the correct center of an ellipse when converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc is now described. The example technique may determine a center point cx cy and the initial and final angles 1 and 2 of an ellipse and or elliptic arc based on an endpoint representation of an ellipse defined by the set of parameters x0 y0 x1 y1 rh rv f and f. An ellipse with center point cx cy radii rh and rv and rotation angle rot may satisfy the implicit equation x y 1 where x x cx cos rot y cy sin rot rh and y x cx sin rot y cy cos rot rv. The transformation from x y to x y maps the desired ellipse into a unit circle centered at the origin.

To determine the center points of the pair of ellipses with common radii and rotation angle that pass through the two given points x y and x y a plane is first transformed into a suitably scaled and rotated coordinate system such that the equation of each ellipse becomes x cx y cy 1. Then the centers i.e. cx c and cx cy of the two unit circles whose circumferences pass through two given points may be found. Finally the center points are placed through an inverse transformation to obtain solutions in the original coordinate system.

The center points of the two unit circles that pass through points x y and x y are given by x y d y x d where x x x 2 y y y 2 x x x y y y and d 1 x y . . If d is infinite or imaginary no solution exists due to the input points being coincident or too far apart respectively. The angles 1 and 2 may be found by finding the slope of the endpoints on the circle and computing arctangents.

The following pseudo code illustrates the process of computing ellipse centers according to the above described technique. The findUnitCircles function is called by findEllipses following inverse transformation of the original ellipse parameters.

Further details regarding converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc may be found in the OpenVG Specification Version 1.1 Section 18.4 Dec. 3 2008 available at http www.khronos.org registry vg specs openvg 1.1.pdf the entire content of which is incorporated herein by reference.

Geometry shader may receive tessellated line segments from domain shader and generate a plurality of triangle primitives based on the tessellated line segments. In accordance with the techniques of this disclosure geometry shader may also generate the triangle primitives based on primitive type data received from tessellator . For example for each of the tessellated line segments geometry shader may execute an instance of a geometry shader program on a shader unit of GPU and generate a triangle primitive for the tessellated line segment based on the respective tessellated line segment. In some examples for each of the tessellated line segments geometry shader may receive two vertices from domain shader that correspond to the respective tessellated line segment and generate a set of three vertices that correspond to a triangle primitive.

In some examples two of the vertices of the triangle primitive may be the same vertices e.g. have the same positional coordinates as the two received vertices. In such examples geometry shader may generate the third vertex based on a common vertex that is common for all tessellated line segments associated with a path segment to be rendered. The common vertex may or may not correspond to one of the endpoints of the tessellated line segments. In some examples the common vertex may correspond to the first vertex in a set of vertices that correspond to the tessellated line segments for a path segment to be rendered.

Geometry shader may be invoked once for each of the tessellated line segments produced by domain shader . For each of the tessellated line segments geometry shader may generate a triangle primitive using a common control point as a first vertex of the triangle and using the two endpoints of the respective tessellated line segment as the second and third vertices of the triangle. For example an example was provided above where domain shader generated the following set of vertices 0 1 2 3 4 5 that define the following line segments 0 1 1 2 2 3 3 4 4 5. For the above listed sequence of line segments geometry shader may generate the following triangles C 0 1 C 1 2 C 2 3 C 3 4 C 4 5 C 4 5 where C is any single vertex that is common to all of the triangles.

In some examples geometry shader may also be configured to stream out output data back to resources block . Graphics pipeline may transmit the streamed out data back to hull shader and domain shader in some examples in order to perform a second tessellation pass.

Rasterizer may be configured to convert a plurality of 3D graphics primitives e.g. points lines and triangles into a plurality of pixels that correspond to the 3D graphics primitives. For example rasterizer may receive three vertices that correspond to a triangle primitive and convert the three vertices into a plurality of pixels that correspond to the screen pixel locations that are covered by the triangle primitive. Screen pixel locations that are covered by the triangle primitive may include screen pixel locations that correspond to the vertices of the triangle the edges of the triangle and the interior of the triangle.

Pixel shader may receive pixels from rasterizer and generate shaded pixels based on the received pixels according to a pixel shader program. For example for each pixel received from rasterizer pixel shader may execute an instance of a pixel shader program on a shader unit of GPU .

In further examples pixel shader may generate one or more output attributes for an output pixel that are not identical to the input attributes of a respective one of the input pixels. For example pixel shader may perform substantive processing on one or more of the attributes of an input pixel to generate one or more attributes for an output pixel. As another example pixel shader may add and or delete attributes from a set of input attributes to generate the set of output attributes for an output pixel.

Output merger may place pixel data received from pixel shader into a render target e.g. a frame buffer or a stencil buffer . In some examples output merger may merge the pixel data received from pixel shader with the pixel data already stored in a render target based on a raster operation.

In addition to domain shader evaluating parametric equations to generate positional coordinates for vertices domain shader may also generate normals e.g. tangents for the vertices during the stroking operation. To generate the normals domain shader may evaluate additional parametric equations for each of the values generated by tessellator and output one or more normals for each evaluation. In some cases the normals may be output as attributes of a vertex that is output by domain shader . For example for the stroking operation an output vertex produced by domain shader may include one or more attributes that are indicative of the position of the vertex one or more attributes that are indicative of a normal or tangent associated with the vertex.

To generate the normals for curved path segments e.g. B zier curves and elliptic arcs the tangent formulae for the curved path segments may be used. In general the tangent formulae for curves and elliptic arcs which may be used to determine the normals are the derivatives of the parametric formulas described above with respect to generating the vertices for the curves and arcs.

For example for a cubic B zier curve domain shader may generate normals for the output vertices of the curve according to the following parametric equation 0 3 1 1 6 1 3 1 2 3 6 1 3 3 9 where t corresponds to an output value provided by tessellator N t corresponds to an output normal that is generated for a particular output value i.e. t and C0 C1 C2 C3 correspond to the control points for the cubic B zier curve. A derivative of the parametric equation for the quadratic B zier curve provided above may be used to generate normals for a quadratic B zier curve in a similar fashion.

Alternatively for the cubic B zier curve domain shader may generate normals for the output vertices of the curve according to the following parametric equations 0 3 1 1 6 1 3 1 2 3 6 1 3 3 10 0 3 1 1 6 1 3 1 2 3 6 1 3 3 2 11 where t corresponds to an output value provided by tessellator x t corresponds to the x coordinate of an output normal that is generated for a particular output value i.e. t y t corresponds to the y coordinate of the output normal that is generated for the particular output value i.e. t and X0 Y0 X1 Y1 X2 Y2 X3 Y3 correspond to the control points for the cubic B zier curve. A derivative of the parametric equations for the quadratic B zier curve provided above may be used to generate normals for a quadratic B zier curve in a similar fashion.

For an elliptic arc path segment domain shader may generate normals for the output vertices of the curve according to the following parametric equations TanCos sin angle Sin cos angle 12 TanSin sin angle Cos cos angle 13 where the parameterization angle angle is determined from tessellator output i.e. t Tancorresponds to the x coordinate of an output normal that is generated for a particular parameterization angle i.e. angle Tancorresponds to the y coordinate of the output normal that is generated for the parameterization angle i.e. angle rh represents the horizontal radius of the unrotated ellipse ry represents the vertical radius of the unrotated ellipse rv Cos rv Sin rh Cos and rh Sin represent rv Cos angle rv Sin angle rh Cos angle and rh Sin angle respectively and angle represents the counter clockwise angle of the ellipse relative to the x axis measured prior to scaling by rh rv . In some examples hull shader may be configured to determine e.g. precompute cos angle and sin angle and or to determine e.g. precompute the rv Cos rv Sin rh Cos and rh Sin values and to provide these values to domain shader for use in evaluating the above recited parametric equations for ellipses.

After finding the tangent the normal vector may be found according to the following equation normal normalize Tan Tan 14 where normal corresponds to a normalized vector for the Tan Tan vector and normalize x y is a function that generates a normalized version of an input vector x y . A normalized version of the vector x y may refer to a vector that has the same direction as vector x y and a length e.g. norm of one.

As discussed above with respect to elliptic arcs the vertices in the patch control list may in some examples include data indicative of an endpoint parameterization. In such examples hull shader may convert the data indicative of an endpoint parameterization of the elliptic arc to data indicative of a center parameterization of the elliptic arc.

Thus in accordance with the techniques of this disclosure one or more stage of graphics pipeline may be configured to receive a primitive type buffer comprising a plurality of primitive type entries wherein each of a plurality of vertices of a vertex buffer of GPU are associated with one or more of the plurality of primitive type entries. Graphics pipeline may be further configured to determine primitives based on the plurality of vertices and the associated one or more primitive type entries and render the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer.

In the example of primtype buffer begins with an OR value indicating an open reset. An open reset indicates the beginning of a new subpath which is a set of path rendering primitives that are connected. More particularly the last vertex of each path rendering primitive of the subpath is connected with the first vertex of the subsequent vertex in the subpath. Depending upon whether the next subpath begins with an OR or a closed reset CR GPU may connect the first vertex of the subpath with the last vertex of the subpath. The end of each subpath and the beginning of a new subpath is also indicated by a subsequent reset value.

Following an open or closed reset value that indicates the beginning of a subpath and before a reset value that indicates the end of the subpath are one or more primtype buffer values that indicate the path rendering primitive types. Each primitive type value indicates the primitive type of one or more vertices comprising one of the primitives that make up the subpath. Input assembler of GPU determines the vertices that comprise each primitive of the subpath generates a primitive based on each of the primitive type values subsequent to the reset beginning the primitive and stores a representation of each generated primitive in resources block .

To determine the number of subpaths associated with the vertices of vertex buffer input assembler may scan the primtype values of primtype buffer to determine the indices of any open or closed reset values. In the example of input assembler determines that primtype buffer includes two subpaths. The start of the first subpath is indicated by open reset and the end of the first subpath is indicated by closed reset CR . CR also indicates the start of the second subpath. In the example of the second last subpath does not include a reset to denote the end of the subpath. If the last subpath does not include a reset input assembler infers that the end reset of the last subpath is a closed reset.

For each subpath input assembler first reads the start reset. In the case of the first subpath the start reset is OR . After reading the start reset of the subpath input assembler reads each primitive type value of primtype buffer up until and including the end reset of the subpath. In this example the primitive types of the first subpath include LINE primitive type and QUAD primitive type and the end reset is CR . Based on these primitive types which input assembler reads from primtype buffer input assembler determines that a line primitive and a quadratic curve primitive comprise the primitives of the first subpath.

Input assembler then groups the vertices of vertex buffer into representations of each primitive. To group the vertices of vertex buffer into primitives input assembler determines the number of vertices associated with each primitive type of the subpath and based on the number of vertices associated with each path rendering primitive type further determines the vertices of vertex buffer associated with each primitive. In the example of the first primitive type value after starting OR is LINE primitive type value which corresponds to a line path rendering primitive type. Input assembler determines that two vertices of vertex buffer are associated with a line because by definition a line is comprised of two vertices. Based on line primitive type input assembler determines that the first two vertices and respectively of vertex buffer are associated with a line primitive.

Once input assembler has determined the vertices of each primitive in this case the line primitive input assembler stores a representation of the primitive including the vertices vertices v0 and v1 in this example in resources block . In some examples input assembler may generate a primID and associated the primitive ID with the representation of the primitive. Input assembler or other stages of GPU may utilize the primID as an index by which to access the primitive data e.g. the vertices associated with the primitive from resources block .

Input assembler then continues the process of determining a primitive type and vertices for each primitive of each subpath. In the example of input assembler reads that the next primitive type is QUAD primitive type indicating that the next primitive type of the subpath is a quadratic curve which by definition has three points. In the absence of a reset value input assembler determines that the vertex of the last primitive vertex v1 in this case is the first vertex of the current primitive of the subpath. Thus input assembler determines that the quadratic curve is associated with vertices v1 v2 and v3 vertices . Input assembler generates a primID for the quadratic curve primitive and stores the primitive in resources block .

Input assembler then reads the next value of primtype buffer CR which indicates the end of the first subpath and the beginning of a second subpath. If the value of the ending reset of a subpath indicates that first and last vertices of the subpath are connected input assembler may generate and store additional primitive data corresponding to a line primitive that connects the first and last vertices of the subpath. In the example of the first subpath the ending reset CR indicates that the first vertex of the first subpath and the last vertex of the subpath are not connected.

After reading an end reset which also indicates the start of a new subpath input assembler then moves on to generating the primitives of the second subpath the start of which is indicated by CR . After reading CR which indicates the start of the second subpath input assembler reads QUAD primitive type value which indicates that the first primitive of the second subpath is a quadratic curve having three vertices. Because CR indicates the start of a new subpath input assembler determines that the first vertex of the second subpath is the vertex after the last vertex of the previous first subpath in this case v4. After determining that the first primitive of the second subpath is a quadratic curve input assembler determines that vertices v4 v5 and v6 vertices are part of the primitive generates a representation of the quadratic curve primitive and a primID for the quadratic primitive and stores the primID and the primitive representation in resources block .

Input assembler then reads the next value of primtype buffer i.e. LINE primitive type value . Input assembler determines that the second primitive of the second primitive is a line primitive having two vertices. Input assembler reads the last vertex of the previous primitive vertex v6 and the next vertex v7 vertices . Input assembler then generates a primID for the primitive and stores a representation of the primitive data including vertices v6 and v7 as well as the primID in resources block .

Because there are no more primitive type values in primtype buffer input assembler and there is no ending reset value included in primtype buffer input assembler infers that the ending reset of the second subpath is a closed reset and that vertices v7 and v4 the first and last vertices of the second subpath are connected. Input assembler generates a primID for the line primitive connecting v4 and v7 and then stores a representation of the line primitive and the primID associated with the line primitive in resources block .

For each primitive to be rendered input assembler may generate primitive state variables sv curr primtype sv prev primtype and sv next primtype. The sv curr primtype indicates the type of the current primitive that is currently being processed by one of the stages of graphics pipeline . The values of sv prev primtype and sv next primptype indicate the primitive types of the previously processed primitive and the next primitive to be processed respectively. Input assembler may assign the values of sv prev primtype sv curr primtype and sv next primtype variables in a similar manner to the primID value.

In accordance with the techniques of this disclosure input assembler provides the sv current primtype and sv next primtype variables to hull shader stage . Based on the sv current primtype and sv next primtype variables data for the current primitive retrieved from resources block and input control points received from vertex shader hull shader generates and outputs tessellation factors to tessellator . Hull shader also generates and outputs output control points a starting normal of the next primitive to be processed and tessellation factors to domain shader .

Tessellator receives tessellation factors from hull shader and outputs domain coordinates in a u v coordinate domain as described above. Tessellator outputs the u v coordinates to domain shader if streamout is disabled. If streamout is enabled which is an option that may be used by an application for feeding back data from one stage of a graphics pipeline to an earlier stage of the graphics pipeline tessellator may output the domain coordinates back to resources block for later use.

Domain shader may generate vertices based on the domain coordinates and tessellation factors received from tessellator . Additionally Domain shader may support receiving a generating the vertices based on a variable number of control points received from hull shader . The variable number of control points may be indicated by the value of sv curr primtype received from hull shader .

Lines of lines when executed may cause GPU to allocate a constant buffer that includes a number of path rendering primitives. Lines define various join and stroking parameters for joining and stroking vector graphics path rendering primitives that are to be rendered. Lines define a stride size line and an offset value line and allocate a vertex buffer that includes one or more primitives based on the stride and offset line sets a primptype buffer to point to a previously allocated primtype buffer and includes a draw call line .

On line the offset argument indicates the starting index from which input assembler begins reading the vertex buffer vertices and the stride argument indicates defines how the vertex buffer vertices are arranged so the GPU may correctly access the vertices.

On line the IASetPrimTypeBuffer call takes as a first argument a pointer to a primType buffer which has been previously allocated. The next argument defines the format of the values of the primtype buffer. In this example the format is defined a 32 bit unsigned integer format. On line the DrawPrimType call is a draw call that utilizes the defined vertex and primtype buffers of lines and . The DrawPrimType buffer takes the number of primitives to be rendered in this examples 6 as its only argument. Upon execution the DrawPrimType call causes GPU to draw the primitives included in the vertex buffer.

Each of a plurality of vertices of the vertex buffer of the GPU may be associated with one or more of the plurality of primitive type entries. Input assembler or another stage of graphics pipeline such as hull shader domain shader etc. may determine primitives based on the plurality of vertices and the associated one or more primitive type entries . GPU may then render the primitives based on the plurality of vertices and the associated one or more primitive type entries of the primitive type buffer .

In various examples in the method of input assembler may be configured to determine an associated primitive type for each of the plurality of the vertices of the vertex buffer based on an entry of the entries in the primitive type buffer. Input assembler may be further configured to output an indication of a current primitive type a previous primitive type and a next primitive type to hull shader and domain shader .

In another example hull shader may receive from input assembler primitive type data. Hull shader may determine further one or more tessellation factors for tessellator of the GPU and determine a tessellation domain type based on the received primitive type data.

Tessellator may receive from hull shader the one or more tessellation factors. Tessellator may further receive from hull shader the tessellation domain type from hull shader and tessellate the tessellation domain based on the one or more received tessellation factors. In another example domain shader may receive from tessellator a plurality of domain coordinates. Domain shader may also receive primitive type data from hull shader .

The techniques described in this disclosure may be implemented at least in part in hardware software firmware or any combination thereof. For example various aspects of the described techniques may be implemented within one or more processors including one or more microprocessors digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or any other equivalent integrated or discrete logic circuitry as well as any combinations of such components. The term processor or processing circuitry may generally refer to any of the foregoing logic circuitry alone or in combination with other logic circuitry or any other equivalent circuitry such as discrete hardware that performs processing.

Such hardware software and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition any of the described units modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather functionality associated with one or more modules or units may be performed by separate hardware firmware and or software components or integrated within common or separate hardware or software components.

The techniques described in this disclosure may also be stored embodied or encoded in a computer readable medium such as a computer readable storage medium that stores instructions. Instructions embedded or encoded in a computer readable medium may cause one or more processors to perform the techniques described herein e.g. when the instructions are executed by the one or more processors. Computer readable storage media may include random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM flash memory a hard disk a CD ROM a floppy disk a cassette magnetic media optical media or other computer readable storage media that is tangible.

Computer readable media may include computer readable storage media which corresponds to a tangible storage medium such as those listed above. Computer readable media may also comprise communication media including any medium that facilitates transfer of a computer program from one place to another e.g. according to a communication protocol. In this manner the phrase computer readable media generally may correspond to 1 tangible computer readable storage media which is non transitory and 2 a non tangible computer readable communication medium such as a transitory signal or carrier wave.

Various aspects and examples have been described. However modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims.

