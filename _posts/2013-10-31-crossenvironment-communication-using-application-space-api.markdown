---

title: Cross-environment communication using application space API
abstract: A mobile computing device with a mobile operating system and desktop operating system running concurrently and independently on a shared kernel without virtualization. The mobile operating system provides a mobile user experience while the desktop operating system provides a full desktop user experience when the mobile computing device is docked to a secondary terminal environment. Applications of the desktop operating system communicate with applications and services of the mobile operating system through a cross-environment communication framework. The cross-environment communication framework may include application programming interfaces through which categories of applications can communicate across a multiple operating system computing environment through category-specific remote communication calls. The mobile computing device may be a smartphone running the Android mobile operating system and a full desktop Linux distribution on a modified Android kernel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09063798&OS=09063798&RS=09063798
owner: Z124
number: 09063798
owner_city: George Town
owner_country: KY
publication_date: 20131031
---
This Application is a continuation of and claims the benefit of the filing date of U.S. patent application Ser. No. 13 247 885 filed Sep. 28 2011 entitled Cross Environment Communication Using Application Space API now U.S. Pat. No. 8 726 294 which is a continuation in part and claims the benefit of the filing date of U.S. patent application Ser. No. 13 217 099 filed Aug. 24 2011 entitled Cross Environment Communication Framework which claims the benefit of U.S. Provisional Application Nos. 61 389 117 filed Oct. 1 2010 entitled Multi Operating System Portable Docking Device 61 507 199 filed Jul. 13 2011 entitled Dockable Mobile Software Architecture 61 507 201 filed Jul. 13 2011 entitled Cross Environment Communication Framework 61 507 203 filed Jul. 13 2011 entitled Multi Operating System 61 507 206 filed Jul. 13 2011 entitled Auto Configuration of a Docked System in a Multi OS Environment and 61 507 209 filed Jul. 13 2011 entitled Auto Waking of a Suspended Secondary OS in a Dockable System wherein the entire contents of all of the foregoing priority applications are herein incorporated by reference for all purposes.

This Application relates generally to the field of mobile computing environments and more particularly to supporting multiple user environments through the use of multiple operating systems in a single mobile computing device.

Mobile computing devices are becoming ubiquitous in today s society. For example as of the end of 2008 90 percent of Americans had a mobile wireless device. At the same time the capabilities of mobile devices are advancing rapidly including smartphones that integrate advanced computing capabilities with mobile telephony capabilities. Mobile providers have launched hundreds of new smartphones in the last three years based upon several different platforms e.g. Apple iPhone Android BlackBerry Palm and Windows Mobile . In the U.S. smartphone penetration reached almost 23 by the middle of 2010 and over 35 in some age groups. In Europe the smartphone market grew by 41 from 2009 to 2010 with over 60 million smartphone subscribers as of July 2010 in the five largest European countries alone.

While smartphones are gaining in popularity and computing capability they provide a limited user experience. Specifically they typically have an operating system that is modified for mobile device hardware and a restricted set of applications that are available for the modified operating system. For example many smartphones run Google s Android operating system. Android runs only applications that are specifically developed to run within a Java based virtual machine runtime environment. In addition while Android is based on a modified Linux kernel it uses different standard C libraries system managers and services than Linux. Accordingly applications written for Linux do not run on Android without modification or porting. Similarly Apple s iPhone uses the iOS mobile operating system. Again while iOS is derived from Mac OS X applications developed for OS X do not run on iOS. Therefore while many applications are available for mobile operating systems such as Android and iOS many other common applications for desktop operating systems such as Linux and Mac OS X are not available on the mobile platforms.

Accordingly smartphones are typically suited for a limited set of user experiences and provide applications designed primarily for the mobile environment. In particular smartphones do not provide a suitable desktop user experience nor do they run most common desktop applications. As a result many users carry and use multiple computing devices including a smartphone laptop and or tablet computer. In this instance each device has its own CPU memory file storage and operating system.

Connectivity and file sharing between smartphones and other computing devices involves linking one device e.g. smartphone running a mobile OS to a second wholly disparate device e.g. notebook desktop or tablet running a desktop OS through a wireless or wired connection. Information is shared across devices by synchronizing data between applications running separately on each device. This process typically called synching is cumbersome and generally requires active management by the user.

Embodiments of the present invention are directed to providing the mobile computing experience of a smartphone and the appropriate user experience of a secondary terminal environment in a single mobile computing device. A secondary terminal environment may be some combination of visual rendering devices e.g. monitor or display input devices e.g. mouse touch pad touch screen keyboard etc. and other computing peripherals e.g. HDD optical disc drive memory stick camera printer etc. connected to the computing device by a wired e.g. USB Firewire Thunderbolt etc. or wireless e.g. Bluetooth WiFi etc. connection. In embodiments a mobile operating system associated with the user experience of the mobile environment and a desktop operating system associated with the user experience of the secondary terminal environment are run concurrently and independently on a shared kernel.

According to one aspect consistent with various embodiments a method comprises receiving in a first operating system a first remote method call of a first inter process communication type directed to a first application running within the first operating system through a first inter process communication channel from a second application the second application running within a second operating system the first and second operating systems running concurrently on a shared kernel the first remote method call including a first data parcel translating in the first operating system the first remote method call into a second remote method call of a second inter process communication type the second remote method call including a second data parcel and sending by the first operating system the second remote method call through a second inter process communication channel to the first application.

According to other aspects consistent with various embodiments the translating in the first operating system may include unparceling the first data parcel and reparceling data into the second data parcel included in the second remote method call. The first remote method call may be a synchronous remote method call while the second remote method call may be an asynchronous remote method call. The first remote method call may be performed using a unix socket and the second remote method call may be performed using the Binder IPC mechanism. The first application may be registered in the first operating system to receive calls to the second remote method. Translating the remote method calls may be performed in a service of the first operating system.

According to other aspects consistent with various embodiments a method comprises instantiating by a first application running within a first operating system a method of an application programming interface of the first operating system the method implementing a sink for a predetermined remote communication request requesting by the method of the application programming interface an extended inter process communication interface instantiating by the first operating system the extended inter process communication interface registering by the first operating system the extended inter process communication interface to receive the predetermined remote communication requests directed to the first application receiving by the first operating system a request to instantiate a proxy for the predetermined remote communication request within a second application running within a second operating system the first and second operating systems running concurrently on a shared kernel and passing by the first operating system a reference to the extended inter process communication interface to the second application.

According to other aspects consistent with various embodiments the predetermined remote communication request may be specific to a category of applications that includes the first and second applications. The sink may obtain a connected endpoint of an inter process communication interface instantiated by a remote communication service of the first operating system.

According to other aspects consistent with various embodiments the method may include receiving by the first operating system a request to instantiate a second proxy for the predetermined remote communication request within a third application and passing by the first operating system the reference to the extended inter process communication interface to the third application. Registering of the extended inter process communication interface by the first operating system may include associating the inter process communication with a name key of the application.

According to other aspects consistent with various embodiments a mobile computing device includes a first application running within a first operating system the first application instantiating a sink for a predetermined remote communication request a second application running within a second operating system the second operating system running concurrently with the first operating system on a shared kernel the second application instantiating a proxy for the predetermined remote communication request and a remote communication service of the first operating system the remote communication service establishing a connection between the proxy and the sink through an extended inter process communication interface.

According to other aspects consistent with various embodiments the sink may include a method of an application programming interface of the first operating system. The application programming interface may be provided within an application space of the first operating system. The application programming interface may include classes of sinks the classes of sinks associated with categories of applications. The application programming interface may include a java archive file. The method of the application programming interface may request the extended inter process communication interface from the remote communication service. The remote communication service may register the sink to receive inter process communication through the extended inter process communication interface. Upon registration by the remote communication service the extended inter process communication interface may be pushed by the remote communication service. The first operating system may be an Android mobile operating system while the second operating system may be a Linux operating system.

Traditionally handheld mobile telephony devices i.e. handsets were developed independently and served a separate and distinct purpose from that of personal computers PCs such as desktops and laptops. Handheld mobile telephony devices were focused primarily on communication while PCs were focused on computing tasks such as creating and editing documents text based communication e.g. email etc. multimedia and web browsing. However mobile telephony devices are including ever increasing computing ability and users increasingly desire convergence of communication and computing capabilities into multi use mobile devices.

For example mobile telephony devices called smartphones that include computing capabilities are increasing in popularity. Many of these smartphones include a mobile operating system OS running on a mobile processor. While mobile processors and mobile OSs have increased the capabilities of these devices smartphones have not tended to replace PC environments such as desktop or notebook computers at least because of the limited user experience provided. In particular for some tasks such as typing or editing documents a full size keyboard and large display are easier to use than the user interface components typically found on a smartphone. For example smartphones typically use a small thumb style QWERTY keyboard touch screen display click wheel and or scroll wheel as user interface components. Selecting menu options or items typically involves either using a touch screen display or using the click wheel or scroll wheel to navigate menus and select items. This interface is suited to the small display screens and limited menu options typically found in smartphones but not suited to controlling more traditional programs with a larger number of menu options larger screen area and user interface built around a pointing device such as a traditional mouse.

Embodiments of the invention are directed to an innovative cross environment communications framework CECF that allows for fast communications between applications and services of multiple operating systems running independently and concurrently on the same shared kernel. For example embodiments allow fast communication between applications and services of an Android mobile OS running on a shared kernel and applications and services of a Linux desktop OS running on the same shared kernel.

Embodiments include an extension to the Android Binder inter process communication IPC mechanism that allows for app to app communications within the Android OS. For example Android OS applications within can register with the remote communication service to be able to communicate e.g. synchronize data settings etc. in a synchronous and or asynchronous way. Other embodiments include base classes of the Binder mechanism for a Linux desktop OS that allow communication between applications of the Linux desktop OS and Android OS applications and services. For example Android applications running on the Android OS can share data settings and preferences with Linux applications running on the Linux desktop OS.

Further embodiments support inter process communication between OSs that use incompatible IPC mechanisms. For example a first OS may use a first IPC mechanism for communication across process boundaries. On a second OS running concurrently with the first OS on a shared kernel applications may use a second IPC mechanism for communication across process boundaries for processes running in the second OS.

Yet further embodiments are directed to simplifying app to app sharing of data content and settings through the use of an application programming interface API layer that provides application category specific functions and methods for requesting and providing information between applications. Notably the applications may be in active concurrent execution within a first OS or running on independent OSs running on the same shared kernel.

Mobile computing device may be connected to I O devices and or through port . I O devices and or may make up a secondary terminal environment . In some instances secondary terminal environment may be more suited to desktop OS than mobile OS . For example secondary terminal environment may include a keyboard pointing device and a display device . In these instances desktop OS can be associated with secondary terminal environment to provide the full capabilities of a notebook or desktop computer environment through secondary terminal environment . In other instances secondary terminal environment may be more suited for mobile OS than desktop OS . For example secondary terminal environment may include a touch screen display. In these instances mobile OS may be associated with secondary terminal environment .

In port is shown as connected to port of secondary terminal environment through interface . However port may include separate connections to each I O device and through interface . Interface may be any suitable wired or wireless interface or combination of wired and wireless interfaces for connecting devices such as keyboards monitors pointing devices etc. For example interface may be a combination of a display interface e.g. VGA DVI HDMI etc. and a device communications interface e.g. USB Bluetooth Firewire other serial communications interface etc. . Alternatively interface may be a single communications interface that supports both video and device communications signals e.g. Thunderbolt etc. .

Traditionally the hardware and software development paths for the handset environment and the PC environment have been completely independent because of different use models and competing constraints on product design. PCs including desktop and laptop computers are designed to be flexible and powerful. Specifically PC hardware architecture is typically based around a general purpose PC processor connected to memory graphics and external components through various general purpose interfaces on a motherboard. For example a personal computer motherboard may include a processor connected through a logic chipset to a graphics processor system memory e.g. RAM and various other components through communication interfaces PCI USB ISA IDE etc. . Some more highly integrated PC processors include an interface to a graphics processor e.g. AGP etc. and or interface to system memory e.g. SDR DDR DDR2 DDR3 DRDRAM etc. on the processor.

PC processors are optimized for high processor clock speed and computationally intensive tasks. The personal computer market is presently dominated by processors based on the x86 CPU architecture. Current x86 based PC processors for desktop computers have multiple 64 bit central processing units CPUs or cores with clock speeds exceeding 2.5 GHz and power consumption approaching 100 Watts. Current x86 based PC processors for laptop computers typically run at clock speeds up to 2.0 GHz and have power consumption in the range of 15 45 Watts. Because of the large power consumption of these processors desktop and laptop computers may require cooling devices such as fans or heat sinks to remove waste heat from the processor. In addition the battery life of laptop computers using x86 based PC processors is typically less than four hours.

In contrast mobile processors for handsets are optimized for low power consumption and a high level of integration to reduce the overall size of the handset. For example mobile processors for handsets such as smartphones typically run at clock speeds lower than 2.0 GHz have power consumption of less than 1 Watt and integrate functions common to the mobile environment such as graphics controllers communications interfaces and camera controllers. The most common mobile processor architectures are reduced instruction set computing RISC processor architectures. Specifically the ARM mobile processor architecture is currently the predominant architecture for mobile processors designed for smartphones and other ultra portable and low power computing devices. Some PC processor manufacturers also refer to PC processors designed for use in laptop computers as mobile processors. However as used herein the term mobile processor refers to a processor suited for use in a handset or smartphone typically consuming less than 1 Watt and integrating mobile functionality.

Personal computers and handsets also typically have different system resources input output I O devices and peripherals. For example desktop and laptop computers typically have much larger amounts of system memory and storage capacity than handsets. While a typical laptop computer may have more than 2 GB of RAM and a hard drive with a capacity of more than 250 GB handsets typically have less than 512 MB of RAM and a solid state drive with a capacity of less than 32 GB. User interface components of personal computers typically include a display screen larger than 9 inches diagonally a full keyboard and pointing device s for user input. In contrast handsets typically include a display screen smaller than 7 inches diagonally and user interface components such as a thumb style QWERTY keyboard touch screen display click wheel and or scroll wheel. Peripherals found on personal computers typically include an optical disk drive e.g. CD DVD DVD RW etc. expansion ports e.g. PCMCIA SCSI Express Card etc. video output port e.g. VGA DVI HDMI etc. and generic device ports e.g. USB etc. . In contrast handsets typically do not have optical disk drives or expansion ports. However other devices are typically integrated into handsets including wireless communications interface s e.g. GSM CDMA LTE EDGE WiFi WiMax etc. GPS chipset accelerometer camera s and or solid state memory port SD Memory Stick etc. .

Software for personal computers and handsets has also traditionally been developed independently. For example personal computers including desktops and laptops typically run different operating systems than mobile devices. An operating system is software that manages computer hardware and resources and provides common services for execution of applications software on the computer hardware. Operating systems are generally described as having various abstraction layers where each layer interfaces with the layer below through an interface.

Generally the kernel of an operating system refers to the core OS layer that manages the computing devices resources such as the CPU s CPU scheduling memory and I O including peripheral and file system access . A kernel will usually provide features for low level scheduling of processes dispatching inter process communication process synchronization context switching manipulation of process control blocks interrupt handling process creation and destruction and process suspension and resumption. The OS kernel may or may not include device drivers. Other layers of the OS interface with the kernel through system calls or an application programming interface API layer.

Generally other OS layers include the libraries layer application framework layer and application layer. The libraries layer typically includes system libraries and other user libraries. The application framework layer includes services managers and runtime environments. The application layer includes user applications which may run within a runtime environment of the application framework layer. A user interacts with the OS through the OS GUI. The GUI presents menus buttons and controls that the user selects to control and use applications running on the OS. Commonly the term desktop environment is used to refer to a style of GUI through which the user interfaces with the OS using icons windows toolbars folders and or desktop widgets and is not limited to a desktop OS. For example a mobile OS could have a desktop environment referring to the look and feel of the mobile OS GUI.

Operating systems for personal computers desktop OSs were designed for multi tasking larger screen areas and to provide a flexible environment for application developers. As used herein the term desktop OS refers to an operating system designed for use with a personal computer environment for example a desktop or laptop use environment. Examples of desktop OSs include various distributions of Linux Mac OS X and Windows 7 among many others.

Operating systems for mobile devices mobile OSs were developed for the smaller screen area lower processing power smaller memory and smaller disk space typically found on handsets and smartphones. Example mobile OSs include Android Apple s iOS for the iPhone and iPad Microsoft s Windows Mobile superseded by Windows Phone 7 Nokia s Symbian and Palm s Palm OS superseded by HP webOS . As used herein the term mobile OS refers to an operating system designed for use with a mobile environment including running on a low power processor with reduced system resources compared to the PC environment i.e. desktop or laptop computer system .

Mobile operating systems generally have a particular application development environment that is used to create application programs i.e. apps that run on the mobile OS. The application development environment both facilitates application development by providing common tools and APIs for accessing system resources and services and limits what applications are allowed to do such that the mobile device is able to continue to provide other required functions. For example incoming phone calls and texts may interrupt a running application to notify the user of the incoming call or text.

The most widely adopted mobile OS is Google s Android. While Android is based on Linux it includes modifications to the kernel and other OS layers for the mobile environment and mobile processors. In particular while the Linux kernel is designed for the x86 CPU architecture the Android kernel is modified for ARM based mobile processors. Android device drivers are also particularly tailored for devices typically present in a mobile hardware architecture including touch screens mobile connectivity GSM EDGE CDMA Wi Fi etc. battery management GPS accelerometers and camera modules among other devices.

In Android applications run within the Dalvik virtual machine on an object oriented application framework designed specifically for the memory and processor speed constraints of mobile hardware architectures. Applications are developed for the Dalvik virtual machine through the Android SDK. In addition Android does not have a native X Window System nor does it support the full set of standard GNU libraries and this makes it difficult to port existing GNU Linux applications or libraries to Android.

Apple s iOS operating system run on the iPhone and Microsoft s Windows Phone 7 are similarly modified for the mobile environment and mobile hardware architecture. For example while iOS is derived from the Mac OS X desktop OS common Mac OS X applications do not run natively on iOS. Specifically applications are developed for iOS through an SDK to run within the Cocoa Touch runtime environment of iOS which provides basic application infrastructure and support for key iOS features such as touch based input push notifications and system services. Therefore applications written for Mac OS X do not run on iOS without porting them through the iOS SDK. In addition it may be difficult to port Mac OS X applications to iOS because of differences between user libraries and application framework layers of the two OSs and differences in system resources of the mobile and desktop hardware.

Because of the differences in processing requirements system resources and application development applications developed for desktop OSs typically do not run on mobile OSs. Additionally desktop applications may not be easily ported to mobile OSs because they are optimized for a larger screen area more processing speed more system memory different libraries and commonly a different GUI. As a result users typically use separate computing devices for each user environment including a smartphone tablet computer laptop computer and or desktop computer. In this instance each device has its own CPU memory file storage and OS.

Connectivity and file sharing between smartphones and other devices involves linking one device e.g. smartphone running a mobile OS to a second wholly disparate device e.g. notebook desktop or tablet running a desktop OS through a wireless or wired connection. Information is shared across devices by synchronizing data between applications running separately on each device. This process typically called synching is cumbersome and generally requires active management by the user.

Recently some attempts have been made to provide a more complete user experience with a single mobile computing device. For example a smartphone may be connected to an external monitor and input devices such as a full keyboard to provide a more desktop like user experience with the mobile OS graphical user interface extended to the larger screen and accepting input from the input devices. However because the external monitor and input devices are only an extension of the smartphone s operating system and user interface the capabilities of the docked environment are limited by the smartphone s mobile OS. For example many software applications available on desktop OSs are not available or have limited functionality on mobile OSs. Accordingly these devices do not present a full desktop user experience when connected to an external environment.

Referring still to computing environment provides multiple user computing experiences without the above limitations. Specifically because mobile computing device includes multiple OSs where each OS is suited to a particular computing environment mobile computing device may be adapted with external devices to provide a broad range of user experiences with a single mobile computing device. For example a user may have a mobile computing device and a secondary terminal environment that provides the user experience of a laptop when connected to mobile computing device . In this instance desktop OS of the mobile computing device is associated with the secondary terminal environment when the secondary terminal environment is connected to mobile computing device . To the user the full capabilities of desktop OS are available through secondary terminal environment .

Processor may be an ARM based mobile processor. In embodiments mobile processor is a mobile ARM based processor such as Texas Instruments OMAP3430 Marvell PXA320 Freescale iMX51 or Qualcomm QSD8650 8250. However mobile processor may be another suitable ARM based mobile processor or processor based on other processor architectures such as for example x86 based processor architectures or other RISC based processor architectures.

While illustrates one exemplary hardware implementation for mobile computing device other architectures are contemplated as within the scope of the invention. For example various components illustrated in as external to mobile processor may be integrated into mobile processor . Optionally external display interface shown in as integrated into mobile processor may be external to mobile processor . Additionally other computer architectures employing a system bus discrete graphics processor and or other architectural variations are suitable for employing aspects of the present invention.

As illustrated in mobile OS has libraries layer application framework layer and application layer . In mobile OS applications and run in application layer supported by application framework layer of mobile OS . Application framework layer includes manager s and service s that are used by applications running on mobile OS . For example application framework layer may include a window manager activity manager package manager resource manager telephony manager gesture controller and or other managers and services for the mobile environment. Application framework layer may include a mobile application runtime environment that executes applications developed for mobile OS . The mobile application runtime environment may be optimized for mobile computing resources such as lower processing power or limited memory space. The mobile application runtime environment may rely on the kernel for process isolation memory management and threading support. Libraries layer includes user libraries that implement common functions such as I O and string manipulation standard C libraries graphics libraries database libraries communication libraries and or other libraries.

As illustrated in desktop OS has libraries layer framework layer and application layer . In desktop OS applications and run in application layer supported by application framework layer of desktop OS . Application framework layer includes manager s and service s that are used by applications running on desktop OS . For example application framework layer may include a window manager activity manager package manager resource manager and or other managers and services common to a desktop environment. Libraries layer may include user libraries that implement common functions such as I O and string manipulation standard C libraries graphics libraries database libraries communication libraries and or other libraries.

In various embodiments of the present disclosure desktop OS runs in a separate execution environment from mobile OS . For example mobile OS may run in a root execution environment and desktop OS may run in a secondary execution environment established under the root execution environment. Processes and applications running on mobile OS access user libraries manager s and service s in the root execution environment. Processes and applications running on desktop OS access user libraries manager s and service s in the secondary execution environment.

Generally applications developed for mobile OS do not run directly on desktop OS and applications developed for desktop OS do not run directly on mobile OS . For example application running in application layer of desktop OS may be incompatible with mobile OS meaning that application could not run on mobile OS . Specifically application may use manager s and service s of application framework layer of desktop OS that are either not available or not compatible with manager s and service s in application framework layer in mobile OS . In addition application may attempt to access user libraries that exist in libraries layer of desktop OS but are either not available or not compatible with user libraries available in libraries layer of mobile OS .

In OS architecture mobile OS and desktop OS run concurrently on shared kernel . This means that mobile OS and desktop OS are running on shared kernel at the same time. Specifically mobile OS and desktop OS both interface to shared kernel through the same kernel interface for example by making system calls to shared kernel . Shared kernel manages task scheduling for processes of both mobile OS and desktop OS . In this regard mobile OS and desktop OS are running independently and concurrently on shared kernel . In addition shared kernel runs directly on mobile processor of mobile computing device hardware as illustrated by hardware interface . Specifically shared kernel directly manages the computing resources of mobile computing device hardware such as CPU scheduling memory access and I O. In this regard hardware resources are not virtualized meaning that mobile OS and desktop OS make system calls through kernel interface without virtualized memory or I O access.

There are several known techniques for providing multiple OSs on the same computing device. However none of these techniques provide multiple different OSs running concurrently and independently on a shared kernel. More particularly none of these techniques provide a solution for a mobile OS and a desktop OS running on a shared kernel.

In one technique known as dual boot multiple OSs are loaded on the computing device one at a time. For example at boot time a user may select one OS from multiple available OSs to be run on the device where each OS has its own kernel libraries framework and applications. The system then boots up into that operating system and the other OS s are not running i.e. no processes of the other OS s are loaded concurrently with the running OS . Therefore this technique does not run multiple OSs on a shared kernel nor does this technique run multiple OSs concurrently.

Another technique for running multiple OSs on the same device is to use a Virtual Machine Manager VMM or Hypervisor. A VMM or Hypervisor runs directly on the hardware and separates the individual kernels of each OS from the hardware controlling which computer hardware resources are available to each OS at any given time. A Hypervisor effectively creates multiple virtual machines from one device such that each OS sees a separate virtual machine. Therefore multiple OSs running on the same device through Hypervisor and VMM are not running on a shared kernel. The Hypervisor adds system overhead due to each OS having to access system resources through virtualization in the Hypervisor. Additionally because the Hypervisor must allocate CPU and other computing resources each OS may not be able to effectively schedule processes and tasks.

Yet another technique for running multiple OSs on the same device is to use a hosted virtual machine. In this technique each OS has its own kernel with the kernel of the guest OS running on a virtual machine in the host OS. The virtual machine may be a virtualized hardware platform different than the physical hardware platform. The virtual machine in the host OS may be implemented in the kernel of the host OS. In this instance the kernel of the host OS acts as a hypervisor through which the kernel of the guest OS accesses the processor and hardware resources. Regardless of where the virtual machine is implemented in this technique the host OS and the guest OS have separate kernels. Therefore hosted virtual machines do not have multiple OSs running on a shared kernel. System performance using this technique may be reduced due to virtualization of hardware resources for the guest OS.

Another form of virtualization is operating system level virtualization. In this technique multiple isolated user space instances may be created on the kernel of an operating system which look like separate OS instances from the point of view of users of each user space instance. In this technique the host OS and guest OS s must be the same OS. Accordingly this technique does not provide a solution for a mobile OS and desktop OS running independently and concurrently on a shared kernel. Further similarly to a hosted virtual machine this technique uses disk space and memory virtualization for the guest OS s . Accordingly this technique does not provide direct access to memory and system resources for each concurrent OS.

These techniques of running multiple OSs have limitations with regard to running both operating systems concurrently and independently. For example virtualization involves setting up a distinct address space for the guest OS and simulating I O to the guest OS. Therefore access to hardware including system memory has higher overhead for the guest OS using virtualization. Additionally techniques using Hypervisors result in lack of certainty in process control of each OS. Specifically the Hypervisor manages the amount of CPU time allocated to each OS and each OS then allocates CPU time for processes within the OS without knowledge of what is occurring in the other OS. In this regard high priority processes within one OS may not be given the required CPU time to complete their tasks because the OS is sharing CPU time through the Hypervisor which cannot account for the relative priorities of processes running within each OS. Because processing power may be limited in mobile processor architectures relative to desktop processor architectures techniques that depend on virtualization including hypervisors and operating system level virtualization may not offer optimal performance for a desktop OS running concurrently with a mobile OS on a mobile processor.

In one embodiment consistent with OS architecture an Android mobile OS and a full Linux OS run independently and concurrently on a modified Android kernel. In this embodiment the Android OS may be a modified Android distribution while the Linux OS Hydroid may be a modified Debian Linux desktop OS. illustrate Android mobile OS Android kernel and Hydroid OS that may be employed in OS architecture in more detail according to various embodiments.

As illustrated in Android OS includes a set of C C libraries in libraries layer that are accessed through application framework layer . Libraries layer includes the bionic system C library that was developed specifically for Android to be smaller and faster than the glibc Linux C library. Libraries layer also includes inter process communication IPC library which includes the base classes for the Binder IPC mechanism of the Android OS. Binder was developed specifically for Android to allow communication between processes and services. Other libraries shown in libraries layer in include media libraries that support recording and playback of media formats surface manager that managers access to the display subsystem and composites graphic layers from multiple applications 2D and 3D graphics engines and lightweight relational database engine . Other libraries that may be included in libraries layer but are not pictured in include bitmap and vector font rendering libraries utilities libraries browser tools i.e. WebKit etc. and or secure communication libraries i.e. SSL etc. .

Application framework layer of Android OS provides a development platform that allows developers to use components of the device hardware access location information run background services set alarms add notifications to the status bar etc. Framework layer also allows applications to publish their capabilities and make use of the published capabilities of other applications. Components of application framework layer of Android mobile OS include activity manager resource manager window manager dock manager hardware and system services desktop monitor service multi display manager and remote communication service . Other components that may be included in framework layer of Android mobile OS include a view system telephony manager package manager location manager and or notification manager among other managers and services.

Applications running on Android OS run within the Dalvik virtual machine in the Android runtime environment on top of the Android object oriented application framework. Dalvik virtual machine is a register based virtual machine and runs a compact executable format that is designed to reduce memory usage and processing requirements. Applications running on Android OS include home screen email application phone application browser application and or other application s App s .

For these reasons applications written for Android do not generally run on Hydroid OS and applications written for standard Linux distributions do not generally run on Android OS . In this regard applications for Android OS and Hydroid OS are not bytecode compatible meaning compiled and executable programs for one do not run on the other.

In one embodiment Hydroid OS includes components of a cross environment communication framework that facilitates communication with Android OS through shared kernel . These components include IPC library that includes the base classes for the Binder IPC mechanism of the Android OS and remote communications service .

In one embodiment Hydroid OS is run within a chrooted created with the chroot command secondary execution environment created within the Android root environment. Processes and applications within Hydroid OS are run within the secondary execution environment such that the apparent root directory seen by these processes and applications is the root directory of the secondary execution environment. In this way Hydroid OS can run programs written for standard Linux distributions without modification because Linux user libraries are available to processes running on Hydroid OS in the chrooted secondary execution environment.

In preemptive multi tasking operating systems direct communication between independent processes is typically prevented for security and reliability reasons. Instead a form of IPC must be used to send information across process boundaries i.e. between process address spaces . Objects sent from one process to another process must be marshaled across the process boundaries. Marshaling is the process of packaging and unpackaging data and parameters so an IPC communication can take place. Some forms of IPC can be used to pass information between processes on different computers on a network. One method of IPC is to allow a process in one address space to cause a subroutine or procedure to execute in another address space. This method of IPC is called a remote procedure call RPC .

Some methods of IPC are platform independent. For example Internet sockets or network sockets are a mechanism of bidirectional IPC across an Internet Protocol IP based computer network. Internet sockets can be used to deliver data packets to application processes or threads based on local or remote IP addresses and port numbers. The operating systems of each local or remote machine maintain mappings of each socket to the appropriate application process or thread.

Referring back to OS architecture includes OS and desktop OS running concurrently on shared kernel . As illustrated in mobile computing device can be docked with secondary terminal environment . Secondary terminal environment may have a user experience profile that is associated with desktop OS . In this instance mobile OS provides a mobile computing experience through touch screen display and I O devices of mobile computing device hardware . At the same time desktop OS provides a desktop computing experience through secondary terminal environment .

Accordingly the user is able to use and interact with mobile applications for example applications and running on mobile OS through the mobile computing experience provided on the user interface components of mobile computing device while using and interacting with desktop applications for example applications and running on desktop OS through secondary terminal environment . In this instance applications of mobile OS are independent from applications of desktop OS . In this regard settings user preferences user data and application states of applications of mobile OS are separate and independent from settings user preferences user data and application states of applications of desktop OS . For example application of mobile OS and application of desktop OS may be spreadsheet applications. When the user opens a spreadsheet file with application and begins editing data the spreadsheet file and associated data are locked by application . Application is not able to access the edited spreadsheet data as that data is maintained in the process space of application .

Embodiments of the invention include a cross environment communications framework that extends IPC between applications and services of a mobile OS running on a shared kernel and applications and services of a desktop OS running on the same shared kernel. The cross environment communications framework supports communication between applications of the desktop OS and applications and services of the mobile OS. The cross environment communications framework also supports communication between mobile OS applications and other mobile OS applications.

Services are components that perform background operations i.e. not directly involving user interaction with the application for applications and or assist in interactions between applications and hardware. While various operating systems may refer to these components by other names a service as used herein is intended to be construed broadly as a component including one or more processes that implements functionality not directly involving user interaction that may be used by applications the operating system and or other services.

As illustrated in desktop application running on desktop OS communicates with service running on mobile OS through an inter process communication channel that includes IPC driver in kernel . Initially desktop application sends a call through IPC driver to bind to service . Service creates an instance of a remotable object which defines the IPC interface through which desktop application communicates with service . Service returns remotable object to desktop application through IPC driver . Subsequently desktop application can make calls to remotable object to communicate with service through IPC driver .

In one form of communication of cross environment communication framework desktop application may call remotable methods of service by making calls to remotable object . A call to remotable object may include zero or more parameters passed to a remotable method of service and or zero or more parameters to be returned from the remotable method of service . Parameters are parceled by the IPC interface to the remotable object and marshaled across process boundaries by IPC driver . In this regard desktop application may pass parameters in a call to remotable object in the form of a parcel object. IPC driver marshals the parcel object to the process space of service . Service unparcels the parcel object and performs the remotable method in its process space using the unparceled parameters and returns another parcel object to desktop application . The returned parcel object may include a reference to the remotable object.

Calls to the remotable object may be synchronous or asynchronous. For example if desktop application makes a synchronous call to the remotable object the calling thread in desktop application blocks and waits for the return from the remotable object before continuing. Alternatively if desktop application makes an asynchronous call to the remotable object the calling thread in desktop application continues and does not wait for the call to the remotable object to return.

Remotable object allows desktop application and service to both access a shared memory space in a thread safe manner. For example a reference to the shared memory space may be included in parcel objects passed by calls to remotable object . Because remotable object is reference counted across process boundaries application and service can share memory across process boundaries in a thread safe manner. In various instances the reference to a shared memory space may be a file descriptor or file handle.

In embodiments service may be a core service of the mobile OS such as a telephony service camera service location service. Service may also be a custom service that performs operations related to an application of mobile OS or desktop OS .

In one embodiment service may be a service that enables app to app communication. For example service may be a remote communications service that implements aspects of the cross environment communications framework to provide app to app communication between applications running on mobile OS . The remote communication service may also enable communication between desktop applications running on desktop OS and mobile applications running on mobile OS . In one embodiment remote communication service of Android OS facilitates app to app communication between applications running on Android OS and or Hydroid OS .

For example mobile application may bind to service . Service then instantiates remotable object and returns remotable object to mobile application . Mobile application may also bind to service and service may return remotable object to mobile application . With mobile applications and may communicate through calls to remotable object . For example mobile application may pass parcel objects using calls to remotable object . The parcel objects may include data and or references to shared memory. Mobile application may access the shared memory by also making calls to remotable object . In the same manner desktop application may also bind to service and communicate with mobile applications and using calls to remotable object .

In one embodiment Android mobile OS and a Linux desktop OS run concurrently on shared kernel . The Android OS includes a lightweight remote procedure call mechanism called Binder. The Binder mechanism uses shared memory to achieve efficient secure IPC. The Binder mechanism includes Binder IPC driver in the Android kernel and user class libraries including Binder IPC library that contain the base classes for Binder objects. In Android OS Binder IPC library is compiled against Bionic C library . A Binder reference is a descriptor maintained by Binder driver to an interface of a remotable Binder object. A process can call the remotable Binder object through the interface. The Android Binder mechanism provides reference counting and manages mapping of object references across processes. However the Android Binder mechanism only provides communication between Android applications and globally registered Android services. Therefore Android applications may not communicate directly with each other through the Binder mechanism.

The IPC mechanisms available in the Linux OS are pipes named pipes system V message queues system V semaphores system V shared memory segments and networking sockets. These IPC mechanisms are not directly compatible with the Binder IPC mechanism in the Android OS or the Binder kernel driver used for the Android Binder IPC mechanism. Therefore Linux applications running cannot use these standard Linux IPC mechanisms to communicate with applications and or service s running on an Android OS.

In one embodiment the cross environment communications framework extends the Binder mechanism to allow applications of Linux desktop OS to access services of Android OS . In one embodiment the cross environment communication framework includes a remote communication service that allows app to app communication within Android OS . In other embodiments the remote communication service allows Linux applications running on Linux desktop OS to communicate with Android applications running on Android OS .

In embodiments the cross environment communications framework also supports use of the user datagram protocol UDP for cross environment communication. UDP is part of the suite of protocols of the Internet Protocol IP . UDP is an asynchronous data transmission mechanism without an implicit handshaking dialogue. Accordingly UDP does not provide a reliable transmission protocol not does it guarantee data ordering or data integrity during transmission. However because UDP has minimal overhead it may be a preferable transmission mechanism for time sensitive information in a real time system. For example where dropping packets is preferable to delaying transmission UDP may be a preferred transmission mechanism.

Android application running on Android OS can communicate with Android application using remotable object by making calls to the remotable object. Calls to the remotable object may include remote method invocations and or parceled data. The parceled data may include various data types including integers strings arrays and or file descriptors among other possible data types. At step of communication flow Android application invokes remote method FN1 of remote communication service . Kernel IPC driver marshals the remote call across the process boundaries and remote communication service receives the call to the remotable object at step . Remote communication service then unparcels data of the remote call and runs the remote method in its process space using the data at step . Remote communication service returns another parcel object through the interface to the remotable object at steps and .

At step Android application makes a call to remotable object . For example Android application may invoke a remote method FN2 of remote communication service . Application may pass a parcel object to the remote method that includes parameters for the remote method. Kernel IPC driver marshals the parcel object to the process space of remote communication service and remote communication service receives the parcel object at step . Remote communication service then unparcels the data and runs the remote method in its process space using the data at step . Remote communication service returns another parcel object through the interface to the remotable object at step . Kernel IPC driver marshals the parcel object across the process boundaries and Android application receives the parcel object at step .

In one embodiment remote communication service may be a bound service of Android OS . In this embodiment the bound service is created by Android OS when an client binds to the service through the Context class of Android OS . The bound service runs as long as clients applications and or services that bind to the service are bound to the service and is destroyed when the last client unbinds from the service. The bound service may implement a shared memory interface allowing clients to share user preferences settings and or user data.

Communications flow provides thread safe cross process communication for sharing data between Android applications and running on Android OS . Android applications and may share data in a shared memory space in a thread safe manner by passing references to the shared data using remotable object . For example Android applications and may pass a parcel object that includes a reference to a shared memory space through remotable object .

Communications flow illustrates synchronous communication between Android applications and and remote communication service . However communication between Android applications and and remote communication service may be asynchronous meaning that Android applications and will return immediately from calls to the remotable object and not wait for a result from the remote method invocation.

Service exposes a Binder interface to clients and at step Hydroid application registers with service by binding to service using the exposed interface though Binder kernel driver . Service returns in interface to a remotable object which Hydroid application receives at step . At step Hydroid application makes a call to remotable object . For example Hydroid application may invoke a remotable method FN1 of service . The remote method call may include a parcel object that includes parameters for the remote method call. Binder driver marshals the parcel object to the process space of service and service receives the data at step . Service unparcels the data and runs the method in its process space using the unparceled data at step . Service returns a parcel object that includes return values of the method through binder driver at steps and . Using communication flow Hydroid application running on Hydroid OS can access methods and data of service of Android OS .

Communications flow provides thread safe cross process communication for sharing data between processes of Android OS and applications of Hydroid OS . For example Hydroid application may access shared data of services of Android OS through shared memory by passing references to the shared memory using remotable object .

Communication flow may be used to allow applications running on Hydroid OS to access various services of Android OS . For example service of Android OS may be a core service of Android OS such as a telephony service camera service location service etc. Alternatively service may be a custom service such as remote communication service .

At step Hydroid application of Hydroid OS registers with remote communication service by binding to remote communication service using the exposed interface though binder kernel driver . Remote communication service returns remotable object which Hydroid application receives at step .

At step Android application makes a call to remotable object . For example Android application may invoke a remote method FN1 of remote communication service . Android application may pass a parcel object to the remote method that includes parameters for the remote method. The parcel object may include a reference to a shared memory space. Binder driver marshals the parceled data across the process boundaries and remote communication service receives the data at step . Remote communication service unparcels the data and runs the method in its process space using the unparceled data at step and returns the remotable object through binder driver at steps and .

At step Hydroid application calls a remote method FN2 of remote communication service through the remotable object . The remote method call may include data that is parceled into remotable object . Binder driver marshals the parceled data across the process boundaries and remote communication service receives the data at step . Remote communication service then unparcels the data and runs the method in its process space using the data at step and returns remotable object through binder driver at steps and .

Communications flow provides thread safe cross process communication for sharing data between applications of Android OS and applications of Hydroid OS . For example Hydroid application of Hydroid OS and Android application of Android OS may share data through shared memory by passing references to the shared memory using remotable object . In communications flow Android application and Hydroid application block on return of the remote method invocation. Accordingly communications flow provides synchronous communication between Android application and Hydroid application . However remote method invocations from Android application and Hydroid application may be asynchronous meaning that applications and will return immediately from calls to remotable object and not wait for a result to be returned.

In one embodiment of communications flow remote communication service is a bound service of Android OS . In this embodiment the bound service is created by Android OS when either an Android application or a Hydroid application binds to the service. The service may implement a shared memory interface allowing Android applications and Hydroid applications to share user preferences settings and or user data.

In one example consistent with communications flow Android application and Hydroid application are spreadsheet programs. User data is stored in shared memory accessed through a remotable object. In this example Android spreadsheet application and Hydroid spreadsheet application both may manipulate the user data by passing a parcel object that includes a reference to the shared memory through calls to remotable object . In this way Android spreadsheet application and Hydroid spreadsheet application can manipulate user data of a spreadsheet stored in shared memory in a thread safe manner.

Accordingly communication flow allows applications running on Hydroid OS to communicate with applications running on Android OS using the Android Binder mechanism. In this way Android application running on Android OS and Hydroid application running on Hydroid OS can share settings user preferences and or user data fast and efficiently.

In one example Android application binds to a socket of socket driver s in shared kernel through UDP module . Hydroid application of Hydroid OS also binds to the socket of socket driver s through UDP module . Android application then sends UDP packets to the socket and Hydroid application receives the UDP packets through UDP module of Hydroid OS .

As described above UDP does not include handshaking for providing reliability or implicit data ordering. Accordingly communication flow may be suitable for communications between applications of Android OS and Hydroid OS where data reliability is not a primary concern. For example communication flow may be used for a Linux streaming audio client to receive a streaming audio signal from an Android streaming audio application or service. In this instance it may be more important for the Linux streaming audio client to keep receiving packets through communication flow rather than wait for handshaking or resending of any dropped packets.

As described above mobile OSs e.g. Android iOS and desktop OSs e.g. Linux Mac OS X typically have been developed under different system constraints and for different use models. One difference between mobile OSs and desktop OSs may be the use of different IPC mechanisms for communication between processes within the OSs. As a result it may be difficult to provide inter process communication between a process running within a mobile OS and a process running in a desktop OS where the mobile OS and desktop OS are running on the same shared kernel as illustrated in . A solution provided by various embodiments described above uses a single IPC transport mechanism with support provided for the single IPC transport mechanism in both the mobile OS and desktop OS. The embodiments described below provide an alternative solution using an IPC translation mechanism within one of the mobile OS or desktop OS to translate IPC calls from a first IPC transport mechanism to a second IPC transport mechanism. It may be possible using this technique to provide a solution for inter process communication between processes running within independent OSs that support different IPC mechanisms with fewer modifications to IPC libraries and or applications.

To illustrate cross environment inter process communication using IPC translation consider that mobile OS uses a first IPC mechanism that is incompatible with a second IPC mechanism used by desktop OS . Shared kernel may include IPC driver s that support both the first IPC mechanism and the second IPC mechanism. This means that processes within mobile OS may communicate with each other through shared kernel using the first IPC mechanism using calls to IPC library and IPC transport through a first IPC driver of IPC driver s . For example applications and may communicate with service using the first IPC mechanism. Processes within desktop OS may communicate with each other using the second IPC mechanism for example using calls to IPC library and IPC transport through a second IPC driver of IPC driver s . For example applications and may communicate with each other over the second IPC mechanism.

In one embodiment service is a remote communication service. Remote communication service provides a connection point for cross environment IPC communication. For example remote communication service may keep a directory or database of IPC communications. In the embodiments described above where a single IPC mechanism is used to communicate between applications in the first and second OS the remote communication service establishes the link over the IPC mechanism between the applications by passing a reference to an IPC interface to each application. Once each application has a reference to an IPC interface the applications effectively communicate through the instantiated IPC interface without further involvement by the remote communication service. In this regard the remote communication service acts as an IPC interface dealer linking the applications through the instantiated IPC interfaces which are then used by the applications to communicate across process boundaries in a thread safe manner.

However in embodiments where an application of the first OS uses a first IPC mechanism and an application of the second OS uses a second IPC mechanism the remote communication service maintains links to both applications through the different IPC mechanisms. The remote communication service then acts as an end point for IPC communications from each application and IPC translator translates the IPC calls between the two different and incompatible IPC mechanisms. The IPC translation occurring in the remote communication service is transparent to the applications which see the endpoint in the remote communication service as if it were the other party.

Consider as an example a first application e.g. word processing application running in an Android mobile OS and a second application e.g. also a word processing application running on a Linux OS where the Linux and Android OSs run concurrently on a shared kernel. As with other Android applications the first application has access to the Binder IPC mechanism within Android for inter process communication i.e. for communication to Android services . The Linux OS supports IPC but through different IPC mechanisms than Binder e.g. unix domain sockets UDP etc. . The shared kernel supports communication using both Binder and the other IPC mechanisms of the Linux OS. Using IPC transport and IPC translation as described above the first application can communicate with the second application through the remote communication service with IPC translation between Binder and a second IPC mechanism taking place in the IPC translator of the remote communication service.

Process flow describes IPC transport and translation of a remote method call from a second application running in a second OS to a first application running in a first OS. The IPC translator can similarly perform IPC translation for a reply message from the first application to the second application. For example the remote method call may include a reply parameter or reply parcel. The second application may pass a remote method call return of the second inter process communication type and the IPC translator may translate the return call to the first inter process communication type for reception by the first application. The translation may include translating parameters and or unparceling and reparceling data included in the IPC reply.

In embodiments the IPC translator may translate between synchronous and asynchronous IPC calls. For example the IPC translator may receive an asynchronous IPC call through a first IPC mechanism and translate the IPC call to a second synchronous IPC call of a second IPC mechanism. The IPC translator may receive the return from the second synchronous IPC call such that the IPC handling in the receiving process of the IPC call is unchanged. In various instances the IPC translator may be able to translate between a synchronous call from a first process to an asynchronous call in a second process. For example where the first process does not expect or operate on a return parcel the IPC translator may be able to pass data from a first process using a synchronous IPC call to a second process using an asynchronous IPC call.

IPC transport and IPC translation may be used in a process flow similar to process flow to make a remote method call from the first application to the second application. Specifically the first application may make a remote method call of the second inter process communication type that is translated by the IPC translator and received in the second application as a remote method call of the first inter process communication type. Accordingly remote method calls may be performed from the first application to the second application or from the second application to the first application using different IPC mechanisms through the IPC translator.

In the embodiments described above the remote communication service instantiates a generic IPC interface to link two applications. In other words the remote communication service establishes the IPC link between applications but does not determine the purpose of the IPC communication or the information passed between applications including the structure of the parcel data that may be passed through the IPC interface. Further embodiments are directed to establishing an application programming interface through which categories of applications can communicate through category specific remote communication calls. These embodiments may be employed whether the IPC communications take place over a single IPC mechanism as illustrated in or use the IPC transport with IPC translation embodiments illustrated in .

The application communication APIs of computing environment may be in application space within the first and or second OS. For example API could be implemented as a runtime library of mobile OS . In one embodiment API is implemented as a JAR file for a Dalvik runtime environment of an Android mobile OS. In other embodiments the application communication APIs of computing environment may be within user libraries or other libraries accessible to applications of the OS. For example in one embodiment API of desktop OS is implemented as a shared user library in a Linux OS.

Application communication API of mobile OS provides category specific remote calls that extend generic IPC interfaces as proxies calls to another process and sinks calls from another process . Application communication API of desktop OS provides corresponding remote calls i.e. proxies that correspond to sinks within the other party . For example API of mobile OS may include sinks and proxies for a specific request of a specific category of application that perform all functionality required to request an IPC interface object from remote communication service and parcel data to the IPC interface object in a format tailored for the specific request.

The APIs may include remote calls for any category of application for which communication between applications may be desirable. This may include communication between applications running within the same OS or cross environment communication between applications running on separate and independent OSs. For example categories of remote calls in APIs and may include browser applications office productivity applications email clients games location enabled applications e.g. GPS enabled augmented reality applications and or any other category for which communication between applications may provide a more seamless computing experience. API may be used by an application running on mobile OS for communication with another application running on mobile OS or for communication with applications running on desktop OS through API .

Consider that an application may be running on the mobile OS and the user may be interacting with the application through the user environment of the mobile OS while the mobile device is not docked. Through this user interaction the application may acquire a particular application state e.g. settings views and application data . The user then docks the mobile device with a secondary terminal environment. When the mobile computing device is docked the desktop OS is associated with the secondary terminal environment. The user may desire to resume interaction using an application of the desktop OS with the application data and at the particular application state where the user left off with the corresponding application of the mobile OS. For example the user may be using a spreadsheet application on the mobile OS before it is docked. When the user docks the mobile device the user may wish to open a spreadsheet program of the desktop OS through the secondary terminal environment and pick up in that program where they left off in the mobile spreadsheet application. The user may desire to do this without closing the file they are working on in the mobile spreadsheet application and re opening the file using the desktop spreadsheet application. This requires communication between the mobile application and the desktop application of application data and application state information.

To provide this user experience APIs and may include proxies and sinks for standard communication methods of spreadsheet applications to enable seamless transition of user data from a spreadsheet application running in the first OS e.g. mobile OS to a spreadsheet application running in the second OS e.g. desktop OS . Specifically API may provide sinks that receive requests for spreadsheet application state information and proxies that request spreadsheet application state information from remote sinks. For example spreadsheet application state information may include application characteristics such as file name sheet active cell and current sheet data. API includes corresponding proxies and sinks for desktop OS applications.

Also illustrated in a second process running within desktop OS e.g. a process of the same application as process or of another application running on the desktop OS communicates with processes of the mobile OS through proxies and sinks using the application communication API layers. Notably as illustrated in multiple proxies may call into the same sink. Specifically proxy of process and proxy of process both call into sink of mobile OS process . Also as illustrated in proxy of mobile OS process calls into sink of desktop OS process . Desktop OS process also communicates with mobile OS process through proxy which makes calls into sink and sink which receives calls from proxy .

In computing environment remote communication service of mobile OS maintains a database hold on remote communication sinks instantiated through application communication APIs. Remote communication service maintains an IPC interface database with holds on each sink s . Any application running on mobile OS or desktop OS can query a sink and make calls to the sink using a local proxy.

At block of process flow one or more application s begin execution. Application s may be one or more mobile OS applications running within the mobile OS and or desktop OS applications running within the desktop OS . At block an application instantiates a proxy of proxy class within application context for a remote communication request. At block an application instantiates a sink of sink class within application context for a remote communication request. As a result in the mobile OS API context name sink class and mobile OS sink class associate the sink with a key at block . For example the mobile OS sink class may associate the sink with a name key provided by the application.

At block of process flow an application connects the proxy to a sink to provide remote communication of application data and or application state. At block the mobile OS proxy class registers the interface of the proxy with the named sink. At block library state class of the mobile OS API context establishes a connection to the remote communication service which maintains a database hold on sinks. At block the proxy is registered through the remote communication service to establish a link to the sink. Upon registration at block the IPC interface of the sink is being pushed by the remote communication service. At block the mobile OS sink class accepts the IPC interface and at block the proxy is linked through the IPC interface to the sink. Notably the API context provides the underlying registration and passing of IPC interfaces such that the applications do not need to be concerned with the underlying IPC transport. The application instantiates a proxy for a specific request of a named application and receives the requested data through the proxy.

Process flow of illustrates further aspects of app to app communication through an API according to various embodiments. Process flow illustrates app to app communication through the API layers in response to an event. Process flow also illustrates unregistering of a proxy sink interface. At block of process flow an incoming message is received over an IPC interface to a sink. This message invokes the remote method handler of the API sink class at block . The remote method handler identifies the sink through the name sink class and makes a virtual function call into the sink at block . This part of process flow illustrates that the API context handles the IPC transport including receiving the IPC call through the instantiated IPC interface. In the application context the sink receives a virtual function call from the API context.

Blocks and illustrate unregistering a sink through the API. At block an event within an application results in the application unregistering proxies and or sinks of the application. One event that may cause an application to unregisters proxies and or sinks is exiting as shown in block . At block the proxy class in application context is disconnected from connected sinks Block shows the proxy being unregistered from a sink. At block the API calls into the IPC interface. On the remote side this call will unregister the proxy i.e. the remote communication service will unregister the proxy in the database hold on sinks .

At block the first operating system receives a request to instantiate a proxy for the predetermined remote communication request within a second application running within a second operating system the first and second operating systems running concurrently on a shared kernel. At block the first operating system passes a reference to the extended inter process communication interface to the second application. At this point the proxy in the second application is linked to the sink of the first application and requests through the proxy will be received and processed by the sink of the first application.

As described above in one embodiment an Android mobile OS and a Linux desktop OS Hydroid run concurrently on the same shared kernel of a single mobile computing device. The Android mobile OS provides a mobile computing experience through mobile computing hardware and the Linux desktop OS provides a desktop computing experience through a secondary terminal environment having a user experience profile associated with the Linux OS. However other OS combinations are contemplated as within various embodiments of the invention. For example various aspects of the invention may be used to run Windows Mobile and Windows 7 on a shared kernel or sharing common kernel mode processes. As another example iOS and Mac OS X running on a shared kernel is also within the scope of various embodiments. Furthermore aspects of the invention may be used advantageously by combinations of embedded OSs and desktop or mobile OSs running on a shared kernel.

The foregoing description has been presented for purposes of illustration and description. Furthermore the description is not intended to limit embodiments of the invention to the form disclosed herein. While a number of exemplary aspects and embodiments have been discussed above those of skill in the art will recognize certain variations modifications permutations additions and sub combinations thereof.

The various operations of methods described above may be performed by any suitable means capable of performing the corresponding functions. The means may include various hardware and or software component s and or module s including but not limited to a circuit an application specific integrated circuit ASIC or processor.

The various illustrative logical blocks modules and circuits described may be implemented or performed with a general purpose processor a digital signal processor DSP an ASIC a field programmable gate array signal FPGA or other programmable logic device PLD discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any commercially available processor controller microcontroller or state machine. A processor may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

The steps of a method or algorithm described in connection with the present disclosure may be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module may reside in any form of tangible storage medium. Some examples of storage media that may be used include random access memory RAM read only memory ROM flash memory EPROM memory EEPROM memory registers a hard disk a removable disk a CD ROM and so forth. A storage medium may be coupled to a processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. A software module may be a single instruction or many instructions and may be distributed over several different code segments among different programs and across multiple storage media.

The methods disclosed herein comprise one or more actions for achieving the described method. The method and or actions may be interchanged with one another without departing from the scope of the claims. In other words unless a specific order of actions is specified the order and or use of specific actions may be modified without departing from the scope of the claims.

The functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions on a tangible computer readable medium. A storage medium may be any available tangible medium that can be accessed by a computer. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other tangible medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein include compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers.

Thus a computer program product may perform operations presented herein. For example such a computer program product may be a computer readable tangible medium having instructions tangibly stored and or encoded thereon the instructions being executable by one or more processors to perform the operations described herein. The computer program product may include packaging material.

Software or instructions may also be transmitted over a transmission medium. For example software may be transmitted from a website server or other remote source using a transmission medium such as a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technology such as infrared radio or microwave.

Further modules and or other appropriate means for performing the methods and techniques described herein can be downloaded and or otherwise obtained by a user terminal and or base station as applicable. For example such a device can be coupled to a server to facilitate the transfer of means for performing the methods described herein. Alternatively various methods described herein can be provided via storage means e.g. RAM ROM a physical storage medium such as a CD or floppy disk etc. such that a user terminal and or base station can obtain the various methods upon coupling or providing the storage means to the device. Moreover any other suitable technique for providing the methods and techniques described herein to a device can be utilized.

Other examples and implementations are within the scope and spirit of the disclosure and appended claims. For example due to the nature of software functions described above can be implemented using software executed by a processor hardware firmware hardwiring or combinations of any of these. Features implementing functions may also be physically located at various positions including being distributed such that portions of functions are implemented at different physical locations. Also as used herein including in the claims or as used in a list of items prefaced by at least one of indicates a disjunctive list such that for example a list of at least one of A B or C means A or B or C or AB or AC or BC or ABC i.e. A and B and C . Further the term exemplary does not mean that the described example is preferred or better than other examples.

Various changes substitutions and alterations to the techniques described herein can be made without departing from the technology of the teachings as defined by the appended claims. Moreover the scope of the disclosure and claims is not limited to the particular aspects of the process machine manufacture composition of matter means methods and actions described above. Processes machines manufacture compositions of matter means methods or actions presently existing or later to be developed that perform substantially the same function or achieve substantially the same result as the corresponding aspects described herein may be utilized. Accordingly the appended claims include within their scope such processes machines manufacture compositions of matter means methods or actions.

