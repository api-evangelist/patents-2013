---

title: Modularizing complex XML data for generation and extraction
abstract: A mechanism is provided for creating modules from an XML schema. The mechanism includes creating a syntax tree from a sample XML fragment of the XML schema, creating a module with a list of parameters based on the syntax tree, identifying variable pieces of information in the syntax tree to be inserted in the list of parameters with a variable sign, and inserting the variable information into the list of parameters. The mechanism includes inserting another module in the syntax tree of the module, in which the other module corresponds to another sample XML fragment and has another list of parameters, and identifying the other module with the variable sign in the syntax tree of the module. The mechanism includes inserting the other module into the list of parameters of the module in which the other module to serve as a parameter, and providing an option for constraining the module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047325&OS=09047325&RS=09047325
owner: International Business Machines Corporation
number: 09047325
owner_city: Armonk
owner_country: US
publication_date: 20130408
---
The present disclosure relates to simplifying a large original XML model e.g. a hierarchical data model into a simpler XML model and more specifically a software tool for creating and manipulating modules.

Extensible markup language XML is a markup language that defines a set of rules for encoding documents in a format that is both human readable and machine readable. It is defined in the XML 1.0 Specification produced by the W3C and several other related specifications which are all gratis open standards.

 Unicode character By definition an XML document is a string of characters. Almost every legal Unicode character may appear in an XML document.

Processor and application The processor analyzes the markup and passes structured information to an application. The specification places requirements on what an XML processor must do and not do but the application is outside its scope. The processor as the specification calls it is often referred to colloquially as an XML parser.

Markup and content The characters making up an XML document are divided into markup and content which may be distinguished by the application of simple syntactic rules. Generally strings that constitute markup either begin with the character and end with a or they begin with the character and end with a . Strings of characters that are not markup are content. In addition whitespace before and after the outermost element is classified as markup.

Tag A markup construct that begins with and ends with . Tags come in three types start tags for example end tags for example empty element tags for example .

Element A logical document component either begins with a start tag and ends with a matching end tag or consists only of an empty element tag. The characters between the start and end tags if any are the element s content and may contain markup including other elements which are called child elements.

Attribute A markup construct consisting of a name value pair that exists within a start tag or empty element tag.

XML is a textual data format with strong support via Unicode for the languages of the world. Although the design of XML focuses on documents it is widely used for the representation of arbitrary data structures for example in web services. Many application programming interfaces APIs have been developed to aid software developers with processing XML data and several schema systems exist to aid in the definition of XML based languages.

An XML schema is a description of a type of XML document typically expressed in terms of constraints on the structure and content of documents of that type above and beyond the basic syntactical constraints imposed by XML itself. These constraints are generally expressed using some combination of grammatical rules governing the order of elements Boolean predicates that the content must satisfy data types governing the content of elements and attributes and more specialized rules such as uniqueness and referential integrity constraints.

According to an embodiment a method and computer program product for creating modules from an XML schema is provided. The method includes creating a syntax tree from a sample XML fragment where the sample XML fragment is an instance of a sample fragment of the XML schema and creating a module based on the syntax tree of the sample XML fragment. The module includes a list of parameters and the syntax tree. The method includes identifying on a computer variable pieces of information in the syntax tree to be inserted in the list of parameters by designating the variable pieces of information with a variable sign inserting the variable pieces of information into the list of parameters of the module based on the variable pieces of information being designated with the variable sign and inserting another module in the syntax tree of the module. The other module corresponds to another sample XML fragment of the XML schema and has another list of parameters. The method includes identifying the other module with the variable sign in the syntax tree of the module inserting the other module designated with the variable sign into the list of parameters of the module in which the other module serves as a parameter and providing an option for constraining the module. Constraining the module allows creation of a cloned module by refining the list of parameters of the module already existing without visibly displaying mapping to the sample XML fragment and without requiring a user to be aware of the mapping to the sample XML fragment.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with the advantages and the features refer to the description and to the drawings.

Many industries need to produce and exchange complicated information. For example in healthcare one might need to transmit the discharge summary for a patient s two week stay in the hospital from one institution to another. Standards that use XML documents to represent such information are common because XML offers great flexibility is platform neutral and is widely adopted. XML permits information to be placed in a strict context based on a high level data model and standard terminologies e.g. in healthcare standards such as SNOMED CT Systematized Nomenclature of Medicine Clinical Terms ICD9 International Classification of Diseases etc. can be used to give the model s elements precise semantics.

However the information that clients need to convey is not originally produced in a semantically rich XML format. Rather the information lies in heterogeneous relational and legacy format databases and in textual or multi media documents. Due to the diverse nature of the original systems and technologies used to produce the data examples from healthcare include EMRs electronic medical record PACS picture archiving and communication system HIS hospital information system LIS laboratory information system etc. it is often the case that the information held within them needs to go through additional computational processing to be identified and used. For example a text document detailing a hospital stay might list numerous medications. In order to put this information into the standard XML format each medication would first need to be correctly identified in the text and assigned an appropriate medical code. The end result of this process is typically a set of small snippets of information collected from many sources and represented as simply as possible that must be placed into context and assembled into a coherent whole that complies with the XML standard. A similar problem exists when consuming standard compliant documents. Analytic tools typically operate on data in a relational format and are less capable of directly integrating data in complex XML formats. If a data scientist or developer knows that all they are looking for out of a set of documents is information about medications a set of simple objects describing each medication is preferable to a complex XML document as discussed in embodiment.

Creating custom code to produce or decompose complex XML documents can be very laborious across different client environments. On the other hand generating code automatically from standard XML schemas results in APIs that are difficult to use and as difficult to wade through as the original standards. One can quickly be overwhelmed by a standard s breadth and expressiveness and lose precious development time. However embodiments provide a methodology and a technology that together modularize this data mapping problem and make it easier to focus on the data of interest e.g. medications and to build up a bidirectional mapping between individual snippets of information e.g. simplified schemas respectively corresponding to modules and complete documents e.g. large complex XML schema by using reusable components called modules.

One conventional approach is a model based approach for specifying mappings between different message formats and a central domain dictionary . In order to transform between format X and format Y one needs two maps one that maps X from to dictionary D and another that maps format Y from to dictionary D. In embodiment the approach can be couched in this framework when the message format X is the complex standard XML format and the dictionary D is a simplified flattened set of models for the domain. Unlike embodiments the conventional approach uses transforms or conversion rules which are specified manually. However embodiments are configured to generate its conversions using the tooling discussed herein which supports modularity and reuse.

In another conventional approach a graphical tool is used for the specification of mappings between message formats models schemas. This conventional approach requires a schema or model for both the source and target of a transformation. In order to create a transformation between simple objects and standard formats a user has to first define a schema or model for the simple objects map the elements of the simplified model source to the standard target model and then specify any elements in the target model that have fixed values as assignments. The same process has to be repeated in reverse to map the target model back to the simplified model and achieve bi directional transformation. However embodiments disclosed herein take a different approach which frees the user from doing these tedious and error prone mapping tasks. Instead of requiring a schema for the simple model to be defined a priori embodiments instead use a sample instance of the complex model to guide development of the mapping thereby considerably reducing the effort required. According to embodiments the user focuses on the pieces of information in the sample that will vary from instance to instance and should therefore be included in the simplified model. Elements whose values are fixed for all instances of the target model can be identified in the sample instance and the values obtained from the sample can be supplied automatically in transformations instead of requiring the user to create an explicit assignment for each one. Instead embodiments also make use of XML instance data which helps to eliminate unlikely paths or recursion that the schema may accommodate but never occur in a production setting.

Certain examples are provided with respect to the health care industry for explanation and not limitation. The health care industry may utilize an HL7 Green CDA. This approach is a recommendation on how to implement a specific customization also known as a template of an entire complex healthcare XML standard format called the HL7 Clinical Document Architecture CDA using simplified XML schemas. HL7 Green CDA is a set of recommendations for simplifying the use of CDA through the creation of runtime artifacts such as schemas transformations . No specific tools are supplied or recommended for the creation of these artifacts. However embodiments are configured to automate the process of creating simplified schemas and bidirectional transforms between simplified schemas and standard formats such as CDA.

The modules in embodiments are designed without the limitation of the modules having to be in a specific way. The present disclosure enables the development of abstractions i.e. modules based on a specific standard representation of the data. Furthermore embodiments have a semi automated and or automated process of generating both schemas and transformations to go between a simpler format and the original complex format.

Now turning to the figures illustrates a computer system for creating and configuring modules according to an embodiment. The computer system includes one or more processors memory and input output devices .

The present disclosure provides a solution to the problem s or issue s described above by designing a tool having computer executable instructions for creating and manipulating modules such as modules through N . As discussed herein a module is an abstraction that captures the key data elements or parameters that define some piece of information while ignoring the structural details of any specific representation. The specific representation may be a large complex original model and or XML schema which in some cases may be a legacy model that is not represented in XML although XML is utilized for explanation purposes . For example in the clinical information domain the key values that define a body temperature measurement are the temperature value e.g. 99.8 the measurement unit e.g. degrees Fahrenheit and the measurement technique e.g. oral axial etc. . The tool disclosed herein allows modules abstracting such simple concepts to be defined and then composed to abstract more complex concepts or collections of concepts. For example the temperature measurement above might be part of a Vital Signs module created by the tool which in turn might be a part of a larger module representing an encounter or patient history.

Unlike other tools for creating modules or schemas the module definition process of the tool in the embodiment is instance driven. Instance driven means the tool allows the user to design the module by starting from a sample instance of the abstraction as represented by the complex XML schema not the schema itself. The advantage is that the sample instance is a standard compliant representation of the abstraction that contains exactly what the module requires no more and no less. The complex XML schema is general and can be used to represent many things and gives no guidance as to how a specific abstraction should be represented.

The user starts with a sample XML document also referred to as sample XML fragment of the large original model complex XML schema that contains an instance of the concept to be modeled in a representation in accord with the standard s best practices for design. Such samples are typically readily available from the organization promulgating the standard. Note that an instance is an occurrence or a copy of an object whether currently executing or not. Using a drag and drop paradigm the tool permits the user to designate the key data elements within the standard compliant representation including variable data that constitute the semantic content of the module which become the module s parameters. To facilitate composition another module can serve as a parameter to any module and modules can be developed in a top down or bottom up fashion. To facilitate modules that contain collections of values or concepts a parameter may be designated as repeatable.

Once modules such as modules through N are defined the tool uses their definitions to create various artifacts that facilitate the creation transformation validation and consumption of data. For example as noted above the representation of clinical concepts in HL7 s standards for interoperability of healthcare data e.g. given as the large original complex XML schema is quite complex and creation of conformant objects with existing tools is difficult and error prone. However using the tool according to embodiments given a suitable set of modules describing the relevant concepts the user can automatically create 

1 An XML schema or Ecore model for a simplified representation of each concept that is easy to instantiate and understand but yet captures its key elements.

2 A pair of XSLT transformations that perform bi directional conversion between the simplified and standard compliant representations. Compositions or collections of these concepts as modules can likewise be transformed. Note that XSLT extensible stylesheet language transformations is a language for transforming XML documents into other XML documents or other objects.

To expedite the construction of modules tailored for a particular use case an existing module can be copied and modified to represent a more specific concept clone and constrain . For example if all temperature readings collected in a particular context were measured orally in degrees Fahrenheit the tool allows one to clone an existing temperature module and constrain these elements i.e. variable parameters to fixed values. The simplified representation generated for this new module requires only the temperature value to be specified and is therefore easier for an analytic or another software application to create and or consume but the transformations of the tool that convert to from the standard compliant representation i.e. the large original complex XML schema supply or remove this fixed information automatically. By utilizing the composition and clone and constrain mechanisms of the tool a user can start with a library or dictionary of basic modules and rapidly create those more specific modules needed for some specific purpose. For example the tool is configured to allow the user to add the basic module as parameters into the specific module and for creating the specific module as further discussed.

Achieving similar results using existing state of the art would be more difficult. As an assumption a user would need to carry out two steps most likely using two different tools in the state of the art 1 Design a simplified representation and create an XML schema to represent it. Although there are many schema definition tools designing a schema de novo is more difficult than selecting key elements from an instance and specifying a small number of properties like repeatability. 2 Use a mapping tool to create XSLT transformations between the simplified representation and the standard compliant representation and vice versa. As noted above mapping tools require an in depth knowledge of both the source and target schemas and often require the user to express complex conditions to select the relevant parts of the source document to be transformed while excluding those with similar structure. However according to embodiments the instance based approach of the tool is far simpler because the user can refer to a sample document e.g. sample XML document that satisfies the necessary conditions and let the tool do the work of formulating them. In addition to requiring the user to switch among multiple tools in the state of the art existing tools for both steps typically provide little support for composition and reuse. Note the necessary conditions means that the sample document should be a valid example of the abstraction the module in intended to represent. For example if the user wants to represent a blood pressure then the sample must include all of the attributes required by the standard to be considered a valid blood pressure.

Now turning to a specific example of module creation and configuration for explanation purposes and not limitation. B C D E F G and H generally referred to as illustrate specific examples e.g. displayed to the user of utilizing the tool to create and configure modules according to an embodiment.

To show various module operations by the tool describes operations and the life cycle of a module including module creation module composition and module cloning. During module creation the tool is configured to execute various operations as illustrated in . Reference can be made to .

At block the tool is configured to bootstrap the module being created with a sample XML document . The sample XML document is provided in advance and an example sample XML document is shown in . The user may select a specific fragment of an instance of the complex XML schema or the whole document to be the sample XML document by using XPath query or an XML document navigator of the tool and this maps the sample XML document to the module as understood by one skilled in the art. The tool creates a syntax tree by traversing the selected sample XML fragment document as shown in . For each element or attribute in the sample XML document a node is created and is added to the parent node in the syntax tree . Initially the tool is configured to designate each node of type FixedNode designated with an F in the syntax tree . The tool stores the syntax tree in the created module through the syntax attribute. In the syntax tree is presented in the module editor of the tool displayed to the user. This initial syntax tree reassembles the original sample XML fragment document but can be modified as discussed herein. For example if any node i.e. element or attribute has any content or value in the syntax tree should be designated a variable node the user can select a desired node and change the selected node into a variable node via the tool .

During module creation the tool is configured to create the module from and based on the sample XML document in . The sample XML document is a sample instance utilized to create the syntax tree which is utilized to create the module in . As shown in the module includes the syntax tree general information initially empty and parameters initially empty . The syntax tree is a representation of the abstract syntactic structure of the sample XML document from the complex XML schema . Each node element of the syntax tree denotes a construct occurring in the source code e.g. XML . The syntax is abstract that it does not represent every detail appearing in the real syntax of the sample XML document . The syntax tree has two columns which are the Name column and the Value Expression column . The Name column has the names of various for various entries. The Value Expression column has the value input initially all designated as Fixed values F for those entries built from the sample XML document . As can be seen the syntax tree has a displayName Body weight an effectiveTime value 19991114 a unit kg and a weight value 86.

Continuing at block a user uses the tool to specify matching criteria to fill in module . Since there could be many elements with same name or type that exist in the sample XML document taken from original document complex XML schema in order to identify the correct element to be mapped to this module a matching criteria is defined usually for the root element of the syntax tree . The top entry in is entry . The matching criteria contains a set of conditions usually a set of fixed nodes to identify the XML fragment document from the original document which correspond to this module . is an example of a display box of tool for such matching criteria to identify the Weight observation entry in an HL7 CDA i.e. the complex XML schema which includes the template Id the code as well as the correct class code. The matching fills in information into the module of . In the module the general information section may list the name e.g. weight target namespace and namespace prefix mapping. The matching criteria selected by the user are indicated in the syntax tree.

At block the tool is configured to create the parameters and specify the target namespace in the module . From the syntax tree presented the user of the tool may identify and or the tool is configured to indicate all the variable pieces of elements or attributes in the syntax tree with a V and then turn the variable pieces into parameters . Using the module editor of the tool a user can select these Fixed nodes turning them from Fixed nodes F into variable nodes V and drag them into the parameters as shown in .

The parameters section is a table with a list of parameters for the module . Each module that is created and or copied has its own syntax tree general information section and parameters section. The parameter table can have a nested structure. The tool is configured to input the name weight in the parameters . Other parameters as sub modules may be added as discussed further. The table for the parameters has various columns required column repeat column nillable column simple type column and fixed value column. In the tool the follow columns are defined 

Required column the abstraction is not valid without a value for this parameter. A value must be specified for this parameter in the simplified schema in order to construct a valid instance of the complex schema and conversely a correct instance of the complex schema will always produce a value for this parameter in the simplified schema.

Repeat column multiple values may be supplied for this parameter when constructing an instance of the simplified schema and multiple values may be produced from an instance of the complex schema. This column is most often used for module parameters e.g. a vital signs section may contain multiple blood pressure measurements.

Fixed value column a parameter may be bound to a fixed value in a module derived from it through the clone and constrain process e.g. binding the unit to kg in a specialization of the Weight module.

Constraints column The constraints column describes any additional constraints on a simple parameter such as length min max length and pattern similar to the facet in XML schema 

The General Information section defines the target namespace for the simplified schema and the prefixes to be used for other namespaces referenced in this module. The Parameters section defines the semantic content of the module parameters may be simple values or other modules. The Hierarchy section shows how modules have been composed. The Logical hierarchy is the module composition hierarchy itself the Physical hierarchy is the hierarchical structure of elements in the simplified schema for the module.

In one case the user utilizes the tool to identify and select e.g. highlight the variable pieces of information from the instance i.e. from the syntax tree and the user adds clicks and drags the variable pieces of information into the parameters table. The variable pieces of information input into the parameters table under weight include time value and unit. The tool performs any mapping needed to utilize the identified variable pieces of information by copying the path for each node.

Referring to illustrates an example of the drag and drop operation executed by the tool for adding parameters according to an embodiment. The tool is configured to convert the dragged node e.g. copied from the syntax tree into the parameters in the syntax tree to a node of VariableNode type at block create a simple parameter of SimpleParameter type at block and set the reference of the simple parameter in the parameters to point to the variable node designated with V in the syntax tree at block . Via the tool whatever is being displayed in the parameters table forms a type definition in XML that captures the key element of the concept that this module represents. With this new type the user can create an XML instance to represent the key element values. Such instance is much simpler than the original sample XML document because many boilerplate structures and context information are already captured in the syntax tree of the module and therefore can be ignored in the new type. The user can then specify the namespace of the module . This namespace is the target namespace of the type defined by this module .

Additionally to identify and create parameters for the module the tool is configured so that the user can select e.g. right click or highlight any element or node under the name in the syntax tree . Once the elements or nodes are selected the user can designate each element with a V to indicate that the element is a variable piece of information in the tool . For all elements nodes in the syntax tree designated with the V the tool converts the elements nodes in the syntax tree to a node of VariableNode type creates a simple parameter of SimpleParameter type for the elements nodes designated as V and sets the elements nodes designated with V as simple parameters in the parameters section. As can be seen the tool presents various ways to capture and add the variable pieces of information into the parameters section.

The tool is configured to further refine the parameters such as for example changing the name setting an optional attribute and specifying any additional expand or extract pre preprocessing function.

Now for module composition the tool is configured to perform similar mechanisms as discussed above in creating another module shown in For example the tool loads in another sample XML document from the large original complex XML schema to generate a syntax tree . Particularly the tool creates a section level module called VitalSignsSection and the tool captures the logical organization of different vital signs from the syntax tree taken from the vital signs sample XML document . The module in has the same structure as discussed above for which includes the syntax tree general information and parameters all of which is specific to the particular sample XML document related to vital signs .

The tool is configured to add the previously created Weight module into the VitalSignsSection module as displayed in . In one case the use of the tool may click and drag the Weight module e.g. entry in the syntax tree of the VitalSignsSection to place the Weight module in the parameters section of the VitalSignsSection module . Accordingly by adding the Weight module to the parameters section of the VitalSignsSection the tool brings along i.e. references the parameters corresponding to the Weight module to now be applied to the VitalSignsSection module . As such the tool quickly and easily refines the parameters for the VitalSignsSection module .

As one example of adding the Weight module to the syntax tree of the VitalSignsSection module so that the Weight module can be selected by the user as a parameter in the VitalSignsSection module reference is made to . displays the listing of different modules that have been created on the left via the tool . The user has selected the VitalSignsSection module so that its syntax tree is displayed on the right note that other portions of the VitalSignsSection module are present but not shown in for the sake of conciseness . To add the Weight module and any other module to the syntax tree of the VitalSignsSection module which can then be added to the parameters of the VitalSignsSection module the user can click and drag the weight module to the syntax tree of VitalSignsSection module . This process creates the entry as an anchor point into hierarchy of the VitalSignsSection module . When user adds the Weight module to the VitalSignsSection module the user has to identify the place in the syntax tree where the Weight module is to be anchored. By anchoring the Weight module in the syntax tree the tool maps the parameters corresponding to the Weight module in the syntax tree of the VitalSignsSection module . This process can be repeated for each of the modules such as the BloodPressure Module the Height module and any other modules so that more and more modules are anchored in the syntax tree of VitalSignsSection module . Also anchoring modules into the VitalSignsSection module can be performed by replacing an existing node. For example the user may select the replace node button shown in in the tool and then select the desired node to be replaced. In this case the user may select e.g. highlight or type in the name for the text node which informs the tool that the text node is going to be replaced. Note that the text node contains the narrative description of the vital signs. The user can then select the Height module as the replacement node and or can drag the Height module over the text node . The tool is configured to anchor the Height module in the syntax tree of the VitalSignsSection module and replace the text node at that hierarchical position. The Height module now anchored as a node in the syntax tree of the VitalSignsSection module is the Vital Signs Narrative Block module. This modularity and reusability allows the user to create various modules for different use cases.

Additionally the tool may configure and create a BloodPressure module from a sample XML document for blood pressure taken from the large original complex XML schema as discussed above for the Weight module and the VitalSignsSection module . The BloodPressure module shown as entry in the syntax tree of the VitalSignsSection is added e.g. automatically by the tool and or by clicking and dragging into the parameters section of the VitalSignsSection module as shown in . As can be recognized this process allows any module to become a sub module of another module .

As another feature to configure the parameters the tool is also configured to execute clone and constrain as discussed below. For example with the new Weight module a user can further simplify the module by restricting the unit to be kg kilograms if this is the value a users expect to receive input of weight value using the clone and constrain mechanism of the tool . As one option the tool is configured for the user to select the unit in the parameter section select click the fixed value column for the unit and then enter the fixed value of kg in the fixed value column. displays a constrain parameters dialog box which allows the user to clone the Weight module and specify constrain the fixed value to be kg .

Additionally clone and constrain of the tool allows the user to create a new module by refining the specified semantic of an existing module such as the Weight module without the need of knowing and displaying the mapping to the original instance i.e. to the original Weight module or its original sample XML document . Refining the semantics of the module means constraining the module to represent a more specific concept. For example clone and constrain of tool can be achieved by performing the following operations against a given module as shown in .

At block the tool is configured to replicate the module instance e.g. of the Weight module including the syntax tree and parameter structure into a cloned module .

The user via the tool can then specify any additional constraint such as any fixed value or the optionality of parameter at block . The additional constraint will be recorded directly in the parameter structure of the cloned module . The constraint may be always having a fixed value for the unit parameter of kg as discussed in . Also the fixed value may always be a specified number value.

At block when the original module e.g. Weight module is being referenced as sub module by other modules i.e. the Weight module is a sub module in the parameters section of the VitalSignsSection module the tool is configured to automatically add the newly cloned module to the same location in the syntax tree of any module containing the original module . For example the tool adds both the weight module and the cloned module in the parameters of the VitalSignsSection module so that the VitalSignsSection module operates according to these added parameters.

At block the tool is configured to store the original module as a reference in the newly cloned module e.g. by adding the original model in the parameters section and into the syntax tree of the newly cloned model . In this case the parameter section of the cloned modes now includes and references the Weight module .

Now turning to illustrate a module model of the tool utilized for building the modules according to an embodiment. The various operations procedures methods etc. discussed herein can be performed against module model .

With reference to sub headings are illustrated below for explanation purposes and not limitation. The module model may include the following classes 

Module The module is the top level class in the module model. A module is composed of parameters and nodes.

Parameter A parameter is used to define data elements for a given module. There are three different types of parameters that are described below.

Node A node is used to define the syntax for a module relative to the complex schema or model that the user is building the abstraction for. There are four different types of nodes that are described below.

SimpleParameter A simple parameter represents a simple data element that is typically of type String but could be typed to other simple types taken from XML Schema e.g. int boolean etc. 

ComplexParameter A complex parameter is a composition of another parameter simple complex or module . A complex parameter can be used to represent a complex data type.

ModuleParameter A module parameter represents data defined in some other module. It is a mostly opaque construct in that it is intended to be a place holder for simple or complex data elements that are defined elsewhere.

FixedNode A fixed node is a node that contains a fixed string value that will also be generated from the syntax tree.

VariableNode A variable node is a simple piece of data that varies from one instance to the next and is bound to a simple parameter.

DerivedNode A derived node gets its value from the evaluation of an expression e.g. XPath . As understood by one skilled in the art an XPath is used to navigate through elements and attributes in an XML document.

ModuleNode A module node represents a placeholder in the syntax tree where another module is referenced. During generation phase the value of the module node is computed based on the value of another module. A module node is bound to a module parameter. Like a module parameter a module node is mostly opaque.

NodeKind Node kind is used to define the type of node from an XML perspective. NodeKind has two values ELEMENT and ATTRIBUTE.

XMLSimpleType XMLSimpleType is an enumeration used to define the set of allowable XML simple types that can be used when defining a simple parameter.

Additionally the module model provides support for value sets. Value sets are predefined sets of values for a given attribute. So for example if the user has a Lab Result with a code that represents what type of Lab it is e.g. Glucose LDL cholesterol etc. the user of the tool can create a value set with all of the legal possible values for that attribute. When generating the simplified XML schema i.e. the model value sets are represented using XSD XML Schema Definition enumerations.

The module model of the tool provides support for simple data constraints. Data constraints can restrict what the actual data values look like within a simplified schema. Some examples of these constraints include 

The tool is configured to load an instance of the sample XML fragment of the complex XML schema to create a syntax tree from the sample XML fragment at block . The tool is configured to create a module based on the syntax tree of the sample XML fragment in which the module includes a list of parameters and the syntax tree at block .

At block the tool is configured to identify variable pieces of information in the syntax tree to be inserted in the list of parameters by designating the variable pieces of information with a variable sign.

The tool is configured to insert the variable pieces of information having been designated with the variable sign into the list of parameters of the module at block .

In response to creating another module having another list of parameters the tool is configured to insert the other module in the syntax tree of the module in which the other module corresponds to another sample XML fragment of the complex XML schema and the other module includes another list of parameters at block .

The tool is configured to identify the other module with the variable sign in the syntax tree of the module at block . The tool is configured to insert the other module having been designated with the variable sign into the list of parameters of the module in which the other module serves as a parameter at block .

The tool is configured to provide an option for constraining the module where constraining the module allows creation of a cloned module by refining a specified semantic of the module already existing without visibly displaying mapping to the sample XML fragment and without requiring a user to be aware of the mapping to the sample XML fragment at block .

Additionally constraining the module includes creating the cloned module as a clone of the module which includes replicating the syntax tree of the sample XML fragment and replicating the list of parameters of the module as a replicated list of parameters in the cloned module. A constraint is specified on at least one parameter in the replicated list of parameters where the constraint includes at least one of removing a requirement of inputting a value for a first variable piece of information applying a fixed value to a second variable piece of information such that the second variable piece of information becomes fixed and removing a third variable piece of information from the replicated list of parameters.

Also constraining the module further includes determining that the module is being referenced as a sub module by different modules in respective syntax trees of the different modules and based on determining that the module is being referenced as the sub module by the different modules adding the cloned module in a same location in the respective syntax trees of the different modules. The module is stored as a reference in the cloned module.

The method also includes creating a plurality of modules each respectively corresponding to a plurality of sample XML fragments of the complex XML schema where the plurality of modules respectively comprise respective lists of parameters. Each of the plurality of modules are inserted into the syntax tree of the module and for the plurality of modules that have been inserted into the syntax tree of the module the tool inserts the plurality of modules into the list of parameters for the module.

The tool the module is reusable and is or corresponds to a simplified schema as compared to the sample XML fragment from which the module was created. Multiple modules e.g. at least one or more can be created from each sample XML fragment and different sample XML fragments constitute the entire complex XML schema .

In the current embodiment the transformations are XSLT scripts that convert between the simplified schema s and the complex schema and vice versa i.e. in either direction . For example B and C generally referred to as illustrate an example of an algorithm executed by the tool to generate the expand transform according to an embodiment. In the tool is configured to move from simple to complex i.e. expand .

However illustrates an example of an algorithm executed by the tool to generate the extract transform according to an embodiment. In the tool is configured to move from complex to simple i.e. extract . The choice of XSLT as a language for implementing the transformations is not critical and the same approach could be used with other transformation languages such as e.g. XQuery.

Via the tool or other software tools in the art note that a software developer with no underlining understanding of the large complex XML schema can take the modules e.g. each simplified schema and transform the simplified schemas into an instance of the complex XML schema via the algorithm shown in . In the reverse direction the software developer with no underlining understanding of the large complex XML schema can take the large complex XML schema and transform large complex XML schema into the instances of the simplified schemas via the algorithm shown in .

Accordingly the tool output three packages 1 the simplified XML schemas such as the simplified XML schema of the Weight Module the simplified XML schema of VitalSignsSection module and the simplified XML schema of the BloodPressure module 2 the XSLT transformation from the simplified XML schemas to the complex XML schema via and 3 the XSLT transformation from the complex XML schema to the simplified schemas via .

As discussed herein the tool reduces complexity because complex data structures taken from industry standard XML based information models are reduced via abstraction i.e. created module . Application developers need only worry about the simplified schemas produced by the tooling i.e. and do not need to be experts in the underlying standard. The tool improves understandability because the simplified schemas represent abstracts of domain concepts e.g. blood pressure . This allows application developers to focus on the domain itself and not worry about the underlying representation. Additionally the tool increases productivity because the application developers can develop applications faster because they do not have the steep learning curve that a complex industry standard imposes.

Embodiments provide modularity i.e. individual modules composability i.e. the modules are created as desired by the user and reusability each created module can be reused with its parameters changes as desired and then used a sub modules in the parameters of other modules . In a state of the art system the emphasis could be based on starting with one complete monolithic sample instance. In embodiments the tool allows users to create modules i.e. unit of abstraction based on smaller instance fragments and compose those modules in different ways for different use cases.

Now further regarding the example computer the computer including the tool that may implement features discussed herein. For example various methods procedures modules flow diagrams tools applications elements and techniques discussed herein may also incorporate and or utilize the capabilities of the computer . The computer may be a distributed computer system over more than one computer.

Generally in terms of hardware architecture the computer may include one or more processors computer readable storage memory and one or more input and or output I O devices that are communicatively coupled via a local interface not shown . The local interface can be for example but not limited to one or more buses or other wired or wireless connections as is known in the art. The local interface may have additional elements such as controllers buffers caches drivers repeaters and receivers to enable communications. Further the local interface may include address control and or data connections to enable appropriate communications among the aforementioned components.

The processor is a hardware device for executing software that can be stored in the memory . The processor can be virtually any custom made or commercially available processor a central processing unit CPU a data signal processor DSP or an auxiliary processor among several processors associated with the computer and the processor may be a semiconductor based microprocessor in the form of a microchip or a macroprocessor.

The computer readable memory can include any one or combination of volatile memory elements e.g. random access memory RAM such as dynamic random access memory DRAM static random access memory SRAM etc. and nonvolatile memory elements e.g. ROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM programmable read only memory PROM tape compact disc read only memory CD ROM disk diskette cartridge cassette or the like etc. . Moreover the memory may incorporate electronic magnetic optical and or other types of storage media. Note that the memory can have a distributed architecture where various components are situated remote from one another but can be accessed by the processor .

The software in the computer readable memory may include one or more separate programs each of which comprises an ordered listing of executable instructions for implementing logical functions. The software in the memory includes a suitable operating system O S compiler source code and one or more applications such as the tool of the exemplary embodiments. As illustrated the application comprises numerous functional components for implementing the features processes methods functions and operations of the exemplary embodiments.

The operating system may control the execution of other computer programs and provides scheduling input output control file and data management memory management and communication control and related services.

The application e.g. software tool may be a source program executable program object code script or any other entity comprising a set of instructions to be performed. When a source program then the program is usually translated via a compiler such as the compiler assembler interpreter or the like which may or may not be included within the memory so as to operate properly in connection with the O S. Furthermore the application can be written as a an object oriented programming language which has classes of data and methods or b a procedure programming language which has routines subroutines and or functions.

The I O devices may include input devices or peripherals such as for example but not limited to a mouse keyboard scanner microphone camera etc. Furthermore the I O devices may also include output devices or peripherals for example but not limited to a printer display etc. Finally the I O devices may further include devices that communicate both inputs and outputs for instance but not limited to a NIC or modulator demodulator for accessing remote devices other files devices systems or a network a radio frequency RF or other transceiver a telephonic interface a bridge a router etc. The I O devices also include components for communicating over various networks such as the Internet or an intranet. The I O devices may be connected to and or communicate with the processor utilizing Bluetooth connections and cables via e.g. Universal Serial Bus USB ports serial ports parallel ports FireWire HDMI High Definition Multimedia Interface etc. .

In exemplary embodiments where the application tool is implemented in hardware the application tool can be implemented with any one or a combination of the following technologies which are each well known in the art a discrete logic circuit s having logic gates for implementing logic functions upon data signals an application specific integrated circuit ASIC having appropriate combinational logic gates a programmable gate array s PGA a field programmable gate array FPGA etc.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one more other features integers steps operations element components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated

The flow diagrams depicted herein are just one example. There may be many variations to this diagram or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the preferred embodiment to the invention had been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

