---

title: Single phase transaction commits for distributed database transactions
abstract: A distributed database system may perform a single phase commit for transactions involving updates to multiple databases of the distributed database system. A client request may be received that involves updates to multiple database of the distributed database system. The updates may be performed at a front-end database and a back-end database. Log records indicating the updates to the front-end database may be sent to the back-end database. The log records and the updates performed at the back-end database may be committed together as a single phase commit at the back-end database. In the event of a system failure of the front-end database, log records may be requested and received from the back-end database. A restoration of the front-end database may be performed based, at least in part, on the received log records.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600500&OS=09600500&RS=09600500
owner: Amazon Technologies, Inc.
number: 09600500
owner_city: Reno
owner_country: US
publication_date: 20130621
---
As the technological capacity for organizations to create track and retain information continues to grow a variety of different technologies for managing and storing the rising tide of information have been developed. Distributed database systems for example provide clients with many different specialized or customized configurations of hardware and software to manage stored information. However the increasing amounts of data organizations must store and manage often correspondingly increases both the size and complexity of data storage and management technologies like database systems which in turn escalate the cost of maintaining the information. For many distributed database systems managing and maintaining data across distributed resources also involves the reliability of storage systems. System transactions that are performed across multiple resources of distributed systems are one area where maintaining reliability can impede efficient performance. As a result new technologies more and more seek to reduce both the complexity and storage requirements of maintaining data while simultaneously improving the efficiency of data storage and data management.

While embodiments are described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that the embodiments are not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to.

Generally database systems adhere to ACID Atomicity Consistency Isolation and Durability properties in order to provide reliability when executing transactions. For distributed database systems maintaining ACID properties is further complicated by the distributed nature of the individual systems nodes or devices implementing the distributed database system. For instance if multiple nodes store the same replica of data then changes made to the data may need to be made at each of the multiple nodes in order to make the changes for the replica of data durable. Without coordinating and ensuring that these changes are made to the nodes incorrect data may be maintained.

Some distributed database systems implement a transaction coordinator to ensure that changes are received and applied across different nodes or in the case where changes at one or more nodes are not applied that the change is removed from the nodes in order to provide consistency. Multiple phase commit protocols such as the two phase commit protocol are typically implemented to provide transaction consistency across changes to multiple nodes e.g. databases . In the two phase commit protocol for example the transaction coordinator maintains the protocol state for each node involved in the transaction. Thus if 5 nodes are involved in a transaction then the state for these 5 nodes are maintained requiring no small amount of overhead. Moreover part of the multiple phase aspect of such protocols is implemented by requiring agreement among the different nodes at different phases in order to ensure transactions are consistently committed among the multiple nodes. Continuing with the 5 node example in a two phase commit protocol each node must first be queried to prepare to commit a transaction. Upon the agreement of the 5 nodes to commit the transaction then a commit request is submitted to each of the 5 nodes which also must acknowledge the commit to the transaction coordinator. Failure of a commit in either phase results in the rollback i.e. undo of the transaction at each node. Such schemes are susceptible to various coordination errors if the transaction coordinator or one or more of the nodes fail at the wrong time. In order to restart a failed node for instance a view of the state of committed or un committed transactions such as in flight transactions at the other nodes must be known in order to maintain consistency of the transaction among the 5 nodes.

This specification begins with a general description of implementing single phase transaction commits for distributed database systems. Then various examples of a distributed data warehouse service are discussed including different components modules or arrangements of components module that may be employed as part of implementing a distributed data warehouse service configured to implement single phase transaction commits. A number of different methods and techniques to implement single phase transaction commits for a distributed database system are then discussed some of which are illustrated in accompanying flowcharts. Finally a description of an example computing system upon which the various components modules systems devices and or nodes may be implemented is provided. Various examples are provided throughout the specification.

The systems described herein may in some embodiments implement various different methods and techniques for providing single phase transaction commits for distributed database transactions. Committed transactions may generally be described as transactions changes updates etc. . . . that are consistently and durably preserved at a distributed database system thus fulfilling ACID properties for the distributed database system. By implementing single phase transaction commits in various embodiments a distributed database system may reduce or eliminate the occurrence of various coordination errors and overhead for performing system transactions that are consistent among nodes systems or devices of a distributed database system. is a block diagram generally illustrating single phase transaction commits for distributed database transactions according to some embodiments.

A distributed database system may generally be any distributed database system that implements one or more databases in a distributed manner. Various different configurations of hardware such as various nodes servers desktop computers or more generally any other form of computing device and or software such as various virtual node instances or database management applications may be used to implement a distributed database system. discussed in greater detail below provide more specific examples of some configurations of a distributed database system. As illustrated in distributed database system implements two different database systems front end databases and back end database . Front end databases and back end database may be included in a variety of different distributed database system architectures and may therefore not be construed as limited in their roles by the terms front end and back end. A front end database for example may receive and apply updates after or as a result of updates applied to a back end database. These databases may also be referred to by recovery methods. For instance front end database s may implement write ahead logging for recovery purposes. While back end database may implement versioning for recovery purposes. The relationship between front end and back end databases may also be defined by independence of the data maintained between the databases. For example in some embodiments the front end database s may be dependent on the version of data maintained at the back end database which may be definitive or authoritative for the front end database s . Additionally front end database s and back end database may be of the same or different types. For example in some embodiments front end database s may be a row oriented database while back end database may be a column oriented database. In at least some embodiments front end database s may be smaller and or accessed with less frequency than back end database .

Distributed database system may also be configured to interact with various other clients systems and or devices such as by implementing a front end service module . Front end service may be configured to receive process and or evaluate various different client requests from one or more clients such as clients described in further detail below with regard to . Front end service may also implement transaction manager which may track and or maintain the status of updates for front end database s and back end database that are involved with client requests . For instance a client request may be received and may involve one or more updates to be performed among the multiple databases of distributed database system . Transaction manager may track the receipt of the client request and indicate the consistent state of the one or more updates to be applied as part of the client request . Client request may generally be any request to perform a task operation calculate manage store and or retrieve data maintained at distributed database system . Client request may be serviced by various components of distributed database system .

As noted above in various embodiments client request may be received. Client request may involve one or more updates to front end database s and to back end database . For example in some embodiments front end database s may maintain metadata describing a database schema for back end database and or access statistics for back end database . If for instance client request involves a request to add a new column to back end database then metadata maintained in front end database s may need to be updated. Thus the one or more updates applied to front end database s may be changes to the metadata related to in accordance with or as a result of updates that are to be applied to back end database .

In some embodiments front end database s may implement a front end data store. Front end data store may be any type of persistent storage device configured to persist data for front end database s . Changes updates modifications etc. to front end database s may be persisted in the front end data store. Consider again the example where front end database s maintains metadata describing a database schema for back end database . If the update applied at front end database is a change to the data type for a column in a database table schema maintained by front end database s then the persistent storage device may be configured to receive and store the updates to the metadata. A front end data store may be generally be used for any operations performed by or implemented using front end database s . For instance in described below in further detail front end database s may be used as part of a node that processes queries received for data maintained at a back end database .

As discussed above front end database s may apply front end updates to the database. In various embodiments front end database s may then generate update logs indicating the updates applied to front end database s . For example front end database may generate one or more redo logs that describe an update to front end database that may be replayed as part of the update log to perform the update. Update logs may be one or more of various types of logs such as redo logs undo logs or other log records. Update logs may be obtained received from front end database s at front end service . Front end database s may in some embodiments also send a snapshot of front end database s to be persisted e.g. to be persisted at back end database or some other persistent storage system .

In various embodiments front end service may be configured to send back end updates to be performed at back end database . Similar to updates applied at front end database s back end updates may be performed at back end database to update add remove or modify data maintained by back end database . Front end service may also be configured to send update logs which may indicate the updates performed at front end database s to be persisted at back end database system . These update logs may be persisted as part of a data object for front end database s such as a particular row or column.

Back end updates to back end database and update logs sent to be persisted at back end database may be considered a single transaction . Transaction may be tracked such as by transaction manager or some other component of distributed database system and be considered to either be committed or not committed together as part of a single phase commit. Thus for example if back end updates have been applied to back end database but update log s have not been persisted then transaction is not considered to be committed. In various embodiments a single phase commit may only require that the back end updates and the update log s be persisted at back end database in order to be committed without additional phases or maintenance of overhead concerning transaction status at front end database s .

Transaction manager may determine whether transaction committed in various ways. For example in some embodiments transaction manager may query one or more nodes implementing back end database in order to determine that transaction committed such as by receiving a commitment acknowledgment from a consensus of storage nodes. Alternatively back end database may be configured to determine and send a commit acknowledgement to transaction manager upon commitment of transaction .

In some embodiments the distributed data warehouse systems described herein may derive much of their performance and fast computing power from the use of massively parallel processing MPP and the clustering of compute nodes that carry out the execution of compiled queries using a divide and conquer strategy. In some embodiments a cluster may include one or more nodes each including one or more disks solid state devices or other persistent storage devices on which data blocks are stored on behalf of clients. In some embodiments clients subscribers may submit queries in a number of ways e.g. interactively via an SQL interface to the data warehouse system. In other embodiments external applications and programs may submit queries using Open Database Connectivity ODBC and or Java Database Connectivity JDBC driver interfaces to the data warehouse system.

In typical large database systems the time it takes to restore data from a backup may represent a significant cost to the system. For example in many existing systems the entire data set needs to be restored before the database system can be restarted following a failure in the system. In some embodiments the data warehouse systems described herein may be configured to back up data e.g. the data making up various database tables to a remote key value storage system incrementally e.g. one physical data block at a time and to store as part of each incremental backup operation a list of the all of the data blocks in the system whether they were backed up as part of that incremental backup or as part of a previous incremental backup operation. In some embodiments the remote key value storage system may be dedicated for backup storage while in other embodiments the remote key value storage system may provide general purpose storage for a variety of clients and or client applications. In various embodiments a data warehouse system a general purpose computing system or a computing system that provides another type of service that stores data locally in memory e.g. ephemerally may write one or more copies of the data to a remote key value storage system that employs disk solid state storage devices or another type of persistent storage media in order to provide durability. As described in more detail below the data warehouse systems described herein may be able to restart a cluster that stores data on behalf of a storage system subscriber e.g. in a database following a failure i.e. allowing it to accept and service queries without waiting for the entire data set to be restored from backup. Instead a backup copy of any lost or corrupted data block may be streamed into the memory of the data warehouse system from the backup system by directly addressing it in the remote system using a unique identifier of the data block as a key.

Note that in the descriptions herein the terms data block and physical data block may be used to refer to a portion or block of data that is stored as an individual or separable object in a distributed data warehouse system and or in a remote key value durable backup storage system on behalf of clients e.g. users client applications and or data warehouse service subscribers or may be used to refer to that portion or block of the data as it is stored on a physical disk in a distributed data warehouse system in system memory on a node in a distributed warehouse system e.g. in systems that implement in memory databases and or in a remote key value durable backup storage system depending on the context in which these terms appear. In some embodiments data may be stored in data blocks having the same size as a standard unit of the data stored in the memory architecture for the system which may correspond to a page in the memory. In other embodiments the data blocks may be of a different size than the page size of the memory.

In some embodiments the distributed data warehouse systems described herein may store two or more copies of each data block locally in the system e.g. across a cluster architecture . For example in one embodiment a primary copy of each 1 MB physical data block may be stored on one disk of a node in a cluster and one or more secondary copies replicas of that physical data block may be stored on other disks of other nodes in the same cluster. However rather than replicating or mirroring an entire disk on one other disk the copies of some of the data blocks stored on a given disk may be distributed on different disks than the copies of other data blocks stored on the given disk. The distributed data warehouse system may also store a copy of each data block as a separate object i.e. value in a remote backup storage system that provides durable key value storage and may store the keys for each data block within a list of data blocks in the system. For example a superblock data structure that lists all of the data blocks stored in the data warehouse system or in a node thereof may include multiple entries each of which stores metadata about an individual data block and the metadata for each block may include a unique identifier ID that serves as a key to access a copy of the data block stored in the remote backup storage system. In some embodiments the distributed data warehouse system may provide very high durability storage to its clients subscribers by storing two copies of each data block in a given cluster e.g. a primary copy and a secondary copy and storing a third copy in a remote key value durable storage system.

In some embodiments the distributed data warehouse systems described herein may employ columnar i.e. column oriented storage for database tables. In other words column information from database tables may be stored into data blocks on disk rather than storing entire rows of columns in each data block as in traditional database schemes . In some embodiments storing table data in such a columnar fashion may reduce the overall disk I O requirements for various queries and may improve analytic query performance. For example storing database table information in a columnar fashion may reduce the number of disk I O requests performed when retrieving data into memory to perform database operations as part of processing a query e.g. when retrieving all of the column field values for all of the rows in a table and may reduce the amount of data that needs to be loaded from disk when processing a query. For a given number of disk requests the column field values for many more rows may be retrieved than would be retrieved if each data block stored entire table rows. In some embodiments the disk requirements may be further reduced using compression methods that are matched to the columnar storage data type. For example since each block contains uniform data i.e. column field values that are all of the same data type disk storage and retrieval requirements may be further reduced by applying a compression method that is best suited to the particular column data type. In some embodiments the savings in space for storing data blocks containing only field values of a single column on disk may translate into savings in space when retrieving and then storing that data in system memory e.g. when analyzing or otherwise processing the retrieved data . For example for database operations that only need to access and or operate on one or a small number of columns at a time less memory space may be required than with traditional row based storage since only data blocks storing data in the particular columns that are actually needed to execute a query may be retrieved and stored in memory.

In various embodiments the distributed data warehouse systems described herein may support a standard or custom application programming interface API for a variety of database operations. For example the API may support operations for creating a database creating a table altering a table creating a user dropping a user inserting one or more rows in a table copying values selecting data from within a table e.g. querying a table cancelling or aborting a query and or other operations.

In some embodiments each cluster of the distributed data warehouse systems described herein may include a leader node and multiple computing nodes i.e. non leader nodes such as query engines each of which is virtual machine having some amount of storage e.g. multiple disks and or processing power. In some embodiments once it is configured a cluster may be directly visible by and accessible to a client subscriber through a network address. In other words a client subscriber may connect directly to a cluster e.g. to submit queries and receive responses to those queries and may not have to go through a web server or service to access the cluster except to set up and manage the configuration of the cluster. In some embodiments the leader node in each cluster which may not store client subscriber data may maintain query plans e.g. including schema information and or metadata for performing various types of queries on the data stored by the computing nodes in the cluster. Within the leader node a scheduler process may send query tasks e.g. via a private network communication fabric to the compute nodes for execution. In some embodiments the leader node may also be responsible for partitioning incoming data i.e. data included in write requests for storage on various nodes of the cluster. For example the leader node may determine the nodes on which primary copies of different portions of the received data will be stored.

In some embodiments when a client request to perform a query e.g. a read request or a write request or some other type of database operation is received e.g. by the leader node in a cluster the distributed data warehouse system may spawn a new process to maintain session information for the client and that process may be maintained as long as the client session remains open and that client is sending query requests to the leader node. The requested operation a SQL query or some other database operation may be routed through a parser and optimizer to develop a query execution plan to perform or execute the specified query or database operation i.e. the logical steps needed to perform the query . The query plan may then be routed to the execution engine which generates and compiles query execution code that the leader node and the non leader nodes sometimes referred to herein as the compute nodes will execute to complete the query. In some embodiments each of the individual execution plan steps may be involve a simple operation or manipulation of data to be performed by the compute nodes or the leader node and the communication network connecting the leader node and compute nodes may be used to distribute intermediate results. In some embodiments the distributed data warehouse system may achieve excellent query execution performance by separating query processes in each of multiple node slices in order to execute the compiled query code in parallel. In addition the distributed data warehouse system may take advantage of optimized network communication memory and disk management to pass intermediate results from one query plan step to the next which may also help to speed query execution. In some embodiments the last segment of a query may return the requested data. If the return set is to be aggregated or sorted the compute nodes may each send a respective portion of the intermediate result to the leader node which may then merge the returned data so that the final result of the query can be sent back to the requesting client subscriber.

A client such as clients through may communicate with a data warehouse cluster or via a desktop computer laptop computer tablet computer personal digital assistant mobile device server or any other computing system or other device such as computer system described below with regard to configured to send requests to the distributed data warehouse clusters and and or receive responses from the distributed data warehouse clusters and . Requests for example may be formatted as a message that includes parameters and or data associated with a particular function or service offered by a data warehouse cluster. Such a message may be formatted according to a particular markup language such as Extensible Markup Language XML and or may be encapsulated using a protocol such as Simple Object Access Protocol SOAP . Application programmer interfaces APIs may be implemented to provide standardized message formats for clients such as for when clients are communicating with distributed data warehouse service manager .

Clients through may communicate with distributed data warehouse clusters and hosted by distributed data warehouse service using a variety of different communication methods such as over Wide Area Network WAN e.g. the Internet . Private networks intranets and other forms of communication networks may also facilitate communication between clients and distributed data warehouse clusters. A client may assemble a message including a request and convey the message to a network endpoint e.g. a Uniform Resource Locator URL corresponding to the data warehouse cluster . For example a client may communicate via a desktop computer running a local software application such as a web client that is configured to send hypertext transfer protocol HTTP requests to distributed data warehouse cluster over WAN . Responses or other data sent to clients may be formatted in similar ways.

In at least some embodiments a distributed data warehouse service as indicated at may host distributed data warehouse clusters such as clusters and . The distributed data warehouse service may provide network endpoints to the clients to of the clusters which allow the clients through to send requests and other messages directly to a particular cluster. As noted above network endpoints for example may be a particular network address such as a URL which points to a particular cluster. For example client may be given the network endpoint http mycluster.com to send various request messages to. Multiple clients or users of a particular client may be given a network endpoint for a particular cluster. Various security features may be implemented to prevent unauthorized users from accessing the clusters. Conversely a client may be given network endpoints for multiple clusters.

Distributed data warehouse clusters such as data warehouse cluster and may be made up of one or more nodes. These clusters may include different numbers of nodes. A node may be a server desktop computer laptop or more generally any other computing device such as those described below with regard to computer system in . In some embodiments the number of nodes in a data warehouse cluster may be modified such as by a cluster scaling request. Nodes of a data warehouse cluster may implement one or more data slices for storing data. These data slices may be part of storage devices such as the disk storage devices discussed below with regard to . Clusters may be configured to receive requests and other communications over WAN from clients such as clients through . A cluster may be configured to receive requests from multiple clients via the network endpoint of the cluster.

In some embodiments distributed data warehouse service may be implemented as part of a web service that allows users to set up operate and scale a data warehouse in a cloud computing environment. The data warehouse clusters hosted by the web service may provide an enterprise class database query and management system that allows users to scale the clusters such as by sending a cluster scaling request to a cluster control interface implemented by the web service. Scaling clusters may allow users of the web service to perform their data warehouse functions such as fast querying capabilities over structured data integration with various data loading and ETL extract transform and load tools client connections with best in class business intelligence BI reporting data mining and analytics tools and optimizations for very fast execution of complex analytic queries such as those including multi table joins sub queries and aggregation more efficiently.

In various embodiments distributed data warehouse service may provide clients e.g. subscribers to the data warehouse service provided by the distributed data warehouse system with data storage and management resources that may be created configured managed scaled and terminated in response to requests from the storage client. For example in some embodiments distributed data warehouse service may provide clients of the system with distributed data warehouse clusters composed of virtual compute nodes. These virtual compute nodes may be nodes implemented by virtual machines such as hardware virtual machines or other forms of software implemented to simulate hardware configurations. Virtual nodes may be configured to perform the same tasks functions and or services as nodes implemented on physical hardware.

Distributed data warehouse service may be implemented by a large collection of computing devices such as customized or off the shelf computing systems servers or any other combination of computing systems or devices such as the various types of devices described below with regard to . Different subsets of these computing devices may be controlled by distributed data warehouse service manager . Distributed data warehouse service manager for example may provide a cluster control interface to clients such as clients through or any other clients or users who wish to interact with the data warehouse clusters managed by the distributed data warehouse manager which in this example illustration would be distributed data warehouse clusters and . For example distributed data warehouse service manager may generate one or more graphical user interfaces GUIs for storage clients which may then be utilized to select various control functions offered by the control interface for the distributed data warehouse clusters hosted in the distributed data warehouse service .

In at least some embodiments distributed data warehouse cluster may be implemented as part of the web based data warehousing service such as the one described above and includes a leader node and multiple compute nodes such as compute nodes and . The leader node may manage communications with storage clients such as clients through discussed above with regard to . For example a leader node may be a server that receives requests from various client programs e.g. applications and or subscribers users then parses them and develops an execution plan e.g. query plan s to carry out the associated database operation s . More specifically the leader node may develop the series of steps necessary to obtain results for complex queries and joins. Leader node may also manage the communications among compute nodes through instructed to carry out database operations for data stored in the distributed data warehousing cluster . For example compiled code may be distributed by leader node to various ones of the compute nodes to to carry out the steps needed to perform queries and intermediate results of those queries may be sent back to the leader node . Leader node may receive data and query responses or results from compute nodes and . A database schema and or other metadata information for the data stored among the compute nodes such as the data tables stored in the cluster may be managed and stored by leader node .

Distributed data warehousing cluster may also include compute nodes such as compute nodes and . These one or more compute nodes may for example be implemented on servers or other computing devices such as those described below with regard to computer system in and each may include individual query processing slices defined for example for each core of a server s multi core processor. Compute nodes may perform processing of database operations such as queries based on instructions sent to compute nodes and from leader node . The instructions may for example be compiled code from execution plan segments and steps that are executable by the particular data compute node to which it is sent. Data compute nodes may send intermediate results from queries back to leader node for final aggregation. Each data compute node may be configured to access a certain memory and disk space in order to process a portion of the workload for a query or other database operation that is sent to one or more of the compute nodes or . Thus compute node for example may access disk up until disk .

Disks such as the disks through illustrated in may be may be implemented as one or more of any type of storage devices and or storage system suitable for storing data accessible to the data compute nodes including but not limited to redundant array of inexpensive disks RAID devices disk drives or arrays of disk drives such as Just a Bunch Of Disks JBOD used to refer to disks that are not configured according to RAID optical storage devices tape drives RAM disks Storage Area Network SAN Network Access Storage NAS or combinations thereof. In various embodiments disks may be formatted to store columnar database tables through various column oriented database schemes.

In some embodiments each of the compute nodes in a distributed data warehouse cluster may implement a set of processes running on the node server s or other computing device s operating system that manage communication with the leader node e.g. to receive commands send back data and route compiled code to individual query processes e.g. for each core or slice on the node in order to execute a given query. In some embodiments each of compute nodes includes metadata for the blocks stored on the node. In at least some embodiments this block metadata may be aggregated together into a superblock data structure which is a data structure e.g. an array of data whose entries store information e.g. metadata about each of the data blocks stored on that node i.e. one entry per data block . In some embodiments each entry of the superblock data structure includes a unique ID for a respective block and that unique ID may be used to perform various operations associated with data block. For example indications of column specific compression techniques applied to the data stored in the data block indications of default compression techniques applied to the data stored in the data block or probabilistic data structures that indicate data values not stored in a data block may all be stored in the respective entry for a data block. In some embodiments the unique ID may be generated and a corresponding entry in the superblock created by the leader node or by a computing node when the data block is first written in the distributed data warehouse system.

In various embodiments a distributed data warehouse service such as illustrated above in may implement various embodiments and techniques for single phase transaction commit for distributed database systems such as those discussed in further detail below with regard to . is a block diagram illustrating single phase transaction commits among nodes implementing a distributed data warehouse system according to some embodiments.

As state above with regard to leader node may interact with and respond to various client requests. As part of responding to various client requests in some embodiments leader node may implement a query engine . Query engine may be implemented as hardware software or some combination of hardware and software that is configured to generate and send one or more query plans that are executable by compute nodes sometimes referred to as storage nodes to respond to queries for data maintained as part of back end database for a client. As part of generating query plans query engine may obtain information from front end database . For example in some embodiments front end database may maintain a database schema mapping client names and or identifiers to back end database identifiers for data. For example query engine may access front end database to map a query for column Sales to back end database column id . Query engine may also access front end database to obtain access statistics for back end database to optimize query plans. For example query engine may distribute work in a query plan according to the expected load for each compute node as determined by access statistics in front end database . In some embodiments query engine may also access transaction manager to determine the consistent state of front end database .

Leader node may also implement front end database . In at least some embodiments front end database may be a row oriented database. Front end database may maintain metadata and other information describing back end database . For instance metadata may include a database schema that may provide mapping information as well as type structure arrangement modification storage preferences etc. of the back end database . Mapping information for instance may translate client terminology for different portions of the database such as Name column Date column or Product column to ID or index values used in the back end database system such as column 0010 for Name column 0012 for Date or column 0030 for Product. Type information such as the data types for a particular row or column are string integer char etc. may be maintained. Various other structural format or modification information may also be maintained such as column 1 has a run length encoding applied whereas column 3 has a dictionary based encoding applied. Descriptive information may also include statistical or other data related to access of a particular table or other object s of the back end database such as the number of times queries are directed toward a particular row column search term or data block as well as the time of data the amount of data retrieved or the frequency with which data is accessed.

Leader node may also implement update engine . Update engine may be implemented by hardware software or some combination thereof to direct the performance of updates in a consistent manner across the front end database and back end database . Update engine may receive a client request that triggers updates to front end database and back end database . For example client request may request an additional column be added to back end database . Update engine may provide access front end database to update the metadata maintained in front end database to include information describing the ne column. Update transaction engine may receive back from the front end database update logs describing the changes applied to the front end database. Thus in the present example the log records that indicate the changes to add information describing the new column. Update engine may also in some embodiments register the client request as a transaction at transaction manager .

In various embodiments update engine may send the back end updates to be performed at back end database . In various embodiments back end database is a columnar or column oriented database. Continuing with the example above the updates include adding an additional column to the database such as by adding a new back end data object . Update engine may also send front end update log to back end database . In some embodiments front end update log may be persisted as its own front end data object . For example log records for a front end database may in some embodiments be stored in a single column of back end database . Front end update log and back end updates may be together considered a single transaction and committed according to a single phase commit. Thus as described above with regard to transaction may not be considered committed until both front end update log and back end updates have been persisted at back end database . As back end updates and front end update log are persisted in back end database superblock may be updated to reflect the newly persisted data.

Leader node may also implement a transaction manager in order to track the status of transactions for the data warehouse cluster. In various embodiments transaction manager may be configured to determine whether a transaction is committed by querying transaction state from the compute nodes . In at least some embodiments compute nodes may implement one or more superblocks such as described above with regard to may describe the location of data stored on the compute nodes . In at least some embodiments superblocks may indicate whether transaction is committed. For example in some embodiments a versioning recovery method may be implemented where commits are performed by writing a new version of superblock for a compute node. A consistent version of the superblock may be maintained while a new version is written. The consistent version of the superblock may then be switched to the new version when writing is complete. In order to respond to query for the transaction state of transaction computes nodes may determine which version of the superblock is the consistent version for compute nodes . If the consistent version of superblock indicates that transaction is persisted and therefore committed compute nodes may send a transaction committed acknowledgment to transaction manager . Alternatively compute nodes may send transaction committed acknowledgment to transaction manager automatically upon determining that transaction is committed. In some embodiments transaction manger may send a request acknowledgment to the client who submitted request .

In the event that front end database fails leader node may be configured to restore front end database according to the various techniques discussed in detail below with regard to . The log records maintained in front end data object may be requested along with a snapshot that may be maintained in back end database system or in some other persistent storage. The log records may then be applied to restore front end database and make front end database available for access such as access by query engine or update engine .

As noted above in typical distribute database systems transactions that involve updates to multiple databases employ multiple states or phases to ensure consistency of a transaction across the multiple databases. For instance a two phase commit protocol is commonly implemented in these types of scenarios. A query to commit message from a transaction manager is sent to the database systems involved in the transaction. The database systems then perform the requested updates until reaching the commit point. The database systems may then return the agreement to commit message to the transaction manager. Upon determining that all of the database systems agree to commit then the transaction manager sends a commit message to the database systems. The database systems either commit and acknowledge the commitment or respond with an abort or failure to respond . The transaction manager either commits the transaction upon receiving an acknowledgement from all of the database systems or sends a roll back instruction if one or more fail to commit.

Implementing multiple phase or states to commit transactions requires increased overhead. In many typical implementations the state of the protocol at each database system must be maintained in addition the extra communication requirements between transaction managers and database systems. Additionally various failure scenarios such as the failure of the transaction manager may lockout or stall the performance of database systems and even require manual intervention from a distributed database system operator to complete or roll back transactions. Multiple phase commit protocols such as two phase commit burden individual databases or nodes with the concern that in flight transactions sent to other nodes may have not committed.

Many different types of distributed database systems may implement single phase transaction commits for distribute database system transactions. illustrated above provides an example of a distribute data warehouse service that implements single phase transaction commits for updates to a front end database and a back end database. While provides an illustration of multiple databases front end database s involved in distributed database system transactions implementing single phase transaction commits. The descriptions provided above with regard to are merely some examples of distributed systems implementing single phase transaction commits and are not intended to be limiting. provides a high level flowchart illustrating various methods and techniques for implementing single phase transaction commits for distributed database transactions according to various embodiments.

As indicated at a client request may be received involving one or more updates to multiple databases of a distributed database system in at least some embodiments. A client request may be one of many different types of requests directed to a distributed database storage system. For example one of the many different types of client requests discussed above with regard to such as a request to modify a database table maintained for a client. Client requests may be formatted according to one of the various different APIs or other communication protocols or technologies discussed above. In some embodiments the client request may be evaluated to identify or determine one or more transactions to be performed at the distributed database system. These transactions may consist of various updates to be applied to the multiple databases.

In some embodiments a front end database may be related to or descriptive of a back end database. One database may for instance the front end database may describe suppliers and the respective product ids supplied while the back end database may describe the particular products themselves. In various embodiments the front end database may maintain metadata or other descriptive information. For example in at least some embodiments a front end database may maintain a database schema of back end database. A database schema may provide mapping information as well as they type structure arrangement modification storage preferences etc. of the back end database. Mapping information for instance may translate client terminology for different portions of the database such as Name column Date column or Product column to ID or index values used in the back end database system such as column 0010 for Name column 0012 for Date or column 0030 for Product. Type information such as the data types for a particular row or column are string integer char etc. may be maintained. Various other structural format or modification information may also be maintained such as column 1 has a run length encoding applied whereas column 3 has a dictionary based encoding applied. Descriptive information may also include statistical or data related to access of the back end database such as the number of times queries are directed toward a particular row column search term or data block as well as the time of data the amount of data retrieved or the frequency with which data is accessed. As many other different examples of descriptive data may be envisioned the previous examples are not intended to be limiting.

In at least some embodiments the one or more updates may be performed at a front end database and a back end database of the distributed database system as indicated at . Updates may be one or more various changes to the front end and back end databases such as adding removing modifying or re writing data. As applying updates to databases is well known to those of ordinary skill in the art the following examples are not intended to be limiting. For example in at least some embodiments updates may involve an insert delete or add remove of a row column at a database table. Thus new data values are added where appropriate or removed where appropriate as part of applying the updates to the particular entries rows or columns of the database. In some embodiments the updates to the back end database and the front end database may involve different operations. If for instance the front end database maintains metadata describing the back end database and a change compression type request is received from a client for a column of a back end database then a new or modified value may be written to an entry in the front end database describing the compression type of the column while the back end database may read the column decompress the data recompress the data according to the new compression type and write the newly compressed data to the column. In various embodiments the different ways updates are applied to a database may be dependent on the database s type. For example in some embodiments a front end database may implement write ahead logging to maintain data while a back end database may implement a versioning method to maintain data at the back end database.

The multiple databases of the distributed database system including the front end database and the back end database may be of the same or different type. For example in some embodiments the front end database may be a row oriented database while the back end database may be a column oriented database. However in other embodiments the front end database may be column oriented while the back end database may be row oriented. Alternatively the front end database and the back end database may be of the same database type such as row oriented or column oriented. Similar diversity may be found when greater than two database systems are implemented such as front end databases that include row and column oriented database types along with a back end database that is a row or column oriented database type. As database type or schema may be implemented in a variety of different ways the previous examples are not intended to be limiting.

In some embodiments one or more log records indicating the updates performed at the front end database may be sent to the back end database as indicated at . Log records as described above with regard to may generally be any type of record entry or data associated with a log. A log may be any record of actions taken with respect to a database. In various embodiments log records may indicate the sequence and or timing of these actions taken with respect to the database. In at least some embodiments log records may be of many different types such as redo log records undo log records or log records associated with a transaction table. The one or more log records sent to the back end database may a group of different types of log records such as redo and undo log records sufficient to apply or remove the update to the front end database. In at least some embodiments log records may be dependent a snapshot of the front end database or some other data or record that provides a previous state of the front end database. Once received log records may be persisted as part of the back end database. In some embodiments such as illustrated in log records for the front end database may be stored along with other log records in a same data object structure row column etc. such as may be defined or allocated for storing log records for the front end database. In at least some embodiments log records may be concatenated together as a single column in the back end database.

A snapshot of the front end database may be sent to be persistently stored in at least some embodiments. A snapshot may be a record of the consistent state of some or all of the values maintained for a database. The snapshot may be stored in some embodiments in the back end database. Alternatively the snapshot may be persistently stored in some other storage service or accessible storage device. In various embodiments a snapshot may be sent to be persistently stored in response to detecting a snapshot event. A snapshot event may be a timer or some other mechanism that periodically triggers the sending of a new snapshot of the front end database to be persisted. A snapshot event may also be a limit or threshold applied to the log recording updates to the front end database such that when the threshold or limit of the number and or size of log records is exceeded a snapshot event may be detected and a new snapshot of the front end database may be sent to be persistently stored.

As indicated at the one or more log records and the one or more updates performed at the back end database may be committed together as a single phase commit at the back end database in various embodiments. As opposed to the multiple phase commits discussed above a single phase commit may direct the back end database to persistently store the one or more log records and persistently apply the one or more updates to the back end database as single transaction. Thus the one or more log records as noted above may be received and persistently stored as part of the back end database. Similarly updates associated with the client request for the back end database may also be applied and persistently stored at the back end database. Upon persistently storing and applying the one or more log records to the back end database the single transaction that includes the log records and the updates may be deemed committed. In this way updates made to the front end database and updates made to the back end database may be made consistent across the front end database and the back end database without maintaining overhead to track the status of transactions updates to be applied to both databases.

In some embodiments an acknowledgment of the commitment may be received at a transaction manager or some other module node or device that requested the log records and the updates to the back end database be committed. described above provides further examples of various techniques to determine whether updates and log records have been committed at a back end database system.

As discussed above typical distributed database systems may implement a multiple phase commit process or protocol to maintain consistent transactions across multiple databases. Often times in the event of a system or other failure the status of transactions at other database systems must be determined in order to restore a consistent state of a particular database system that has failed. is a high level flowchart illustrating a method for recovering from a system failure of a database in a distributed system implementing single phase transaction commits according to some embodiments.

As indicated at log records indicating changes to a front end database may be persisted at a back end database as part of a single phase commit for a transaction involving the indicated updates to the front end database and the back end database of a distributed. A system or some other kind of failure may occur causing the front end database to fail. For example a virtual instance implementing the front end database may stall or crash. Alternatively a physical computing device such as computing system described below regard to may lose power or restarting causing the front end database system to fail. In various embodiments upon recovery from a system failure of the front end database as indicated at the log records indicating updates to the front end database may be requested from the back end database as indicated at . Log records persisted at the back end database may as noted above with regard to be stored in a single data object in some embodiments. Log records may also comprise one of more different types of log records such as redo log records undo log records etc. . . . The requested log records may include any and or all log records persisted at the back end database that may be sufficient to reconstruct the consistent state of the front end database. In some embodiments a snapshot of the front end database may also be obtained. The snapshot may be requested from the back end database or some other service system node or device persistently storing the snapshot of the front end database. The snapshot may be in some embodiments the snapshot on which the log records are dependent.

As indicated at upon receiving the requested log records the front end database may be restored based at least in part on the requested log records according to various embodiments. Log records may be used to generate the consistent state of the front end database alone or combination with other data such as a snapshot. For example in some embodiments the entire log of changes updates made to a front end database such as the initial creation population and subsequent modification of the front end database may be persisted in the back end database. To restore the front end database the entire log may simply be replayed or applied. Alternatively in some embodiments log records persisted in the back end database may be dependent on a snapshot or some other data in order to restore the consistent state of the log. For instance the log records may describe updates to data stored in the front end database in a relative fashion such as referencing a prior data value of a block e.g. block value 12 . As many different techniques for applying logs to restore databases are well known to those of ordinary skill in the art the previous examples are not intended to be limiting as to various other methods or techniques.

In at least some embodiments as indicated at upon restoration the front end database system may be made available for receiving and or servicing access requests. discussed above provides some examples of various ways and purposes for which a front end database may service access requests as part of a distributed database system.

Computer system includes one or more processors any of which may include multiple cores which may be single or multi threaded coupled to a system memory via an input output I O interface . Computer system further includes a network interface coupled to I O interface . In various embodiments computer system may be a uniprocessor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may be any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the x86 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA. The computer system also includes one or more network communication devices e.g. network interface for communicating with other systems and or components over a communications network e.g. Internet LAN etc. . For example a client application executing on system may use network interface to communicate with a server application executing on a single server or on a cluster of servers that implement a distributed system. In another example an instance of a server application executing on computer system may use network interface to communicate with other instances of the server application that may be implemented on other computer systems.

In the illustrated embodiment computer system also includes one or more persistent storage devices and or one or more I O devices . In various embodiments persistent storage devices may correspond to disk drives tape drives solid state memory other mass storage devices or any other persistent storage device. Computer system or a distributed application or operating system operating thereon may store instructions and or data in persistent storage devices as desired and may retrieve the stored instruction and or data as needed.

Computer system includes one or more system memories that are configured to store instructions and data accessible by processor . In various embodiments system memories may be implemented using any suitable memory technology e.g. one or more of cache static random access memory SRAM DRAM RDRAM EDO RAM DDR 10 RAM synchronous dynamic RAM SDRAM Rambus RAM EEPROM non volatile Flash type memory or any other type of memory . System memory may contain program instructions that are executable by processor s to implement the methods and techniques described herein. In various embodiments program instructions may be encoded in platform native binary any interpreted language such as Java byte code or in any other language such as C C Java etc. or in any combination thereof. For example in the illustrated embodiment program instructions include program instructions executable to implement the functionality of a leader node of a cluster in a distributed data warehouse system a compute node or storage node of a cluster in a distributed data warehouse system a distributed data warehouse front end service module or any other component of a distributed database system. In some embodiments program instructions may implement multiple separate clients server nodes and or other components.

In some embodiments program instructions may include instructions executable to implement an operating system not shown which may be any of various operating systems such as UNIX LINUX Solaris MacOS Windows etc. Any or all of program instructions may be provided as a computer program product or software that may include a non transitory computer readable storage medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to various embodiments. A non transitory computer readable storage medium may include any mechanism for storing information in a form e.g. software processing application readable by a machine e.g. a computer . Generally speaking a non transitory computer accessible medium may include computer readable storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM coupled to computer system via I O interface . A non transitory computer readable storage medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc. that may be included in some embodiments of computer system as system memory or another type of memory. In other embodiments program instructions may be communicated using optical acoustical or other form of propagated signal e.g. carrier waves infrared signals digital signals etc. conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface .

In some embodiments system memory may include data store which may be configured as described herein. For example the information described herein as being stored by the data warehouse system e.g. on a leader node or a compute node such as a superblock data structure one or more data block access counters a query history an transaction log or other information used in performing the methods described herein may be stored in data store or in another portion of system memory on one or more nodes in persistent storage and or on one or more remote storage devices in various embodiments. In some embodiments and at various times system memory e.g. data store within system memory persistent storage and or remote storage may store primary copies of data blocks secondary copies i.e. replicas of data blocks backup copies of data blocks metadata associated with data blocks and or their state database configuration information and or any other information usable in implementing the methods and techniques described herein.

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the system including through network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computer system and other devices attached to a network such as other computer systems which may implement one or more server nodes and or clients of the distributed data warehouse system and or a distributed database system for example. In addition network interface may be configured to allow communication between computer system and various I O devices and or remote storage . Input output devices may in some embodiments include one or more display terminals keyboards keypads touchpads scanning devices voice or optical recognition devices or any other devices suitable for entering or retrieving data by one or more computer systems . Multiple input output devices may be present in computer system or may be distributed on various nodes of a distributed system that includes computer system . In some embodiments similar input output devices may be separate from computer system and may interact with one or more nodes of a distributed system that includes computer system through a wired or wireless connection such as over network interface . Network interface may commonly support one or more wireless networking protocols e.g. Wi Fi IEEE 802.11 or another wireless networking standard . However in various embodiments network interface may support communication via any suitable wired or wireless general data networks such as other types of Ethernet networks for example. Additionally network interface may support communication via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol. In various embodiments computer system may include more fewer or different components than those illustrated in e.g. displays video cards audio cards peripheral devices other network interfaces such as an ATM interface an Ethernet interface a Frame Relay interface etc. 

It is noted that any of the distributed system embodiments described herein or any of their components may be implemented as one or more network based services. For example leader nodes within a data warehouse system may present data storage services and or database services to clients as network based services. In some embodiments a network based service may be implemented by a software and or hardware system designed to support interoperable machine to machine interaction over a network. A network based service may have an interface described in a machine processable format such as the Web Services Description Language WSDL . Other systems may interact with the network based service in a manner prescribed by the description of the network based service s interface. For example the network based service may define various operations that other systems may invoke and may define a particular application programming interface API to which other systems may be expected to conform when requesting the various operations.

In various embodiments a network based service may be requested or invoked through the use of a message that includes parameters and or data associated with the network based services request. Such a message may be formatted according to a particular markup language such as Extensible Markup Language XML and or may be encapsulated using a protocol such as Simple Object Access Protocol SOAP . To perform a network based services request a network based services client may assemble a message including the request and convey the message to an addressable endpoint e.g. a Uniform Resource Locator URL corresponding to the network based service using an Internet based application layer transfer protocol such as Hypertext Transfer Protocol HTTP .

In some embodiments network based services may be implemented using Representational State Transfer RESTful techniques rather than message based techniques. For example a network based service implemented according to a RESTful technique may be invoked through parameters included within an HTTP method such as PUT GET or DELETE rather than encapsulated within a SOAP message.

The various methods as illustrated in the figures and described herein represent example embodiments of methods. The methods may be implemented manually in software in hardware or in a combination thereof. The order of any method may be changed and various elements may be added reordered combined omitted modified etc.

Although the embodiments above have been described in considerable detail numerous variations and modifications may be made as would become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such modifications and changes and accordingly the above description to be regarded in an illustrative rather than a restrictive sense.

