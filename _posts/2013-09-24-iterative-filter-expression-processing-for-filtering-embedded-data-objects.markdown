---

title: Iterative filter expression processing for filtering embedded data objects
abstract: A computerized device filters a set of first data objects each including primitive-valued fields and object-valued fields each specifying a respective second data object as an embedded object. A filter object specifies filter criteria as a set of filter expressions. Each first data object and its respective embedded second filter objects are processed according to the filter expressions. The processing includes iterated execution of a filter expression loop, a first iteration producing a first filter test result for each primitive-valued field of the first data object and initiating a second iteration for each object-valued field of the first data object, and the second iteration producing a second filter test result for each primitive-valued field of the respective embedded second filter object. A given first data object is included in a final set of filtered objects only if both the first and second filter test results are success test results.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09348888&OS=09348888&RS=09348888
owner: EMC Corporation
number: 09348888
owner_city: Hopkinton
owner_country: US
publication_date: 20130924
---
The present invention is related to the field of data object processing such as in the context of displaying object data in a graphical user interface of an application.

Applications used for displaying or otherwise manipulating large amounts of structured data may employ a so called object model representation by which the data is accessed. Object model representations are used for example in web delivered applications and other distributed applications in which a local client device accesses the data from a remote server. An interface to the remote data may use the Representational State Transfer REST architecture identifying data objects as resources and hiding any details of a database or other specific data storage mechanism from the application.

One need arising in applications of this kind is to apply filters to objects so as to return only relevant object data in response to a request thereby making efficient use of available communications bandwidth. REST APIs commonly support filtering in the form of explicit filter expressions included as part of REST requests and executed by REST servers against a larger set of data objects. Filtering is based on properties fields of the objects.

Typical databases used to store object data include rich functionality that supports both object model structuring as well as filtering operations. Object model structuring can be reflected in corresponding relational structuring of tables storing object data. Databases support powerful data manipulation operations such as joins that can be used to create filtered results.

It is common in object models that a given object includes both primitive valued fields i.e. fields containing data of a primitive type such as a number text string etc. as well as object valued fields i.e. fields containing references to other objects. Such referenced objects may be viewed as sub objects or embedded objects of the object that references them. Embedded objects can present a particular challenge for filtering especially when the object data is not stored in a database that provides powerful data manipulation operations such as joins. In one example herein object data is stored in an array of files and filtering must be performed by a server application lacking the facilities of an underlying database for satisfying requests that involve filtering. In this setting it is important to use an efficient technique for implementing filtering of objects containing embedded objects.

Thus a technique is disclosed for filtering and retrieving properties of embedded objects when the processing functions of a database are unavailable. A disclosed technique uses a tree based structure for handling the filtering of embedded objects. Each object is filtered separately returning only the properties from that object that the user has requested. An iterated filter expression loop is employed. Whenever a new embedded object is found within a given object a new logical branch is created and the filter expression loop is iterated for the embedded object.

More particularly a method is disclosed by which a computerized device filters a set of first data objects where each first data object includes one or more primitive valued fields and one or more object valued fields each specifying a respective second data object as an embedded object of the respective first data object. The method includes receiving a filter object specifying filter criteria in the form of a set of filter expressions to be applied to fields of the first and second data objects. Each first data object and its respective embedded second filter objects are processed according to the filter expressions. The processing includes iterated execution of a filter expression loop where a first iteration produces a first filter test result for each primitive valued field of the first data object and initiates a second iteration for each object valued field of the first data object and the second iteration produces a second filter test result for each primitive valued field of the respective embedded second filter object. A given first data object is included in a final set of filtered objects only if both the first and second filter test results are success test results.

In one embodiment the client application is a web application used for management of one or more data storage systems and the data in the object database is data related to the configuration and operation of such data storage system s . Specific examples of such data are described below. As a web application the client application may be implemented in a web based programming language such as Java JavaScript or FLEX and delivered from the server to the client where it is executed. Additionally the server may itself be part of a data storage system being managed by the client application . Examples of this type of system and web delivered storage management application are VNX and VNXe data storage arrays and UNISPHERE storage management application sold by EMC Corporation.

The object database may be realized as a relational database. The internals of the database and the queries by which it is accessed are not visible to the object model client which instead is presented with an object model structuring of data by the object model server . In one embodiment the communications between the object model client and object model server employs a so called RESTful application programming interface API where REST refers to a distributive development architecture known as representational state transfer . This interface can also be viewed as a resource oriented interface as it employs resource identifiers to identify data objects that are the subjects of requests and responses. Thus in such an embodiment the external requests E RQ and external responses E RS are REST requests and responses respectively. Specific examples are given below.

The above mentioned normal mode of operation occurs when the client is being used to access data of the object database for example as part of managing operation of a data storage system. A potentially large quantity of information may be available and used. The object database may include data such as identification and configuration data for a set of storage arrays or systems in a managed environment e.g. a datacenter as well as detailed information about each system such as identification and configuration of a set of storage devices e.g. disk drives in each system. It may also include real time operational data such as monitored environmental and performance data e.g. percent utilization throughput latencies read write command mix etc. . Other specific examples are given below.

The purpose of the demo mode of operation is to exercise the client application in more of a standalone manner without requiring a production object database or even a separate server . Demo mode can be used for a variety of purposes such as development of the client application training of new users product demonstrations in support of sales and marketing activities etc. In demo mode the client application accesses the demo data which in general includes made up or canned data created for demonstration purposes and not necessarily reflecting any real system or its operation. The demo data may be included with the demo server service as part of a demo library provided as a component of an overall package of software components that includes the client application . Preferably the demo server service supports not only read access of the demo data but also write access so that demo operation more fully represents normal operation.

In general it is assumed that the demo data is not provided in the form of a relational or similar structured database as is used for the object database . Relational databases provide a power and flexibility for data access that is not necessary for demo operation and they also carry significant overhead and complexity in terms of design maintenance and operation. Thus in one embodiment the demo data is provided in the form of an array of data files. In particular so called configuration files may be used each of which includes the data for the objects of a corresponding type in the object model. In one particular embodiment files employing JavaScript Object Notation JSON may be employed. Thus in the context of managing a data storage system for example there may be separate files for logical storage units disks etc. using names like LUN.JSON DISK.JSON etc. Alternative data organizations include eXtensible Markup Language XML . Object data is read by accessing the files and retrieving their contents.

The demo server service may also employ specialized routines called handlers that handle the request and response update based on the REST operation. For example a GET request will simply return information whereas a POST PUT will add or modify information. In one embodiment and modifications or additions are simply stored in memory the contents of the underlying configuration file for the object is not modified. In other embodiments the configurations files may themselves be modified in response to updates. Handlers may be ordered from specific to general so that they can be searched for a handler best suited for a particular operation. Handlers may also employ helper functions for obtaining information about objects to facilitate how the objects are subsequently manipulated. The process of updating an object may depend in some specific way for example on the detailed structure of that object.

One of the particular challenges of demo operation is how so called embedded objects are handled and in particular how they are filtered in response to internal requests I RQ that include filter expressions for limiting the scope of data being accessed and returned. As described more below the object model specifies the so called primitive data that is directly associated with each object such as a text string device identifier primitive for a disk drive object . The object model also specifies object contents that are themselves other objects. In one example described more below a license object includes a system sub object i.e. a reference to a data object for a data storage system that is subject to the license and the system object in turn includes primitives and may include other sub objects as well. In the present description such sub objects are also referred to as embedded objects. Because demo operation uses the demo data rather than the more powerful structure and access methods of the object database special operation is required to support filtering of embedded objects in this context.

The files may be named according to their type and the respective objects they contain. In one embodiment object data files such as XML or JSON files may be used. As an example to illustrate the naming the objects of row may be License objects and those of row may be System objects. Thus the file of row may have a name like Licenses.json for example and the file of row may have a name like Systems.json etc.

It will be appreciated that the totality of relevant information about all the Licenses in a system is stored in not just the respective License objects but also in the embedded System objects and Location objects stored in separate files . This organization presents challenges for applications making certain uses of the object data in particular to applications performing filtering of object data as described more below. The file system of the client provides no specific support for filtering in contrast to a typical database application i.e. for the O M database that provides for rich structuring of data as well as powerful data manipulation procedures such as Joins that can be used for filtering. Thus the techniques described below are used to support filtering of object data in environments such as the demo environment in which the features of a database are not available.

At one or more filter expressions are created based on the higher level filter function being performed and at a Filter object is created that includes the filter expressions. At an internal request I RQ is generated identifying object data to be obtained and returned to the requestor such as the client application . To this request is attached the Filter object created at .

Step corresponds to the functionality of the switch of . In demo mode operation proceeds to where the internal request and attached Filter object are sent to the demo server service while normal operation proceeds to where the internal request and attached Filter object are sent to the O M client . Processing by the demo server service is described below. In normal operation the O M client uses the internal request and Filter object to create the RESTful external request E RQ sent to the server . Although not shown in at a later time the O M client receives a corresponding external response E RS uses the contents to create a corresponding internal response I RS and forwards this to the client application via the switch .

When all objects have been processed at the collection or array of filtered objects that have been produced in the processing of are returned as part of the internal response I RS to the client application .

At a next filter expression of the Filter object is applied to a next object that is the subject of the request. Example filter expressions are given below. Applying the filter expression generates a result indicating whether the object meets the specified criteria success or does not meet the specified criteria failure . This result is used in a test explained below.

At is a test whether there are more fields to be processed for the current object. If not then processing proceeds to step described below. If there are more fields then at is a test whether the next field is an embedded object. If not i.e. if the field is a primitive valued field then at the success failure result for this field is recorded and processing returns to the next field test . This path represents iteration for all primitive valued fields that are specified for testing according to a given filter expression. If at it is determined that the next field is an embedded object then at the embedded object portion is selected and a new iteration is begun at for the embedded object portion. It will be appreciated that this represents movement to a next lower level in a multi level arrangement of objects. For example with reference to the iteration path from to and is executed first for the System embedded object and then a second time for the Location embedded object .

Step is performed once all the fields for a given filter expression have been processed. At this step it is determined whether the overall result for the expression is success or failure i.e. whether or not all fields have had a success indication recorded at respective iterations of step . If not then the expression fails overall which in turn means that the object being processed does not meet the filter criteria. Thus processing stops for the current object and instead returns to for a next object.

If the filter expression has succeeded for the current object then at it is tested whether this is the last filter expression of the Filter object. If not then processing iterates by returning to step for a next filter expression. If this is the last filter expression then the current object has satisfied the Filter object and is added to the collection of filtered objects to be returned.

Below is a specific example of an internal request I RQ and corresponding Filter object. The internal request is for licenses that of either of two specific versions or are for systems other than those located in Arizona and that expire before Nov. 30 2013. The Filter object is created to include filter expressions accordingly.

Internal Request GET api types license instances filter version eq 1.0.1 OR version eq 1.0.2 OR system.location.state ne Arizona AND expires lt 2013 11 30T12 00.000Z

While various embodiments of the invention have been particularly shown and described it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.

