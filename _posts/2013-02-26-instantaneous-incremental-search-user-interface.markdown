---

title: Instantaneous incremental search user interface
abstract: An incremental search user interface is implemented to reduce search requests from a client system to a server system. In one aspect, a result list is cached in a memory of the client system, where the result list corresponds to a search request from the client system to the server system. In another aspect, a check is repeatedly performed, in a predetermined time interval, to determine whether an input keystroke is received. Upon confirming the receiving of an input keystroke, based on a partial query and the cached result list, determine whether a search request to the server is unnecessary.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09122755&OS=09122755&RS=09122755
owner: SAP SE
number: 09122755
owner_city: Walldorf
owner_country: DE
publication_date: 20130226
---
Traditional information retrieval systems return search results after a submits a fully formulated search query. A system waits for the user to type the query after which it is the user who waits the system to process the search request. With such systems the user has little visibility into how effectively the formulated search query may locate information of interest prior to completion the processing of the query. The user guesses beforehand what query pattern is sufficient for the system to distinguish the desired information from other similar information within the searched content. This information access paradigm is referred to as delimited search .

Delimited search is opposed to an incremental search in which as the user types the search query character by character possible matches for the partially typed query are found and presented to the user. Incremental search is also referred to as search as you type type ahead search find as you type etc. With incremental search search query suggestions or search query results are dynamically presented potentially upon each keystroke. The incremental search provides constant feedback as to the results while the user incrementally enters the search query. Incremental searching results in an increased number of search queries generated potentially by each keystroke compared to one query per submission. The increased number of search queries may increase the system s response time as perceived by the user. The perception of increased response time may have a negative effect on user satisfaction and usability of the search interface.

Embodiments of techniques for instantaneous incremental search interface are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

User may operate with an instance of search user interface . Search user interface is a user interface of client application for incremental searching of data. In one embodiment search user interface is operable to send search requests to backend server system and to display results returned at client application in response to the requests. Search user interface is operable to search enterprise data at backend server system . For example data persisted in data source of backend server system may be queried based on the search requests. In one embodiment backend server system may have one or more data sources that are systems separate from backend server system .

Enterprise data may be structured data representing business information of an enterprise or other organization. The structured data may be identifiable and searchable based on the structure of a container that hosts the data Common form of structured data is a relational data source. A relational data source comprises a set of one or more tables. A table contains data about a set of entities that can be described by the same attributes. Tables comprise columns or attributes and rows or records. A table contains at least one column. A column indicates an attribute that can be used to describe each of the entities. A column definition may include the attribute name type size restriction default value and in some cases all of its possible values. A row indicates the set of attribute values one attribute value for each column in the table which describe a single entity. Structured data may be searchable by attributes of the entities. For example by an attribute last name of an entity business partner .

In one embodiment a search request is a request for information based on a search query. A search query may be any character based one or more keywords. Search queries may be expressed as one or more terms in a natural language. In one embodiment the search query may be of data type string . Search queries may be entered into search field e.g. characters and symbols of the search query may be typed into field . A search result of a search request is an entity including data that matches or satisfies the search query based on which the request is generated.

In one embodiment search user interface provides search results based on partially entered search query. The search results are provided incrementally upon entering keystrokes e.g. as the user is typing the search query character by character. To illustrate with an example user of client system such as a mobile phone may be looking up business partners by typing last names in search field . User may intent to search for John Doe and thus the user types in d . Upon entering character d a list of business partners such as Fred Daniels Elizabeth Daughetry John Denver etc. may be instantaneously displayed for example within no more than a second. Next user may continue by typing o and the results are updated by showing business partners whose last name begin with Do such as Hank Doane John Doe Mickey Donnoly etc. Already the business partner searched for is displayed in the list with returned results. At this point instead of completing the full last name user may directly select the desired business partner.

The incremental search provides results while the user incrementally enters the search query. Thus as the user is typing relevant results are returned and displayed. The user can glance over the results while typing. The content relevant to the user may be received potentially faster compared to a delimited search because the user may receive desired information without finishing typing a full search term or without additional manual actions such as pressing a search button. The answer searched for may be displayed before the query is completely entered. Further the user may explore displayed results while typing backspacing and retyping thus adjusting and improving the search strategy based on the results that are dynamically presented.

Typically incremental searching generates higher number of search requests to a data source compared to one request to the source per one query submission e.g. upon submitting a search request by the user via a search button. For example an incremental search user interface may potentially generate a request to backend server system upon each keystroke. In an enterprise system environment such as computer system increase in the number of requests sent to backend server system may increase the response time.

In a system environment before a search request reaches the target data source e.g. data source the request may be processed by various other systems. For example requests may be processed by reverse proxy server which is a type of proxy server that retrieves resources on behalf of client application from one or more servers such as backend server system . These resources are then returned to client application as if they originated from backend server system itself. Reverse proxy server acts as an intermediary for one or more associated servers and returns data provided by those associated servers. Then the search requests may be processed by security server which may provide functionality for user on boarding user authentication distribution of security certificates etc. In one embodiment reverse proxy server and security server may communicate via network such as an enterprise intranet network. The search requests may then be also processed by a gateway server which is an interface that exposes backend services of backend server system to consumer applications such as client application . Gateway server may be designed based on Representational State Transfer REST architecture. Gateway server permits business data content of one or more systems such as backend server system to be accessible as REST resources through a uniform stateless interface to any software system that can communicate based on Hypertext Transfer Protocol HTTP and can interpret Extensible Markup Language XML or JavaScript Object Notation NON based messages One example of such gateway server system may be SAP NetWeaver Gateway.

Once the search request is processed by reverse proxy server security server and gateway server the request reaches backend server system . In response to the search request data source is queried based on the search query and respective results are retrieved. Then the retrieved results may be processed by backend server system gateway server security server reverse proxy server until the results are provided to client application and displayed on a graphical user interface GUI of search user interface .

Processing search requests by various systems that are typical for an enterprise system environment may increase the response time to the search requests. For example user may have to wait on each keystroke. Also triggering a search request potentially upon each keystroke may generate additional load at backend server system that in turn may also increase the response time for processing the requests. In order to simulate instantaneous retrieval and display of search results the number of search requests sent to a data source may be minimized.

In one embodiment it is possible to present data to user in response to entering a search query without actually sending a search request to backend server system . For example user may be looking up business partners whose last name begin with Yi . User may type a y and a request to backend server system is sent it could be that there are no business partners whose last names begin with y in such case no results are returned. Then user types an i to determine whether there are business partners whose last name begins with yi . Another search request based on search query yi is unnecessary because if there is no business partner whose last name begins with y also there is no business partner whose last name begins with yi . To limit and reduce the number of search requests that are sent to backend server system a method to determine whether a search request is unnecessary is implemented.

In one embodiment the one or more variables are stored in a cache or other storage of the client system from which system search requests are sent. Further a list of results that are retrieved based on the cached search string is also stored in the cache i.e. a cached result list. In one embodiment results in the cached result list are ordered in a sequence for example alphabetically. The last cached result is the last result in the alphabetical sequence of results in the cached result list. For example if a user types s and a list of 50 results are returned and cached where the first result in the list is Samson and the last result in the list is Sutherland then the last cached result is Sutherland . The first cached result is the first result in the alphabetical sequence of results in the cached result list.

A prefix of a last cached result represents the initial one or more characters of the string representing the last cached result where the initial characters are equal in length to the number of characters of the current search string. Thus the prefix of the last cached result consists of an equal number of symbols as the current search string. For example if a user types an s for which results are cached and then w and the last cached result is Sutherland then cached search string equals s the current search string equals sw and the prefix of last cached result equals su e.g. the first two characters from Sutherland . An exception where the prefix of the last cached result does not consist of an equal number of symbols as the current search string is when the current search string is greater in length than the last cached result e.g. where the current search string consists of more symbols than the last cached result. In such case the prefix of the last cached result is identical to the last cached result itself. For example if a user types k upon which a search request to a backend server system is triggered and responded with a result list for the search query k . Then the user types os and thus the current search string is kos . If the last cached result of the list of results for search query k is a last name Ko then Ko is shorter in length than kos . Thus the prefix of the last cached result and the last cached result itself is ko . Therefore a prefix of a last cached result is either equal in length to a current search string or if the current search string is longer than the last cached result the prefix of the last cached result is the last cached result itself.

A prefix of a first cached result represents the initial one or more characters of the string representing the first cached result where the initial characters are equal in length to the number of characters of the current search string. Thus in one embodiment the prefix of the last cached result consists of an equal number of symbols as the current search string. In one embodiment a prefix of a first cached result is either equal in length to a current search string or if the current search string is longer than the first cached result the prefix of the first cached result is the first cached result itself.

The length of the cached result list represents the number of search results included in the cached result list. For example 10 business partners may be returned as results based on the cached search string. Hence the length of the cached result list equals 10. In one embodiment a value of a threshold that specifies a maximum number of search results that are permitted to be cached at the client system is also stored. For example in case the client system is a mobile device with limited storage capacity a limit on the size of the results that can be cached is defined. Another reason for limiting the total number of results that can be cached at the client system is that it may be uncommon or inconvenient for users to scroll through high number of search results because it is time consuming. A more typical scenario may be that a user rather further specifies the search query instead of scanning through many results. Thus to improve user experience the total number of results that may be returned and displayed at the client system may be limited for example the maximum number of results permitted to be returned to the client may be 50.

At a check is performed to determine if the cached search string is empty or blank e.g. if no value is stored for the cached search string. The cached search string may be empty if no search request is yet triggered and responded to. For example cached search string may be empty if the received input keystroke is a first inputted character of the partial search query. Cached search string may also be empty if the cache of the client is cleared. If there is no value stored for the cached search string then no results are cached on the client system. If the cached search sting is empty at a search request based on the current search string is sent to a server system to retrieve results for the partial search query and process ends.

If the cached search string is not empty another check is used to determine whether a search request based on the current search string to the server system is necessary. When the cached search string is not empty a result list based on the cached search string of the partial query is stored in the cache. In one embodiment a search request may be necessary in case there is a probability that the cached result list does not include a result that matches the current search string. At a check is performed to determine if the cached search string is a prefix of the current search string. If the cached search string is not a prefix of the current search string a search request based on the current search string is sent to the server system and process ends. The cached search string may not be a prefix of the current search string if for example the user backspaces to replace the last one or more characters of the partial search query. For example the user may type search query sw that represents the cached search string and then backspaces once and types u to replace w e.g. to correct a typo. Thus the cached search string sw is not a prefix of the current search string su and a search request to the server system based on su is sent.

If the cached search string is a prefix of the current search string a check is performed to determine whether a search request to the server system is unnecessary. In one embodiment a search request to the server may be unnecessary when matches or results to the current search string can be retrieved from the cached result list. At a check is performed to determine if the cached search string is identical to the current search string. For example the user may search a business partner with last name Samson . Characters sa may be already typed and stored as the cached search string. The results of the cached search string are also cached. Then the user may type n instead of m . The user may quickly backspace before a response to a search request for the string san is received if a request for san has been triggered. In such case after removing character n the current search string is again sa and is identical to the cached search string although keystroke input is received. One string is identical to another string in case the symbols of both strings are identical or alphabetically equal and also the symbols are in the same order in both strings. In one embodiment even if case of the symbols lowercase or uppercase does not match the strings may still be considered to be alphabetically equal or identical. If the current search string is identical to the cached search string at it is indicated that a search request based on the current search string to the server is unnecessary and process ends. Results retrieved based on the same search query as the current search string are already cached at the client system. In the case where the cached search string is identical to the current search string commonly the user either enters more characters to further specify the search query or the user is finished typing for example the user may press the search button or select one of the listed results.

If the current search string is not identical to the cached search string another check is performed to determine whether a search request to the server system is unnecessary. At a check is performed to determine whether the length of the cached result list is less than a maximum. For example it is checked if the length of the cached result list is below a value of the threshold that specifies the maximum total number of search results that are permitted to be cached at the client system. At this stage it is already determined that the cached search string is not empty and results retrieved based on the cached search string are stored as the cached result list. Also it is determined that the cached search string is a prefix of the current search string but not identical to the current search string. Hence the current search string may further narrow down or specify the cached search string e.g. the user may have appended additional one or more characters to the search query represented by cached search string. For example the cached search string may be sa and the current search string may be sam .

If the length of the cached result list is less than the maximum then the cached result list includes all available matches of the cached search string. There are no results that are excluded from the cached result list because the cached result list does not exceed the maximum number of total results permitted to be cached. For example the cached result list includes all business partners available at the data source whose last name start with sa . In such a case the cached result list also includes all available matches of the current search string e.g. sam . If the cached result list includes all business partners available at the data source whose last name starts with sa then it also includes all business partners whose last name starts with sam . If the length of the cached result list is less than the maximum it is determined that the cached result list already includes matches to the current search string and a search request to the server based on the current search string is unnecessary and process ends.

If the length of the cached result list is not less than the maximum it is concluded that the total number of matches to the cached search string that are available at the sever system may not be determined or estimated. There may be more results available that are not returned and cached at the client system. Thus another check is performed to determine whether a search request to the server system is unnecessary. At a check is performed to determine if the prefix of the last cached result is alphabetically after the current search string. In one embodiment if two search strings that include numbers are compared the increasing order of the numbers is compared to determine if one string is alphabetically after or before the other. If the prefix of the last cached result is alphabetically after the current search string then possible matches of the current search string are already available at the cached results list. Thus search request to the server is unnecessary and process ends. If the prefix of the last cached result is not alphabetically after the current search string then a search request based on the current search string is sent to the server.

If the prefix of the last cached result is not alphabetically after it is determined that more results may be available that are not returned and cached at the client system or that the total number of results that match the current search string are equal to the maximum number of results that are permitted to be cached. If the prefix of the last cached result is equal to the current search string then it is possible that matches for the current search string may be excluded from the cached result list because the threshold is exceeded. For example the user may be looking up for a business partner with last name Simson and the current search string may be sim . The last cached result may be Simpson and thus the prefix sim of the last cached result Simpson is equal to the current search. Because the prefix of the last cached result is equal to the current search string more results that match the current search string and are alphabetically after the last cached result may be available but not cached. For example the result Simson that match the query sim is alphabetically after the last result Simpson and may be excluded because of exceeded threshold.

At this stage if the prefix of the last cached result is equal to the current search string it is concluded that possible matches for the current search string sim that are available at the server system may be excluded from the cached result list. In such case the prefix of the last cached result is not alphabetically after the current search string thus it is determined that a search request to the server is necessary and process ends. Likewise if current search string is longer than the last cached result and thus the prefix of the last cached result is the last cached result itself then the last cached result is not alphabetically after the current search string and thus it is determined that a search request to the server is necessary and process ends. In one embodiment instead of sending a search request based on the current search string more keystrokes have to be inputted so that the partial search query is further specified e.g. by further completing the partial search query. For example such scenario may be common if few characters are entered and the characters are insufficient to effectively locate desired information. In one embodiment it may be indicated to the user that more characters are expected to be inputted.

In one embodiment if the prefix of the last cached result is equal to the current search string and if the number of search results exceeds the threshold another check may be performed in such case a prefix of the first cached result may be compared to the prefix of the last cached result. If the prefix of the first cached result is alphabetically equal to the prefix of the last cached result which is equal to the current search string the user may request that more results are returned and displayed at the client system e.g. by scrolling down. For example if the user is looking up for a business partner with last name Smith and has typed sm as the current search string if the threshold equals 100 and there are 500 business partners available at the server system whose last name is or begins with Smith then the user may request to retrieve matching results that are not displayed but are available at the sever. Such scenario is possible for example when there are numerous identical matches to the partial search query for example numerous business partners with last name Smith . In one embodiment process prevents sending search requests to a backend server system by identifying cases where such requests based on the current search string are unnecessary for retrieving results matching the current search query. In cases where process determines that a search request to the server is unnecessary no additional network traffic and load to the server system are generated. Further the response time is also reduced and the search speeds up because instead of waiting for a search request to be processed by the server system matches that are cached at the client system may be instantaneously displayed to the user. Thus a better user experience may be achieved. In one embodiment in terms of algorithms complexity the running or processing time of process is constant e.g. O 1 .

At a check is performed to determine if a predetermined amount of time has passed. In one embodiment upon starting the client application process is started and is running while the client application is also running. At a timer that keeps track of time elapsed is started. The check at is repeated until the predetermined amount of time passes. In one embodiment predetermined amount of time may be any time interval within one second for example a quarter or half a second. Upon passage of the predetermined amount of time at the timer is reset. At a check is performed to determine if a keystroke of a search query is received. The search query may be partial e.g. a search term is not fully completed. The search query may also be complete. If an input of a keystroke is not received it is check if the predetermined amount of time has passed.

If a keystroke of a search query is received at it is determined if a search request to a server is unnecessary where the search request is based on the search query. In one embodiment process is executed to determine whether a search request to the server is unnecessary. Process repeatedly and continuously is executed until for example the client application is stopped.

Process throttles search requests for example requests are limited to be generated upon passage of the pre determined time interval and in case a keystroke is received within that time interval instead of generating a search request upon each received keystroke. Nonetheless that requests are generated upon passage of certain amount time a user s perception may be that results are retrieved instantaneously. For example users cannot distinguish a delay of a quarter of a second in displaying results upon entering a keystroke.

In one embodiment search requests generated by the incremental search user interface are processed asynchronously. For example keystrokes may be continuously inputted even if a request is sent or even if a request is sent but it is not responded to. Asynchronous processing may result in out of order processing of and responding to the search requests. In such a case a search interface may display results in non working order. For example if a user inputs an s then an u and both keystrokes generate a search request to a backend server system one request for business partners whose last name begin with s and one request for business partners whose last name begin with su . If 100 results are returned for the search query s and only 2 results for the search query su it is possible that the smaller in size result list is returned to the search interface faster because of the smaller size. This may be problematic because when the bigger in size result list is returned to the search interface it will overwrite the first result list. Thus results of the first query s may be displayed as results of the second query su . In one embodiment a method to discard late responses to search requests is implemented. A response is determined based on a search request and includes results of the search request. A late response is a response of an out of order request that includes a result list that is no longer relevant to the search query

At a response to the search request including a result list and the identifier of the search request are received where the result list is determined based on the search request. To match the search request to a corresponding result list of the search request the unique identifier of the request is returned along with the response to the request. The response is received at an incremental search user interface of the client system. The result list is retrieved from the backend server system.

At a check is performed to determine if the received identifier corresponds to an identifier of the most recent request if the received identifier corresponds to the identifier of the most recent search request the response is a response to the most recent search request and at the received result list is displayed and cached and process ends. The result list may be displayed on a GUI of the incremental search interface.

If the response is not a response to the most recent search request then it is determined that the response is returned out of order. In such case at a check is performed to determine if the number of results in the received result list are less than or equal to the number of results in a currently cached result list e.g. a result list that is cached at the client system and is based on a cached search string. If the number of results in the received result list is less than or equal number to the number of the currently cached results then the cached result list may be larger in size and more exhaustive than the received result list. Thus to maintain a result list in the cache that is as large as possible result lists returned out of order that are smaller or equal in size are discarded at .

In one embodiment process may prevent search requests to a backend system based on cached results of a search string previous to a current search string of a search query. A list of results that is as large as possible is maintained in the cache to increase chance that the cached result list includes matches of the current search string. In other words a result list that is as large as possible within a threshold and as large as possible among result lists that are received at the client system is maintained in the cache where the result list includes results that match a current search string. The threshold represents a maximum number of search results that are permitted to be cached at the client. Thus by overwriting a currently cached result list with result lists of late responses that are larger than the currently cached result list a result list that is as large as possible is maintained in the cache and search requests to the server system may be reduced. A larger cached result list is more likely to prevent a search request than the smaller cached result list.

If the number of results in the received result list is greater than the number of results in the cached result list or there are no results cached at a check is performed to determine whether a search request based on a current search query to a server system would have been prevented if the received result list had been cached instead of the currently cached result list. In one embodiment to determine whether a search request would have been prevented if the received result list had been cached process is performed with the received result list as the cached result list and with the most recent search string as the current search string. Then if process indicates that a search request to the server would have been unnecessary at the currently cached result list is overwritten with the received result list and process ends. For example if the newly received result list would have prevented a search request to the backend system if it had already been cached at the client system the old cached result list is discarded and the newly received out of order result becomes the new cached result list.

Process either caches result lists of most recent search requests or caches result lists of late responses that are larger than a currently cached result list and that may prevent a search request from a client to a server system. Thus in one embodiment process maintains a result list in the cache that is as large as possible and that may prevent search requests to the backend system. In the example in which a user types s then u and results of the su search query are returned first if the user sees the results and backspaces because the user meant to type sw immediately upon backspacing results beginning with s are instantaneously displayed. The results are instantaneously displayed because the out of order result list for query s is cached when it is received out of order.

In traditional delimited search interfaces a search is triggered manually by the user for example a search request may be submitted by pressing a search button. Therefore there may be an expectation of users for a GUI control with which searches may be invoked. With incremental searching searches are invoked upon receiving keystrokes. If incremental searching is combined with searching invoked via a GUI control defects may be manifested for example results may be displayed out of order. In one embodiment a non functional GUI control for searching is implemented e.g. search button in . User experience of fast response time may be created by providing a non functional search button. Upon clicking on the non functional search button the clicking may be visually indicated without invoking a search e.g. without sending a search request to a server system e.g. backend server system in . The search button may be on screen control that although it is enabled it does not perform its regular function. Instead for example by pressing the non functional search button an on screen keyboard of a client system e.g. client system in such as a mobile device may be minimized to visually signal the user that the search button is successfully pressed. From the perspective of the user response time of the search user interface is reduced and sped up. By the time the user reaches and presses the search button a search request may already have been sent to the backend server system and has been responded to with results returned to client system. Thus the user may perceive that results to the search request are returned and displayed instantaneously upon pressing the non functional search button.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented tower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term. computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc in other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders sonic concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

