---

title: Data communications in a distributed computing environment
abstract: Data communications may be carried out in a distributed computing environment that includes a plurality of computers coupled for data communications through communications adapters and an active messaging interface (‘AMI’). In such an environment, data communications may include: issuing, by a sender to a receiver, an eager SEND data communications instruction to transfer SEND data, the instruction including information describing a location and size of a send buffer in which the SEND data is stored; transmitting, by the sender to the receiver, the SEND data as eager data packets; issuing, by the receiver to the sender in dependence upon data flow conditions, a STOP instruction, the STOP instruction including an order to stop transmitting the eager data packets; and transferring the SEND data by the receiver from the sender's data location to a receive buffer by remote direct memory access (“RDMA”).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09544261&OS=09544261&RS=09544261
owner: International Business Machines Corporation
number: 09544261
owner_city: Armonk
owner_country: US
publication_date: 20130827
---
The field of the invention is data processing or more specifically methods apparatus and products for data communications in a distributed computing environment.

The development of the EDVAC computer system of 1948 is often cited as the beginning of the computer era. Since that time computer systems have evolved into extremely complicated devices. Today s computers are much more sophisticated than early systems such as the EDVAC. Computer systems typically include a combination of hardware and software components application programs operating systems processors buses memory input output devices and so on. As advances in semiconductor processing and computer architecture push the performance of the computer higher and higher more sophisticated computer software has evolved to take advantage of the higher performance of the hardware resulting in computer systems today that are much more powerful than just a few years ago.

Data communications is an area of computer technology that has experienced advances and modes of data communications today effectively implement distributed computing environments. In the 1990s a consortium that included Apollo Computer later part of Hewlett Packard IBM Digital Equipment Corporation and others developed a software system that was named Distributed Computing Environment. That software system is mentioned here for the sake of clarity to explain that the term distributed computing environment as used in this specification does not refer that software product from the 1990s. As the term is used here distributed computing environment refers to any aggregation of computers or compute nodes coupled for data communications through a system level messaging layer in their communications protocol stacks where the system level messaging layer provides active messaging messaging with callback functions. Implementations of such system level messaging include messaging layers in client server architectures messaging layers in Symmetric Multi Processing SMP architectures with Non Uniform Memory Access NUMA and messaging layers in parallel computers including Beowulf clusters and even supercomputers with many compute node coupled for data communications through such system level messaging. Common implementations of system level messaging for parallel processing include the well known Message Passing Interface MPI and the Parallel Virtual Machine PVM . Both of these permit the programmer to divide a task among a group of networked computers and collect the results of processing. Examples of MPI implementations include OpenMPI and MPICH. These and others represent examples of implementations of system level messaging that can be improved for data communications in a distributed computing environment according to embodiments of the present invention.

Parallel computing is another area of computer technology that has experienced advances. Parallel computing is the simultaneous execution of the same application split up and specially adapted on multiple processors in order to obtain results faster. Parallel computing is based on the fact that the process of solving a problem often can be divided into smaller jobs which may be carried out simultaneously with some coordination. Parallel computing expands the demands on middleware messaging beyond that of other architectures because parallel computing includes collective operations operations that are defined only across multiple compute nodes in a parallel computer operations that require particularly in supercomputers massive messaging at very high speeds. Examples of such collective operations include BROADCAST SCATTER GATHER AND REDUCE operations.

Many data communications network architectures are used for message passing among nodes in parallel computers. Compute nodes may be organized in a network as a torus or mesh for example. Also compute nodes may be organized in a network as a tree. A torus network connects the nodes in a three dimensional mesh with wrap around links. Every node is connected to its six neighbors through this torus network and each node is addressed by its x y z coordinate in the mesh. In a tree network the nodes typically are connected into a binary tree each node has a parent and two children although some nodes may only have zero children or one child depending on the hardware configuration . In computers that use a torus and a tree network the two networks typically are implemented independently of one another with separate routing circuits separate physical links and separate message buffers.

A torus network lends itself to point to point operations but a tree network typically is inefficient in point to point communication. A tree network however does provide high bandwidth and low latency for certain collective operations message passing operations where all compute nodes participate simultaneously such as for example an allgather.

There is at this time a general trend in computer processor development to move from multi core to many core processors from dual tri quad hexa octo core chips to ones with tens or even hundreds of cores. In addition multi core chips mixed with simultaneous multithreading memory on chip and special purpose heterogeneous cores promise further performance and efficiency gains especially in processing multimedia recognition and networking applications. This trend is impacting the supercomputing world as well where large transistor count chips are more efficiently used by replicating cores rather than building chips that are very fast but very inefficient in terms of power utilization.

At the same time the network link speed and number of links into and out of a compute node are dramatically increasing. IBM s BlueGene Q supercomputer for example will have a five dimensional torus network which implements ten bidirectional data communications links per compute node and BlueGene Q will support many thousands of compute nodes. To keep these links filled with data DMA engines are employed but increasingly the HPC community is interested in latency. In traditional supercomputers with pared down operating systems there is little or no multi tasking within compute nodes. When a data communications link is unavailable a task typically blocks or spins on a data transmission in effect idling a processor until a data transmission resource becomes available. In the trend for more powerful individual processors such blocking or spinning has a bad effect on latency.

Of course if an application blocks or spins on a data communications program then the application is advised immediately when the transfer of data pursuant to the instruction is completed because the application cease further processing until the instruction is completed. But that benefit comes at the cost of the block or the spin during a period of time when a high performance application could have otherwise been performing other functions. There is therefore a trend in the technology of large scale messaging toward attenuating this need to spin on a data communications resource waiting for completion of a data transfer. In some of these trends a particular data communications protocol is selected for each data communications transmission based on a variety of factors including for example total message size. Some examples of such data communications protocols include an eager protocol and a rendezvous protocol both of which are described below in greater detail. In most embodiments the sender or origin of the data transmission selects the protocol to utilize for the data communications transmission but does so without full knowledge of the receiver s or target s readiness to accept such a transmission. At times then the sender s selection of the protocol actually results in a less efficient means of data transmission.

Methods apparatus and computer program products are described for data communications in a distributed computing environment. The distributed computing environment includes a plurality of computers coupled for data communications through communications adapters and an active messaging interface AMI . Data communications in such a distributed computing environment according to embodiments of the present invention may include issuing by a sender to a receiver an eager SEND data communications instruction to transfer SEND data the instruction including information describing a location and size of a send buffer in which the SEND data is stored transmitting by the sender to the receiver the SEND data as eager data packets issuing by the receiver to the sender in dependence upon data flow conditions a STOP instruction the STOP instruction including an order to stop transmitting the eager data packets and transferring the SEND data by the receiver from the sender s data location to a receive buffer by remote direct memory access RDMA .

The foregoing and other objects features and advantages of the invention will be apparent from the following more particular descriptions of example embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of example embodiments of the invention.

Example methods apparatus and products for data communications in a distributed computing environment according to embodiments of the present invention are described with reference to the accompanying drawings beginning with . sets forth a functional block diagram of an example distributed computing environment that implements data communications according to embodiments of the present invention. The distributed computing environment of includes several computers an origin computer a target computer and other computers all of which are coupled for data communications through communications adapters and an active messaging interface AMI . For ease of illustration only the origin computer and the target computer are illustrated in detail with the communications adapters and the AMI but the other computers also are so equipped. From time to time in this specification an origin compute node may also be referred to as a sender and a target compute node may also be referred to as a receiver. 

The origin and target computers in the example of include one or more computer processors or CPUs as well as random access memory RAM . Each processor can support multiple hardware compute cores and each such core can in turn support multiple threads of execution hardware threads of execution as well as software threads. Each processor is connected to RAM through a high speed memory bus and through a high speed front side bus a bus adapter and an expansion bus to other components of the computer. Stored in RAM is an application program a module of computer program instructions that carries out user level data processing using linear SMP or parallel algorithms that include data communications among the computers in the distributed computing environment including issuing data communications instructions to the AMI .

Also shown stored in RAM is the AMI itself a module of automated computing machinery that carries out data communications in a distributed computing environment according to embodiments of the present invention. An AMI can be developed from scratch to carry out data communications in a distributed computing environment according to embodiments of the present invention using a traditional programming language such as the C programming language or C for example and using traditional programming methods to write communications routines that send and receive data among computers in the distributed computing environment through data communications networks or shared memory transfers. Such an AMI developed from scratch can expose to applications an entirely new application programming interface API . As an alternative to an AMI developed from scratch an AMI can expose a traditional API such as MPI s API to the application so that the application can gain the benefits of an AMI with no need to recode the application. As an alternative to development from scratch however existing prior art system level messaging modules may be improved to carry out data communications in a distributed computing environment according to embodiments of the present invention existing modules that already implement a traditional interface. Examples of prior art system level messaging modules that can be improved to implement data communications in a distributed computing environment according to embodiments of the present invention include such parallel communications libraries as the traditional Message Passing Interface MPI library the Parallel Virtual Machine PVM library MPICH and the like. In the example of the AMI is represented in RAM . Readers will recognize however that the representation of the AMI in RAM is a convention for ease of explanation rather than a limitation of the present invention because the AMI in fact can be implemented partly as software or firmware and hardware or even at least in some embodiments entirely in hardware.

Also stored in RAM is an operating system . An operating system is a computer software component that is responsible for execution of applications programs and for administration of access to computer resources memory processor time and I O functions on behalf of application programs. Operating systems useful for data communications in a distributed computing environment according to embodiments of the present invention include UNIX Linux Microsoft XP AIX IBM s i5 OS and others as will occur to those of skill in the art. The application the AMI and the operating system in the example of are shown in RAM but many components of such data processing modules typically are stored in non volatile memory also such as for example on a disk drive .

The origin computer of includes disk drive adapter coupled through expansion bus and bus adapter to the processor and other components of the computer . Disk drive adapter connects non volatile data storage to the computer in the form of disk drive . Disk drive adapters useful in computers for data communications in a distributed computing environment according to embodiments of the present invention include Integrated Drive Electronics IDE adapters Small Computer System Interface SCSI adapters and others as will occur to those of skill in the art. Non volatile computer memory also may be implemented as an optical disk drive electrically erasable programmable read only memory so called EEPROM or Flash memory RAM drives and so on as will occur to those of skill in the art.

The example origin computer of includes one or more input output I O adapters . I O adapters implement user oriented input output through for example software drivers and computer hardware for controlling output to display devices such as computer display screens as well as user input from user input devices such as keyboards and mice. The example computer of includes a video adapter which is an example of an I O adapter specially designed for graphic output to a display device such as a display screen or computer monitor. Video adapter is connected to processors through a high speed video bus bus adapter and the front side bus which is also a high speed bus.

The example target and origin computers of include communications adapters for data communications with other computers through a data communications network or a segment of shared memory . Such data communications may be carried out serially through RS 232 connections through external buses such as a Universal Serial Bus USW through data communications data communications networks such as Internet Protocol IP data communications networks and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer directly through shared memory or through a data communications network. Examples of communications adapters useful for data communications in a distributed computing environment according to embodiments of the present invention include modems for wired dial up communications Ethernet IEEE 802.3 adapters for wired data communications network communications and 802.11 adapters for wireless data communications network communications. In the particular example of communications adapters adapt computers for communications through a network . Examples of networks useful for data communications in a distributed computing environment according to embodiments of the present invention include Infiniband Gigabit Ethernet Fibre Channel PCI Express Serial ATA and others.

The communications adapters in the example of include direct memory access DMA adapters modules of automated computing machinery that implement through communications with other DMA adapters on other computers direct memory access to and from memory on its own computer as well as memory on other computers. Direct memory access is a way of reading and writing to and from memory among computers with reduced operational burden on computer processors a CPU initiates a DMA transfer but the CPU does not execute the DMA transfer. A DMA transfer essentially copies a block of memory from one computer to another or between RAM segments of applications on the same computer from an origin to a target for a PUT operation from a target to an origin for a GET operation for example.

Also in the example of communications adapters adapt computers for communications through a segment of shared memory . In the example of each processor or compute core has uniform access to the RAM on the same computer so that accessing a segment of shared memory is equally fast regardless where the shared segment is located in physical memory. In some embodiments however modules of physical memory are dedicated to particular processors so that a processor may access local memory quickly and remote memory more slowly a configuration referred to as a Non Uniform Memory Access or NUMA. In such embodiments a segment of shared memory can be configured locally for one endpoint and remotely for another endpoint or remotely from both endpoints of a communication. In an embodiment the origin computer and the target computer are both compute cores on the same compute node in a parallel computer and in that circumstance at least a segment of shared memory can be local to both the origin computer and the target computer . From the perspective of an origin computer transmitting data through a segment of shared memory that is configured remotely with respect to the origin endpoint transmitting data through the segment of shared memory will appear slower that if the segment of shared memory were configured locally with respect to the origin or if the segment were local to both the origin and the target. The shared memory communications adapter presents a similar interface to the AMI as do the other adapters including availability of an injection FIFO buffer . In embodiments where communications through a shared memory segment is available however it will often be faster than other methods.

The origin computer and the target computer are so labeled in this example because the origin computer is described as executing data communications instructions and therefore originating data transfers and the target computer is described as a subject of data communications instructions. The origin target distinction does not describe the direction of data flow. A DMA PUT instruction transfers data from the origin computer to the target computer a DMA GET instruction transfers data in the opposite direction from the target to the origin. In addition the description here of only one target and one origin is not a limitation. In processing collective BROADCAST as a data communications instruction a root process on an origin computer can transfer data to a large plurality of targets including for example all of the computers in the distributed computing environment including treating itself as one of the targets. Similarly in a collective GATHER origin processes on all the computers in the distributed computing environment can transfer data to a single root process on one origin computer. In client server SMP peer to peer and other architectures multiple origin computers send and receive message data among multiple target computers through an AMI.

The origin computer in the example of functions generally to carry out data communications in a distributed computing environment by receiving in the AMI from an application a sequence . . . of data communications instructions. In an embodiment the application calls a function in an API that is exposed by the AMI to insert or post the instructions into an instruction queue in the AMI. In this way the application s call to the API function is non blocking That is the application is not required to block spin or otherwise wait for completion of the processing of the data communications instructions. The application inserts or posts an instruction into the queue continues with other processing and is informed of instruction completion by the AMI through a done callback.

Each instruction specifies a transfer of payload data among computers in the distributed computing environment and at least one of the instructions specifies a callback function. Examples of data communications instructions amendable to or that can be improved to work with data communications according to embodiments of the present invention include the following as well as others that will occur to those of skill in the art 

The term payload distinguishes header data and the like in data communications. The payload data is specified typically with a buffer memory address and a quantity. The location and quantity of payload data as well as any callback functions are provided by the application as parameters of the data communications instructions . . . . A callback function is often referred to in this specification simply as a callback. Callback functions include dispatch callbacks as well as done callbacks. A dispatch callback is a function to be called upon receipt of a data communications instruction. A done callback is a function to be called upon completion of the transfer of payload data as specified by a data communications instruction. Except as otherwise stated in context discussion and description of a callback in this specification is a description of a done callback so that the term callback and done callback are generally synonyms unless otherwise stated.

The origin computer in the example of also injects by the AMI for each data communications instruction . . . into a slot in an injection FIFO buffer of a data communication adapter a transfer descriptor . The transfer descriptor specifies to the communications adapter the transfer of payload data and the slot in the injection FIFO buffer has a corresponding slot in a pending callback list . The term injection connotes the injection of transfer data into a data communications resource a network a shared memory and the like for actual transport to a target. A transfer descriptor provides a description of a data communications instruction that is recognizable or administrable by lower level data communications resources including communications adapters DMA adapters and the like. The origin computer also lists through the AMI in the corresponding slot in the pending callback list for each data communications instruction any callback function specified by that instruction and increments a pending callback counter for each listed callback function.

The communications adapter here one of that received the transfer descriptor transfers payload data in accordance with each transfer descriptor in its injection FIFO buffer and increments a transfer counter upon completion of each transfer. The origin computer through its AMI also determines from counter values whether the pending callback list presently includes callback functions for which transfers of payload data have been completed and calls through its AMI any callback functions in the pending callback list for which transfers of payload data have been completed decrementing the pending callback counter for each callback function called.

The description set forth above regarding data communications describes lower level or underlying steps that effect such data communications. The computers in the example of may also be configured to carry out data communications with one or more protocols. For example a sender such as the origin computer of may be configured to issue to a receiver an eager SEND data communications instruction to transfer SEND data. The SEND instruction may be issued by the application as call to the AMI as described above and may be processed through the AMI data communications adapters an the network as described above. The SEND instruction may include information describing data location at the sender and data size.

The sender may also transmit to the receiver the SEND data as eager data packets. The sender may transmit such packets through any one of the communications adapter or .

The receiver may be configured to issue to the sender a STOP instruction. The STOP instruction may be an order to stop transmitting the eager data packets. Data flow conditions may refer to any condition that affects data flow including for example availability in the receiver of a RECEIVE instruction corresponding to the eager SEND instruction where the RECEIVE instruction including the memory location of a receive buffer availability of temporary buffer space for the eager data packets at one or more of the receiver s adapters present network bandwidth utilization processor utilization and so on.

The receiver may also be configured to transfer the SEND data from the sender s data location to a receive buffer by remote direct memory access RDMA . Various examples of receiver transferring the SEND data from the sender s data location to a receiver buffer by RDMA such as one or more DMA GET operations are set forth below.

The arrangement of computers communications adapters and other devices making up the example distributed computing environment illustrated in are for explanation not for limitation. Data processing systems useful for data communications in a distributed computing environment according to various embodiments of the present invention may include additional servers routers other devices and peer to peer architectures not shown in as will occur to those of skill in the art. Networks in such data processing systems may support many data communications protocols including for example TCP Transmission Control Protocol IP Internet Protocol HTTP HyperText Transfer Protocol WAP Wireless Access Protocol HDTP Handheld Device Transport Protocol and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in .

For further explanation sets forth a block diagram of an example protocol stack useful in apparatus that implements data communications in a distributed computing environment according to embodiments of the present invention. The example protocol stack of includes a hardware layer a system messaging layer and an application layer . For ease of explanation the protocol layers in the example stack of are shown connecting an origin computer and a target computer although it is worthwhile to point out that in embodiments the origin computer and the target computer can be the same computer because any particular transfer can be from an origin application on a computer to a target application on the same computer. This pattern would be very common for example in a supercomputer whose compute nodes operate multi threaded. Every thread of execution on such a computer can function as both an origin or a target for data transfers through an AMI and both the origin and its target can be located on the same computer. So an origin computer and its target computer can in fact and often will be the same computer.

The application layer provides communications among applications running on the computers by invoking functions in an Active Messaging Interface AMI installed on each computer. Applications may communicate messages by invoking functions of an application programming interface API exposed by the AMI . The AMI can expose a novel custom API or the AMI can expose a traditional API such as for example an API of an MPI library to applications so that the application can gain the benefits of an AMI reduced network traffic callback functions and so on with little or no need to recode the application.

The example protocol stack of includes a system messaging layer implemented here as an Active Messaging Interface or AMI . The AMI provides system level data communications functions that support messaging in the application layer and the system messaging layer . Such system level functions are typically invoked through an API exposed to the application in the application layer .

The protocol stack of includes a hardware layer that defines the physical implementation and the electrical implementation of aspects of the hardware on the computers such as the bus network cabling connector types physical data rates data transmission encoding and many other factors for communications between the computers on the physical network medium. In computers that implement data communications in a distributed computing environment according to embodiments of the present invention the hardware layer includes communications adapters including DMA adapters and network links including routers packet switches and the like. In this particular example the hardware layer in each computer includes a communication adapter .

The origin computer in the example of functions generally to carry out data communications in a distributed computing environment by receiving in the AMI from an application a sequence . . . of data communications instructions. In an embodiment the application calls a function in an API that is exposed by the AMI to insert or post the instructions into an instruction queue in the AMI. In this way the application s call to the API function is non blocking. The application does not block or spin on the post to the instruction queue. Instead the application inserts or posts an instruction into the queue continues with other processing and is eventually informed of instruction completion by the AMI through a done callback. Each instruction . . . specifies a transfer of payload data among computers in a distributed computing environment and some of the data communications instructions specify callback functions .

The origin computer in the example of also injects by the AMI for each data communications instruction . . . into a slot in an injection FIFO buffer of a data communication adapter a transfer descriptor .

 FIFO is an abbreviation of first in first out and connotes the fact that the communications adapter processes its descriptors in the order in which they are placed in the injection FIFO buffer . The transfer descriptor specifies to the communications adapter the transfer of payload data and the slot in the injection FIFO buffer has a corresponding slot in a pending callback list . Both the injection FIFO buffer and the pending callback list are apportioned into N slots here labeled . . . N 1. The slots correspond in that 

The term pending as used here indicates that a callback has been listed but its corresponding data transfer has not yet been completed. Each done callback is called only after completion of its corresponding data transfer the transfer represented by a transfer descriptor in a corresponding slot in the injection FIFO buffer.

The communications adapter transfers payload data in accordance with each transfer descriptor in its injection FIFO buffer and increments a transfer counter upon completion of each transfer through its AMI any callback functions in the pending callback list for which transfers of payload data have been completed as it does so.

Also depicted in the example of is an adapter receive buffer at the target computer an AMI receive buffer allocated in AMI memory space of the target computer and an application receive buffer in application memory space of the target computer . From time to time any one or more of these receive buffers may be full or not yet allocated. In such an embodiment the target computer may receive from the origin computer an eager SEND data communications instruction to transfer SEND data to the target computer where the instruction includes information describing data location at the sender and data size. Then the target computer may receive the SEND data as eager data packets. Depending upon the state of the receive buffers may issue to the sender a STOP instruction including an order to stop transmitting the eager data packets and transfer the SEND data from the sender s data location to a receive buffer by RDMA.

For further explanation sets forth a calling sequence diagram illustrating an example method of data communications in a distributed computing environment according to embodiments of the present invention. The distributed computing environment in the example of may be similar to that described above with respect to . More specifically the example distributed computing environment of includes an origin compute node which is referred to here as a sender. The example distributed computing environment of also includes a target compute node which is referred to here as a receiver. 

The example sender of includes an origin endpoint an application level module of computer program instructions that among other operations is configured to call AMI functions to effect data communications between the sender and the receiver . The sender also includes an AMI . In a similar manner the example receiver includes an target endpoint configured to receive data communications from the origin compute node via an AMI at the receiver . Not shown here are communication adapters that may operate in a manner similar to those shown in and .

The sender in the example of issues to a receiver an eager SEND data communications instruction to transfer SEND data. The sender issues the eager SEND data communications instruction as a result of the origin endpoint makes a SEND call into the AMI . The AMI responsive to the SEND call issues the SEND instruction to the AMI of the receiver . The instruction may include information describing data location at the sender and data size of the SEND data.

The sender in the example of then transmits to the receiver the SEND data as eager data packets . In the example of the sender transmits multiple eager data packets increasing in size.

In the example of the receiver issues to the sender in dependence upon data flow conditions a STOP instruction . The STOP instruction includes an order to stop transmitting the eager data packets. The sender ceases transmitting eager data packets upon receipt of the STOP instruction .

Also in the example of the receiver discards eager data packets transmitted by the sender before the sender received the STOP instruction also in dependence upon data flow conditions .

Also in the example of the receiver may transfer the SEND data from the sender s data location to a receive buffer by RDMA . In the example of the data flow conditions causing the receiver to transfer the SEND data by RDMA includes the target endpoint making a call to a RECEIVE function in the AMI . The call is an example of a RECEIVE instruction that corresponds to the SEND instruction and includes a memory location of a receive buffer.

The RDMA in the example of is a remote GET operation and upon completion of the data transfer the receiver sends an acknowledgement advising the sender of the completed data transfer. The AMI of the sender receives the acknowledgement and issues a return to the origin endpoint s RECEIVE instruction or RECEIVE function call advising the origin endpoint that the data transmission is complete.

For further explanation sets forth a calling sequence diagram illustrating another example method of data communications in a distributed computing environment according to embodiments of the present invention. The calling sequence diagram of is similar to that of in that the diagram of depicts a similar distributed computing environment with a sender receiver AMIs and endpoints . The example diagram of is also similar to that of in that the diagram of includes the sender issuing to the receiver an eager SEND data communications instruction to transfer SEND data the sender transmitting to the receiver the SEND data as eager data packets the receiver issuing a STOP instruction to the sender and the receiver transferring SEND data by RDMA .

The diagram of differs from that of however in that the receiver transmits the SEND data beginning from the top of the send buffer as multiple eager send packets increasing in size. The term top refers to one end of a buffer especially when implemented as a FIFO buffer and the term bottom refers to the opposite end of the buffer.

Also in the example diagram of the receiver initially accepts the eager data packets transmitted from the sender before the sender receives the STOP instruction. At nearly the same time the receiver sends the STOP instruction the sender also issues several RDMA get instructions to transfer the SEND data beginning from the bottom of the send buffer by RDMA. In some embodiments then the receiver is issued a SEND instruction sends a STOP instruction nearly immediately and begins to accept eager data packets sent by the sender prior to the sender receiving and processing the STOP instruction. Those eager data packets include payload from the top portion of the buffer. While receiving those eager data packets the receiver begins to transfer data in increasing quantity or in predefined quantities in one or more RDMA operations from the bottom of the buffer. The sender then sends data from the top while the receiver begins transferring data from the bottom of the receive buffer.

Then in the example of the sender transmits to the receiver a clear to send CTS message advising the receiver of the quantity of eager SEND data transmitted before the sender received the STOP instruction. In this way the receiver knows both the quantity of data transferred from the bottom of the buffer and the quantity of data from the top of the buffer received as eager data packets . The receiver in the example of transfers the untransmitted SEND data from the send buffer via RDMA with one or more DMA GET operations . That is the receiver transfers only that portion of the buffer not previously transferred from the bottom of the buffer nor that portion of the top of the buffer received in data eager packets.

In such an embodiment transferring the SEND data may be carried out by the receiver transferring the SEND data of the discarded packets from the sender s data location to a receive buffer by RDMA . Upon completion the receiver may send an acknowledgement to the AMI of the sender advising the sender of completion. The AMI may then provide a return to the origin endpoint s SEND instruction advising the origin endpoint of data transmission completion.

Although not shown in the example of upon completion of the final data transfer the receiver may send an acknowledgement advising the sender of the completed data transfer. The AMI of the sender may receives the acknowledgement and issue a return to the origin endpoint s RECEIVE instruction or RECEIVE function call advising the origin endpoint that the data transmission is complete.

For further explanation sets forth a calling sequence diagram illustrating another example method of data communications in a distributed computing environment according to embodiments of the present invention. The calling sequence diagram of is similar to that of in that the diagram of depicts a similar distributed computing environment with a sender receiver AMIs and endpoints . The example diagram of is also similar to that of in that the diagram of includes the sender issuing to the receiver an eager SEND data communications instruction to transfer SEND data the sender transmitting to the receiver the SEND data as eager data packets the receiver issuing a STOP instruction to the sender and the receiver transferring SEND data by RDMA .

The diagram of differs from that of however in that the receiver initially accepts the eager data packets transmitted from the sender before the sender receives the STOP instruction . Also the STOP instruction in the example of may also include includes a designation of a receive buffer . Such a designation may include a location in memory a size and so on.

Knowing the amount of data already transmitted and accepted as eager data packets the sender also knows the amount of data remaining to be transmitted. With the designation of the receive buffer from the STOP instruction the sender rather than the receiver transfers the SEND data that was not sent before the sender received the STOP instruction from the SEND buffer into the receiver buffer by RDMA. That is the sender transfers by RDMA such as DMA PUT operation the SEND data not transmitted to the receiver in data eager packets prior to receiving the STOP instruction.

The method of includes issuing by a sender to a receiver an eager SEND data communications instruction to transfer SEND data . The instruction includes information describing data location at the sender and data size . Issuing an eager SEND data communications instruction to transfer SEND data may be carried out responsive to an AMI of the sender receiving from an application a call to a SEND function via an API exposed by the AMI. The AMI responsive to the send call may send the instruction via data communications adapters such as those set forth in the example of and in the manner described therein.

The method of also includes transmitting by the sender to the receiver the SEND data as eager data packets . Transmitting the SEND data as eager data packets may be carried out by the AMI of the sender through data communications adapters. Such packets may be of equal size or of varying size.

The method of also includes issuing by the receiver to the sender in dependence upon data flow conditions a STOP instruction. Issuing a STOP instruction may be carried out by the receiver s AMI in one or more data communications packets sent to the sender s AMI via one or more data communications adapters. The STOP instruction includes an order to stop transmitting the eager data packets. The sender upon receipt of the STOP instruction ceases transmission of the SEND.

Issuing the STOP instruction may be carried out with no utilization of an eager protocol limit. The eager protocol limit may include a data size above which a sender selects a rendezvous protocol instead of an eager protocol for transmission of data. Further issuing the STOP instruction may be carried out with no utilization of any flow control token or flow control accounting.

The method of also includes transferring by the receiver from the sender s data location to a receive buffer by remote direct memory access RDMA the SEND data . Transferring the SEND data may be carried out in some embodiments in dependence upon the data flow conditions . That is transferring the SEND data may be carried out responsive to a change in the data flow conditions after the SEND instruction is received. For example a temporary receive buffer at the receiver s adapter in the AMI memory space or in Application memory space may become available. In another example a RECEIVE instruction may be received by the receiver s AMI that corresponds to the SEND instruction issued by the sender.

Transferring the SEND data by RDMA may be carried out by the sender providing to a DMA engine in a DMA communications adapter at the sender a transfer descriptor that indicates the data location and the size of the SEND data at the sender followed by one or more GET DMA operations.

For further explanation sets forth a flow chart illustrating an example method of data communications in a distributed computing environment according to embodiments of the present invention. The method of is similar to the method of in that the method of is carried out in a similar distributed computing environment and the method of includes issuing to a receiver an eager SEND data communications instruction transmitting to the receiver the SEND data as eager data packets issuing to the sender a STOP instruction and transferring the SEND data by RDMA.

The method of differs from the method of however in that transmitting the SEND data from the sender to the receiver is carried out by transmitting multiple eager data packets increasing in size. The method of also includes discarding by the receiver the eager data packets transmitted by the sender before the sender receives the STOP instruction.

For further explanation sets forth a flow chart illustrating an example method of data communications in a distributed computing environment according to embodiments of the present invention. The method of is similar to the method of in that the method of is carried out in a similar distributed computing environment and the method of includes issuing to a receiver an eager SEND data communications instruction transmitting to the receiver the SEND data as eager data packets issuing to the sender a STOP instruction and transferring the SEND data by RDMA.

The method of differs from the method of however in that transmitting the SEND data from the sender to the receiver is carried out by transmitting beginning from the top of the send buffer the SEND data as multiple eager send packets increasing in size.

The method of also includes accepting by the receiver the eager data packets transmitted from the sender before the sender receives the STOP instruction.

Here rather than discarding the data packets received from the sender prior to the sender receiving the STOP instruction as in the method of the receiver actually accepts the data packets.

Immediately and during the acceptance of the data packets the receiver in the method of also begins transferring the SEND data beginning from the bottom of the send buffer by RDMA. In this way the receiver may transfer the SEND data from one end of the send buffer while the sender transmits SEND data as eager data packets from the opposite end of the buffer in parallel.

The sender upon receiving the STOP instruction ceases transmitting the eager data packets and transmits a CTS message to the receiver. The CTS message may include information advising the receiver of the quantity of eager SEND data transmitted before the sender received the STOP instruction. To that end the method of also includes receiving by the receiver from the sender the CTS message and transferring the untransmitted SEND data from the send buffer.

For further explanation sets forth a flow chart illustrating an example method of data communications in a distributed computing environment according to embodiments of the present invention. The method of is similar to the method of in that the method of is carried out in a similar distributed computing environment and the method of includes issuing to a receiver an eager SEND data communications instruction transmitting to the receiver the SEND data as eager data packets issuing to the sender a STOP instruction and transferring the SEND data by RDMA.

The method of differs from the method of however in that the method of includes accepting by the receiver the eager data packets sent from the sender before the sender receives the STOP instruction. The STOP instruction in the example of may also include a designation of a receive buffer. Such a designation may include a memory address of the receive buffer. To that end the method of continues by transferring not by the receiver but by the sender via RDMA into the receive buffer the SEND data that was not sent before the sender received the STOP instruction. The sender is aware of the quantity of SEND data transmitted as eager data packets and thus is aware of the quantity of SEND data that was not transmitted prior to receiving the STOP instruction. As such the sender need no other information to transfer the remaining SEND data to the receive buffer other than the location of the receive buffer.

Example embodiments of the present invention are described largely in the context of fully functional computers that implements data communications in a distributed computing environment according to embodiments of the present invention. Readers of skill in the art will recognize however that the present invention also may be embodied in a computer program product disposed upon computer readable storage media for use with any suitable data processing system. Such computer readable storage media may be any storage medium for machine readable information including magnetic media optical media or other suitable media. Examples of such media include magnetic disks in hard drives or diskettes compact disks for optical drives magnetic tape and others as will occur to those of skill in the art. Persons skilled in the art will immediately recognize that any computer system having suitable programming means will be capable of executing the steps of the method of the invention as embodied in a computer program product. Persons skilled in the art will recognize also that although some of the example embodiments described in this specification are oriented to software installed and executing on computer hardware nevertheless alternative embodiments implemented as firmware or as hardware are well within the scope of the present invention.

As will be appreciated by those of skill in the art aspects of the present invention may be embodied as method apparatus or system or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment or an embodiment combining software and hardware aspects firmware resident software micro code microcontroller embedded code and the like that may all generally be referred to herein as a circuit module system or apparatus. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable media having computer readable program code embodied thereon.

Any combination of one or more computer readable media may be utilized. Such a computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described in this specification with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowcharts and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of computer apparatus methods and computer program products according to various embodiments of the present invention. In this regard each block in a flowchart or block diagram may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustrations and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims.

