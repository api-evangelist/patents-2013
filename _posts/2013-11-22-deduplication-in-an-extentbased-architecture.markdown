---

title: Deduplication in an extent-based architecture
abstract: It is determined that a first data block contains the same data as a second data block. The first data block is associated with a first extent and the second data block is associated with a second extent. In response to determining that the first data block contains the same data as the second data block, the second data block is associated with the first extent and the first data block is disassociated with the second extent.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043287&OS=09043287&RS=09043287
owner: NetApp, Inc.
number: 09043287
owner_city: Sunnyvale
owner_country: US
publication_date: 20131122
---
This present application is a continuation of co pending U.S. patent application Ser. No. 13 165 631 filed Jun. 21 2011 which is assigned to the same assignee as the present application.

This invention relates generally to data storage systems and more particularly to deduplication in an extent based data storage system.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings hereto Copyright 2011. NetApp Inc. All Rights Reserved.

Various forms of network based storage systems exist today. These forms include network attached storage NAS storage area networks SAN s and others. Network based storage systems are commonly used for a variety of purposes such as providing multiple users with access to shared data backing up critical data e.g. by data mirroring etc.

A network based storage system typically includes at least one storage server which is a processing system configured to store and retrieve data on behalf one or more client processing systems clients . In the context of NAS a storage server may be a file server which is sometimes called a filer . A filer operates on behalf of one or more clients to store and manage shared files. The files may be stored in a storage system that includes one or more arrays of mass storage devices such as magnetic or optical disks or tapes by using a data storage scheme such as Redundant Array of Inexpensive Disks RAID . Additionally the mass storage devices in each array may be organized into one or more separate RAID groups. In a SAN context a storage server provides clients with block level access to stored data rather than file level access. Some storage servers are capable of providing clients with both file level access and block level access such as certain storage servers made by NetApp Inc. NetApp of Sunnyvale Calif.

WAFL aggregate is a physical storage container that can store data in the WAFL file system. Flexible volume is a logical volume that allows the virtualization of the allocation of volumes on physical storage . Thereby multiple independently managed flexible volumes can share the same physical storage e.g. physical storage . The virtualization requires mapping between virtual volume block numbers VVBNs used by flexible volume and physical volume block numbers PVBNs used by WAFL aggregate to access data stored in physical storage . A PVBN as used herein refers disk blocks that have been abstracted into a single linear sequence in the aggregate. Each volume container corresponds to a flexible volume . Volume container contains all the data blocks for a corresponding flexible volume .

As used herein a block offset or an offset refers to a distance in blocks from the beginning of a storage object such as a volume file extent etc. Block addresses used within flexible volume refer to block offsets within volume container . Since volume container contains every block within flexible volume there are two ways to refer to the location of a particular block. The PVBN specifies the location of a block within WAFL aggregate . The VVBN specifies the offset of the block within the container file. When a block in a file is requested flexible volume translates the file offset into a VVBN. The VVBN is passed from flexible volume to volume container . Volume container translates the VVBN to a PBVN. The PVBN is then used to access the requested block in physical storage . Additionally when a PVBN is initially written the block pointer for the PVBN in flexible volume is written to include e.g. in a cache the PVBN for the VVBN. Thereby when the requested block is required the flexible volume can use the stored PVBN to access physical storage .

Current implementations of WAFL define a file as a tree of indirect blocks. Each indirect block in the tree has a fixed span a fixed number of entries each pointing to another block in the tree. Extents are represented using an entry for each block within the extent. An extent as used herein refers a contiguous group of one or more blocks. As a result the amount of indirect block metadata is linear with respect to the size of the file. Additionally disk gardening techniques such as segment cleaning file reallocation etc. are complicated by caching PVBN pointers in VVBN blocks.

Storage systems often use a predetermined block size for all internal operations. For example WAFL uses 4 KB e.g. 4096 bytes blocks for both VVBN and PVBN as do client side file systems for file block numbers FBN . Block boundaries are expected to occur every 4 KB from an initial offset e.g. FBN 0 . Since file systems usually offset individual files based on these block boundaries application writers take advantage of a file system s block size and alignment to increase the performance of their input output I O operations for example always performing I O operations that are a multiple of 4 KB and always aligning these operations to the beginning of a file. Other file systems or applications such as a virtual machine may use a block boundary of a different size e.g. a virtual machine environment in which an initial master boot record block of 512 bytes is followed by the expected 4 KB blocks resulting in misalignment between FBN s and PVBN s. Additionally multiple virtual machines may share a single volume container and each virtual machine may misaligned by a different amount.

Storage servers may implement a deduplication algorithm. Deduplication eliminates redundant copies of data that is stored within the data storage. Deduplication is accomplished in several ways including hierarchical deduplication in line deduplication and background deduplication.

Hierarchical deduplication includes deriving one file from another usually by one file starting off as copy of another but zero or nearly zero bytes of data are actually copied or moved. Instead the two files share common blocks of data storage. An example is a snapshot where a snapshot is made of a file system such that the snapshot and active file system are equal at the time snapshot is taken and share the same data storage and thus are effectively copies that involve zero or near zero movement of data. As the source file system changes the number of shared blocks of data storage reduces. A variation of this is a writable snapshot also referred to as a clone which is taken of a file system. In this variation as the source and cloned file systems each change there are fewer shared blocks.

In line deduplication includes a storage access protocol initiator e.g. an NFS client creating content via write operations while the target of the storage access protocol checks if the content being written is duplicated somewhere else on the target s storage. If so the data is not written. Instead the logical content e.g. metadata pointer etc. refers to the duplicate.

Background deduplication includes a background task e.g. on a storage access protocol target scanning for duplicate blocks freeing all but one of the duplicates and mapping corresponding pointers or other logical content from the now free blocks to the remaining duplicate.

However these existing deduplication algorithms allow for sharing of data storage but have an impact on performance of the system since the data must be processed as it is received. Furthermore metadata used by the active file system and snapshots is not deduplicated thereby not maximizing the space efficiency of the active file system and snapshots.

Deduplication in an extent based architecture is performed by receiving a request to remove duplicate data. A log data container associated with a storage volume in a storage server is accessed. The log data container includes a plurality of entries. Each entry is identified by an extent identifier in a data structures stored in a volume associated with the storage server. For each entry in the log data container a determination is made if the entry matches another entry in the log data container. If the entry matches another entry in the log data container a determination is made of a donor extent and a recipient extent. If an external reference count associated with the recipient extent equals a first predetermined value block sharing is performed for the donor extent and the recipient extent. A determination is made if the reference count of the donor extent equals a second predetermined value. If the reference count of the donor extent equals the second predetermined value the donor extent is freed.

In the following detailed description of embodiments of the invention reference is made to the accompanying drawings in which like references indicate similar elements and in which is shown by way of illustration specific embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention and it is to be understood that other embodiments may be utilized and that logical mechanical electrical functional and other changes may be made without departing from the scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

Embodiments are described for deduplication in an extent based architecture. References in this specification to an embodiment one embodiment or the like mean that the particular feature structure or characteristic being described is included in at least one embodiment of the present invention. Occurrences of such phrases in this specification do not necessarily all refer to the same embodiment nor are they necessarily mutually exclusive.

Deduplication in an extent based architecture is performed by receiving a request to remove duplicate data in a storage server. A log data container associated with a storage volume in the storage server is accessed. The log data container includes a plurality of entries. Each entry is identified by an extent identifier in a data structures stored in a volume associated with the storage server. For each entry in the log data container a determination is made if the entry matches another entry in the log data container. If the entry matches another entry in the log data container a determination is made of a donor extent and a recipient extent. If an external reference count associated with the recipient extent equals a first predetermined value block sharing is performed for the donor extent and the recipient extent. A determination is made if the reference count of the donor extent equals a second predetermined value. If the reference count of the donor extent equals the second predetermined value the donor extent is freed. Deduplication in an extent based architecture is not required to be performed inline as data arrives. Therefore deduplication in an extent based architecture is performed after the data has been written. Moreover metadata associated with the data such as extents can be deduplicated thereby allowing for more space efficiency.

Storage of data in storage units is managed by storage servers which receive and respond to various read and write requests from clients directed to data stored in or to be stored in storage units . Storage units constitute mass storage devices which can include for example flash memory magnetic or optical disks or tape drives illustrated as disks A B . The storage devices can further be organized into arrays not illustrated implementing a Redundant Array of Inexpensive Disks Devices RAID scheme whereby storage servers access storage units using one or more RAID protocols known in the art.

Storage servers can provide file level service such as used in a net work attached storage NAS environment block level service such as used in a storage area network SAN environment a service which is capable of providing both file level and block level service or any other service capable of providing other data access services. Although storage servers are each illustrated as single units in a storage server can in other embodiments constitute a separate network element or module an N module and disk element or module a D module . In one embodiment the D module includes storage access components for servicing client requests. In contrast the N module includes functionality that enables client access to storage access components e.g. the D module and may include protocol components such as Common Internet File System CIFS Network File System NFS or an Internet Protocol IP module for facilitating such connectivity. Details of a distributed architecture environment involving D modules and N modules are described further below with respect to and embodiments of an D module and an N module are described further below with respect to .

In yet other embodiments storage servers are referred to as network storage subsystems. A network storage subsystem provides networked storage services for a specific application or purpose. Examples of such applications include database applications web applications. Enterprise Resource Planning ERP applications etc. e.g. implemented in a client. Examples of such purposes include file archiving backup mirroring etc. provided for example on archive backup or secondary storage server connected to a primary storage server. A network storage subsystem can also be implemented with a collection of networked resources provided across multiple storage servers and or storage units.

In the embodiment of one of the storage servers e.g. storage server A functions as a primary provider of data storage services to client . Data storage requests from client are serviced using disks A organized as one or more storage objects. A secondary storage server e.g. storage server B takes a standby role in a mirror relationship with the primary storage server replicating storage objects from the primary storage server to storage objects organized on disks of the secondary storage server e.g. disks B . In operation the secondary storage server does not service requests from client until data in the primary storage object becomes inaccessible such as in a disaster with the primary storage server such event considered a failure at the primary storage server. Upon a failure at the primary storage server requests from client intended for the primary storage object are serviced using replicated data i.e. the secondary storage object at the secondary storage server.

It will be appreciate that in other embodiments network storage system may include more than two storage servers. In these cases protection relationships may be operative between various storage servers in system such that one or more primary storage objects from storage server A may be replicated to a storage server other than storage server B not shown in this figure . Secondary storage objects may further implement protection relationships with other storage objects such that the secondary storage objects are replicated e.g. to tertiary storage objects to protect against failures with secondary storage objects. Accordingly the description of a single tier protection relationship between primary and secondary storage objects of storage servers should be taken as illustrative only.

Nodes may be operative as multiple functional components that cooperate to provide a distributed architecture of system . To that end each node may be organized as a network element or module N module A B a disk element or module D module A B and a management element or module M host A B . In one embodiment each module includes a processor and memory for carrying out respective module operations. For example N module may include functionality that enables node to connect to client via network and may include protocol components such as a media access layer Internet Protocol IP layer Transport Control Protocol TCP layer User Datagram Protocol UDP layer and other protocols known in the art.

In contrast. D module may connect to one or more storage devices via cluster switching fabric and may be operative to service access requests on devices . In one embodiment the D module implements an extent based storage architecture as will be described in greater detail below. In one embodiment the D module includes storage access components such as a storage abstraction layer supporting multi protocol data access e.g. Common Internet File System protocol the Network File System protocol and the Hypertext Transfer Protocol a storage layer implementing storage protocols e.g. RAID protocol and a driver layer implementing storage device protocols e.g. Small Computer Systems Interface protocol for carrying out operations in support of storage access operations. In the embodiment shown in a storage abstraction layer e.g. file system of the D module divides the physical storage of devices into storage objects. Requests received by node e.g. via N module may thus include storage object identifiers to indicate a storage object on which to carry out the request.

Also operative in node is M host which provides cluster services for node by performing operations in support of a distributed storage system image for instance across system . M host provides cluster services by managing a data structure such as a RDB RDB A RDB B which contains information used by N module to determine which D module owns services each storage object. The various instances of RDB across respective nodes may be updated regularly by M host using conventional protocols operative between each of the M hosts e.g. across network to bring them into synchronization with each other. A client request received by N module may then be routed to the appropriate D module for servicing to provide a distributed storage system image.

It should be noted that while shows an equal number of N and D modules constituting a node in the illustrative system there may be different number of N and D modules constituting a node in accordance with various embodiments of rapid cloning. For example there may be a number of N modules and D modules of node A that does not reflect a one to one correspondence between the N and D modules of node B. As such the description of a node comprising one N module and one D module for each node should be taken as illustrative only.

Moreover the description of is intended to provide an overview of computer hardware and other operating components suitable for performing the methods of the invention described above but is not intended to limit the applicable environments. One of skill in the art will immediately appreciate that the invention can be practiced with other computer system configurations. The invention can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network.

It will be readily apparent to one of skill that input output devices such as a keyboard a pointing device and a display may be coupled to the storage server. These conventional features have not been illustrated for sake of clarity.

Memory includes storage locations addressable by processor network adapter and storage adapter for storing processor executable instructions and data structures associated with rapid cloning. Storage operating system portions of which are typically resident in memory and executed by processor functionally organizes the storage server by invoking operations in support of the storage services provided by the storage server. It will be apparent to those skilled in the art that other processing means may be used for executing instructions and other memory means including various computer readable media may be used for storing program instructions pertaining to the inventive techniques described herein. It will also be apparent that some all of the functionality of the processor and executable software can be implemented by hardware such as integrated currents configured as programmable logic arrays. ASICs and the like.

Network adapter comprises one or more ports to couple the storage server to one or more clients over point to point links or a network. Thus network adapter includes the mechanical electrical and signaling circuitry needed to couple the storage server to one or more client over a network. Each client may communicate with the storage server over the network by exchanging discrete frames or packets of data according to pre defined protocols such as TCP IP.

Storage adapter includes a plurality of ports having input output I O interface circuitry to couple the storage devices e.g. disks to bus over an I O interconnect arrangement such as a conventional high performance. FC or SAS link topology. Storage adapter typically includes a device controller not illustrated comprising a processor and a memory for controlling the overall operation of the storage units in accordance with read and write commands received from storage operating system . In one embodiment the storage operating system implements an extent based storage architecture as will be described in greater detail below. As used herein data written by a device controller in response to a write command is referred to as write data. whereas data read by device controller responsive to a read command is referred to as read data. 

User console enables an administrator to interface with the storage server to invoke operations and provide inputs to the storage server using a command line interface CLI or a graphical user interface GUI . In one embodiment user console is implemented using a monitor and keyboard.

When implemented as a node of a cluster such as cluster of the storage server further includes a cluster access adapter shown in phantom having one or more ports to couple the node to other nodes in a cluster. In one embodiment. Ethernet is used as the clustering protocol and interconnect media although it will apparent to one of skill in the art that other types of protocols and interconnects can by utilized within the cluster architecture.

Multi protocol engine includes a media access layer of network drivers e.g. gigabit Ethernet drivers that interface with network protocol layers such as the IP layer and its supporting transport mechanisms the TCP layer and the User Datagram Protocol UDP layer . A file system protocol layer provides multi protocol file access and to that end includes support for the Direct Access File System DAFS protocol the NFS protocol the CIFS protocol and the Hypertext transfer Protocol HTTP protocol . A VI layer implements the VI architecture to provide direct access transport DAT capabilities such as RDMA as required by the DAFS protocol . An iSCSI driver layer provides block protocol access over the TCP IP network protocol layers while a FC driver layer receives and transmits block access requests and responses to and from the storage server. In certain cases a Fibre Channel over Ethernet FCoE layer not shown may also be operative in multi protocol engine to receive and transmit requests and responses to and from the storage server. The FC and iSCSI drivers provide respective FC and iSCSI specific access control to the blocks and thus manage exports of luns to either iSCSI or FCP or alternatively to both iSCSI and FCP when accessing blocks on the storage server.

The storage operating system also includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on storage devices. Information may include data received from a client in addition to data accessed by the storage operating system in support of storage server operations such as program application data or other system data. Preferably client data may be organized as one or more logical storage objects e.g. volumes that comprise a collection of storage devices cooperating to define an overall logical arrangement. In one embodiment the logical arrangement may involve logical volume block number vbn spaces wherein each volume is associated with a unique vbn.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustrated as a SCSI target module . The SCSI target module is generally disposed between drivers and the file system to provide a translation layer between the block lun space and the file system space where luns are represented as blocks. In one embodiment the file system implements a WAFL write anywhere file layout file system having an on disk format representation that is block based using. e.g. 4 kilobyte KB blocks and using a data structure such as index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . File system uses files to store metadata describing the layout of its file system including an inode file which directly or indirectly references points to the underlying data blocks of a file.

For one embodiment the file system includes an extent based architecture as an extension to WAFL. Operationally a request from a client is forwarded as a packet over the network and onto the storage server where it is received at a network adapter. A network driver such as layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to file system . There file system generates operations to load retrieve the requested data from the disks if it is not resident in core i.e. in memory . If the information is not in memory file system in cooperation with the extent based architecture accesses an indirect volume to retrieve an extent identifier accesses an extent to physical block data structure to retrieve a PVBN and passes the PVBN to the RAID system . In one embodiment the extent to physical block data structure is implemented as a map. There the PVBN is mapped to a disk identifier and device block number disk DBN and sent to an appropriate driver of disk driver system . The disk driver accesses the DBN from the specified disk and loads the requested data block s in memory for processing by the storage server. Upon completion of the request the node and operating system returns a reply to the client over the network.

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the storage server adaptable to the teachings of the invention may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by the storage server in response to a request issued by a client. Moreover in another alternate embodiment of the invention the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the storage server. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

When implemented in a cluster data access components of the storage operating system may be embodied as D module for accessing data stored on disk. In contrast multi protocol engine may be embodied as N module to perform protocol termination with respect to a client issuing incoming access over the network as well as to redirect the access requests to any other N module in the cluster. A cluster services system may further implement an M host e.g. M host to provide cluster services for generating information sharing operations to present a distributed file system image for the cluster. For instance media access layer may send and receive information packets between the various cluster services systems of the nodes to synchronize the replicated databases in each of the nodes.

In addition a cluster fabric CF interface module CF interface modules A B may facilitate intra cluster communication between N module and D module using a CF protocol . For instance D module may expose a CF application programming interface API to which N module or another D module not shown issues calls. To that end CF interface module can be organized as a CF encoder decoder using local procedure calls LPCs and remote procedure calls RPCs to communicate a file system command to between D modules residing on the same node and remote nodes respectively.

Deduplication in an extent based architecture requires receiving a request to deduplicate deduplicating a physical volume associated with the request and deduplicating one or more extents associated with the deduplicated physical volume and may be performed by deduplication module in file system .

Although the present invention is shown herein to implement deduplication within the storage operating system it will be appreciated that deduplication may be implemented in other modules or components of the storage server in other embodiments. In addition deduplication may be implemented as one or a combination of a software executing processor hardware or firmware within the storage server. As such deduplication may directly or indirectly interface with modules of the storage operating system in accordance with teachings of the present invention.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows XP or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write anywhere file system the teachings of the present invention may be utilized with any suitable file system including conventional write in place file systems.

The extent based entries of the extent to physical block map provide per aggregate indirection. In contrast virtual volume block numbers VVBN of volume containers provide per volume indirection. A per aggregate extent based entry as used herein refers to an extent being unique across volume boundaries within an aggregate. A per volume indirect entry refers to an entry being unique within volume boundaries. For per aggregate indirection when the storage server copies moves or makes other changes to physical blocks the changes are reflected within the aggregate layer in the extent to physical block map . These changes however do not need to be propagated into the volume layer because the extent identifier associated with the physical block does not need to change. This enables compression decompression sharing and unsharing of extents to occur without communication with the volume layer . Blocks can be easily shared across volume boundaries enabling cross volume deduplication. Segment cleaning and related disk gardening techniques can be performed on the extent to physical block map in a single pass all without having to propagate changes up into the volume layer .

For one embodiment the length of extents may be predefined e.g. 8 blocks . For an alternate embodiment the length of extents may vary. For one embodiment the length of an extent is expressed as the number of blocks within the extent. For example an extent containing only a single block would have a length of 1 an extent containing two blocks would have a length of 2 etc. For one embodiment extents have a maximum length driven by user I O or write allocation e.g. extents having a maximum length of 64 blocks .

For an embodiment utilizing an extent based tree with variable length extents as the data structure of extent based data structure the height of the tree is variable even between two files of the same size. For one embodiment the span of an internal node is also variable. As used herein the span of an indirect block refers to the number of blocks to which that indirect block refers. As a comparison in previous implementations of WAFL the span of an indirect block is fixed the span of a tradvol indirect block is 1024 the span of a flexvol indirect block e.g. as stored in flexible volume is 510 and the span of a 32 bit flexvol indirect block e.g. as stored in flexible volume is 255.

Additionally in the previous implementations of WAFL a contiguous extent containing N blocks would use the same amount of indirect space as N randomly located blocks because each data block of the extent would be represented by a separate indirect entry in the volume layer. An extent based sorted data structure however greatly reduces the amount of indirect space used because volume layer entries are per extent rather than per block. For example consider a 64 bit flexvol storing a file containing 532 685 800 bytes of data approximately 508 MB as implemented in previous implementations of WAFL. The flexvol includes indirect blocks having 255 entries a span of 255 and each entry refers to a 4 KB block. The flexvol represents the 508 MB file using two level 2 indirect blocks pointing to level 1 indirect blocks pointing to 130050 4 KB level 0 data blocks. In an extent based sorted data structure instead of using one entry for each 4 KB block the storage server uses one entry for each extent. Extents can be longer than a single 4 KB block. For example an extent is a contiguous group of one or more 4 KB blocks. Using an extent based sorted data structure with 16 block long extents and 127 entries per block the storage server represents the 130050 4 KB with only 8129 leaf nodes and internal nodes resulting in an 87 savings in indirect block metadata.

For one embodiment the storage server uses an extent based sorted data structure to implement an indirect volume . For one embodiment the storage server implements each indirect volume as a B tree. shows an exemplary volume layer indirect entry for a leaf node of an extent based sorted data structure used to implement an indirect volume . The volume layer indirect entry stores a FBN a corresponding extent identifier and a length of the extent . The storage server uses the FBN as the primary sorting key to navigate the extent based sorted data structure and find the extent identifier that corresponds to the FBN . For one embodiment the FBN is 48 bits the extent identifier is 48 bits and the length is 8 bits. Alternatively the storage server uses different sizes for one or more of the FBN extent identifier or length . For example the extent identifier may be 64 bits long in an alternate embodiment e.g. to provide for 512 byte granularity in the offset of blocks . For one embodiment the extent length varies. For an alternate embodiment the extent length is fixed.

Extent identifiers are allocated during a rite allocation. For one embodiment the storage server allocates extent identifiers from a finite pool of extent identifiers. Alternatively extent identifiers are monotonically increasing values that never wrap.

The per volume container files of previous implementations of WAFL are not used in an extent based sorted data structure used to implement an indirect volume . Instead of per volume container files the storage server uses an extent to physical block map. As described above the use of the extent to physical block map can result in reduced indirect metadata. The indirect volume blocks however no longer contain cached pointers to PVBN s. Accesses to an extent involves the storage server looking up an extent identifier in the indirect volume and looking up the PVBN e.g. by way of a pointer in the extent to physical block map . The computational overhead of this additional I O look up is offset by some of the features of extent based architecture . For example I O accesses are per extent rather than per block and therefore multiple blocks are accessed by a single I O access. Additionally the extent based architecture gains advantages in compression deduplication segment cleaning etc. Actions such as deduplication can easily span the aggregate rather than just a single volume and many changes to blocks e.g. resulting from compression and segment cleaning do not need to be propagated up to the indirect volume e.g. to correct cached indirect pointers .

For one embodiment the storage server uses an extent based tree as an extent based sorted data structure to implement an extent to physical block map . For one embodiment the storage server implements an extent to physical block map as a B tree. shows an exemplary extent map entry for a leaf node of an extent based sorted data structure used to implement an extent to physical block map . Leaf nodes of an extent based sorted data structure used to implement an extent to physical block map store extent identifiers one or more pointers to PVBN s or another extent identifier offsets for the extents and lengths for the extents . For one embodiment the extent identifier is 48 bits the pointer extent identifier is 48 bits the offset is 8 bits and the length is 8 bits.

For one embodiment each extent map entry includes either a pointer or other reference directly to a PVBN or to another extent identifier that directly references a PVBN. Additionally each PVBN is owned by only one extent and any other extent that references the PVBN does so by way of referencing the owner extent. In one embodiment the owner extent is the extent that directly references the PVBN. As a result the maximum additional look up for a given extent to get to a PVBN should be no more than one. This maximum prevents the level of indirect references in extent map entries from becoming arbitrarily deep large and taking an arbitrary amount of time as measured in terms of disk I O operations assuming that each extent entry is likely to be stored within a different disk block . As used herein deep refers to a number of levels of indirect references.

As a result the storage server uses the owner extent identifier as a tag unique number or other context for the purpose of lost write detection. As used herein lost write detection refers to the detection of writes that storage server reports have been completed even though storage server has actually flailed to write data to an I O persistent storage e.g. storage A storage B etc. .

For an alternate embodiment all extent identifiers map directly to a PVBN and PVBNs can be owned by more than one extent. For an embodiment including lost write detection the storage server creates a context tag or unique number. e.g. via a separate table that is separate different from the extent identifiers due to the possibility of multiple extent identifiers referencing a single PVBN.

For one embodiment the storage server maintains e.g in one or more metafiles reference counts for references by extents to each extent and by extents to each PVBN. Reference counts enable the storage server to be aware of whether or not other extents would be affected by operations performed on an extent PVBN e.g. reallocation segment cleaning etc. . In one embodiment an extent is affected by operations performed on the extent when an operation performed on the extent changes one or more values stored within the extent. The storage server tracks increments and decrements of the reference count in one or more log data containers. For example the storage server would increment a reference count when a new extent PVBN is allocated when an extent identifier is shared e.g. via clone creation snapshot creation or deduplication etc. For one embodiment the storage server accumulates increments and decrements using a log data container and makes batch updates to reference count metafiles e.g. at a consistency point.

An external reference count is maintained as a reference count on an extent that is generated from outside e.g. external to the extent to physical block map . A single external reference count is used for each extent. For example an external reference count for an extent is set to one when a new extent is allocated e.g. during file creation or modification . For one embodiment the storage server increments the external reference count from zero to one for a PVBN directly bypassing the log data container when allocating a new extent PVBN. An external extent is an extent in the extent to physical block map that contains at least one external reference. In one example if the external reference count for an extent is non zero the external extent cannot be freed by a deduplication operation.

Internal reference count is maintained for an extent map entry . Internal reference count includes an internal reference count for each PBVN inside of extent map entry . Each internal reference count is generated by an internal operation of the extent to physical block map . An internal extent is an extent in the extent to physical block map that contains a predetermined number of external references e.g. external reference count is zero . In one embodiment the storage server executes all increments and decrements of the reference counts via the respective reference count log data container in all cases other than allocating a new extent PBVN e.g. modifying PBVN overwriting PBVN etc. .

A request to perform deduplication is received at processing instruction block . The request may be received from a user or administrator that determines that deduplication must be performed. In an alternate embodiment the request to perform deduplication is received periodically. In another alternate embodiment the request to perform deduplication is received a predetermined time before a long retained snapshot or a snapshot that will be archived is taken. In one embodiment a long retained snapshot is a snapshot that will be kept in persistent storage for a long period of time e.g. one week one month one year etc. . For example if a long retained snapshot is taken every Sunday at midnight and the deduplication process takes 2 hours the request to perform deduplication can be set to occur on Sunday at noon in order to give enough time for the deduplication of the snapshot to be performed. The request to perform deduplication may include a specific snapshot to deduplicate. In an alternate embodiment the most recent snapshot is the default snapshot for deduplication. In another alternate embodiment all snapshots are deduplicated whenever a new snapshot is taken. In yet another alternate embodiment data in the extent based architecture other than snapshots is deduplicated.

A log data container is accessed at processing instruction block . The log data container is a data structure for storing identifying information for each block in a physical volume e.g. physical volume that has been write allocated and or modified. In one embodiment the log data container is a file. In one embodiment the log data container contains the extent ID and a fingerprint of the write allocated and or modified data block. In an alternate embodiment the log data container contains the extent ID and a pointer to a fingerprint accessible to the extent based architecture . A fingerprint is a coded string of binary digits generated by a mathematical algorithm that uniquely identities a data block. The fingerprint for the data block is generated by any method commonly known in the art. The fingerprint is stored in a fingerprint structure not shown . Although the fingerprint structure is not in any of the Figures one of skill in the art would understand that the fingerprint structure can be implemented in an operating system in memory in a fingerprint database accessible to the operating system memory etc.

In one embodiment the log data container contains data blocks which have been allocated and or modified since a previous snapshot was performed. In an alternate embodiment the log data container contains all data blocks which have been allocated and or modified since the physical volume was included in the system. In another alternate embodiment the log data container contains the data blocks allocated for the snapshot received with the deduplication command. In one embodiment the log data container can include a timestamp indicating when a data block was write allocated and or modified. In an alternate embodiment no timestamp is included in the log data container. The most recently write allocated or modified block is the most recent entry in the log data container. An entry in the log data container is accused at processing instruction block .

At processing instruction block the extent ID of the current entry is compared to the extent IDs of the other entries in the log data container. The extent IDs are compared by any method commonly known in the art. If the extent ID of the current entry matches the extent ID of another entry in the log data container the method proceeds to block . If the extent ID of the current entry does not match the extent ID of another entry in the log data container the method proceeds to block .

At processing block the reference count and pointer IDs for the matching entries are updated. In one embodiment the internal reference count of the current entry is updated to include the internal reference count of the matching entry. For example if the internal reference count of the current entry was lour and the internal reference count of the matching entry was eight the internal reference count of the current entry will be updated to twelve the sum of four and eight. In this embodiment the internal reference count of the matching entry will be updated to zero. In an alternate embodiment the internal reference count of the matching entry is updated to include the internal reference count of the current entry. In this embodiment the internal reference count of the current entry will be updated to zero. In one embodiment if the internal reference count of the current entry is updated to include the internal reference count of the matching entry the pointer of the matching entry extent ID will be updated to point to the extent ID of the current entry. In another embodiment if the internal reference count of the matching entry is updated to include the internal reference count of the current entry the pointer of the current entry extent ID will be updated to point to the extent ID of the matching entry.

At processing block a determination is made of whether a reference count of either the extent associated with the current entry or the extent associated with the matching entry is a predetermined value e.g. zero . In one embodiment the reference count is the external reference count for the extents. In an alternate embodiment the reference count is the internal reference counts for the extents. In this embodiment every internal reference count for the extent must equal the predetermined value for a match to occur. If the reference count of either extent equals the predetermined value the method proceeds to block . If the reference count of both extents does not equal the predetermined value the method proceeds to block .

At block the extent whose reference count equals the predetermined value is freed. The extent is freed by freeing the PVBNs comprising the extent and removing each mapping from the extent to physical block map for the PBVNs. In one embodiment freeing the extent also adds the extent identifier back into the pool of extent identifiers which are free to be used. In an alternate embodiment no pool of extent identifiers exists and therefore the extent identifier is not placed back into a pool of extent identifiers.

At processing block a determination is made of whether there are more entries in the log data container to process. If there are more entries in the log data container the method returns to processing block to access the next entry in the log data container. If there are no more entries in the log data container the method ends.

A request to perform deduplication is received at processing instruction block . The request may be received from a user or administrator that determines that deduplication must be performed. In an alternate embodiment the request to perform deduplication is received periodically. In another alternate embodiment the request to perform deduplication is received a predetermined time before a long retained snapshot or a snapshot that will be archived is taken. For example if a long retained snapshot is taken every Sunday at midnight and the deduplication process takes 2 hours the request to perform deduplication of the snapshot can be set to occur on Sunday at noon in order to give enough time for the deduplication of the snapshot to be performed. The request to perform deduplication may include a specific snapshot or data to deduplicate. In an alternate embodiment the most recent snapshot is the default snapshot for deduplication. In another alternate embodiment all snapshots are deduplicated whenever a new snapshot is taken. In yet another alternate embodiment data in the extent based architecture other than snapshots is deduplicated.

A log data container is accessed at processing instruction block . In one embodiment the log data container is a data structure for recording identifying information for each block in a physical volume e.g. physical volume that has been write allocated and or modified. In one embodiment the log data container is a log file. In one embodiment the log data container contains the extent ID and a fingerprint of the write allocated and or modified data block. In an alternate embodiment the log data container contains the extent ID and a pointer to a fingerprint stored in a fingerprint database accessible to the extent based architecture . The fingerprint for the data block is generated by any method commonly known in the art. In one embodiment the log data container contains data blocks which have been allocated and or modified since a previous snapshot was performed. In an alternate embodiment the log data container contains all data blocks which have been allocated and or modified since the physical volume was included in the system. In another alternate embodiment the log data container contains the data blocks allocated for the snapshot received with the deduplication command. In one embodiment the log data container can include a timestamp indicating when a data block was write allocated and or modified. In an alternate embodiment no timestamp is included in the log data container. The most recently write allocated or modified block is the most recent entry in the log data container. An entry in the log data container is accessed at processing instruction block .

At processing block a determination is made of whether the current entry in the log data container has a match. In one embodiment the determination is made by determining if a fingerprint associated with the current entry matches a fingerprint associated with any of the other entries in the log data container. In an alternate embodiment the determination is made by determining if the fingerprint associated with the current entry matches a fingerprint stores in a fingerprint database. The fingerprints are compared by any method commonly known in the art.

If the fingerprint associated with the current entry is determined not to have a match the method proceeds to block . In one embodiment if the fingerprint associated with the current entry is determined to have a match a byte comparison is performed. In this embodiment the byte comparison compares each byte in the data block associated with the current entry with each byte in the data block with the matching fingerprint. For example if entry X has a fingerprint with a value Y and entry Z is also determined to have a fingerprint with a value Y each byte in the data block associated with entry X would be compared with each byte in the data block associated with entry Z. In an alternate embodiment the byte comparison is not performed and the method proceeds to block if there is a fingerprint match for the current entry.

At processing block the donor extent and the recipient extent are determined based on the match. In one embodiment the extent associated with the current entry is determined to be the donor extent and the extent associated with the matching entry is determined to be the recipient extent. In an alternate embodiment the extent associated with the current entry is determined to be the recipient extent and the extent associated with the matching entry is determined to be the donor extent. In another embodiment the timestamps of the current entry and matching entry are compared and the donor extent is determined to be the older entry and the recipient extent is determined to be the newer entry. In another alternate embodiment the timestamps of the current entry and matching entry are compared and the donor extent is determined to be the newer entry and the recipient extent is determined to be the older entry.

At processing block a determination is made of whether the external reference count for the recipient extent is equal to a predetermined value e.g. zero . If the external reference count for the recipient extent is equal to the predetermined value the method proceeds to processing block . For example if the external reference count for the recipient extent is zero the recipient extent must be an internal extent. If the recipient extent is an internal extent block sharing between the donor extent and the recipient extent is not performed. If the recipient extent is not an internal extent and is therefore an external extent block sharing is performed at block . The block sharing is performed as described below in conjunction with .

At processing block a determination is made if the reference counts of extents equal a predetermined value e.g. zero . In one embodiment the external reference counts are compared to the predetermined value. In an alternate embodiment the internal reference counts are also compared to the predetermined value to determine if any PBVNs associated with the extents should also be freed. In one embodiment the determination is made for each extent in the extent to physical block map e.g. per aggregate extent to physical block map . In an alternate embodiment the determination is made for the donor extent and the recipient extent.

If the reference count of an extent does not equal the predetermined value e.g. zero the method proceeds to processing block . If the reference count of an extent equals the predetermined value e.g. zero the extent is freed at processing block . Freeing an extent is performed as described below in conjunction with .

At processing block a determination is made of whether there are more entries in the log data container to process. If there are more entries in the log data container the method returns to processing block to access the next entry in the log data container. If there are no more entries in the lot data container the method ends.

At processing block the internal reference count associated with the data block to be shared in the recipient extent is updated to include the internal reference count for the matching block in the donor extent. For example if the internal reference count for the data block to be shared in the recipient extent was four and the internal reference count for the matching data block in the donor extent was eight the internal reference count for the data block to be shared in the recipient would be updated to twelve. In one embodiment the internal reference count for the data block to be shared in the recipient is updated by updating the extent entry for the extent ID of the recipient extent in the extent to physical data block map .

At processing block the internal reference count of the matching data block in the donor extent is updated to zero. In one embodiment the internal reference count for the matching data block in the donor extent is updated by updating the extent entry for the extent ID of the donor extent in the extent to physical data block map .

At processing block a new extent map entry is created including an extent identifier set to the extent identifier of the donor extent a reference to the extent identifier of the recipient extent an offset equal to the offset of the data block to be shared in the recipient extent a length of the data block s to be shared and an external reference count incremented by one from the previous value e.g. from zero to one . In one embodiment the external reference count of the donor extent is incremented to prevent the level of indirect reference in the extent to physical block map entries from becoming arbitrarily deep and taking an arbitrary amount of time as measured in terms of disk I O operations assuming that each extent entry is likely to be stored within a different disk block and require a separate I O operation . As used herein deep refers to a number of levels of indirect references.

At processing block an extent entry for the donor extent is updated. An extent identifier set to the extent identifier of the donor extent. A reference is set to the PBVN of the data block to be shared. An offset is set to the location of the first data block in the donor extent e.g. if the first data block in the donor extent was shared and is no longer referenced by the donor extent the offset would be set to one which is the first block in the donor extent that is not being shared . A length is set to the number of data blocks in the donor extent that were not shared e.g. if one block was shared and the extent had a length of eight the length would be updated to seven . An external reference count is decremented if the length is zero. If the length of the donor extent is now zero then the extent is no longer referencing any PBVNs and therefore should be freed. In one embodiment the extent entry for the donor extent is updated by overwriting the existing extent entry in the aggregate layer sorted data structure. In an alternate embodiment the extent entry is updated by adding a new entry for the updated extent.

At processing block the storage server uses the allocated extent identifier as a key to traverse the aggregate layer extent based sorted data structure and adds the one or more new extent map entries .

At processing block the PVBNs comprising the extent are freed. The PVBNs are freed using methods commonly known in the art.

At processing block each entry in the extent to physical block map for the extent ID and corresponding PBVNs is removed.

At processing block the extent identifier of the extent being freed is added into a pool of extent identifiers which are free to be used. In an alternate embodiment processing block is optional and is not performed. In one embodiment processing block is optional if no pool of extent identifiers exists. In this embodiment the extent identifier is not placed back into a pool of extent identifiers. In certain embodiments if processing block is omitted the process ends from block .

Thus embodiments of deduplication in an extent based architecture are implemented in a computer system as described herein. In practice the methods and may constitute one or more programs made up of computer executable instructions. Describing the methods with reference to the flowchart in and enables one skilled in the art to develop such programs including such instructions to carry out the operations acts represented by logical blocks until until until and until on suitably configured computers the processor of the computer executing the instructions from computer readable media . The computer executable instructions may be written in a computer programming language or may be embodied in firmware logic or in hardware circuitry. If written in a programming language conforming to a recognized standard such instructions can be executed on a variety of hardware platforms and for interface to a variety of operating systems.

In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein. Furthermore it is common in the art to speak of software in one form or another e.g. program procedure process application module logic . . . as taking an action or causing a result. Such expressions are merely a shorthand way of saying that execution of the software by a computer causes the processor of the computer to perform an action or produce a result. It will be further appreciated that more or fewer processes may be incorporated into the method illustrated in and FIG. without departing from the scope of the invention and that no particular order is implied by the arrangement of blocks shown and described herein.

Deduplication in an extent based architecture has been described. Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that any arrangement which is determined to achieve the same purpose may be substituted for the specific embodiments shown. This application is intended to cover any adaptations or variations of the present invention.

The term memory as used herein is intended to encompass all volatile storage media such as dynamic random access memory DRAM and static RAM SRAM . Computer executable instructions can be stored on non volatile storage devices such as magnetic hard disk an optical disk and are typically written by a direct memory access process into memory during execution of software by a processor. One of skill in the art will immediately recognize that the term computer readable storage medium includes any type of volatile or non volatile storage device that is accessible by a processor.

Therefore it is manifestly intended that this invention be limited only by the following claims and equivalents thereof.

Use of the phrase at least one of . . . or should not be construed to be exclusive. For instance the phrase X comprises at least one of A B or C does not mean that X comprises only one of A B C it does not mean that X comprises only one instance of each of A B C even if any one of A B C is a category or sub category and it does not mean that an additional element cannot be added to the non exclusive set i.e. X can comprise A B Z .

