---

title: Multi-primitive graphics rendering pipeline
abstract: This disclosure describes techniques for rendering a plurality of primitives that includes at least two different types of primitives during the execution of a single draw call command. This disclosure also describes techniques for rendering a plurality of primitives using tessellation domains of different tessellation domain types during the execution of a single draw call command. The techniques of this disclosure may, in some examples, reduce the complexity and processing overhead for user applications, reduce the number of times that the rendering state of the graphics rendering pipeline needs to be switched during the drawing of a graphics scene, and/or reduce the number of times that shader programs need to be reloaded into different processing stages of a graphics pipeline during the rendering of a graphics scene.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09177351&OS=09177351&RS=09177351
owner: QUALCOMM Incorporated
number: 09177351
owner_city: San Diego
owner_country: US
publication_date: 20130315
---
This application claims the benefit of U.S. Provisional Application No. 61 711 693 filed Oct. 9 2012 the entire content of which is incorporated herein by reference.

This disclosure relates to graphics processing systems and more particularly to the rendering of graphics primitives in a graphics processing system.

Computing devices often utilize a graphics processing unit GPU to accelerate the rendering of graphics data for display. Examples of such computing devices may include computer workstations mobile phones e.g. so called smartphones embedded systems personal computers tablet computers and video game consoles. Rendering generally refers to the process of converting a three dimensional 3D graphics scene which may include one or more 3D graphics objects into two dimensional 2D rasterized image data. A GPU may include a 3D rendering pipeline to provide at least partial hardware acceleration for the rendering of a 3D graphics scene. The 3D graphics objects in a scene may be subdivided by a graphics application into one or more 3D graphics primitives e.g. points lines triangles patches etc. and the GPU may convert the 3D graphics primitives of the scene into 2D rasterized image data. Therefore in the specific context of GPU rendering rendering may refer to the process of converting 3D graphics primitives that correspond to 3D objects in a graphics scene into 2D rasterized image data.

This disclosure describes graphics processing unit GPU based techniques for rendering a plurality of primitives that includes at least two different types of primitives during the execution of a single draw call command. This disclosure also describes techniques for rendering a plurality of primitives using tessellation domains of different tessellation domain types during the execution of a single draw call command. As used herein a primitive may refer to a group of one or more vertices and or one or more control points that are grouped together and or connected to define a geometric entity e.g. point line polygon surface object patch etc. for rendering by a GPU. A primitive type may define how vertices and or control points are to be grouped together and or connected to form a primitive for rendering. For example a primitive type may specify how many control points are to be used to define a respective one of the primitives to be rendered. A tessellation domain may refer to an object that is subdivided by a tessellator of a graphics pipeline to generate a plurality of coordinates for use by one or more subsequent processing stages of the graphics pipeline. A tessellation domain type may define one or more attributes of the object e.g. the shape of the object that is to be subdivided by the tessellator.

By allowing multiple different primitive types to be rendered during the execution of a single draw call command and multiple different tessellation domain types to be used during the execution of a single draw call command user applications do not necessarily need to perform separate draw call commands in order to render primitives of different types that are included in a single 3D object or mesh which may in some examples reduce the complexity and processing overhead for user applications. In further examples the techniques of this disclosure may reduce the number of times that the rendering state of the graphics rendering pipeline needs to be switched when rendering a graphics scene thereby improving the rendering efficiency of the graphics processing system. In additional examples the techniques of this disclosure may reduce the number of times that shader programs need to be reloaded into different processing stages of the pipeline when rendering a graphics scene thereby providing further improvements in the rendering efficiency of the graphics processing system.

In one example this disclosure describes a method that includes rendering with a GPU a plurality of primitives that includes at least two different types of primitives during execution of a draw call command.

In another example this disclosure describes a device that includes a GPU configured to render a plurality of primitives that includes at least two different types of primitives during execution of a draw call command.

In another example this disclosure describes an apparatus that includes means for executing a draw call command. The apparatus further includes means for rendering a plurality of primitives that includes at least two different types of primitives during execution of the draw call command.

In another example this disclosure describes a computer readable storage medium storing instructions that when executed cause one or more processors to render a plurality of primitives that includes at least two different types of primitives during execution of a draw call command.

The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

This disclosure describes graphics processing unit GPU based techniques for rendering a plurality of primitives that includes at least two different types of primitives during the execution of a single draw call command. This disclosure also describes techniques for rendering a plurality of primitives using tessellation domains of different tessellation domain types during the execution of a single draw call command. As used herein a primitive may refer to a group of one or more vertices and or one or more control points that are grouped together and or connected to define a geometric entity e.g. point line polygon surface object patch etc. for rendering by a GPU. A primitive type may define how vertices and or control points are to be grouped together and or connected to form a primitive for rendering. For example a primitive type may specify how many control points are to be used to define a respective one of the primitives to be rendered. A tessellation domain may refer to an object that is subdivided by a tessellator of a graphics pipeline to generate a plurality of coordinates for use by one or more subsequent processing stages of the graphics pipeline. A tessellation domain type may define one or more attributes of the object e.g. the shape of the object that is to be subdivided by the tessellator.

By allowing multiple different primitive types to be rendered during the execution of a single draw call command and multiple different tessellation domain types to be used during the execution of a single draw call command user applications do not necessarily need to perform separate draw call commands in order to render primitives of different types that are included in a single 3D object or mesh which may in some examples reduce the complexity and processing overhead for user applications. In further examples the techniques of this disclosure may reduce the number of times that the rendering state of the graphics rendering pipeline needs to be switched when rendering a graphics scene thereby improving the rendering efficiency of the graphics processing system. In additional examples the techniques of this disclosure may reduce the number of times shader programs need to be reloaded into different processing stages of the pipeline when rendering a graphics scene thereby providing further improvements in the rendering efficiency of the graphics processing system.

Rendering may refer to the process of converting 3D graphics primitives that correspond to 3D objects in a graphics scene into 2D rasterized image data. A computing device may often utilize a graphics processing unit GPU that includes a 3D graphics rendering pipeline to accelerate the rendering of graphics primitives. A 3D graphics rendering pipeline may include a plurality of processing stages that are configured to render 3D graphics primitives. The processing stages may include programmable processing stages and fixed function processing stages. Programmable processing stages may be configured to execute a user specified program that may be compiled and loaded onto the GPU. Fixed function processing stages may be hardwired to perform one or more functions which may be configurable. Although the functions performed by the fixed function processing stages may be configurable the fixed function processing stages are typically not capable of receiving and executing user specified programs from a host processor.

To render one or more 3D graphics primitives of a particular primitive type a user application executing on a host central processing unit CPU may set up the state of the GPU to render primitives of that particular type and place geometry data corresponding to the primitives to be rendered into a GPU accessible memory. Setting up the state of the GPU may involve issuing one or more state commands to the GPU that indicate a particular type of primitive that is to be rendered by the GPU and binding one or more types of shader programs to the GPU pipeline. The one or more types of shader programs may be configured to process data in a manner that is specific to the type of primitive to be rendered. If on chip tessellation is being used to render the primitives one or more of the shader programs that are bound to the GPU pipeline may specify a particular domain type e.g. isoline triangle quad etc. to use for tessellation when rendering the primitives. Placing the geometry data into the GPU accessible memory may involve e.g. populating one or more vertex buffers in GPU accessible memory with vertices and or control points that correspond to the primitives to be rendered.

Once the state of the GPU has been set up to render primitives of a particular type and the geometry data corresponding to the primitives has been placed into the GPU accessible memory the user application executing on the host CPU may issue a draw call command to the GPU. In response to receiving the draw call command the GPU may render the geometry that is stored in the GPU accessible memory according to the current GPU state which defines a particular primitive type to be used for processing the draw call instruction. If tessellation is used the GPU may render the geometry using a particular tessellation domain type that is specified in one or more of the shader programs that were previously bound to the graphics pipeline.

If the CPU decides to render a primitive of a different type and or to render a primitive using a tessellation domain of a different type then the CPU may need to issue different draw calls for each of the different types of primitives to be rendered and or for each of the different tessellation domain types to be used when rendering. Between the issuance of the different draw call commands the CPU may need to set up the state of the GPU and bind new shader programs to the graphics pipeline in order to configure the pipeline to render a particular type of primitive that will be processed during the next draw call and or to configure the pipeline to use a particular type of tessellation domain for rendering primitives during the next draw call. Thus for GPUs that do not implement the techniques of this disclosure rendering a scene that has primitives of different primitive types and or that uses different tessellation domain types may result in a significant amount of processing overhead in terms of rendering pipeline state configuration and shader program configuration.

One example of where a scene that has different primitive types and or that uses different tessellation domain types may arise is in when a 3D designer and or modeler generates a mesh to model a 3D object to be rendered. In such examples a single 3D mesh may include primitives of different primitive types which may result in multiple draw call commands needing to be executed in order to render the mesh that represents the 3D object. For example the original Proog and Emo meshes from Blender s Elephant s Dream include 32 118 97.8 quadrilaterals and 886 2.7 triangles.

If a mesh includes primitives of at least two different primitive types a host processor e.g. the CPU may need to separate out the different primitive types into different groups so that the different primitive types can be rendered during different draw calls. This may add significant complexity and delay to user applications that need to draw complex 3D objects and meshes that have multiple different primitive types. Moreover between each of the draw calls the rendering state of the pipeline may need to be changed to support different primitive types and or different tessellation domain types. In addition different shader programs may need to be bound to the graphics pipeline to support different primitive types and or different tessellation domain types. The switching of the rendering state between each of the draw call commands may consume a significant number of processing cycles and therefore slow down the rendering of 3D meshes.

This disclosure describes techniques for rendering a plurality of primitives of different primitive types during the execution of a single draw call command. This disclosure also describes techniques for rendering a plurality of primitives using tessellation domains of different domain types during the execution of a single draw call command. By allowing multiple different primitive types to be rendered during the execution of a single draw call command and multiple different tessellation domain types to be used during the execution of a single draw call command user applications do not necessarily need to perform separate draw call commands in order to render primitives of different types that are included in a single 3D object or mesh which may reduce the complexity and processing overhead for user applications.

Moreover the techniques of this disclosure may reduce the number of times that the rendering state of the pipeline needs to be switched between draw call commands thereby improving the rendering efficiency of the graphics processing system. In addition the techniques of this disclosure may reduce the number of times that shader programs need to be reloaded into different processing stages of the pipeline thereby providing further improvements in the rendering efficiency of the graphics processing system.

According to some aspects of this disclosure techniques are described for rendering a plurality of primitives of different primitive types during the execution of a draw call command. For example a 3D graphics pipeline may render a first subset of a plurality of primitives that have a first primitive type during the execution of the draw call command and render a second subset of the plurality of primitives that have a second primitive type during the execution of the same draw call command. The first primitive type may be different than the second primitive type. In some examples the first primitive type may be a three control point patch and the second primitive type may be a four control point patch. In some examples a primitive type may refer to a type of primitive that is capable of being received and processed by the graphics processing pipeline. In further examples a primitive type may specify how many control points are to be used to define a respective one of the primitives to be rendered. Example primitive types may include points lines triangles line lists line strips triangle lists triangle strips 2 control point patch lists 3 control point patch lists 4 control point patch lists etc. In some examples the primitive types may correspond to the Microsoft DirectX 11 primitive topologies.

In some examples the techniques of this disclosure may provide a 3D graphics pipeline that is configured to determine a primitive type associated with one or more vertices to be processed during the execution of a draw call command and to configure one or more stages of the 3D graphics pipeline to process the vertices based on the primitive type during the execution of the draw call command. For example the 3D graphics pipeline may receive primitive type data from one or more buffers associated with a plurality of vertices to be processed during a draw call command and generate data that is indicative of the primitive type associated with each of the vertices to be processed. The data indicative of the primitive type associated with each of the vertices may be provided to one or more processing stages in the graphics rendering pipeline so that such stages may select appropriate data processing techniques for processing the received data based on the primitive type corresponding to the received data. In some examples the data indicative of the primitive type associated with each of the vertices may be a system generated value generated by an input assembler of the graphics processing pipeline.

In further examples the techniques of this disclosure may provide a shader architecture and or a shader programming model that allows different data processing techniques to be selected based on a primitive type associated with the data to be processed. The shader architecture and or the shader programming model may correspond to the shader architecture and or the shader programming model for one or more of shader processing stages of a GPU rendering pipeline such as e.g. the hull shader processing stage the domain shader processing stage the geometry shader processing stage the tessellation control shader processing stage or the tessellation evaluation shader processing stage.

In additional examples the techniques of this disclosure may include selecting with a shader program executing on a shader unit of a GPU a data processing technique from a plurality of data processing techniques based on a primitive type associated with the data to be processed by the shader program and processing with the shader program executing on a shader unit of the GPU the data according to the selected data processing technique. For example the shader program may select a first data processing technique for processing data associated with a first primitive type and a second data processing technique for processing data associated with a second primitive type. The shader program may be for example a hull shader program a domain shader program a geometry shader program a tessellation control shader program or a tessellation evaluation shader program.

In some examples the hull shader program and or the domain shader program or alternatively the tessellation control shader program and the tessellation evaluation shader program may determine whether the primitive is a three control point patch e.g. a triangle or a four control point patch e.g. a quad . In response to determining that the primitive is a three control point patch the hull shader program and or the domain shader program may convert the primitive into a triangular B zier patch surface and generate a plurality of triangle primitives to approximate the curvature of the triangular B zier patch surface. In response to determining that the primitive is a four control point patch the hull shader program and or the domain shader program may convert the primitive into a bi cubic B zier patch surface and generate a plurality of triangle primitives to approximate the curvature of the bi cubic B zier patch surface.

The plurality of triangles that approximate the triangular B zier patch surface may be optionally further processed by a geometry shader program and may be rasterized by a rasterizer to generate a rasterized version of the triangular B zier patch surface i.e. a rasterized 2D image that depicts the triangular B zier patch surface . Similarly the plurality of triangles that approximate the bi cubic B zier patch surfaces may be optionally further processed by a geometry shader program and may be rasterized by a rasterizer to generate a rasterized version of the bi cubic B zier patch surface a rasterized 2D image that depicts the bi cubic B zier patch surface .

In some examples during the execution of a draw call command the hull shader stage may configure the number of times that the hull shader program is to be invoked for processing a primitive based on the primitive type of the primitive to be processed. For example the hull shader stage may invoke a hull shader program three times for processing a three control point patch during the execution of a draw call command and invoke the hull shader program four times for processing a four control point patch during the execution of a draw call command. In such examples the patch constant function may be invoked in some examples once per primitive.

In further examples a rasterizer may be configured to select a rasterization technique from a set of two or more rasterization techniques based on a rasterization primitive type received from a different processing stage in the graphics pipeline. For example the rasterizer may select a first rasterization technique from the set of two or more rasterization techniques if the rasterization primitive type is a first rasterization primitive type and select a second rasterization technique from the set of two or more rasterization techniques if the rasterization primitive type is a second rasterization primitive type. The first rasterization primitive type may be different than the second rasterization primitive type. The first rasterization technique may be different than the second rasterization technique. In some examples the rasterization primitive type may be received by the rasterizer from a geometry shader processing stage of the graphics rendering pipeline. Allowing a rasterizer to rasterize rasterization primitives of different rasterization primitive types during a single draw call may enable the graphics pipeline to render input primitives that map to different rasterization primitive types during a single draw call.

In some examples the set of rasterization primitive types may correspond to primitive types that are capable of being received and rasterized by a rasterizer in a graphics rendering pipeline. For example the set of rasterization primitive types may correspond to primitive types for which a rasterizer in a graphics rendering pipeline has a distinct set of rasterization rules. In other words in some examples each of the rasterization primitive types may correspond to a respective one of a plurality of sets of rasterization rules that defines how the rasterizer is to rasterize the respective rasterization primitive type. In some examples there may be a one to one correspondence between the sets of rasterization rules and the rasterization primitive types. In contrast the input primitive types may correspond to primitive types that are capable of being received by a GPU from a host processor e.g. a CPU and capable of being rendered by a graphics rendering pipeline implemented by the GPU.

In some examples the rasterization primitive type may be selected from a set of rasterization primitive types that includes a point stream a line stream and a triangle stream. In further examples the rasterization primitive type may be selected from a set of rasterization primitive types that includes a point a line and a triangle. In some cases the rasterization techniques may correspond to the different rasterization rules defined by a graphics API such as e.g. the DX 11 graphics API. For example if the rasterization primitive type is a triangle stream then the rasterizer may select a set of rasterization rules that corresponds to rasterizing triangles in a triangle stream.

In yet further examples the techniques of this disclosure may provide an application programming interface API that allows a user application to specify a primitive type associated with individual vertices and or groups of vertices to be rendered during the execution of a draw call. For example the API may allow a user to specify different primitive types for different vertices to be rendered. In some examples the API may also include instructions and or data structures that allow a user application to place data indicative of the primitive type for each of the vertices to be processed during a draw call instruction into one or more buffers e.g. vertex buffers that are accessible by the GPU. In additional examples the API may include a state command that instructs the GPU to execute a draw call command based on the data indicative of the primitive type for each of the vertices to be processed.

In more examples the techniques of this disclosure may provide a host processor e.g. a CPU that is configured to place a plurality of vertices to be processed by a GPU into one or more buffers to place data indicative of a primitive type for each of the plurality of vertices to be processed by the GPU into the one or more buffers and to issue a draw call command to the GPU where the draw call command instructs the GPU to process the vertices in the one or more buffers based on the data indicative of the primitive type for each of the plurality of vertices.

According to some aspects of this disclosure techniques are described for rendering a plurality of primitives using tessellation domains of different domain types during the execution of a draw call command. For example a 3D graphics pipeline may render a first subset of the plurality of primitives based on a first tessellation domain type during the execution of the draw call command and render a second subset of the plurality of primitives based on a second tessellation domain type during the execution of the same draw call command. The first tessellation domain type may be different than the second tessellation domain type. In some cases the primitive type of the first subset of the plurality of primitives may be different than the primitive type of the second subset of the plurality of primitives. In additional cases individual primitives in the first subset of the plurality of primitives and or individual primitives in the second subset of the plurality of primitives may be of different primitive types.

A tessellator may be a fixed function processing stage that is configured to generate positional coordinates based on a tessellation domain and one or more tessellation factors. The tessellation factors may specify the degree of tessellation that the tessellator is to apply to the domain e.g. how finely the domain should be subdivided and or the number of smaller objects into which the domain should be subdivided .

In some examples the techniques of this disclosure may provide a 3D graphics pipeline that is configured to determine a primitive type associated with one or more vertices to be processed during the execution of a draw call command and to select a tessellation domain type for processing the vertices based on the primitive type during the execution of the draw call command. For example the 3D graphics pipeline may receive primitive type data from one or more buffers associated with a plurality of vertices to be processed during a draw call command and provide that data to a processing stage of the graphics pipeline that specifies a tessellation domain to be used by the tessellator. The processing stage that specifies the tessellation domain may select a tessellation domain for processing a primitive based on the primitive type associated with the primitive. The tessellator stage may be invoked for each of a plurality of primitives processed by the graphics pipeline. The processing stage that specifies the tessellation domain may select a tessellation domain for each of the primitives based on the primitive type of the primitive to be processed and provide the selected tessellation domain to the tessellator stage to be used during an invocation of the tessellator stage that corresponds to the primitive to be processed. The processing stage that specifies a tessellation domain to be used by the tessellator stage may be for example a hull shader processing stage.

In further examples the techniques of this disclosure may provide a shader architecture and or a shader programming model that allows different tessellation domain types to be selected and provided as a varying output i.e. an output that may vary during the draw call to other processing stages in the graphics pipeline based on a primitive type associated with the data to be processed. The shader architecture and or the shader programming model may correspond to the shader architecture and or the shader programming model for one or more of shader processing stages in a GPU rendering pipeline such as e.g. the hull shader processing stage the domain shader processing stage the geometry shader processing stage the tessellation control shader processing stage and the tessellation evaluation shader processing stage.

In additional examples the techniques of this disclosure may include selecting with a shader program executing on a shader unit of a GPU a tessellation domain type based on a primitive type associated with the data to be processed by the shader program and rendering with the GPU a primitive associated with the data to be processed based on the selected tessellation domain type. For example the shader program may select a first tessellation domain type for data associated with a first primitive type and a second tessellation domain type for data associated with a second primitive type. The shader program may be for example a hull shader program a domain shader program a geometry shader program a tessellation control shader program or a tessellation evaluation shader program.

In some examples the hull shader program may determine whether the primitive is a three control point patch e.g. a triangle or a four control point patch e.g. a quad . In response to determining that the primitive is a three control point patch the hull shader program may select a triangle domain type i.e. tri to be used for processing the primitive and provide the selected triangle domain type to the tessellator processing stage. In response to determining that the primitive is a four control point patch the hull shader program may select a quadrilateral domain type i.e. quad to be used for processing the primitive and provide the selected quadrilateral domain type to the tessellator processing stage.

In some examples the hull shader program may provide the selected tessellation domain type to other processing stages of the graphics pipeline in addition to or in lieu of the tessellation stage including e.g. the domain shader stage and the geometry processing stage. The selection of the tessellation domain type may in some examples be performed as part of the patch constant function of the hull shader program. In addition to hull shader stage selecting the domain type based on the primitive type of the primitive to be processed the hull shader stage may also select a processing technique and or a number of times to invoke the hull shader program based on the primitive type of the primitive to be processed.

In further examples the techniques of this disclosure may provide a shader architecture and or a shader programming model that allows different data processing techniques to be selected based on a tessellation domain type associated with a primitive to be processed. The shader architecture and or the shader programming model may correspond to the shader architecture and or the programming model for one or more of shader processing stages in a GPU rendering pipeline such as e.g. the hull shader processing stage the domain shader processing stage the geometry shader processing stage the tessellation control shader processing stage and the tessellation evaluation shader processing stage.

In additional examples the techniques of this disclosure may include selecting with a shader program executing on a shader unit of a GPU a data processing technique from a plurality of data processing techniques based on a tessellation domain type associated with the data to be processed by the shader program and processing with the shader program executing on a shader unit of the GPU the data according to the selected data processing technique. For example the shader program may select a first data processing technique for processing data associated with a first tessellation domain type and a second data processing technique for processing data associated with a second primitive type. The shader program may be for example a domain shader program a geometry shader program or a tessellation evaluation shader program.

As used herein a vertex may generally refer to a vertex data structure or a control point data structure. A vertex data structure may correspond to a vertex included in the actual geometry of a primitive to be rendered while a control point data structure need not correspond to a point in the actual geometry of the control patch to be rendered. Rather a control point may be used to indirectly define the geometry of the control patch.

As illustrated in the example of computing device includes a user interface a CPU a memory controller a system memory a graphics processing unit GPU a GPU cache a display interface a display and bus . User interface CPU memory controller GPU and display interface may communicate with each other using bus . It should be noted that the specific configuration of buses and communication interfaces between the different components shown in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include for example an operating system a word processor application an email application a spread sheet application a media player application a video game application a graphical user interface application or another program. The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct GPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API an X3D API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadrilaterals triangle strips etc.

Memory controller facilitates the transfer of data going into and out of system memory . For example memory controller may receive memory read and write commands and service such commands with respect to memory system in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to system memory . Although memory controller is illustrated in the example computing device of as being a processing module that is separate from both CPU and system memory in other examples some or all of the functionality of memory controller may be implemented on one or both of CPU and system memory .

System memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example system memory may store user applications and graphics data associated with the applications. System memory may additionally store information for use by and or generated by other components of computing device . For example system memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example system memory may store any combination of texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like. In addition system memory may store command streams for processing by GPU . System memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

GPU may be configured to perform graphics operations to render one or more graphics primitives to display . Thus when one of the software applications executing on CPU requires graphics processing CPU may provide graphics commands and graphics data to GPU for rendering to display . The graphics commands may include e.g. draw call commands GPU state programming commands memory transfer commands general purpose computing commands kernel execution commands etc. In some examples CPU may provide the commands and graphics data to GPU by writing the commands and graphics data to memory which may be accessed by GPU . In some examples GPU may be further configured to perform general purpose computing for applications executing on CPU .

GPU may in some instances be built with a highly parallel structure that provides more efficient processing of vector operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices control points pixels and or other data in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to render graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than rendering the images using CPU . In addition the highly parallel nature of GPU may allow GPU to process certain types of vector and matrix operations for general purposed computing applications more quickly than CPU .

GPU may in some instances be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . In further instances GPU may be located on the same microchip as CPU forming a system on a chip SoC . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

GPU may be directly coupled to GPU cache . Thus GPU may read data from and write data to GPU cache without necessarily using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by reducing the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however GPU may not include a separate cache but instead utilize system memory via bus . GPU cache may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM etc.

CPU and or GPU may store rendered image data in a frame buffer that is allocated within system memory . Display interface may retrieve the data from the frame buffer and configure display to display the image represented by the rendered image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing.

Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone handset or a tablet computer. Alternatively display may be a stand alone device coupled to computer device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

Bus may be implemented using any combination of bus structures and bus protocols including first second and third generation bus structures and protocols shared bus structures and protocols point to point bus structures and protocols unidirectional bus structures and protocols and bidirectional bus structures and protocols. Examples of different bus structures and protocols that may be used to implement bus include e.g. a HyperTransport bus an InfiniBand bus an Advanced Graphics Port bus a Peripheral Component Interconnect PCI bus a PCI Express bus an Advanced Microcontroller Bus Architecture AMBA Advanced High performance Bus AHB an AMBA Advanced Peripheral Bus APB and an AMBA Advanced eXentisible Interface AXI bus. Other types of bus structures and protocols may also be used.

According to some aspects of this disclosure GPU may be configured to render a plurality of primitives that includes at least two different types of primitives during the execution of a draw call command. For example the plurality of primitives may include a first subset of primitives having a first primitive type and a second subset of primitives having a second primitive type and GPU may be configured to render the first subset of the plurality of primitives during the execution of the draw call command and to render the second subset of the plurality of primitives during the execution of the draw call command. The second primitive type may be different than the first primitive type. The second subset of the plurality of primitives may be different than the first subset of the plurality of primitives.

In some examples the first and second primitive types may be indicative of how many control points are to be used to define a primitive according to the respective primitive type. For example the first primitive type may indicate that three control points are to be used to define a primitive according to the first primitive type and the second primitive type may indicate that four control points are to be used to define a primitive according to the second primitive type. In such an example the first and second primitive types may correspond to a three control point patch list primitive type and a four control point patch list primitive type respectively.

In further examples the first and second primitive types may be indicative of a shape of a primitive of the respective primitive type. For example the first primitive type may indicate that a primitive of the first primitive type has a line shape and the second primitive type may indicate that a primitive of the second primitive type has a triangle shape. In such an example the first primitive type may be e.g. a line list primitive type and the second primitive type may be e.g. a triangle list primitive type.

In additional examples the first and second primitive types may be indicative of a shape of one or more primitives that are generated based on the respective primitive type. For example the first primitive type may indicate that primitives generate based on the first primitive type have a line shape and the second primitive type may indicate that primitives generate based on the second primitive type have a triangle shape. In such an example the first primitive type may be e.g. a line list primitive type and the second primitive type may be e.g. a triangle list primitive type.

In more examples the first and second primitive types may be indicative of how vertices are to be connected to form a plurality of primitives of a particular shape. For example the first primitive type may indicate that a triangle primitive is to be formed out of every three vertices in a vertex stream. In this example the second primitive type may indicate that a triangle primitive is to be formed out of the first three vertices in a vertex stream and that a triangle primitive is to be formed for each of the subsequent vertices in the vertex stream out of the respective subsequent vertex and the two vertices that are prior to the respective subsequent vertex. In this example the first primitive type may be a triangle list primitive type and the second primitive type may be a triangle strip primitive type.

In further examples the primitive type for each of the primitives to be rendered may be indicative of any combination of one or more of the following 1 whether the primitive is a patch primitive 2 if the primitive is a patch primitive how many control points are to be used to define the primitive of the respective primitive type 3 if the primitive is not a patch primitive the shape of the primitives that are generated based on the respective primitive type and 4 if the primitive is not a patch primitive how vertices are to be connected to form one or more primitives of the particular shape associated with the respective primitive type. Other combinations are also possible.

In some examples the primitive types may be selected from a set of primitive types that corresponds to all or a subset of the input primitive types that are capable of being received from a host device e.g. CPU and rendered by a graphics rendering pipeline implemented by GPU . For example the primitive types may be selected from a set of primitive types that corresponds to the input primitive topologies available for a graphics rendering API such as e.g. the DX 11 API.

In further examples the primitive types may be selected from a set of rasterization primitive types that corresponds to all or a subset of the rasterization primitive types that are capable of being received and rasterized by a rasterizer. For example the primitive types may be selected from a set of rasterization primitive types that corresponds to the rasterization primitive types available for rasterization by a rasterizer in a graphics rendering API such as e.g. the DX 11 API.

According to additional aspects of this disclosure GPU may be configured to render a plurality or primitives using at least two different tessellation domain types during execution of the draw call command. For example GPU may be configured to render a first subset of the second plurality of primitives based on a first tessellation domain type during the execution of the draw call command and to render a second subset of the second plurality of primitives based on a second tessellation domain type during the execution of the draw call command. In some examples the plurality of primitives may include at least two different types of primitives. The second tessellation domain type may be different than the first tessellation domain type. The second subset of the plurality of primitives may be different than the first subset of the plurality of primitives. In some examples the at least two different tessellation domain types may include a triangle tessellation domain type and a quadrilateral tessellation domain type.

A tessellation domain may refer to an object that is subdivided by a tessellator of a graphics pipeline to generate a plurality of coordinates for use by one or more subsequent processing stages of the graphics pipeline. In some examples a tessellation domain type may define a shape of the object that is to be subdivided by the tessellator. In other words the tessellation domain type that is used to render a respective one of a plurality of primitives may be indicative of the shape of the tessellation domain that is to be used for tessellating the respective one of the primitives when rendering the respective one of the plurality of primitives. For example the first tessellation domain type may indicate that a triangle tessellation domain is to be used for tessellating primitives that are to be rendered using the first tessellation domain type and the second tessellation domain type may indicate that a quadrilateral is to be used for tessellating primitives that are to be rendered using the second tessellation domain type.

In some examples GPU may include one or more shader units that are configured to execute a shader program that causes the one or more shader units to select a tessellation domain type for a primitive to be rendered based on a primitive type of the primitive to be rendered. For example the shader program may cause the one or more shader units of GPU to determine a primitive type for a primitive to be rendered to select a first tessellation domain type for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a first primitive type and to select a second tessellation domain type for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is the second primitive type. In such examples GPU may be configured to render the primitive based on the selected tessellation domain type. In some cases the shader program executed by the one or more shader units may be a hull shader program. In additional cases the shader program executed by the one or more shader units may be a tessellation evaluation shader program.

In examples where GPU includes one or more shader units that execute a shader program to select a tessellation domain type the shader program may be further configured to cause the one or more shader units of GPU to provide the selected tessellation domain type to one or more processing stages in a graphics pipeline of GPU that are different than a processing stage that executes the shader program. In such examples GPU may be configured to render using at least the one or more processing stages that are different than the processing stage that executes the shader program the primitive based on the selected tessellation domain. In such examples the one or more processing stages in the graphics pipeline of GPU that are different than the processing stage that executes the shader program may include at least one of a domain shader stage a tessellator stage and a geometry shader stage.

In further examples where GPU includes one or more shader units that execute a shader program to select a tessellation domain type the one or more shader units of GPU may be further configured to execute at least one of a domain shader program and a geometry shader program that causes the one or more shader units to select a data processing technique from a plurality of data processing techniques based on the selected tessellation domain type and to process data associated with the primitive to be rendered based on the selected data processing technique.

In additional examples where GPU includes one or more shader units that execute a shader program to select a tessellation domain type the shader program may be further configured to cause the one or more shader units of GPU to determine whether a primitive to be rendered is a three control point patch primitive or a four control point patch primitive to select a triangle tessellation domain type in response to determining that the primitive to be rendered is a three control point patch primitive and to select a quadrilateral tessellation domain type in response to determining that the primitive to be rendered is a four control point patch primitive. In such examples GPU may be further configured to render the primitive based on the selected tessellation domain type. For example GPU may render a triangular B zier patch surface based on the triangle tessellation domain type in response to determining that the primitive to be rendered is a three control point patch primitive and render a bi cubic B zier patch surface based on the quadrilateral tessellation domain type in response to determining that the primitive to be rendered is a four control point patch primitive.

In some examples GPU may include one or more shader units that are configured to execute a shader program that causes the one or more shader units to select a data processing technique from a plurality of data processing techniques based on a primitive type of a primitive associated with data to be processed by the shader program. In such examples the shader program may further cause the one or more shader units to process the data according to the selected data processing technique. In some cases the shader program may include at least one of a hull shader program a domain shader program a geometry shader program a tessellation control shader program and a tessellation evaluation shader program.

In further examples GPU may include one or more shader units that are configured to execute a shader program that causes the one or more shader units to determine whether a primitive to be rendered is a three control point patch primitive or a four control point patch primitive and cause GPU to render one of a triangular B zier patch surface and a bi cubic B zier patch surface based on whether the primitive to be rendered is a three control point patch primitive or a four control point patch primitive. In such examples the shader program may cause GPU to generate a plurality of triangle primitives that approximate the curvature of a triangular B zier patch surface defined by control points of the primitive to be rendered in response to the one or more shader units determining that the primitive to be rendered is a three control point patch primitive and to generate a plurality of triangle primitives that approximate the curvature of a bi cubic B zier patch surface defined by the control points of the primitive to be rendered in response to the one or more shader units determining that the primitive to be rendered is a four control point patch primitive.

In additional examples GPU may be configured to receive from a host device first data indicative of a primitive type for each of a plurality of vertices to be rendered and to provide second data indicative of a primitive type to one or more processing stages in a graphics rendering pipeline of the GPU. In some cases the second data indicative of the primitive type may be a system generated value that is generated by an input assembler stage of the graphics rendering pipeline of the GPU.

In some examples the techniques described in this disclosure may be implemented in any of the components in computing device illustrated in including e.g. CPU GPU and system memory . For example the techniques for rendering a plurality of primitives of different primitive types during the execution of a draw call command and or the techniques for rendering a plurality of primitives using tessellation domains of different domain types during the execution of a draw call command may be implemented for example in GPU . The techniques described above with respect to the host processor and the API may be implemented for example in CPU . The data indicative of the primitive types to be rendered and the plurality of vertices to be rendered may be stored e.g. in system memory .

CPU is configured to execute a software application a graphics API a GPU driver and an operating system . GPU includes a command engine and one or more processing units . The one or more processing units may form a 3D graphics rendering pipeline.

Memory may store one or more vertices to be rendered by GPU primitive type data associated with individual ones of and or groups of vertices and one or more commands . In some examples vertices may be stored in one or more vertex buffers allocated in memory . In such examples primitive type data may be stored in the same vertex buffers as vertices in other vertex buffers or in other data structures altogether. Commands may be stored in one or more command buffers e.g. a ring buffer .

Each of vertices may include one or more attributes such as e.g. positional coordinates normal coordinates texture coordinates etc. As discussed above vertices may correspond to the geometric vertices of a primitive and or to the control points of a primitive. Primitive type data may include data that is indicative of the primitive type for each of vertices . For example vertices may be grouped into groups of one or more vertices and each of these groups of vertices may correspond to a primitive. The primitive type data may indicate the type of primitive associated with each of the groups of vertices and or associated with the individual vertices within the groups of vertices. In some examples the different primitive types may correspond to the set of primitive topologies that the graphics pipeline implemented by processing units is capable of processing. In further examples the different primitive types may correspond to the set of primitive topologies that are defined by graphics API and are available for use by software application .

Commands may include one or more state commands and or one or more draw call commands. A state command may instruct GPU to change one or more of the state variables in GPU such as e.g. the draw color. A draw call command may instruct GPU to render the geometry defined by a group of one or more vertices e.g. defined in a vertex buffer stored in memory . The geometry defined by the group of one or more vertices may in some examples correspond to a plurality of primitives to be rendered. In general the draw call command may invoke GPU to render all of the vertices stored in a defined section e.g. buffer of memory . In other words once the GPU receives the draw call command control is passed to GPU for rendering the geometry and primitives represented by the vertices in the defined section e.g. buffer of memory .

Software application may each include one or more instructions that cause graphics images to be displayed and or one or more instructions that cause a non graphics task e.g. a general purposed computing task to be performed on GPU . Software application may issue instructions to graphics API . Graphics API may be a runtime service that translates the instructions received from software application into a format that is consumable by GPU driver .

GPU driver receives the instructions from software application via graphics API and controls the operation of GPU to service the instructions. For example GPU driver may formulate one or more commands place the commands into memory and instruct GPU to execute the commands . In some examples GPU driver may place the commands into memory and communicate with GPU via operating system e.g. via one or more system calls.

Command engine is configured to retrieve and execute commands stored in memory . In response to receiving a state command command engine may be configured to set one or more state registers in GPU to particular values based on the state command and or to configure one or more of the fixed function processing units based on the state command. In response to receiving a draw call command command engine may be configured to cause processing units to render the geometry represented by vertices in memory based on primitive type data stored in memory . Command engine may also receive shader program binding commands and load particular shader programs into one or more of the programmable processing units based on the shader program binding commands.

Processing units may include one or more processing units each of which may be a programmable processing unit or a fixed function processing unit. A programmable processing unit may include for example a programmable shader unit that is configured to execute one or more shader programs that are downloaded onto GPU from CPU . A shader program in some examples may be a compiled version of a program written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc. In some examples a programmable shader unit may include a plurality of processing units that are configured to operate in parallel e.g. an SIMD pipeline. A programmable shader unit may have a program memory that stores shader program instructions and an execution state register e.g. a program counter register that indicates the current instruction in the program memory being executed or the next instruction to be fetched. The programmable shader units in processing units may include for example vertex shader units pixel shader units geometry shader units hull shader units domain shader units compute shader units and or unified shader units.

A fixed function processing unit may include hardware that is hard wired to perform certain functions. Although the fixed function hardware may be configurable via one or more control signals for example to perform different functions the fixed function hardware typically does not include a program memory that is capable of receiving user compiled programs. In some examples the fixed function processing units in processing units may include for example processing units that perform raster operations such as e.g. depth testing scissors testing alpha blending etc.

The techniques described in this disclosure may be implemented in any of the components shown in including e.g. graphics API GPU driver command engine and processing units . For example the techniques for rendering a plurality of primitives of different primitive types during the execution of a draw call command and or the techniques for rendering a plurality of primitives using tessellation domains of different domain types during the execution of a draw call command may be implemented in command engine and or in a graphics pipeline implemented by processing units . The techniques described above with respect to the host processor may be implemented for example in software application graphics API and or graphics driver .

As shown in graphics pipeline includes a resources block and a plurality of processing stages. The plurality of processing stages include an input assembler IA a vertex shader VS a hull shader HS a tessellator a domain shader DS a geometry shader GS a rasterizer a pixel shader PS and an output merger . Hull shader tessellator and domain shader may form the tessellation stages of graphics pipeline .

Resources block may correspond to one or more memory resources used by graphics pipeline such as e.g. one or more textures and or one or more buffers. Resources block may store input data to be processed by one or more of the processing stages in graphics pipeline and or output data from one or more of the processing stages in graphics pipeline . As one example resources block may store one or more vertex buffers. The one or more vertex buffers may store a plurality of vertices and or a plurality of control points. As another example resources block may store a frame buffer that holds a rasterized version of the primitives rendered according to the techniques of this disclosure. In some examples the memory resources that form resources block may reside in memory and or GPU cache of computing device .

The processing stages depicted in with straight corners represent fixed function processing stages and the processing stages depicted in with rounded corners represent programmable processing stages. For example as shown in input assembler tessellator rasterizer and output merger are fixed function processing stages and vertex shader hull shader domain shader geometry shader and pixel shader are programmable processing stages. Each of the programmable stages may be configured to execute a shader program of a particular type. For example vertex shader may be configured to execute a vertex shader program hull shader may be configured to execute a hull shader program etc. Each of the different types of shader programs may execute on a common shader unit of the GPU and or on one or more dedicated shader units that are dedicated to executing shader programs of one or more particular types.

As shown in input assembler vertex shader hull shader domain shader geometry shader pixel shader and output merger are communicatively coupled to resources block . Input assembler vertex shader hull shader domain shader geometry shader pixel shader and output merger are configured to retrieve and or to receive input data from resources block . Geometry shader and output merger are configured to write output data to resources block . The above described configuration of communication between the processing stages in graphics pipeline and resources block is merely one example of how the communication may be configured between the processing stages of graphics pipeline and resources block . In other examples more or less uni directional and or bi directional communication channels may be provided between the processing stages of graphics pipeline and resources block .

In some examples the functionality of the different components and processing stages in graphics pipeline may include some or all of the functionality described for similarly named components and processing stages in the Microsoft DirectX DX 11 graphics pipeline. Additional background information regarding the general operation of the DirectX 11 graphics pipeline may be found in Zink et al. Practical Rendering Computation with Direct3D 11 CRC Press 2011 the entire content of which is incorporated herein by reference. In addition to incorporating some or all of the functionality of the similarly named components and processing stages DX 11 pipeline in such examples one or more of the components and processing stages in graphics pipeline may also be configured to perform the multi primitive type rendering techniques of this disclosure and or the multi tessellation domain type rendering techniques of this disclosure.

Input assembler is configured to retrieve a plurality vertices from one or more vertex buffers and to output the vertices to vertex shader for further processing. The one or more vertex buffers may be stored in a memory e.g. memory shown in and or resources block shown in . The vertices and or control points may correspond to one or more primitives to be rendered. Each of vertices may include one or more attributes such as e.g. positional coordinates normal coordinates texture coordinates etc. As discussed above vertices may correspond to the geometric vertices of a primitive and or to the control points of a primitive.

In some examples graphics pipeline may be configured to perform indexed based vertex retrieval. In such examples input assembler may retrieve vertex indexing data for a plurality of primitives to be rendered from a memory e.g. memory shown in and or resources block shown in . The vertex indexing data may be indicative of the order in which vertices from a vertex buffer are to be retrieved from the vertex buffer. The vertex indexing data may define a vertex order for each of the primitives to be rendered.

In examples where graphics pipeline is configured to perform indexed based vertex retrieval input assembler may retrieve vertices and or control points that correspond to the plurality of primitives to be rendered from a vertex buffer based on the vertex indexing data. For example input assembler may retrieve a first vertex index corresponding to a first vertex to be retrieved from a vertex buffer and may retrieve the first vertex from a first location e.g. a first vertex slot in the vertex buffer that is identified by the first vertex index. After retrieving the first vertex in this example input assembler may retrieve a second vertex index corresponding to a second vertex to be retrieved from a vertex buffer and may retrieve the second vertex from a second location e.g. a second vertex slot in the vertex buffer that is identified by the second vertex index. Using indexed rendering may allow out of order access to vertices in a vertex buffer i.e. vertices to be retrieved in a different order than the order in which such vertices were indexed . Using indexed based vertex retrieval may allow the vertices in a vertex buffer to be accessed in an out of order fashion which may reduce the complexity of vertex buffer generation by a graphics application. In addition using indexed based vertex retrieval may allow the same vertex to be retrieved multiple times from a vertex buffer during a single draw call which may reduce memory footprint requirements for a particular draw call.

In examples where indexed based vertex retrieval is not used input assembler may retrieve vertices and or control points from a vertex buffer in the order in which the vertices are indexed. For example if the vertex buffer includes an ordered sequence of vertex slots input assembler may retrieve a first vertex from a first vertex slot in the ordered sequence of vertex slots followed by a second vertex from a second vertex slot in the ordered sequence of vertex slots etc.

In response to retrieving a vertex from a vertex buffer input assembler may pass the vertex on to vertex shader for further processing. In some examples input assembler may pass the vertices to be processed by vertex shader directly to vertex shader . In additional examples input assembler may direct vertex shader to retrieve particular vertices for processing from a vertex buffer in resources block .

In some examples input assembler may generate and output one or more system generated values and pass the system generated values onto one or more subsequent processing stages for use by the one or more subsequent processing stages. System generated values may include for example a vertex identification value and a primitive identification value and an instance identification value. The vertex identification value may be different for different vertices processed by graphics pipeline . Similarly the primitive identification value may different for different primitives processed by graphics pipeline .

According to this disclosure input assembler may receive from a host device e.g. CPU data indicative of a primitive type for each of a plurality of vertices to be rendered and provide data indicative of the primitive type of each of the vertices to one or more subsequent processing stages of graphics pipeline . For example input assembler may be configured to retrieve primitive type data for a plurality of vertices to be rendered from a memory e.g. memory shown in and or resources block shown in . As one example input assembler may retrieve the primitive type data from a primitive type buffer stored in resources block . The primitive type data may be indicative of the primitive type for each of vertices retrieved by input assembler .

A primitive type may refer to a type of primitive that is capable of being received and processed by the graphics processing pipeline. For example the vertices retrieved by input assembler may be grouped into groups of one or more vertices and each of these groups of vertices may correspond to a primitive. The primitive type data may indicate the type of primitive associated with each of the groups of vertices and or associated with the individual vertices within the groups of vertices. For example the primitive type may define how vertices and or control points are to be grouped together and or connected to form a primitive for rendering. As another example the primitive type may specify how many control points are to be used to define a respective one of the primitives to be rendered. In some examples the different primitive types may correspond to the set of primitive topologies that graphics pipeline is capable of processing. In further examples the primitive types may correspond to the Microsoft DirectX 11 primitive topologies. In additional examples the different primitive types may correspond to the set of primitive topologies that are defined by a graphics API that is configured to interact with graphics pipeline . Example primitive types may include points lines triangles line lists line strips triangle lists triangle strips 2 control point patch lists 3 control point patch lists 4 control point patch lists etc.

According to this disclosure input assembler may be configured to determine the primitive type associated with each of the vertices to be processed by graphics pipeline e.g. based on data indicative of a respective primitive type for each of the vertices and provide data indicative of a primitive type of each of the vertices to one or more subsequent processing stages of graphics pipeline . For example input assembler may pass the data indicative of the primitive type of each of the vertices to hull shader domain shader and or geometry shader . In some examples input assembler may pass the data indicative of the primitive type of each of the vertices to pixel shader . In some examples the data indicative of the primitive type may be a system generated value that is generated by input assembler .

Vertex shader is configured to process vertices received from input assembler and or resources block and to generate an output vertex for each input vertex processed by vertex shader . For example for each input vertex vertex shader may execute an instance of a vertex shader program on a shader unit of GPU . The input vertices received by vertex shader and the output vertices generated by vertex shader may be alternatively referred to as input control points and output control points respectively.

In some examples vertex shader may perform one or more per vertex operations for each of the vertices received by vertex shader to generate the output vertices. As one example vertex shader may perform one or more of a world transformation a view transformation a projection transformation or any combination thereof on the positional attributes of the input vertices to generate one or more transformed positional attributes for the output vertices. In further examples vertex shader may generate output vertices that have attributes which are identical to the input vertices e.g. a pass through vertex shader . As another example vertex shader may add and or delete attributes from the set of input attributes to generate a set of output attributes for an output vertex.

If tessellation stages are enabled for graphics pipeline then the output vertices generated by vertex shader may be passed on to hull shader e.g. either directly or through resources block for further processing. If tessellation stages are not enabled for graphics pipeline but geometry shader is enabled then the output vertices generated by vertex shader may be passed on to geometry shader e.g. either directly or through resources block for further processing. If tessellation stages are not enabled for graphics pipeline and geometry shader is not enabled for graphics pipeline then the output vertices generated by vertex shader may be passed on to rasterizer e.g. either directly or through resources block for further processing.

Tessellation stages i.e. hull shader tessellator and domain shader may tessellate a higher order surface e.g. a patch a B zier surface a subdivision surface etc. into a plurality of lower order primitives e.g. points lines triangles . In some examples the higher order surfaces may be curved surfaces and the lower order primitives may have non curved surfaces and non curved edges. Each of the higher order surfaces may be defined based on one or more control points in a control point patch list and based on one or both of a hull shader program and a domain shader program that are used to tessellate the surface. The plurality of lower order primitives generated for each tessellated higher order surface may approximate the curvature of the higher order surface. The control point patch list that is used to define the higher order surface may correspond to an input primitive that has a particular primitive type e.g. a three control point patch list a four control point patch list etc. 

In general hull shader may pass the control points received from vertex shader to domain shader for further processing and provide configuration data to tessellator . Tessellator may determine values at which one or more parametric equations that represent a particular type of higher order surface should be evaluated. Domain shader may evaluate the parametric equations at the values determined by tessellator and output a vertex for each evaluation. The vertices that are output by domain shader may be grouped together to define a plurality of low order primitives that approximate the curvature of the higher order surface.

More specifically hull shader may process the control points received from vertex shader and or resources block and may generate an output control point for each instance of the hull shader program executed by hull shader . For example for each output control point to be generated by hull shader hull shader may execute an instance of a hull shader program on a shader unit of GPU . In some examples hull shader may execute a pass through hull shader program for each output control point. The pass through hull shader program may cause hull shader to for each output control point output a control point that corresponds to a respective one of the input control points. In this case an output control point may correspond to an input control point if the output control point has the same attributes as the input control point.

In further examples hull shader may generate one or more output attributes for an output control point that are not identical to the input attributes of a respective one of the input control points. For example hull shader may perform substantive processing on one or more of the attributes of the input control points to generate one or more attributes for the output control points. As another example hull shader may add and or delete attributes from a set of input attributes to generate the set of output attributes for an output control point.

Hull shader may also execute an instance of a patch constant function for each primitive e.g. higher order surface . The patch constant function may determine and provide configuration parameters to tessellator to be used by tessellator when generating output values. For example the patch constant function may cause hull shader to provide tessellation factors to tessellator . The tessellation factors may specify a degree of tessellation that tessellator is to apply to a particular tessellation domain e.g. how finely the domain should be subdivided and or the number of smaller objects into which the domain should be subdivided .

As another example the patch constant function may cause hull shader to provide a tessellation domain type to tessellator . A tessellation domain may refer to an object that is used by tessellator to generate a plurality of coordinates for use by domain shader . Conceptually the tessellation domain may correspond to an object that is subdivided by tessellator into a plurality of smaller objects. A tessellation domain type may define one or more attributes of the object e.g. the shape of the object that is to be subdivided by the tessellator. The positional coordinates of the vertices of the smaller objects are then sent to domain shader for further processing. In some examples the tessellation domain type may be selected from a set of tessellation domain types that include a quadrilateral tessellation domain type i.e. a quad a triangle tessellation domain type i.e. a tri and a line tessellation domain type i.e. an isoline . The smaller objects into which the domain is subdivided in some examples may correspond to triangles line segments or points.

According to this disclosure hull shader may be configured to selectively configure the tessellation domain type to be used by tessellator for tessellation on a primitive by primitive basis. For example hull shader may be configured to execute a hull shader program e.g. a patch constant program that causes hull shader to select a tessellation domain type for a primitive to be rendered based on a primitive type of the primitive to be rendered. For example hull shader may determine a primitive type for a primitive to be rendered select a first tessellation domain type for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a first primitive type and select a second tessellation domain type for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a second primitive type.

One example tessellation domain type selection scheme will now be described. According to this example if the primitive type of the primitive to be rendered is a four control point patch list then hull shader may select the quadrilateral tessellation domain type as the tessellation domain type to be used for tessellating the primitive. In such examples if the primitive type of the primitive to be rendered is a three control point patch list a triangle list or a triangle strip then hull shader may select the triangle tessellation domain as the tessellation domain type to be used for tessellating the primitive. In such examples if the primitive type of the primitive to be rendered is a two control point patch list a line list or a line strip then hull shader may select the isoline domain as the tessellation domain type to be used for tessellating the primitive. The example tessellation domain type selection scheme described above is merely one example that is described for illustrative purposes. It should be understood that other examples are possible and within the scope of this disclosure.

In response to selecting the tessellation domain type for a primitive to be rendered hull shader may cause graphics pipeline to render the primitive based on the selected tessellation domain type. For example hull shader may provide the selected tessellation domain type to one or more additional processing stages in graphics pipeline that are different than hull shader . Graphics pipeline may use the one or more additional processing stages to render the primitive based on the selected tessellation domain type. For example each of the one or more additional processing stages may perform a processing technique that is dependent on the selected tessellation domain type. In some examples the one or more additional processing stages may include tessellator and or domain shader .

In some examples to determine the primitive type of a primitive to be rendered hull shader may receive data indicative of the primitive type of a primitive to be rendered from input assembler . For example hull shader may receive a system generated value from input assembler that is indicative of the primitive type of the primitive to be rendered.

In further examples hull shader may select a hull shader data processing technique from a plurality of hull shader data processing techniques for processing data associated with a primitive to be rendered based on the primitive type of the primitive to be rendered. In such examples hull shader may process data associated with the primitive to be rendered based on the selected data processing technique. For example hull shader may determine a primitive type for a primitive to be rendered select a first hull shader data processing technique from a plurality of hull shader data processing techniques for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a first primitive type and select a second hull shader data processing technique from a plurality of hull shader data processing techniques for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a second primitive type.

In additional examples hull shader may pass the data indicative of the primitive type of the primitive to be rendered to one or more additional processing stages in graphics pipeline . For example hull shader may pass the data indicative of the primitive type of the primitive to be rendered to geometry shader which may in turn use the data to select a processing technique for processing the vertices that correspond to the primitive.

Tessellator may generate a plurality of output values for each primitive e.g. higher order surface processed by tessellation stages . The output values may determine the values at which one or more parametric equations that represent a particular type of higher order surface should be evaluated by domain shader . In some examples tessellator may generate the plurality of output values based on one or more tessellation factors and or based on a tessellation domain type provided to tessellator by hull shader .

For example if the selected tessellation domain type is a quadrilateral tessellation domain type tessellator may in some examples subdivide a quadrilateral tessellation domain into a plurality of triangles and output normalized coordinates that correspond to each of the vertices of the triangles to domain shader for further processing. As another example if the selected tessellation domain type is a triangle tessellation domain type tessellator may in some examples subdivide a triangle tessellation domain into a plurality of triangles and output normalized coordinates that correspond to each of the vertices of the triangles to domain shader for further processing. As a further example if the selected tessellation domain type is an isoline tessellation domain type tessellator may in some examples subdivide an isoline tessellation domain into a plurality of line segments and output normalized coordinates that correspond to each of the vertices i.e. endpoints of the line segments to domain shader for further processing. In each of these examples the tessellation factors may determine the amount by which tessellator subdivides the corresponding tessellation domain.

Domain shader may receive the normalized coordinates generated by tessellator and the control points for a higher order surface from hull shader and generate output vertices that correspond to a plurality of tessellated triangles and or a plurality of tessellated line segments. The plurality of tessellated triangles and or line segments may approximate the curvature and or shape of a higher order surface. For example for each output value received from tessellator domain shader may execute an instance of a domain shader program on a shader unit of GPU . The domain shader program may cause domain shader to evaluate one or more parametric equations at a particular value that is determined based on the particular coordinates received from tessellator and to generate coordinates for an output vertex based on the evaluations. One or more of the coefficients of the parametric equations used to generate the output vertex coordinates may be defined based on one or more of the control points received from hull shader .

In examples where tessellation stages are configured to generate a plurality of tessellated triangles each of the output vertices generated by tessellation stages may correspond to a respective vertex of a respective one of the plurality of tessellated triangles and three consecutive output vertices may correspond to the vertices of a single tessellated triangle. In examples where tessellation stages are configured to generate a plurality of line segments each of the output vertices generated by tessellation stages may correspond to a respective endpoint of a respective one of the plurality of line segments and two consecutive output vertices may correspond to the endpoints of a single tessellated line segment. Each of the vertices may include one or more positional attributes that are indicative of the position of the respective vertex.

According to this disclosure domain shader may be configured to select a domain shader data processing technique from a plurality of domain shader data processing techniques for processing data associated with a primitive to be rendered based on the tessellation domain type selected for the primitive to be rendered. In such examples domain shader may process data associated with the primitive to be rendered based on the selected data processing technique. For example domain shader may determine a selected tessellation domain type for a primitive to be rendered select a first domain shader data processing technique from a plurality of hull shader data processing techniques for the primitive to be rendered in response to determining that the selected tessellation domain type for the primitive to be rendered is a first tessellation domain type and select a second domain shader data processing technique from a plurality of domain shader data processing techniques for the primitive to be rendered in response to determining that the selected tessellation domain type for the primitive to be rendered is a second tessellation domain type. In some examples to determine the selected tessellation domain type for a primitive to be rendered domain shader may receive data indicative of the selected tessellation domain type from hull shader .

One example scheme for selecting a domain shader processing technique for a primitive to be rendered based on a tessellation domain type for the primitive to be rendered is now described. If the selected tessellation domain type for the primitive to be rendered is a quadrilateral then domain shader may evaluate a first set of one or more parametric equations to generate a plurality of triangle primitives that approximate the curvature of a bi cubic B zier patch surface defined by control points of the primitive to be rendered. In such examples if the primitive type of the primitive to be rendered is a three control point patch list a triangle list or a triangle strip then hull shader may evaluate a second set of one or more parametric equations to generate a plurality of triangle primitives that approximate the curvature of a triangular B zier patch surface defined by control points of the primitive to be rendered. In such examples if the primitive type of the primitive to be rendered is a two control point patch list a line list or a line strip then hull shader may generate a plurality of line segments that correspond to the primitives to be rendered. The example domain shader data processing technique selection scheme described above is merely one example that is described for illustrative purposes. It should be understood that other examples are possible and within the scope of this disclosure.

In further examples domain shader may select a domain shader data processing technique from a plurality of domain shader data processing techniques for processing data associated with a primitive to be rendered based on the primitive type of the primitive to be rendered. In such examples domain shader may process data associated with the primitive to be rendered based on the selected data processing technique. For example domain shader may determine a primitive type for a primitive to be rendered select a first domain shader data processing technique from a plurality of domain shader data processing techniques for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a first primitive type and select a second domain shader data processing technique from a plurality of domain shader data processing techniques for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a second primitive type.

In some examples to determine a primitive type for a primitive to be rendered domain shader may receive data indicative of the primitive type of a primitive to be rendered from input assembler . For example domain shader may receive a system generated value from input assembler that is indicative of the primitive type of the primitive to be rendered. In further examples domain shader may receive data indicative of the primitive type of a primitive to be rendered from hull shader .

If geometry shader is enabled for graphics pipeline then the output vertices generated by domain shader may be passed on to geometry shader e.g. either directly or through resources block for further processing. If geometry shader is not enabled for graphics pipeline then the output vertices generated by domain shader may be passed on to rasterizer e.g. either directly or through resources block for further processing.

Geometry shader may receive vertices that correspond to an input primitive from one or more prior processing stages in graphics pipeline and may generate output vertices that correspond to an output primitive. The vertices for the output primitive may be passed on to rasterizer for further processing. In examples where tessellation is enabled for graphics pipeline the input primitives and vertices received by geometry shader may correspond to tessellated primitives e.g. triangles or line segments that are generated by domain shader . In examples where tessellation is not enabled for graphics pipeline the input vertices received by geometry shader may correspond to vertices that are output by vertex shader .

Geometry shader may be invoked once for each of the primitives produced by domain shader . For example for each of the tessellated primitives geometry shader may execute an instance of a geometry shader program on a shader unit of GPU and generate an output primitive based on the input primitive. In some examples the primitives that are generated by geometry shader may take the form of triangle streams and or line streams. In some examples the output primitive may be identical to the input primitive.

In additional examples geometry shader may perform one or more per primitive operations for each of the primitives received by geometry shader to generate zero or more output primitives based on the input primitive. For example geometry shader may modify one or more attributes of the input vertices of the input primitive to produce output vertices for the output primitive. As another example geometry shader may add and or delete vertices with respect to the input to produce output vertices for the output primitive. As a further example geometry shader may generate multiple output primitives based on a single input primitive and or drop particular input primitives from further rendering in graphics pipeline .

According to this disclosure geometry shader may select a geometry shader data processing technique from a plurality of geometry shader data processing techniques for processing data associated with a primitive to be rendered based on the primitive type of the primitive to be rendered. In such examples geometry shader may process data associated with the primitive to be rendered based on the selected data processing technique. For example geometry shader may determine a primitive type for a primitive to be rendered select a first geometry shader data processing technique from a plurality of geometry shader data processing techniques for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a first primitive type and select a second geometry shader data processing technique from a plurality of geometry shader data processing techniques for the primitive to be rendered in response to determining that the primitive type of the primitive to be rendered is a second primitive type.

In some examples to determine the primitive type of a primitive to be rendered geometry shader may receive data indicative of the primitive type of a primitive to be rendered from input assembler . For example geometry shader may receive a system generated value from input assembler that is indicative of the primitive type of the primitive to be rendered. In further examples geometry shader may receive data indicative of the primitive type of a primitive to be rendered from hull shader .

According to this disclosure geometry shader may for each of the primitives received by geometry shader select a rasterization primitive type based on the primitive type of the respective primitive received by geometry shader and generate one or more rasterization primitives of the selected rasterization primitive type based on the respective primitive received by geometry shader . For example if the primitive received by geometry shader has a first primitive type then geometry shader may select a first rasterization primitive type and generate one or more rasterization primitives of a first rasterization primitive type based on the primitive received by geometry shader . As another example if the primitive received by geometry shader has a second primitive type then geometry shader may select a second rasterization primitive type and generate one or more rasterization primitives of a second rasterization primitive type based on the primitive received by geometry shader . The first primitive type and the second primitive type may be different. The first rasterization primitive type and the second rasterization primitive type may be the same or different.

Geometry shader may provide the rasterization primitive type for each of the rasterization primitives generated by geometry shader to rasterizer for further processing. For example geometry shader may for each of the rasterization primitives generated by geometry shader provide data indicative of the respective rasterization primitive to rasterizer and data indicative of a rasterization primitive type of the respective rasterization primitive to rasterizer .

Rasterizer may be configured to convert a plurality of primitives e.g. points lines and triangles into a plurality of pixels that correspond to the primitives. For example rasterizer may receive three vertices that correspond to a triangle primitive and convert the three vertices into a plurality of pixels that correspond to the screen pixel locations that are covered by the triangle primitive. Screen pixel locations that are covered by the triangle primitive may include screen pixel locations that correspond to the vertices of the triangle the edges of the triangle and the interior of the triangle. The primitives may be received from one or more prior stages of graphics pipeline e.g. vertex shader domain shader geometry shader and or resources block .

According to this disclosure rasterizer may be configured to select a rasterization technique from a plurality of rasterization techniques based on a rasterization primitive type received from a different processing stage in graphics pipeline . For example rasterizer may select a first rasterization technique from the plurality of rasterization techniques if the rasterization primitive type is a first rasterization primitive type and select a second rasterization technique from the plurality rasterization techniques if the rasterization primitive type is a second rasterization primitive type. The first rasterization primitive type may be different than the second rasterization primitive type. The first rasterization technique may be the same as or different than the second rasterization technique. Allowing rasterizer to rasterize rasterization primitives of different rasterization primitive types during a single draw call may enable the graphics pipeline to render input primitives that map to different rasterization primitive types during a single draw call.

In some examples rasterizer may receive data indicative of the rasterization primitive type for each of a plurality of rasterization primitives to be rasterized from geometry shader . In examples where geometry shader is disabled rasterizer may receive data indicative of the rasterization primitive type for each of a plurality of rasterization primitives to be rasterized from domain shader and or from input assembler .

In some examples the rasterization primitive type may be selected from a set of rasterization primitive types that includes a point stream a line stream and a triangle stream. In further examples the rasterization primitive type may be selected from a set of rasterization primitive types that includes a point a line and a triangle. In general the set of rasterization primitive types may correspond to the types of primitives that are capable of being rasterized by a rasterizer in the graphics pipeline. In some cases the rasterization primitive types and the corresponding rasterization techniques may correspond to the different rasterization primitive types and corresponding rasterization rules defined by a graphics API such as e.g. the DX 11 graphics API. For example if the rasterization primitive type is a triangle stream then the rasterization may select a set of rasterization rules that corresponds to rasterizing triangles in a triangle stream.

Pixel shader may receive pixels from rasterizer and generate shaded pixels based on the received pixels according to a pixel shader program. For example for each pixel received from rasterizer pixel shader may execute an instance of a pixel shader program on a shader unit of GPU . In some examples pixel shader may execute a pass through pixel shader program for each pixel. The pass through pixel shader program may cause pixel shader to for each pixel output a pixel that corresponds to a respective one of the input pixel. In this case an output pixel may correspond to an input pixel if the output pixel has the same attributes as the input pixel.

In further examples pixel shader may generate one or more output attributes for an output pixel that are not identical to the input attributes of a respective one of the input pixels. For example pixel shader may perform substantive processing on one or more of the attributes of an input pixel to generate one or more attributes for an output pixel. As another example pixel shader may add and or delete attributes from a set of input attributes to generate the set of output attributes for an output pixel.

Output merger may place pixel data received from pixel shader into a render target e.g. a frame buffer . In some examples output merger may merge the pixel data received from pixel shader with the pixel data already stored in a render target based on a raster operation.

Graphics pipeline may allow multiple different primitive types to be rendered during the execution of a single draw call command and or multiple different tessellation domain types to be used during the execution of a single draw call command. Therefore when user applications decide to render graphics objects and or scenes that include primitives of different primitive types and or require the use of different tessellation domains such user applications do not necessarily need to perform separate draw call commands in order render the different primitive types. Relieving applications from the requirement of issuing separate draw calls for different primitive types may reduce the complexity and processing overhead for user applications.

In some examples graphics pipeline may be configured to switch between the rendering of different primitive types without requiring the rendering state to be switched and without requiring new shader programs to be bound to the pipeline. This may reduce the number of times that the render state of the pipeline needs to be switched during the rendering of a graphics scene and or the number of times that shader programs need to be reloaded into different processing stage of the graphics pipeline thereby improving the rendering efficiency of the graphics processing system.

3D designers and or modelers often generate meshes to model a 3D object to be rendered. In some cases a single mesh may include primitives of different primitive types which may result in multiple draw call commands needing to be executed in order to render the mesh that represents the 3D object. For example a mesh may include small number of isolated triangles in an otherwise quadrilateral mesh. As one specific example the original Proog and Emo meshes from Blender s Elephant s Dream include 32 118 97.8 quadrilaterals and 886 2.7 triangles. is an image illustrating an example mesh from the Blender s Elephant s Dream. As shown in the isolated triangles are located around the center of the eyes and above eyebrows see dark circles in an otherwise quadrilateral surface mesh.

One approach for rendering meshes that include both triangles and quadrilaterals is to replace each of the triangles in the mesh with three quadrilaterals by applying Catmull Clark CC subdivision. This approach can solve the problem of needing to use separate draw calls for rendering the mesh but may quadruple the number of patches everywhere else and may therefore increase the amount of computation by fourfold. For example one step of CC subdivision may turn the Proog and Emo models into a purely quadrilateral mesh with 131K facets. This may affect both memory requirements and CPU GPU transfer e.g. memory bandwidth usage .

Another approach for rendering meshes that include both triangles and quadrilaterals is to convert each of the triangles into a triangular B zier patch. There are several schemes capable of converting a triangle into a triangular patch. However these schemes typically require a separate pass and hence an overhead e.g. sorting primitives by type and no longer preserving primitive order that is to be avoided in real time rendering.

This disclosure describes techniques for rendering meshes that include both triangles and quadrilaterals. The techniques of this disclosure may include enhancing the programmability of the hull shader HS to handle different domains in the same draw call. In some examples the techniques of this disclosure may provide one or more new API instructions which may be utilized to implement the aforementioned approach of converting triangles into triangular B zier patches. The techniques of this disclosure may in some examples convert triangles into triangular B zier patches independently from quads being converted into bi cubic B zier patches as described in further detail below with respect to . It should be noted that conversion of triangles into triangular B zier patches and quads into bi cubic B zier patches is merely one example of using the techniques of this disclosure and that other example uses are possible and within the scope of this disclosure.

Each of example instantiations of the DX11 pipeline shown in is associated with a single type of draw call command e.g. DrawCall1 Quad DrawCall2 Tri etc. . Each of the types of draw call commands is associated with a single tessellation domain type. For example the first type of draw call command i.e. DrawCall1 Quad is associated with a quadrilateral i.e. quad tessellation domain type the second type of draw call command i.e. DrawCall2 Tri is associated with a triangle i.e. tri tessellation domain type and the third type of draw call command i.e. DrawCall3 Line is associated with a line i.e. isoline tessellation domain type.

Prior to invoking each of the instantiations of the DX11 pipeline shown in a host processor e.g. a CPU may provide one or more state commands to the GPU to set the state of the GPU to render a specific type of primitive i.e. the Primitive Topology shown in . For example the left hand instantiation of the DX11 pipeline indicates that the graphics pipeline is configured by the host processor to render primitives of a four control point patch list primitive type. Similarly the middle instantiation of the DX11 pipeline indicates that the graphics pipeline is configured by the host processor to render primitives of a three control point patch list primitive type. Likewise the right hand instantiation of the DX11 pipeline indicates that the graphics pipeline is configured by the host processor to render primitives of a two control point patch list primitive type.

The primitive topologies shown in may correspond to the primitive type discussed in other portions of this disclosure. The primitive topologies shown in may be alternatively referred to as input primitive types in order to distinguish such primitive types from the rasterization primitive types.

Also prior to invoking each of the instantiations of the DX11 pipeline shown in the host processor may provide a compiled HS program to the GPU to be bound to the pipeline instantiation. Binding the HS program to the pipeline instantiation may involve placing the HS program into the program memory e.g. instruction cache associated with the HS and causing the HS program to execute when the pipeline is invoked in response to a draw call command. The HS program may specify the tessellation domain type to be used by the tessellation stage during the execution of a draw call command. For example the left hand instantiation of the DX11 pipeline indicates that the HS program specifies that a quad domain type is to be used by the tessellation stage the middle instantiation of the DX11 pipeline indicates that the HS program specifies that a tri domain type is to be used by the tessellation stage and the right hand instantiation of the DX11 pipeline indicates that the HS program specifies that an isoline domain type is to be used by the tessellation stage.

The rasterization primitive types shown in indicate the type of rasterization primitive that is output by domain shader. For example in the example pipeline instantiation of triangle rasterization primitives are generated for each of the input primitives when the quad domain type and the triangle domain type is specified by the HS program and line rasterization primitives are generated for each of the input primitives when the isoline domain type is specified by the HS program.

As shown in only primitives of a single primitive type can be rendered during a single draw call command in the existing DX 11 pipeline. If a mesh or another 3D graphics object includes primitives of different primitive types then multiple draw call commands may need to be executed. Therefore a host processor may need to separate out the different primitive types into different groups so that the different primitive types can be rendered during different draw calls. This may add significant complexity and delay to user applications that need to draw complex 3D objects and meshes with multiple different primitive types.

Moreover between each of the draw calls the rendering state of the pipeline may need to be changed to support different primitive types and different shader programs may need to be bound to the graphics pipeline. The switching of the rendering state between each draw call command may consume a significant number of processing cycles and therefore slow down the rendering of 3D scenes.

The IA stage may determine the primitive type associated with each vertex or control point to be processed and pass data indicative of the primitive type of each of the vertices to one or more subsequent processing stages e.g. as a system generated value . For example the IA stage may pass the data indicative of the primitive type of each of the vertices to the HS stage the DS stage and or the GS stage. In some examples the IA stage may pass the data indicative of the primitive type of each of the vertices to the PS stage.

The HS stage may select a tessellation domain type for processing the primitive based on the data indicative of the primitive type. For example as shown in if the primitive type is a four control point patch list then the HS stage may select the quad domain as the tessellation domain type. Similarly if the primitive type is a three control point patch list then the HS stage may select the tri domain as the tessellation domain type. Likewise if the primitive type is a two control point patch list then the HS stage may select the isoline domain as the tessellation domain type.

In some examples the HS stage may select a hull shader processing technique from a plurality of hull shader processing techniques for processing an input primitive based on the primitive type of the input primitive. In further examples the DS stage may select a domain shader processing technique from a plurality of domain shader processing techniques for processing an input primitive based on the primitive type of the input primitive. In additional examples the GS stage may select a geometry shader processing technique from a plurality of geometry shader processing techniques for processing tessellated primitives for an input primitive based on the primitive type of the input primitive.

The rasterizer may be configured to receive data indicative of the rasterization primitive type from geometry shader and rasterize the rasterization primitives received from the geometry shader based on the rasterization primitive type. For example the rasterizer may select one or more rasterization rules to use when rasterizing primitives based on the rasterization primitive type.

By allowing multiple different primitive types to be rendered during a single draw call command and multiple different tessellation domain types to be used during a single draw call command user applications do not necessarily need to perform separate draw call commands in order to render primitives of different types which may reduce the complexity and processing overhead for user applications particularly in cases where a 3D object or mesh may include primitives of differing types. Moreover the techniques of this disclosure may reduce the number of times that the render state of the pipeline needs to be switched between draw call commands thereby improving the rendering efficiency of the graphics processing system. In addition the techniques of this disclosure may reduce the number of times that shader programs need to be reloaded into different processing stage of the pipeline thereby providing further improvements in the rendering efficiency of the graphics processing system.

Prior to invoking each of the instantiations of the DX11 pipeline shown in a host processor e.g. a CPU may provide one or more state commands to the GPU to set the state of the GPU to render a specific type of primitive i.e. the Primitive Topology shown in . For example the left hand instantiation of the DX11 pipeline indicates that the graphics pipeline is configured by the host processor to render primitives of the four control point patch list primitive type. Similarly the middle instantiation of the DX11 pipeline indicates that the graphics pipeline is configured by the host processor to render primitives of a triangle list primitive type a triangle strip primitive type or a three control point patch list primitive type. Likewise the right hand instantiation of the DX11 pipeline indicates that the graphics pipeline is configured by the host processor to render primitives of a line list primitive type a line strip primitive type or a two control point patch list primitive type.

It should be noted that where multiple primitive types i.e. multiple primitive topologies are shown in a single example pipeline instantiation in the pipeline instantiation may be configured to render only a single one of the primitive types for a given draw call command. In other words where multiple primitive types are listed for a single illustrated pipeline instantiation such a notation is effectively representing multiple different actual instantiations of the graphics pipeline one instantiation for each primitive type. For example the middle pipeline instantiation illustrated in represents three different actual instantiations of the pipeline a first instantiation for the TriangleList primitive type a second instantiation for the TriangleStrip primitive type and a third instantiation for the 3 CONTROL POINT PATCHLIST primitive type. Only a single instantiation and therefore a single primitive type may be used for a given draw call instruction in the example of .

The primitive topologies shown in may correspond to the primitive type discussed in other portions of this disclosure. The primitive topologies shown in may be alternatively referred to as input primitive types in order to distinguish such primitive types from the rasterization primitive types.

Although the hardware tessellation stages are disabled in the graphics pipeline instantiations of such graphics pipelines may in some examples still be able to perform tessellation using the geometry shader. In such examples prior to invoking each of the instantiations of the DX11 pipeline shown in the host processor may provide a compiled GS program to the GPU to be bound to the pipeline instantiation. Binding the GS program to the pipeline instantiation may involve placing the GS program into the program memory e.g. instruction cache associated with the GS and causing the GS program to execute when the pipeline is invoked in response to a draw call command. The GS program may specify a tessellation technique to be used when tessellating input primitives during execution of the draw call command.

For example the left hand instantiation of the DX11 pipeline indicates that the GS program specifies a tessellation technique that tessellates a four control point patch list into a plurality of triangles that form a triangle stream. Similarly the middle instantiation of the DX11 pipeline indicates that the GS program specifies a tessellation technique that tessellates one of a triangle list a triangle strip and a three control point patch list into a plurality of triangles that form a triangle stream. Likewise the right hand instantiation of the DX11 pipeline indicates that the GS program specifies a tessellation technique that tessellates one of a line list a line strip and a two control point patch list into a plurality of lines that form a line stream.

The rasterization primitive types shown in indicate the type of rasterization primitive that is output by the geometry shader. For example in the example pipeline instantiation of a triangle stream rasterization primitive type is generated for each of the input primitives when the input primitive is a four control point patch list a triangle list a triangle strip or a three control point patch list. The triangle stream rasterization primitive type may correspond to the triangle rasterization primitive type discussed above with respect to . Similarly in the example pipeline instantiation of a line stream rasterization primitive type is generated for each of the input primitives when the input primitive is a line list a line strip and a two control point patch list. The line stream rasterization primitive type may correspond to the line rasterization primitive type discussed above with respect to . It should be noted that the icons illustrated beneath the rasterization primitive type in do not depict tessellation domain types but rather depict a plurality of tessellated primitives that may be generated by geometry shader for a particular input primitive.

As shown in only primitives of a single primitive type can be rendered during a single draw call command in the existing DX 11 pipeline. If a mesh or another 3D graphics object includes primitives of different primitive types then multiple draw call commands may need to be executed. Therefore a host processor may need to separate out the different primitive types into different groups so that the different primitive types can be rendered during different draw calls. This may add significant complexity and delay to user applications that need to draw complex 3D objects and meshes with multiple different primitive types.

Moreover between each of the draw calls the rendering state of the pipeline may need to be changed to support different primitive types and different shader programs may need to be bound to the graphics pipeline. The switching of the rendering state between each draw call command may consume a significant number of processing cycles and therefore slow down the rendering of 3D scenes.

Similar to the IA stage may determine the primitive type associated with each vertex or control point to be processed and pass data indicative of the primitive type of each of the vertices to one or more subsequent processing stages e.g. as a system generated value . For example the IA stage may pass the data indicative of the primitive type of each of the vertices to the GS stage. In some examples the IA stage may pass the data indicative of the primitive type of each of the vertices to the PS stage. The GS stage may in some examples select a geometry shader processing technique from a plurality of geometry shader processing techniques based on the primitive type of the input primitive.

In some examples the plurality of geometry shader processing techniques may include a plurality of tessellation techniques that are capable of generating a plurality of tessellated primitives based on an input primitive and that are capable of being implemented in the GS stage. In some examples the GS stage may be invoked once per primitive and during the single invocation for each primitive the GS stage may generate a tessellation grid e.g. parametric domain points and iterate them.

The rasterizer may be configured to receive data indicative of the rasterization primitive type from geometry shader and rasterize the rasterization primitives received from the geometry shader based on the rasterization primitive type. For example the rasterizer may select one or more rasterization rules to use when rasterizing primitives based on the rasterization primitive type.

By allowing multiple different primitive types to be rendered during a single draw call command and multiple different tessellation domain types to be used during a single draw call command user applications do not necessarily need to perform separate draw call commands in order to render primitives of different types which may reduce the complexity and processing overhead for user applications particularly in cases where a 3D object or mesh may include primitives of differing types. Moreover the techniques of this disclosure may reduce the number of times that the render state of the pipeline needs to be switched between draw call commands thereby improving the rendering efficiency of the graphics processing system. In addition the techniques of this disclosure may reduce the number of times that shader programs need to be reloaded into different processing stage of the pipeline thereby providing further improvements in the rendering efficiency of the graphics processing system.

The HS may receive the primitive type value as a system generated value same as output of IA and may operate differently for each primitive type. For example the HS stage may select a tessellation domain type based on the primitive type value and or select a hull shader processing technique for a primitive to be processed by the HS based on the primitive type value. The HS may output the selected domain types such as e.g. isoline tri quad for the primitive being processed by the HS to the tessellator TS stage and or the DS stage.

The TS stage may receive the domain type from the HS stage and tessellation factors from the HS and generate a tessellation grid based on the domain type received from the HS stage and the tessellation factors received from the HS stage.

The DS stage may receive the domain type from the HS stage and may operate differently for each domain type. For example the DS stage may select a domain shader processing technique for a primitive to be processed from a set of domain shader processing techniques based on the domain type provided by the HS stage. In further examples the DS stage may select a domain shader processing technique for a primitive to be processed from a set of domain shader processing techniques based on the primitive type value.

The GS stage may receive the primitive type value as output by the HS stage and may operate differently for each primitive type. For example the GS stage may select a geometry shader processing technique for a primitive to be processed by the GS stage based on the primitive type value. GS also output a rasterization primitive type for the rasterizer such as e.g. a triangle stream e.g. TriangleStream or a line stream e.g. LineStream .

As shown in the HS stage may need to know the primitive type triangle or quad as well as output domain type. For example the pipeline may provide a primitive type value i.e. prim type as a system generated value. In addition a domain type value may be generated along with tessellation factors both of which may be sent to tessellation engine. The underlying output patch data may be a type which will be used by the DS stage.

To render a plurality of graphics primitives a graphics driver e.g. GPU driver typically receives a draw call command from a higher level graphics application e.g. software application that instructs the graphics driver to render the plurality of graphics primitives. The graphics driver typically passes on the draw call command to a GPU for further processing. In some cases however the graphics driver may split up the draw call command received from the higher level graphics application into a plurality of draw call commands and issue the plurality of draw call commands to one or more GPUs for further processing. Splitting up a draw call command may refer to subdividing the primitives to be rendered as part of the draw call received from the higher level graphics application into a plurality of groups of primitives and issuing a respective one of a plurality of draw call commands to one or more GPUs for each of the groups of primitives.

A graphics driver may split up a draw call command for various reasons. For example a graphics driver may utilize a plurality of separate GPUs to provide hardware accelerated graphics rendering services to higher level applications. In such an example a graphics system may be able to more efficiently process a draw call by subdividing the work among the plurality of separate GPUs and leveraging the parallelism gained by such a subdivision.

One technique for splitting up the primitive data associated with a draw call is to subdivide the primitive data received from the higher level application into various subsets of data without analyzing the particular data that is to be subdivided. In other words if 256 kilobytes kB of primitive data is received from a higher level application then the graphics driver may subdivide the data into two subsets of 128 kB. When performing this technique it is important that the subdivision boundary or subdivision boundaries coincide with the primitive boundaries within the primitive data. In other words it is important the start of each of the subsets of primitive data be aligned with the starting data of a particular primitive. Otherwise the subsets of the primitive data may include only partial data for some of the primitives which may cause such primitives to not render properly.

In conventional GPUs ensuring that the subdivision boundaries coincide with the primitive boundaries could be achieved by ensuring that the size of the data blocks after subdivision was divisible by the size of an individual primitive. Alternatively coincidence of the subdivision and primitive boundaries could be achieved by ensuring that the number of vertices in the data blocks after subdivision was divisible by the number of vertices in an individual primitive.

The techniques in this disclosure however may allow different primitive types to be rendered during a single draw call. The different primitive types may have differing numbers of vertices and hence different sizes of data footprints. The different sizes of data footprints may prevent the primitive data from being subdivided without further analysis of the data in order to determine where the primitive boundaries occur within the primitive data. Further analyzing the data to determine where the primitive boundaries occur may be expensive in terms of processing time and resources.

According to some aspects of this disclosure a data format specification for transferring primitive data between a higher level software application and a graphics driver may specify a universal primitive data unit size to be used for defining primitives in the primitive data. The universal primitive data unit size may indicate the size of data unit that is to be used for storing data indicative of a primitive to be rendered. The primitive data unit size may be universal in that the sense that it applies to all of the different primitive types that are to be rendered during a single draw call. If a particular primitive does not need all of the data specified by the universal primitive data unit size the data format specification may require that the higher level software application pad the primitive data with enough data so that the amount of data stored for that particular primitive is equal to the universal primitive data unit size.

In some examples instead of specifying a universal primitive size for each of the primitives to be rendered the data format specification may specify a universal number of vertices to be used for defining each primitive to be rendered. The universal number of vertices to be used for defining each primitive may indicate the number of vertices that are to be used for defining a primitive to be rendered. The number of vertices may be universal in that the sense that it applies to all of the different primitive types that are to be rendered during a single draw call. If a particular primitive does not need all of the vertices specified by the universal number of vertices the data format specification may require that the higher level software application pad the primitive data with enough vertices so that the amount of data stored for that particular primitive is equal to the universal number of vertices.

The overhead for padded indices may be in some examples at most a 34 increase in the index buffer. For example for a mesh consisting of 99 triangles and 1 quad the size of the original index buffer may be 301 99 3 1 4 . With padded indices the size may increase up to 400 99 4 1 4 . This is an extreme case and typically most 3D meshes are quad dominant with small numbers of isolated triangles.

As shown in the IA stage e.g. input assembler may be configured to selectively discard vertices of one or more primitives to be rendered based on data indicative of the type of primitive to be rendered. In the specific example of the IA stage may receive a set of four vertices for each of the primitives to be rendered as part of a draw call. In response to receiving a set of vertices associated with each of the primitives to be rendered the IA stage may determine whether the data indicative of the type of primitive to be rendered for the respective primitive indicates that the respective primitive is a triangle.

If the data indicative of the type of primitive to be rendered for the respective primitive indicates that the respective primitive is a triangle then the IA stage may discard the last vertex included in the set of vertices associated with the respective primitive. Otherwise if the data indicative of the type of primitive to be rendered for the respective primitive indicates that the respective primitive is a quad then the IA stage may not discard the last vertex included in the set of vertices associated with the respective primitive. Discarding unnecessary vertices at the IA stage may reduce the number of instantiations of the geometry processing pipeline. By discarding vertices in this manner additional vertices may be added to the input primitive data to allow draw calls to be efficiently split on the driver side when rendering primitives of different primitive types without causing an increase in the number of instantiations of the geometry processing pipeline.

The technique shown in may be generalized to draw calls that are performed with respect to more than two different primitive types. In general the IA stage may determine how many vertices to discard based on the data indicative of the type of primitive to be rendered and discard the determined number of vertices based on the determination. If the actual number of vertices needed to represent a primitive is equal to the universal number of vertices then the IA stage may determine to discard no vertices i.e. zero vertices . If the actual number of vertices needed to represent a primitive is less than the universal number of vertices then the IA stage may determine to discard the difference between the universal number of vertices and the actual number of vertices needed to represent a primitive. The position of the padded vertices may be anywhere in the data structure and need not necessarily be at the end of the set of vertices as is shown in .

In some examples discarding a vertex may include reading the data included in an index slot of the index buffer but not retrieving the corresponding vertex from the vertex buffer. In such examples not discarding a vertex or discarding zero vertices may include reading the data included in an index slot of the index buffer and retrieving the corresponding vertex from the vertex buffer based on the data read from the index slot of the index buffer.

In further examples discarding a vertex may include reading the data included in an index slot of the index buffer retrieving the corresponding vertex from the vertex buffer based on the data read from the index slot of the index buffer but not passing the retrieved vertex on to one or more subsequent processing stages of the graphics pipeline e.g. vertex shader . In such examples not discarding a vertex or discarding zero vertices may include reading the data included in an index slot of the index buffer retrieving the corresponding vertex from the vertex buffer based on the data read from the index slot of the index buffer and passing the retrieved vertex on to one or more subsequent processing stages of the graphics pipeline e.g. vertex shader .

GPU initiates execution of a draw call instruction . Input assembler retrieves vertices and a primitive type indicator for each of the vertices from one or more buffers . For each of the vertices the primitive type indicator for the respective vertex may include data indicative of a primitive type of a primitive to be rendered that is associated with the respective vertex. In some examples input assembler may retrieve the vertices from a vertex buffer and the primitive type indicators from a primitive type buffer. Other buffer combinations are possible. The buffers may be stored for example in memory and or resources block . Input assembler provides the primitive type indicator to hull shader and to geometry shader .

Hull shader selects a tessellation domain type for the primitive to be rendered based on the primitive type of the primitive to be rendered . Hull shader may use the primitive type indicator received from input assembler to determine the primitive type of the primitive to be rendered. Hull shader provides the selected tessellation domain type to tessellator and to domain shader . Tessellator tessellates a higher order surface that corresponds to the primitive to be rendered based on the selected tessellation domain . The higher order surface may be defined by a number of control points that corresponds to the input primitive to be rendered e.g. an n control point patch list where n is an integer greater than or equal to two .

Domain shader selects a domain shader data processing technique for processing data associated with the primitive to be rendered based on the selected tessellation domain type received from hull shader . Domain shader processes data associated with the primitive to be rendered based on the selected domain shader processing technique . The data associated with the primitive to be rendered may include control points received from hull shader and normalized coordinates produced by tessellator .

Geometry shader selects a geometry shader data processing technique for processing data associated with the primitive to be rendered based on the primitive type of the primitive to be rendered . Geometry shader may use the primitive type indicator received from hull shader to determine the primitive type of the primitive to be rendered. Geometry shader processes data associated with the primitive to be rendered based on the selected geometry shader processing technique . The data associated with the primitive to be rendered may include vertices received from domain shader .

Although not shown in geometry shader may be further configured to select a rasterization primitive type based on the primitive type of the primitive to be rendered and generate one or more rasterization primitives of the selected rasterization primitive type. Geometry shader may provide the rasterization primitives and the selected rasterization primitive type to rasterizer for further processing.

Rasterizer may select a rasterization technique from a plurality of rasterization techniques based on the selected rasterization primitive type and rasterize the rasterization primitives based on the selected rasterization technique. In some examples each of the rasterization techniques may specify a set of rasterization rules for rasterizing a rasterization primitive of a particular rasterization primitive type.

This disclosure describes techniques for content rendering without necessarily modifying the original content. The content rendering techniques of this disclosure may be used to render higher order surfaces HOS such as e.g. B zier patches and non uniform rational basis splines NURBS surfaces.

The techniques of this disclosure may be used in some examples in a variety of contexts including for example smooth surfaces rendering. Representing geometry as HOSs may provide one or more advantages over polygonal faceted mesh representations. HOSs may represent a model more compactly may guarantee smooth transitions and silhouettes and may have more high level handles to manipulate the shape. Therefore HOSs are increasingly replacing polyhedral representations in applications such as movie productions or applications that represent game characters. The techniques of this disclosure may be able to handle different domains in single draw call thereby allowing the rendering of triangular patches and quadrilateral patches to happen during the same draw call.

Another context in which the techniques of this disclosure may be used is to render creases and corners. The Real Time Creased Approximate Subdivision Surfaces paper Proceedings of the 2009 symposium on Interactive 3D graphics and games I3D 09 the entire content of which is incorporated herein by reference presented an extension of ACC for surfaces with creases and corners which may be useful for many applications. The paper integrated their implementation into Valve s Source game engine and analyzed performance. The first image in of the above cited paper illustrates characters from the game Team Fortress 2 modeled as a Catmull Clark subdivision surface and rendered with the techniques described in the above mentioned paper. The character and his weapon contain sharp features which may require crease support to render correctly. In the second image in of the cited paper the light colored lines indicate patch edges with tagged crease edges highlighted in green. When polyhedral representations are converted into HOSs the techniques of this disclosure may be used to adapt the algorithm disclosed in the above mentioned paper to support creases and corners.

Another context in which the techniques of this disclosure may be used is to perform displacement mapping. For example whether polyhedral representations are converted to HOSs or not the displacement mapping may transform the final position evaluated in the DS stage to give surfaces a great sense of depth and detail. Therefore this technique is currently domain dependent. The techniques of this disclosure however may be used to apply displacement mapping on a triangle domain and a quad domain as part of a single draw call.

In some examples the techniques of this disclosure may be used with an isoline domain to for example render B zier curves e.g. hair grass etc. .

In some examples the techniques of this disclosure may provide an API extension and corresponding hardware which may allow content to be rendered without necessarily modifying it. Generally 3D content may include quads and triangles which are calculated using subdivision surfaces. Because many graphics pipelines are configured to render only a single primitive type using a single tessellation domain type during a draw call command the quads and triangles may need to be rendered during separate draw call instructions.

One approach to solve this problem is to replace each triangle by three quadrilaterals by applying Catmull Clark CC subdivision. This approach can solve the problem but may quadruple the number of patches everywhere else and may therefore increase the amount of computation fourfold. For example one step of CC subdivision may turn the Proog and Emo models in a purely quadrilateral mesh with 131K facets. This may affect both memory requirements and CPU GPU transfer.

Another approach to solve this problem is to convert each of the triangles into a triangular B zier patch. There are several schemes capable of converting a triangle into a triangular patch. These schemes typically require a separate pass and hence an overhead sorting primitives by type and no longer preserve primitive order that is to be avoided in real time rendering. If the DX11 API is used then a triangle can be handled by inserting a fake vertex which means modifying input data which could result in asymmetric output.

This disclosure describes a multi domain tessellation processing system that may be configured to render a plurality of different primitive types using a plurality of different tessellation domain types during a single draw call command. The techniques of this disclosure may enhance the programmability of the HS stage to handle different domains in the same draw call. In some example triangles may be converted into triangular B zier patches independently from quads being converted into bi cubic B zier patches. In some examples the techniques of this disclosure may provide one or more advantages including for example 1 You render what you create a content creator may never need to explode the data or manipulate to fit in GPU 2 Single draw call generic HS handling both primitive types tri and quad and 3 No fake vertices need to be introduced.

The three control point patch and the four control point patch described in this disclosure may be alternatively referred to respectively as a three control point patch list and a four control point patch list. In some examples the techniques of this disclosure may allow during a single draw call multiple different primitive types to be rendered and multiple different tessellation domain types to be used for tessellating the primitives to be rendered.

The techniques described in this disclosure may be implemented at least in part in hardware software firmware or any combination thereof. For example various aspects of the described techniques may be implemented within one or more processors including one or more microprocessors digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or any other equivalent integrated or discrete logic circuitry as well as any combinations of such components. The term processor or processing circuitry may generally refer to any of the foregoing logic circuitry alone or in combination with other logic circuitry or any other equivalent circuitry such as discrete hardware that performs processing.

Such hardware software and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition any of the described units modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather functionality associated with one or more modules or units may be performed by separate hardware firmware and or software components or integrated within common or separate hardware or software components.

The techniques described in this disclosure may also be stored embodied or encoded in a computer readable medium such as a computer readable storage medium that stores instructions. Instructions embedded or encoded in a computer readable medium may cause one or more processors to perform the techniques described herein e.g. when the instructions are executed by the one or more processors. Computer readable storage media may include random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM flash memory a hard disk a CD ROM a floppy disk a cassette magnetic media optical media or other computer readable storage media that is tangible.

Computer readable media may include computer readable storage media which corresponds to a tangible storage medium such as those listed above. Computer readable media may also comprise communication media including any medium that facilitates transfer of a computer program from one place to another e.g. according to a communication protocol. In this manner the phrase computer readable media generally may correspond to 1 tangible computer readable storage media which is non transitory and 2 a non tangible computer readable communication medium such as a transitory signal or carrier wave.

Various aspects and examples have been described. However modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims.

