---

title: De-serialization of objects based on difference in information content
abstract: A mechanism is provided for de-serializing a representation of a source object of a source software component written in a source language into a target software component written in a target language. A representation of the source object is received and a determination is made of a set of candidate types among a plurality of available types that are in the target language for the target software component, each candidate type being compatible with the representation of the source type. A set of match metrics is calculated, each one for a corresponding candidate type, where the match metric being indicative of a difference in information content between the candidate type and the representation of the source object. One of the candidate types is selected according to the match metrics and a mapping of the representation of the source object onto a target object of the selected candidate type is created.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009687&OS=09009687&RS=09009687
owner: International Business Machines Corporation
number: 09009687
owner_city: Armonk
owner_country: US
publication_date: 20130410
---
The solution according to one or more embodiments of the present invention relates to the data processing field. More specifically this solution relates to the de serialization of objects based on differences in information content.

Exchange of data among different software components is a commonplace activity in modern data processing systems. For this purpose serialization de serialization techniques also known as deflating inflating techniques may be used.

Particularly a source object to be provided from a source software component to a target software component is serialized by converting it into a corresponding representation that may be passed to the target software component. The representation of the source object is then de serialized by creating a target object in the target software component that maps it i.e. it is semantically equivalent to the source object . Typically the representation of the source object is in a format that is independent of the actual implementation of both the source object and the target object in this way it is possible to exchange data among heterogeneous software components especially in data processing systems with distributed architecture in a reliable manner.

In this context however a problem arises when the source software component and the target software component are written in different programming languages that do not support the same types of objects for example classes with fields of different types in object oriented programming languages . Indeed in this case it may be possible that no type of the target software component perfectly matches the representation of the source object. Therefore it is quite difficult if not impossible to de serialize the representation of the source object into the corresponding target object automatically.

A typical example is the exchange of objects between a Rich Internet Application RIA written in the JavaScript language and a web service written in the Java language which objects may be represented in the JavaScript Object Notation JSON format trademarks the Java language has a richer set of types than the JavaScript language has so that it may be not possible to de serialize a JSON representation of a JavaScript object into a Java object perfectly mapping it.

In order to tackle this problem a custom converter is usually added to the target software component the converter comprises code specifically written for handling the de serialization of the representations of the source objects into corresponding target objects for example as described in US A 2010 0083277 the entire disclosure of which is herein incorporated by reference for de serializing incoming request messages in a SOA framework into Java objects.

However this increases the development cost of the target software component. Moreover the maintenance of the converter is quite difficult since it requires working on two layers to maintain the converter in the target software component synchronized with the source software component. This process is time consuming thereby further increasing the development cost of the target software component and prone to errors thereby adversely affecting the quality of the target software component . The problem is particular acute when the source objects have a complex structure for example a list of items of different types a list of nested lists and the like .

Alternatively US A 2011 0321010 the entire disclosure of which is herein incorporated by reference mentions the possibility of using a new format which allows specifying the type of each source object and its fields. However the use of this format would require a corresponding parser that is not described in the cited document and it does not have any reference implementation . Moreover metadata modeling each source object would be required both in the definitions of the source objects in the new format and in the target software component this involves the replication of information with detrimental effects on its maintenance. At the end the possibility mentioned in the cited document would require the learning of a new language different from the ones commonly known at the moment .

In its general terms the solution according to one or more embodiments of the present invention is based on the idea of automating at least in part the de serialization.

Particularly one or more aspects of the solution according to specific embodiments of the invention are set out in the independent claims and advantageous features of the same solution are set out in the dependent claims with the wording of all the claims that is herein incorporated verbatim by reference with any advantageous feature provided with reference to a specific aspect of the solution according to an embodiment of the invention that applies mutatis mutandis to every other aspect thereof .

More specifically an aspect of the solution according to an embodiment of the invention provides a method for de serializing a representation of a source object of a source software component into a target software component wherein one of a set of candidate types being compatible with the representation of the source type among a plurality of types being available for the target software component is selected for mapping the source object according to a difference in information content between the candidate types and the representation of the source object.

Another aspect of the solution according to an embodiment of the invention provides a computer program for performing this method.

Another aspect of the solution according to an embodiment of the invention provides a corresponding system.

With reference in particular to the a schematic block diagram is shown of a system wherein the solution according to an embodiment of the invention may be applied.

The system has a distributed architecture typically based on the Internet the Internet is formed by millions of server computers or simply servers which are connected among them through a global communication network a subset of the servers known as World Wide Web or simply web allows accessing corresponding web sites.

The servers are generally grouped in server farms . A generic server farm is formed by several data processing units comprising the corresponding servers for example of the rack or blade type and storage disks for example of the RAID type the server farm also comprises a console for controlling the servers and the disks for example a personal computer also provided with a drive for reading DVD or CD ROMs . A switch router system manages communications among the servers the disks and the console and with the network for this purposes the servers the disks and the console are connected to the switch router system through a cabling system . The server farm is also provided with a cooling system not shown in the figure which is used to maintain its temperature at a value ensuring the correct operation of the servers .

A generic server is formed by several units that are connected in parallel to a communication bus . In detail a set of one or more microprocessors P controls operation of the server a RAM is directly used as a working memory by the microprocessors and a ROM stores basic code for a bootstrap of the sever . Moreover the server comprises a network adapter which is used to connect the server to the cabling system .

Users of client computers or simply clients access the Internet through computers that operate as access providers not shown in the figure in order to exploit the services offered by the servers and particularly to access their web sites by means of a web browser.

For example a generic client may run a RIA. The RIA is a software application that runs within a software framework of the web browser the RIA may provide functionalities comparable to the ones of standard desktop applications but without requiring its installation on the client . The RIA exploits web services i.e. services each one having an interface formally described in a public WSDL document for example by using AJAX techniques the web services are provided by the servers for example within an application server such as the Tivoli Integrated Portal TIP running on the WebSphere by IBM Corporation trademarks . For this purpose the RIA and the web service need to exchange data in the form of corresponding objects.

The RIA is generally written in JavaScript JavaScript is a scripting language which is interpreted from source code by a JavaScript engine. The web service instead is generally written in pure Java Java is a high level language that is compiled from source code into platform independent byte code which in turn is executed by a Java Virtual Machine JVM . Both JavaScript and Java are object oriented programming languages which involve the manipulation of objects instantiating classes each one embedding the definition of both data in corresponding fields and functions in methods that may be applied to the fields . Moreover both JavaScript and Java are typed languages wherein each field is associated with a type defining its possible values and the operations that may be performed thereon however JavaScript features weak or loose typing i.e. allowing a large number of implicit or explicit type conversions whereas Java features strong typing i.e. placing severe restrictions on type conversions .

The objects to be exchanged between the RIA i.e. JavaScript objects and the web service i.e. Java objects may be represented in the JSON format. JSON is a language independent data format of the text type which is derived from a subset of JavaScript . JSON lacks semantics with any data element or JSON element that is simply represented with a name value pair colon separated the value may be a string a number a Boolean a null value an array i.e. an ordered sequence of values comma separated and enclosed in square bracket or an object i.e. an unordered collection of data elements comma separated and enclosed in curly braces . Since JavaScript is a superset of JSON and it features weakly typing any JSON representation may always be mapped onto a JavaScript object perfectly matching it for example by invoking the eval function even if it is recommend to use a JSON parser for security reasons conversely since Java defines several data types that are not supported by JSON and it features strong typing it is not always possible to map a JSON object onto a Java object perfectly matching it.

Moving now to the an exemplary scenario of application of the solution according to an embodiment of the invention is shown.

A generic server receives from a generic client the JSON representation of a JavaScript object to be mapped onto a corresponding Java object in its web service the server also accesses a list of Java classes that are available for the web service for example determined when they are loaded . The server selects a set of candidate Java classes among the available Java classes which candidate Java classes are compatible with the JSON representation for example having Java fields corresponding to the JSON elements with correct methods for getting setting them . For each candidate Java class the server calculates a match metric which is indicative of a difference in information content between the candidate Java class and the JSON representation for example based on lost JSON elements of the JSON representation that cannot be assigned to the candidate Java class and on exceeding Java fields of the candidate Java class that cannot be assigned by the JSON representation . The server selects a Java class among the candidate Java classes according to their match metrics i.e. the one providing the lowest difference in information content . The server then maps the JSON representation onto a Java object instantiating the selected Java class .

The above described solution makes the de serialization of the JSON representation into the Java object or more generally of any representation of a source object into a target object substantially automatic at least in part. Indeed in most practical situations the target object may be created without any manual intervention even if it does not match the representation of the source object perfectly thereby automatically handling any discrepancies and misalignments with the representation of the source object . Therefore it is possible to avoid the need of any custom converter specifically written for handling the de serialization. This significantly reduces the development cost of the web service or more generally of any target software component and it simplifies the maintenance thereof all of the above also has a beneficial effect on the quality of the target software component especially when the source objects to be mapped therein have a complex structure .

The main software modules that mat be used to implement the solution according to an embodiment of the invention are shown in the . These software modules are denoted as a whole with the reference . The information programs and data is typically stored in the disks of the corresponding server farm and loaded at least partially into the working memory of a generic server thereof when the programs are running together with an operating system and other application programs not shown in the figure . The programs are initially installed onto the disks for example from DVDs through the corresponding console.

The server comprises a JVM on top of which a generic web service runs particularly a class loader of the JVM is in charge of controlling the loading of the definition of any new class required by the web service from a corresponding class file storing its bytecode . The class loader is customized to update a table which stores the list of available Java classes for the web service together with their definition comprising the specification of the corresponding methods .

The server also comprises a general purpose de serializer running on top of the JVM as well the de serializer interfaces with the web service for de serializing the JSON representation of any JavaScript object that is received from the clients not shown in the FIG. . For this purpose the de serializer passes the JSON representation to a sorter which also accesses the table of the available Java classes. The sorter determines the candidate Java classes being compatible with the JSON representation among the available Java classes and stores their names into a table . An estimator accesses both the table of the available Java classes and the table of the candidate Java classes and it also receives the JSON representation from the sorter not shown in the figure for the sake of simplicity . For each candidate Java class the estimator calculates the corresponding match metric and stores it into a table particularly the match metric comprises a loss index that measures the lost JSON elements of the JSON representation that cannot be assigned to corresponding Java fields of the candidate Java class and an excess index that measures the exceeding Java fields of the candidate Java class that cannot be assigned by corresponding JSON elements. A selector accesses both the table of the candidate Java classes and the table of the match metrics the selector selects a Java class among the candidate Java classes according to their match metrics and returns its name to the de serializer that in turn passes it to the web service .

An activity diagram describing the flow of activities relating to an implementation of the solution according to an embodiment of the invention is shown in the FIG. A FIG. B. In this respect each block in the diagram may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . Particularly the diagram represents an exemplary process that may be implemented in a generic server for de serializing JSON representations of JavaScript objects received from any clients into corresponding Java objects with a method .

The method passes from block to block as soon as the class loader receives a request of loading a new class by the web service. In response thereto the class loader adds the name of the new class to the list of available Java classes for the web service. Continuing to block the definition of the new class is loaded as usual with the addition of the definition of its methods to the list of available Java classes . The flow of activity then returns to the block waiting for a next request from the web service.

In this way the list of available Java classes is determined in a fully automatic way while the web service runs without requiring any initialization thereof.

In a completely asynchronous way the method passes from block to block as soon as the JSON representation of a JavaScript object is received by the web service for example within a HTTP command submitted by a generic client . In response thereto an outer loop is performed for each available Java class starting from the first one the loop begins by retrieving the definition of the methods of a current available Java class and setting its loss index to zero. The method then enters an inner loop at block for each JSON element of the JSON representation starting from the first one . Continuing to block the definition of the methods of the available Java class is scanned for searching a getter method and a setter method for getting and setting respectively a Java field of the available Java class with the same name of a current JSON element. For example when the available Java classes comply with the naming convention of JavaBeans the getter method of a generic Java field my Field of a generic type myType has the following signature 

public myType getMyField meaning that the method is public returns a result of the type myType is called with the keyword get followed by the name of the Java field myField and does not require any argument alternatively if the type myType is Boolean the getter method may also have the following alternative signature 

meaning that the method is public does not return any result is called with the keyword set followed by the name of the Java field myField and requires an argument of the type myType.

The method branches at block according to the result of the above mentioned search. If the getter method and or the setter method for the JSON element have not been found the loss index of the available Java class is incremented by one at block to indicate that the JSON element cannot be assigned to any Java field of the available Java class. Conversely if both the getter method and the setter method for the JSON element have been found their signatures are compared with the value of the JSON element at block . If the signature of the getter method and or the signature of the setter method are not compatible with the value of the JSON element i.e. the result of the getter method cannot take this value and the same value cannot be passed as argument to the setter method the method again passes to the block to increment the loss index of the available Java class . The flow of activity then merges at block from the block or directly from the block when both the signature of the getter method and the signature of the setter method are compatible with the value of the JSON element.

In any case a test is now made to determine whether the last JSON element has been processed. If not the method returns to the block to repeat the same operations on a next JSON element. Conversely once all the JSON elements of the JSON representation have been processed the inner loop is exit by descending into block . In this phase there is verified whether the available Java class perfectly matches the JSON representation this condition is met when all the JSON elements may be assigned to the Java fields i.e. the loss index is zero and vice versa i.e. the available Java class does not have any further Java field identified by a corresponding setter method and getter method . If so the available Java class is directly selected for mapping the JSON representation at block .

Conversely the method passes to block wherein the loss index of the available Java class is compared with a threshold for example equal to 0 30 with respect to the total number of JSON elements . If the loss index does not reach this threshold meaning that the amount of information of the JSON representation that is lost because its JSON elements cannot be assigned to corresponding Java fields is acceptable the name of the available Java class is added to the list of candidate Java classes at block . The method then descends into block the same point is also reached directly from the block when the loss index reaches the threshold i.e. it is equal to or greater than it .

In any case a test is now made to determine whether the last available Java class has been processed. If not the method returns to the block to repeat the same operations on a next available Java class. Conversely once all the available Java classes have been processed the outer loop is exit by descending into block .

In this phase the number of candidate Java classes is verified. If only a single candidate Java class has been found this candidate Java class is directly selected for mapping the JSON representation at block .

Conversely the method passes to block wherein an outer loop is performed for each candidate Java class starting from the first one the loop begins by determining the exceeding Java fields of a current candidate Java class i.e. the Java fields each one identified by a corresponding setter method and getter method that have not been associated with corresponding JSON elements in the foregoing and setting its excess index to zero. The method then enters an inner loop at block for each exceeding Java field starting from the first one In this phase the type of the exceeding Java field is determined as indicated in the signature of its setter getter methods . Continuing to block the maximum number of bits that are required to represent the type of the exceeding Java field is determined for example 1 bit for Boolean 64 bits for double integer and the like . The method then passes to block wherein the excess index of the candidate Java class is incremented by the number of bits of the exceeding Java field to indicate that this amount of information cannot be assigned in the candidate Java class by the JSON representation.

A test is made at block to determine whether the last exceeding Java field has been processed. If not the method returns to the block to repeat the same operations on a next exceeding Java field. Conversely once all the exceeding Java fields have been processed the inner loop is exit by descending into block . A further test is now made to determine whether the last candidate Java class has been processed. If not the method returns to the block to repeat the same operations on a next candidate Java class. Conversely once all the candidate Java classes have been processed the outer loop as well is exit by descending into block .

In this phase the candidate Java classes with the lowest loss index are determined. The number of candidate Java classes so determined is verified at block . If only a single candidate Java class has been found this candidate Java class is selected for mapping the JSON representation at block . Conversely the method passes to lock wherein the candidate Java class with the lowest excess index among them is selected for mapping the JSON representation by taking any one of them if again more than one .

The flow of activity then merges at block from the block from the block from the block or from the block . In any case a Java object is created by instantiating the selected Java class the JSON representation is then mapped onto this Java object by initializing the Java fields thereof associated with the JSON elements to their values. The method then returns to the block waiting for a next JSON representation.

The above described algorithm selects the Java class to be used for mapping the JSON representation with a heuristic approach this automatically determines the Java class that should best match the JSON representation so as to increase the probability of being able to construct a valid functioning Java object from its instantiation. Particularly the above described two stage procedure at first reduces the amount of information of the JSON representation that is lost in the Java object for the same conditions this procedure then reduces the amount of information that is exceeding in the Java object.

Three Java classes available for mapping the JSON representation class class and class expose the following methods 

In this case assuming that the threshold for the loss index is 0 meaning that all the JSON elements have to be assigned to corresponding Java fields only the available Java classes class and class are candidate to map the JSON representation conversely the available Java class class is discarded since the JSON element name cannot be assigned to any Java field thereof being its value incompatible with the Boolean type of the setter getter methods for its name . The excess index of the Java class class is 64 bits for the field name of the double integer type whereas the excess index of the Java class class is 1 bit for the field name of the Boolean type . Therefore the Java class class is selected for mapping the JSON object.

Naturally in order to satisfy local and specific requirements a person skilled in the art may apply to the solution described above many logical and or physical modifications and alterations. More specifically although this solution has been described with a certain degree of particularity with reference to one or more embodiments thereof it should be understood that various omissions substitutions and changes in the form and details as well as other embodiments are possible. Particularly different embodiments of the invention may even be practiced without the specific details such as the numerical values set forth in the preceding description to provide a more thorough understanding thereof conversely well known features may have been omitted or simplified in order not to obscure the description with unnecessary particulars. Moreover it is expressly intended that specific elements and or method steps described in connection with any embodiment of the disclosed solution may be incorporated in any other embodiment as a matter of general design choice. In any case ordinal or other qualifiers are merely used as labels to distinguish elements with the same name but do not by themselves connote any priority precedence or order. Moreover the terms include comprise have contain and involve and any forms thereof should be intended with an open non exhaustive meaning i.e. not limited to the recited items the terms based on dependent on according to function of and any forms thereof should be intended as a non exclusive relationship i.e. with possible further variable involved and the term a an should be intended as one or more items unless expressly indicated otherwise .

For example an embodiment of the present invention provides a method for de serializing a representation of a source object of a source software component written in a source language into a target software component written in a target language. The method comprises the following steps. The representation of the source object is received. A set of one or more candidate types is determining among a plurality of available types which are available in the target language for the target software component each candidate type is compatible with the representation of the source type. A set of match metrics is calculated each one for a corresponding candidate type the match metric is indicative of a difference in information content between the candidate type and the representation of the source object. One of the candidate types is selected according to the match metrics. The representation of the source object is mapped onto a target object of the selected candidate type.

However the source language the target language and the representation of the source object may be of any type the candidate types may be determined among the available types in any way the match metrics may be calculated in any way and the candidate type to be used to map the representation of the source object may be selected in any way see below . Moreover the same method may be applied to any source and target software components even outside the web realm for example a desktop application and a remote legacy application respectively .

In an embodiment of the invention the source language is a programming language featuring weakly typing the target language is a programming language featuring strong typing and the representation of the source object is written in a language independent format lacking semantics.

However the source language the target language and the format of the representation of the source object may of any type for example with both languages featuring strong typing with the format dependent on one of these languages and the like .

In an embodiment of the invention the source language is JavaScript the target language is Java and the format is JSON.

However the above mentioned examples are merely indicative and in no way limitative. More generally the same method may also be applied to any other language even a conventional language wherein the types simply relate to their variables for example C C PHP Python. Perl SQL Ruby VisualBasic and the like trademarks likewise the representation of the source object may be in any other format for example XML OGDL YAML CSV and the like .

In an embodiment of the invention the method further comprises the steps of monitoring each request of loading a definition of a new type from the target software component and updating the available types according to each monitored request.

However the available types may be provided in any other way even not automatically for example by properly initializing the target software component .

In an embodiment of the invention the types are classes and the target object is an instance of the selected candidate class. The steps of monitoring comprises receiving each request of loading the definition of the new class from the target software component by a class loader the class loader controls the execution of said step of updating the available classes according to each monitored request.

However the loading requests may be monitored in any other way for example by means of a wrapper for a standard class loader or by means of hooking techniques .

In an embodiment of the invention the representation of the source type comprises a set of one or more elements and each available type comprises a set of one or more fields. The step of determining a set of candidate types comprises the following steps. A set of loss indexes is calculated each one for a corresponding available type the loss index measures lost ones of the elements being not assignable to the fields of the available type. Each available type is set as a candidate type when the corresponding loss index does not reach a threshold.

However the threshold may be configurable to any value even dynamically moreover the candidate types may be determined in any way even without calculating any loss index for example only considering the available types for which all the elements of the representation of the source object may be assigned to the fields thereof .

However the loss index may be defined in any other way for example by taking into account the number of bits of the lost elements in addition or in alternative to their number .

In an embodiment of the invention each element comprises a name and a value. The step of calculating a set of loss indexes comprises the following steps for each available type. Each element is set as a lost element when the available type lacks a getter method and a setter method for getting and setting respectively a field with the name of the element the getter method and the setter method have a signature compatible with the value of the element.

However the lost elements may be determined in any other way for example by examining the fields of the available types directly .

In an embodiment of the invention the step of setting each element as a lost element comprises searching a pair of methods of the available type conforming to a naming convention comprising the name of the element together with a getter keyword and a setter keyword respectively.

However the getter setter methods may be based on different naming conventions or they may be determined in any other way for example by means of introspection techniques .

In an embodiment of the invention the match metrics comprise the corresponding loss indexes. The step of calculating a set of match metrics further comprises the following steps. A set of excess indexes is calculated each one for a corresponding available type the excess index measures exceeding ones of the fields of the available type being not assignable by the elements.

However the match metrics may be defined in any other way for example only according to the excess indexes or more generally by any metric of one or more values that indicates a difference in information content between the candidate type and the representation of the source object .

In an embodiment of the invention each excess index comprises a number of bits of the exceeding fields.

However the excess index may defined in any other way for example by taking into account the number of the exceeding fields in addition or in alternative to the number of their bits .

In an embodiment of the invention the step of selecting one of the candidate types according to the match metrics comprises selecting the candidate type having the lowest loss index first and the lowest excess index next.

However the candidate type to be used to map the representation of the source object may be selected according to any other criteria for example weighting the loss index and the excess index considering the number of exceeding fields first and their number of bits next and so on .

In an embodiment of the invention the step of selecting one of the candidate types according to the match metrics comprises selecting a matching one of the candidate types matching the representation of the source object with no lost element and no exceeding field during said step of determining a set of candidate types the selecting of the matching candidate type causes the skipping of said step of calculating a set of match metrics.

In general similar considerations apply if the same solution is implemented with an equivalent method by using similar steps with the same functions of more steps or portions thereof removing some steps being non essential or adding further optional steps moreover the steps may be performed in a different order concurrently or in an interleaved way at least in part .

Another embodiment of the present invention provides a computer program which comprises code means for causing a data processing system to perform the steps of the above described method when the computer program is executed on the data processing system.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon. Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device. A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in base band or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing. Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the relevant computer as a stand alone software package partly on this computer and partly on a remote computer or entirely on the remote computer. In the latter scenario the remote computer may be connected to the computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . Aspects of the present invention have been described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Another embodiment of the present invention provides a system which comprises means for performing the steps of the same method.

However similar considerations apply if the system has a different structure or comprises equivalent components or it has other operative characteristics. In any case every component thereof may be separated into more elements or two or more components may be combined together into a single element moreover each component may be replicated to support the execution of the corresponding operations in parallel. It is also pointed out that unless specified otherwise any interaction between different components generally does not need to be continuous and it may be either direct or indirect through one or more intermediaries. Moreover the proposed method may also be carried out on a system based on a different architecture for example a local wide area cellular or satellite network and exploiting any type of wired and or wireless connections. However its implementation on a stand alone computer is not excluded. In any case the computer may have another structure or may comprise similar elements such as cache memories temporarily storing the programs or parts thereof moreover it is possible to replace the computer with any code execution entity either based on a physical machine or a virtual machine such as a PDA a mobile phone and the like or with a combination of multiple entities such as a multi tier architecture a grid computing infrastructure and the like .

