---

title: Concurrent insertion of elements into data structures
abstract: A method of adding an element to a data structure may include atomically associating the element with the data structure if the element is not associated with the data structure. The element may be prepared for insertion into a location in the data structure. The method may also include atomically inserting the element into the location in the data structure if another element has not been inserted into the location.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09171103&OS=09171103&RS=09171103
owner: Intel Corporation
number: 09171103
owner_city: Santa Clara
owner_country: US
publication_date: 20130925
---
This application is a divisional of U.S. patent application Ser. No. 10 685 070 filed Oct. 13 2003 the content of which is hereby incorporated by reference.

The claimed invention relates to concurrent data processing and more particularly to concurrent data processing involving a shared resource.

For some time computing environments have been available that support multithreading which enables programs whose parts may execute concurrently. Such parts of a program that may execute independently of other parts are typically referred to as threads. Examples of computing environments that may support concurrent e.g. parallel execution of threads may include operating systems compilers virtual machines run time systems and just in time JIT compilers.

In some situations multiple threads may want to perform different operations on the same data element and or data structure i.e. a shared resource . To handle such instances multithreaded computing environments typically include one or more synchronization mechanisms for synchronizing parallel activities of threads. One example of such a synchronization mechanism that may be provided e.g. via an application programming interface API or other interface is a lock that allows exclusive use of the shared resource for a certain time by a particular thread. In such a case a thread may acquire a lock perform one or more operations that need to be mutually exclusive and release the lock after performing the operation s . The computing environment may ensure that only one thread at a time can acquire a lock regardless of other threads also trying to acquire a lock.

Such locking synchronization mechanisms however may require a substantial amount of overhead for associated system calls e.g. for keeping track of which threads own which locks and or the states of locks . This overhead may be large enough to impact performance if the locks are used in performance critical code. Also these locking mechanisms may not be tolerant of faults. For example if a thread that has acquired a lock dies e.g. is killed or exits abnormally before releasing its lock other threads may be prevented from accessing the shared resources protected by that unreleased lock. Further if a thread that owns a lock is suspended a deadlock may occur if the resumption of the suspended thread is dependent on the completion of another task whose progress in turn is dependent on the lock of the suspended thread.

The following detailed description refers to the accompanying drawings. The same reference numbers may be used in different drawings to identify the same or similar elements. Also the following detailed description illustrates certain implementations and principles but the scope of the claimed invention is defined by the appended claims and equivalents.

During the execution of a program it may be desirable to collect a list of items that have certain properties. Typically this is done using a global dynamic structure such as a linked list or a stack. Upon observing an item that meets certain criteria e.g. upon activation of a program function a routine may be called to add the item e.g. a pointer to the function information to the list. If the program is multithreaded multiple threads may try to add items to the list simultaneously.

Although the following description may primarily describe adding elements to a linked list it should be noted that other types of data structures and operations may be implemented consistent with the principles of the invention. For example data structures such as stacks queues sets doubly linked lists database data structures etc. may be implemented consistent with the principles of the invention as described herein. Nor is the claimed invention limited to the operation of adding an element to a data structure. Rather the principles described and claimed herein are applicable to a range of scenarios where there may be competition for and or contention over a shared resource among threads.

Data elements may include a data portion denoted by letters A C and a pointer denoted by next A C . Although only three data elements are illustrated for ease of explanation many more elements may be present. The data portions may include data of possibly various types. The pointer next A for example may point to another element if data element is part of list .

When data elements are initialized their respective pointers next A next B and next C may be given a null value or some other predetermined known value to indicate that elements are not initially part of list . Thus initialized any of elements may be checked to decide whether that element belongs to list . If next A is null for example then element is not part of list otherwise element may be part of list . Thus pointers next A C of elements may perform the dual functions of indicating whether a particular element has been added to list and linking together elements once added to list .

Processing may begin with the thread determining whether the pointer next E of the element to be added E is null act . This determination may conclude process at act if element E is already present in list i.e. next E is not null . Act may enforce a condition that an element E may appear in list only once and may efficiently determine whether element is already in list before performing other acts in process . Because element has a null pointer value in the decision in act is affirmative and not explicitly illustrated.

If the pointer next E of the element to be added E is null process may continue with the thread executing a first atomic operation act . As used herein an atomic operation may be defined as an operation and or software primitive that is uninterruptible by another thread e.g. this may be conceptualized as an apparently instantaneous or uninterruptible indivisible operation hence the atomic label . Atomic act may perform a compare and exchange type operation to replace the pointer next E of element with its address E if next E is initially null. Such operations will be described in greater detail below. Like act act may conclude process at act if next E is not null. As illustrated in for the single Thread 1 atomic act may result in element pointing to itself indicating that it is associated with list .

Process may continue with the thread modifying the pointer next E of element E to point to the value of ListP act . As illustrated in act causes the pointer next E of element to point to the same location as ListP. In the example of where list initially includes no elements the value of ListP and next E may be the head of list but in other cases next E would be modified by act to point to the first element in list .

Process may continue with the thread executing a second atomic compare and exchange type operation act . Atomic act may replace the value of ListP with the address E of element if the values of ListP and next E are initially equal. As illustrated in for the single Thread 1 atomic act may result in ListP pointing to element because no other threads have changed the value of value of ListP before act .

As will be explained in a multiple thread example below the values of ListP and next E may not necessarily be equal in act despite assigning ListP to next E in the previous act due to interference from other threads. In such a case where the values of ListP and next E are not equal in act process may repeat acts and until element E is added to list as illustrated in .

Process may conclude with act a return from the adding routine. As illustrated in act may be reached from acts and . In acts and the thread may reach act when it has been unable to add element E to list . Thus addition process may be considered completed even when element E has not been added to list . By contrast the thread may reach act from act upon successful addition of element E to list .

Further in the example of Threads 2 5 may execute process nearly concurrently. That is each of Threads 2 5 may execute act for example at approximately the same time. When one thread must execute before another e.g. for atomic acts and or Thread 2 may be assumed to execute slightly before Thread 3 which in turn executes slightly before Thread 4 which in turn executes slightly before Thread 5. Such an order has been chosen for the purposes of illustration only and may differ in practice. Similarly the numbers of threads and elements shown in are purely exemplary and may also vary from that shown.

Threads 2 5 may execute act . Threads 3 5 may continue beyond act because the respective pointers next A and next B of elements and are null. Thread 2 may return exit from process because it seeks to add element that is already present in list e.g. having a non null pointer next E . Such returning exiting from process is illustrated in by Thread 2 s arrow stopping at act .

Continuing in process Thread 3 may execute atomic act causing the pointer next A of element to point to its address. Because Thread 4 cannot execute atomic act concurrently with Thread 3 or otherwise interrupt Thread 3 s execution of atomic act Thread 4 may execute act slightly afterward. Thread 4 may find in act that next A of element is no longer null due to Thread 3. Accordingly Thread 4 may return exit from process . Such returning exiting from process is illustrated in by Thread 4 s arrow stopping at act .

Thread 5 may successfully execute atomic act causing the pointer next B of element to point to its address. Thus after act list may be unaltered and elements and may point to themselves. This resulting state of list and elements is conceptually illustrated in immediately below the dotted line of act .

Continuing process both Thread 3 and Thread 5 may perform act . After act the pointers next A and next B of elements and may both point to the same location e.g. element as the list pointer ListP of list . The resulting state of list and elements after act is conceptually illustrated in immediately below the uppermost dotted line of act .

Thread 3 may execute atomic act . Finding List P of list being equal to the pointer next A of element Thread 3 may change ListP to the location of element . This successful execution of atomic act is illustrated in by Thread 3 s arrow stopping at act . The resulting state of new list including elements and and element after atomic act is conceptually illustrated in immediately below the uppermost dotted line of act .

Because Thread 5 cannot execute atomic act concurrently with Thread 3 or otherwise interrupt Thread 3 s execution of atomic act Thread 5 may execute act slightly afterward. Thread 5 may find in act that List P of list is not equal to the pointer next B of element due to the prior execution of atomic act by Thread 3. Accordingly Thread 5 may return to act to try again to add element to list . Such returning to act is illustrated in by Thread 5 s arrow continuing beyond the uppermost dotted line of act to the lowermost line of act .

Thread 5 may perform act again. After act the pointer next B of element may point to the same location e.g. element as the list pointer ListP of list . The resulting state of list and element after act is conceptually illustrated in immediately below the lowermost dotted line of act .

Thread 5 may execute atomic act again. Finding List P of list being equal to the pointer next B of element Thread 5 may change ListP to the location of element . This second time executing act Thread 5 does not encounter a ListP that was changed by another thread. This successful execution of atomic act is illustrated in by Thread 5 s arrow stopping at the lowermost act . The resulting state of new list including elements and after atomic act is conceptually illustrated in immediately below the lowermost dotted line of act .

With regard to the example in the following characteristics of process may be noted. Act may provide an efficient mechanism for checking whether an element is already in list . Atomic act may resolve contention among two or more threads seeking to add the same element to list . Atomic act may ensure that a concurrent update of list by a number of threads is performed correctly.

Further process may be tolerant of faults and may not produce deadlocks regardless of whether threads are suspended or killed. Atomic acts and at least conceptually reduce lock time to essentially zero because atomic acts are assumed to be instantaneous uninterruptible . Also act when it repeats acts and for some thread that was unable to add its element may modify the position in list of another element that was just added by another concurrent thread.

The atomic operations of acts and may be performed by compare and exchange type atomic instructions and . Computing environments may provide an API CompareAndExchange or a similar atomic primitive that has the following characteristics. The API may include three arguments CompareAndExchange dst new cmp and may perform the following operations atomically. It may compare a content of the destination dst with a value of the comparand cmp . If dst and cmp are equal then CompareAndExchange may store the third value new to the destination dst. Otherwise CompareAndExchange may not modify the destination dst. In either event CompareAndExchange may return the initial value of the destination dst. In this manner an atomic instruction similar to CompareAndExchange may be used to implement acts and or .

Certain aspects of implementations of the claimed invention may be implemented using hardware software or a combination thereof and may be implemented in one or more computer systems or other processing systems. In fact in one implementation methods described herein may be implemented in programs executing on programmable machines such as mobile or stationary computers personal digital assistants PDAs set top boxes cellular telephones and pagers and other electronic devices that each include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and one or more output devices. Program code may be applied to the data entered using the input device to perform the functions described and to generate output information. The output information may be applied to one or more output devices.

One of ordinary skill in the art may appreciate that implementations consistent with the principles of the invention may be practiced with various computer system configurations including multiprocessor systems minicomputers mainframe computers and the like. Implementations consistent with the principles of the invention may also be practiced in distributed computing environments where tasks may be performed by remote processing devices that are linked through a communications network.

Each program may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. However programs may be implemented in assembly or machine language if desired. In any case the language may be compiled and or interpreted.

Program instructions may be used to cause a general purpose or special purpose processing system that is programmed with the instructions to perform the methods described herein. Alternatively the methods may be performed by specific hardware components that include hardwired logic for performing the methods or by any combination of programmed computer components and custom hardware components. The methods described herein may be provided as a computer program product that may include a machine readable medium having stored thereon instructions that may be used to program a processing system or other electronic device to perform the methods.

The term machine readable medium or machine accessible medium used herein may include any medium that is capable of storing or encoding a sequence of instructions for execution by the machine and that causes the machine to perform any one of the methods described herein. The terms machine readable medium and machine accessible medium accordingly may include but may not be limited to solid state memories optical and magnetic disks and a carrier wave that encodes a data signal. Furthermore it is common in the art to speak of software in one form or another e.g. program procedure process application module logic and so on as taking an action or causing a result. Such expressions are merely a shorthand way of stating that the execution of the software by a processing system may cause the processor to perform an action or produce a result.

The foregoing description of one or more implementations consistent with the principles of the invention provides illustration and description but is not intended to be exhaustive or to limit the claimed invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention.

For example the principles of the invention described herein may be applied to data structures other than linked lists and to operations other than adding an element to the data structure.

Moreover the acts in need not be implemented in the order shown nor do all of the acts necessarily need to be performed. Also those acts that are not dependent on other acts may be performed in parallel with the other acts. Further the acts in this figure may be implemented as instructions or groups of instructions implemented in a computer readable medium.

No element act or instruction used in the description of the present application should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. The scope of the claimed invention is defined by the claims and their equivalents.

Embodiments may be used in many different types of systems. For example in one embodiment a communication device can be arranged to perform the various methods and techniques described herein. Of course the scope of the present invention is not limited to a communication device and instead other embodiments can be directed to other types of apparatus for processing instructions or one or more machine readable media including instructions that in response to being executed on a computing device cause the device to carry out one or more of the methods and techniques described herein.

Embodiments may be implemented in code and may be stored on a non transitory storage medium having stored thereon instructions which can be used to program a system to perform the instructions. The storage medium may include but is not limited to any type of disk including floppy disks optical disks solid state drives SSDs compact disk read only memories CD ROMs compact disk rewritables CD RWs and magneto optical disks semiconductor devices such as read only memories ROMs random access memories RAMs such as dynamic random access memories DRAMs static random access memories SRAMs erasable programmable read only memories EPROMs flash memories electrically erasable programmable read only memories EEPROMs magnetic or optical cards or any other type of media suitable for storing electronic instructions.

While the present invention has been described with respect to a limited number of embodiments those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention.

