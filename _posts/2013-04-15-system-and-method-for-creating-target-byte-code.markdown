---

title: System and method for creating target byte code
abstract: A system and method for converting byte code of a first type into byte code of a second type. Byte code of a first type and markup language code are received as inputs. The first byte code is converted into constituent byte code data elements that can comprise any logical unit or grouping of at least a portion of a software application. The markup language code is converted into constituent markup language data elements that can comprise individual markup language tags and references to data or functionality in the first byte code. The first byte code data elements and markup language data elements are mapped to data elements of a second byte code type. The second byte code data elements are assembled into a resulting second byte code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08850416&OS=08850416&RS=08850416
owner: Appcelerator, Inc.
number: 08850416
owner_city: Mountain View
owner_country: US
publication_date: 20130415
---
The present application claims is a continuation of U.S. patent application Ser. No. 12 955 881 entitled System And Method For Creating Target Byte Code filed Nov. 29 2010 now U.S. Pat. No. 8 423 953 which is a continuation of U.S. patent application Ser. No. 11 372 685 entitled System And Method For Creating Target Byte Code filed Mar. 10 2006 now U.S. Pat. No. 7 844 958 which claims the benefit of priority to U.S. provisional application Ser. No. 60 661 061 entitled System And Method For Creating Target Byte Code filed on Mar. 11 2005 and U.S. provisional application Ser. No. 60 663 484 entitled System And Method For Creating Target Byte Code filed on Mar. 18 2005 all of which are hereby incorporated in their entirety by reference.

The present invention relates generally to computer code and more specifically to a system and method for improved conversion of computer code to target computer byte code of a second type.

Traditionally most computer programs comprised machine dependent system level instructions. A program would be written in a higher level language source code such as C or C and converted into machine instructions object code that could be executed by a computer processor. While the resulting object code could be executed very efficiently source code compiled on one computer architecture for example the Microsoft Windows operating system environment on an Intel Pentium processor based computer system could not subsequently run on a different architecture such as an Apple Macintosh operating system environment on a PowerPC processor based computer system WINDOWS is a registered trademark of Microsoft Corp. PENTIUM is a registered trademark of Intel Corp. MACINTOSH is a registered trademark of Apple Computer Inc. and POWERPC is a trademark of International Business Machines Corp. . To properly execute a program on different computer architectures programmers typically undertook steps to re compile source code for each target architecture. Additionally machine specific differences often required significant revision to the program s source code in order to even enable recompilation for a different architecture.

A modern innovation to this traditional method of compiling source code into machine level object code is to use intermediate byte languages and byte code interpreters. Byte code also known as bytecode or byte code is a form of intermediate language that is typically more abstract than object code but closer to machine language than a higher level language. Examples of languages that compile to byte code include Java from Sun Microsystems Inc. and languages that target the Common Language Infrastructure CLI from Microsoft Corporation JAVA is a trademark of Sun Microsystems Inc. . A program that utilizes byte code is initially programmed in source code. The source code is then compiled into byte code. Compiled Java byte codes for example are typically in the form of .class or .jar files. The Common Language Infrastructure is an implementation of the Standard ECMA 335 specification. Source code written under the Common Language Infrastructure can be compiled to Common Intermediate Language CIL byte code. Common Intermediate Language byte code is typically packaged in a .Net Assembly which can comprise Common Intermediate Language byte code assembly metadata type metadata and other resources. A .Net Assembly may be a standalone file or comprise multiple files. Metadata known as the assembly manifest describes how the elements in a given assembly relate to each other. Compiled byte code whether standalone or contained in a larger package can be interpreted by a byte code interpreter also called a virtual machine that translates the byte codes into machine level instructions. Examples of virtual machines include the Java Virtual Machine from Sun Microsystems and the Common Language Runtime CLR also called the Virtual Execution System from Microsoft Corporation.

Thus by way of example a programmer using the Common Language Infrastructure can program an application in higher level language such as Microsoft s C or Visual Basic .Net and compile the program source code into Common Intermediate Language byte code and package it into a .Net Assembly. The resulting byte code can then be run in the CLR.

Typically a virtual machine is available for different computer architectures. The virtual machine can take input from a program compiled in a standard byte code form and run the program on the native computer architecture in which the machine resides. Thus in contrast to machine specific object code a byte code program can run in a virtual machine on any different architecture that has a virtual machine without a recompilation or reprogramming of the underlying source code. By way of example a Java program compiled into byte code could run without modification in a virtual machine on both an Apple Macintosh computer and a Microsoft Windows computer.

During this same time markup languages such as eXtensible Markup Language XML have gained popularity for their data description capabilities. Markup languages generally describe data and user interfaces as well as the details of the structure and appearance of both. Although most markup languages typically comprise ASCII text markup language files may alternatively be serialized in a binary form such as Microsoft s Binary extensible Application Markup Language BAML . Markup languages such as HTML are well known for defining text and layout descriptions. Graphics markup languages such as the Scalable Vector Graphic SVG XML based markup language can describe two dimensional vector graphics. Scripting markup languages allow a programmer to add functional program code to markup language code that may then execute in a web server and dynamically output different markup language code. Exemplary scripting markup languages include Java Server Pages JSP Hypertext Preprocessor PHP Cold Fusion Markup Language CFML and Active Server Pages ASP . For example a programmer could create a web page comprised of mostly HTML tags and further including a CFML tag that inserted the current date and time every time the page was accessed. Upon access by a client web browser the CFML code would execute and the web browser would receive an HTML page with the current date and time inserted as HTML data by the CFML code. Additionally extensible languages such as XML allow programmers to define their own customized tags. This extensibility allows programmers to define validate and interpret data exchanged between applications even as the underlying data formats change over time.

When used in conjunction with functional programming language code markup languages can be used inter alia to define the layout and appearance of objects in a program. For example Microsoft s eXtensible Application Markup Language XAML an XML based language allows a programmer to define user interfaces and instantiate objects defined in Common Intermediate Language and contained in .Net Assembly packages. XAML and Common Intermediate Language code can be cross referenced and executed by the Common Language Runtime. As an alternate example XML User Interface Language XUL from the Mozilla Foundation is an XML based language that can similarly describe the window layouts and user interfaces for modular software components written in languages including C C and JavaScript using the Cross Platform Component Object Model XPCOM framework.

While byte code software applications particularly when used in conjunction with markup language code are quite useful and portable one disadvantage of these approaches is that byte code of one type cannot be easily executed by a byte code interpreter of another type or converted efficiently to byte code of another type. Thus although byte code may generally overcome machine dependency there is some level of dependency on a specific byte code interpreter application. Developers generally have to manually re code applications for different byte code interpreters which can be quite difficult in the case where source code is unavailable and only compiled byte code is on hand. Although some tools exist to disassemble compiled byte code into an assembly language or higher level language a developer still has to port that source code to a different byte code language type in order to convert byte code of a first type into byte code of another type. In these respects creation of target byte code according to the present invention substantially departs from the conventional concepts and designs of the prior art and in doing so provides a system and method of byte code creation that is more flexible robust and efficient than conventional byte code creation methods.

The present invention is directed toward a system and method for converting data of a first type into data of a second type. Preferably in accordance with an embodiment of the present invention byte code of a first type and markup language code can be converted into byte code of a second type. An example environment in which this embodiment can be applied is a computer system. For example in this environment a developer can run a byte code conversion software application taking byte code of a first type and markup language code as inputs and create byte code of a second type as output.

In accordance with an embodiment of the invention byte code of a first type and markup language code can be converted into byte code of a second type. Byte code of a first type and markup language may be converted as part of the same process as entirely separate processes or as a process on one type of code which then calls the other. Byte code can comprise an intermediate code format that is typically lower level than source code but typically more abstract and machine independent than object code. Examples of byte code include Common Intermediate Language JAVA application or SHOCKWAVE FLASH SWF byte code. Markup language code can refer to objects data elements or other external information as well as define layout and user interfaces for text and graphics. Markup language code may also associate markup language tags with objects in byte code of a first type or define a user interface for a software application in byte code of a first type. For example a XAML XML or XUL markup language file could define a graphical user interface and associate objects in Common Intermediate Language byte code with the user interface. Markup language files may also be converted to a binary markup language format such as BAML.

In an additional embodiment according to the invention the first byte code type is the same as the second byte code type.

According to one aspect of the invention markup language code may be transformed into a third byte code. In one embodiment markup language code can be transformed into source code files of a byte code programming language. Exemplary source code languages include any of the Common Language infrastructure languages and the Java and ActionScript programming languages. The source code can then be compiled into byte code of a third type or of the same type as the first source byte code or second target byte code. The new byte code and original source byte code are transformed into target byte code.

According to a further aspect of the invention markup language code may be converted into an object graph that refers to data elements of the first byte code. An object graph is typically a directed graph or tree data structure consisting of related objects. An object graph can represent at least a portion of markup language tags and or markup language references to byte code of a first type. In accordance with one alternative aspect of the invention an object graph is created by parsing markup language code into an intermediate graph structure. An intermediate graph structure reflects the original structure of the source markup language code and is typically a tree structure.

According to another aspect of the invention byte code of a first type may be optionally converted into an intermediate language format and or an intermediate data structure. The intermediate data structure preserves and represents at least a portion of the semantics syntax and metadata contained in the byte code of a first type. An intermediate data structure can be implemented for example as an abstract syntax tree or abstract semantic graph. According to an optional embodiment an intermediate data structure may be created by disassembling byte code of a first type into an intermediate language format. Intermediate language format source code generally represents the lowest level human readable language that can be derived from the byte code and is typically in the form of ASCII text. For example Common Intermediate Language compiled byte code can be disassembled into CIL Assembly Language source code an intermediate language format . The intermediate language source code can then be parsed into an intermediate data structure. According to an alternative embodiment higher level source code can be converted directly into an intermediate data structure without first converting the source code into byte code. An object graph and byte code of a second type or intermediate data structure may be converted into byte code of a second type.

In accordance with another embodiment of the invention byte code of a first type and markup language is converted into one or more constituent markup language data elements. Both markup language data elements and data elements of a first byte code type can be converted into data elements of a second byte code type.

The data elements of a first byte code type can be mapped to one or more data elements of a second type. Where a direct mapping of first to second byte code language formats is not possible or desired one or more second byte code data elements can be combined and mapped in order to mimic the layout or functionality of the first byte code data element. The mapped data elements of a second type can be assembled into byte code of a second type. Data elements can include any logical unit or grouping that comprises at least a portion of a software application. Data elements may include for example objects instructions metadata variables classes functions methods or groupings thereof. Optionally data elements may comprise remote stub functions which contain instructions to remotely connect to a network resource. For example remote data elements may execute a method on a network resource not available in the byte code of a second type or may connect to information stores like a relational database for information. Optionally byte code of a first type may be converted into an intermediate data structure as described above. The intermediate data structure may then be parsed into data elements of a first type. According to another aspect of the invention the step of mapping data elements of a first type to data elements of a second type may reference one or more mapping libraries. A mapping library can contain instructions for mapping specific data elements of a first type to one or more data elements of a second type. A mapping library may comprise data structures such as hash tables lookup tables and or arrays to facilitate efficient lookup and mapping of data elements.

Markup language data elements can include data structures defining colors lines shapes text and layout positions. Markup language data elements may additionally comprise references to for instance objects functionality or data in a first byte code. Markup language data elements can be mapped to one or more data elements of a second byte code type with or without reference to a first byte code or first byte code data elements. Data elements of a second byte code type and markup language data elements can be assembled into byte code of a second type. According to another aspect of the invention as described above byte code of a second type may be converted into an intermediate language format and or intermediate data structure. A resulting intermediate data structure may be converted into data elements of a first type. Similarly markup language code may be converted into an intermediate graph structure and or an object graph. An object graph may then be converted into markup language data elements.

According to an aspect of the invention bridging byte code of a second type may be inserted into byte code of a second type. During the data element mapping step it is possible that not all of the first byte code or markup language data elements can be successfully matched and mapped to data elements of a second type. In this case an embodiment of the present invention can insert additional byte code of a second type to replace or substitute missing data or functionality. The bridging byte code may be inserted automatically in response to the data element mapping process according to one embodiment of the present invention. In an alternative embodiment a developer or external software application may insert bridging byte code into byte code of a second type.

According to yet another aspect of the invention one or more markup language mapping libraries may be referenced during the data element mapping process. A markup language mapping library is similar to a byte code mapping library and contains instructions for mapping markup language data elements to one or more data elements of a second type. A markup language mapping library and or a byte code mapping library may be referenced during the step of converting markup language data elements and data elements of a first byte code type into data elements of a second byte code type.

In one exemplary embodiment of the invention XAML markup language code is converted into markup language data elements and Common Intermediate Language byte code is converted into byte code data elements. Common Intermediate Language data elements can include for example namespaces types attributes and members. These exemplary data element types can be discerned into further sub categories of Common Intermediate data element types. Common Intermediate Language data elements can be mapped through various and alternative mapping steps to SWF data elements. The resulting SWF data elements can include SWF tags records action tags and combinations thereof. SWF byte code can be created from one or more SWF data elements. The Common Intermediate Language data elements can be mapped to one or more SWF data elements. XAML data elements can include for example colors brushes pens shapes text images animation transforms sound video and controls. Further because XAML is an extensible language additional custom XAML data elements can be created. The Common Intermediate Language data elements and XAML data elements can be mapped through various mapping steps to SWF data elements. The mapping process may optionally cross reference one or more XAML data elements to one or more Common Intermediate Language data elements. SWF data elements can be assembled into a SWF byte code.

According to another aspect of the invention byte code files of a first type or source code and markup language of a first type may be stored as inline data in a wrapping markup language code of a second type. In one embodiment the inline byte code and inline markup language code are extracted from the wrapping markup language code and converted into byte code of a second type. Alternately inline source code and inline markup language code can be extracted from another wrapping markup language code and converted into a target second byte code.

According to an alternate aspect of the invention byte code files of a first type and optionally markup language files of a first type may be converted into byte code of a second type and markup language of a second type. In an alternate embodiment according to the present invention byte code files of a first type and optionally markup language files of a first type may be converted into source code of a second type and markup language of a second type. In yet another alternate aspect of the invention byte code files of a first type and markup language files can be converted into byte code of a second type and media files such as image audio or video format files. Exemplary image file formats include Portable Network Graphics Joint Photographic Experts Group Graphics Interchange Format or bitmap formats. Exemplary audio file formats include Audio Interchange File Format MP3 WAVEform audio format Windows Media Audio Advanced Audio Coding Ogg Vorbis or Real Audio formats. Exemplary video file formats include QuickTime MPEG RealVideo Audio Video Interleave or Windows Media Video formats.

In one embodiment of the present invention target byte code of a second type is transmitted across a network. The network can optionally comprise a peer to peer server client or other network topology. According to a further aspect of the invention source byte code may be transformed into one or more byte code components of a second type on a network computer. When a network user requests byte code of a second type from the network computer the computer can return target second byte code by creating new byte code components and or reusing existing byte code components and assembling all of the necessary components into byte code of a second type.

Further features and advantages of the present invention as well as the structure and operation of various embodiments of the present invention are described in detail below with reference to the accompanying drawings.

The present invention is directed toward a system and method for converting data of a first type into data of a second type. More specifically according to one embodiment of the invention a byte code converter is provided for a computer system allowing a user or program to convert byte code of a first type and related markup language into byte code of a second different type.

For example according to one embodiment of the invention byte code files and markup language files that contain references to data and objects in the compiled byte code are received. At least a portion of the compiled byte code is converted into one or more intermediate data structures. At least a portion of the markup language files are similarly converted into one or more object graph structures. The byte code converter can parse and examine these intermediate structures created from the original byte code and markup language and map data elements from both to new byte code data elements of a different target type. As a result of the byte code conversion process a new target byte code file can be produced. Various alternative methods can be used to convert byte code and markup language into intermediate data forms as well as convert both the original byte code and markup language into target byte code of different types.

Conventional software applications can be stored as object code and comprise machine specific instructions which can be executed by a processor on a specific computer system . For example an object code software application written for a computer system with an Intel Pentium processor and the Microsoft Windows operating system typically could not be executed by a different computer system with a PowerPC G5 processor and the Apple Macintosh operating system.

One approach to overcome this machine specific dependency utilizes byte code. Byte code can be created by first programming a software application source code in a higher level language such as JAVA C J or Visual Basic .Net. Source code is typically compiled into byte code. Byte code is an intermediate form of code that is created by reducing higher level source code commands into very basic language instructions. Nonetheless byte code is more abstract than object code contains additional metadata such as namespaces and classes and most notably is generally not comprised of machine specific instructions. Software applications in byte code form can be executed by a byte code interpreter .

A byte code interpreter also called a virtual machine parses byte code files and translates the byte code operations into machine specific instructions for a given computer system . The byte code interpreter itself is typically stored and executed as object code similar to a conventional software application . Thus a separate byte code interpreter must be created for each different computer system architecture. The advantage to such a system is that software applications in byte code can then be executed without substantial modification on a byte code interpreter for many different types of computer systems . Accordingly byte code is much more portable than object code across computer systems . Thus by way of example because JAVA byte code interpreter applications exist for both the Apple Macintosh and Microsoft Windows operating system environments JAVA byte code that runs on an APPLE MACINTOSH JAVA byte code interpreter should also run unmodified on a MICROSOFT WINDOWS JAVA byte code interpreter .

Although byte code software applications can contain all of the operations and instructions used to execute a full program in a byte code interpreter other types of code can be used in conjunction with byte code files to provide a more extensible development environment. Byte code files can be used in conjunction with markup language files where the markup language interacts with the byte code files to define user interface elements in a program. Markup language refers generally to types of languages that encode text to represent text data and interfaces as well as details of the structure and appearance of the text data and or interfaces. Examples of markup languages include SGML HTML XML as well as any derived or related languages. For example XUL and XAML are both XML based markup languages. Markup languages may also be sub or super sets of other markup languages. For example HTML is a subset of XML which in turn is a subset of SGML.

In the present exemplary environment the functional aspects and object definitions of a program can be written in a higher level language and compiled to intermediate byte codes. Markup languages can instantiate objects and data elements from the intermediate byte code as well as define a user interface for the program. A byte code interpreter can take both the byte code and markup language files and execute a program using the functional aspects of the byte code and display aspects of the markup language code.

The present invention is described in terms of this example environment. Description in these terms is provided for convenience only. It is not intended that the invention be limited to application in this example environment. Although particular computer systems and components are shown those of ordinary skill in the art will appreciate that the present invention also works with a variety of other computers and components. Moreover after reading the following description it will become apparent to a person of ordinary skill in the relevant art how to implement the invention in alternative environments.

Although byte code is portable from a byte code interpreter on one computer architecture to a byte code interpreter on another byte code of one type is conventionally not compatible with a byte code interpreter of another type. For example a JAVA class file compiled byte code will run on its native runtime environment the JAVA Virtual Machine a byte code interpreter . However a JAVA class file will not run without modification on the Macromedia Flash Player a different byte code interpreter FLASH is a registered trademark of Macromedia Inc. .

Some systems allow a number of different source code files in different programming languages to compile to a single byte code file or set of related byte code files that run on a specific byte code interpreter. For example the Common Language Infrastructure used in .Net allows software development in a set of higher level source languages such as Visual Basic .Net Visual C .Net C and J . Source code in any of these languages can then be compiled into Common Intermediate Language byte code that will run on a specific runtime environment the Common Language Runtime a byte code interpreter . Other examples of source code languages include the JAVA programming language which compiles to JAVA byte code and the Flash programming language which compiles to SWF byte code. However even in these systems once compiled byte code is created the byte code is still tied to a specific byte code interpreter. Thus similar to a JAVA class file Common Intermediate Language byte code will not run on the Flash Player.

Currently programmers may use disassembler programs to in some cases convert portions of byte code into more easily understood source code. Disassembled source code can be used in porting and reprogramming the code to a target byte code of a different type. However such methods that presently exist are cumbersome and require significant additional programming to create a byte code of a different type. What is needed is a means of converting byte code of one type into byte code of another type so that byte code programs can not only run on a variety of different computer system architectures but run on a variety of different byte code interpreters as well.

Referring again to in one embodiment of the present invention the byte code transformation step is performed by referencing table structures within the source byte code . Many forms of byte code such as CIL byte code contain data such as class definitions and types that can be stored in table structures such as tables arrays or indexes. One or more table structures in the first byte code can be mapped to one or more table or array structures in the second byte code . The mapping of data elements from a first byte code to data elements from a second byte code is described in more detail below and illustrated in . In one configuration the second byte code table structure can be substantially similar to that in the first byte code . In an alternate configuration the second byte code table structure can be different than that in the first byte code . For example CIL source byte code files can contain multiple tables for data elements such as methods types and classes. In a transformation step the data in the multiple tables from the CIL source byte code can be stored in rows or slots within a single global type array in a target SWF byte code file . Even different types of rows from multiple tables in CIL source byte code can be stored in a single heterogeneous table in SWF target byte code . Thus instead of reflecting the multiple table structure of the source CIL byte code the resulting SWF byte code hones down all class and type references to a single array or lesser number of arrays. In another example JAVA source byte code can contain multiple table structures for classes in different JAVA class files. Similarly these table structures can be pared down to less tables upon conversion to a byte code of a second type . By using fewer table structures than the source byte code the target byte code can be smaller in size and data and objects are more quickly located within a single or limited number of tables instead of constantly cross referencing a great number of tables. Moreover in one configuration data and objects unused by the target byte code can be omitted from the destination byte code table structure.

Additionally instantiated objects in many byte code languages such as those compiled from ECMA scripting languages like ActionScript JavaScript or JScript can also be referenced as arrays tables. Thus one or more global table structures according to the invention can reference instantiated object methods in array notation such as object 23 instead of a name based lookup such as object.MethodCall . Additionally in one exemplary embodiment according to the invention metadata for an object in source byte code such as the visibility of types and members private public etc. and custom defined attributes can be stored in an array for the corresponding object in the target byte code . The metadata can similarly be referenced by index to the metadata array and external references to elements of the metadata array can be stored in a global table structure.

In a further configuration numerical indexes in the destination table structure can be referenced for types and classes in the target byte code . Conventionally data and objects such as classes members types local variables and arguments are stored as string literals in byte code and then looked up at execution time. Conventional systems create additional byte code for each different class increasing the amount of memory used for storage and the amount of data that must be parsed for lookups. Moreover if a class namespace comprises multiple sub classes such as My.Long.Namespace then a lookup for the type information of the class must execute individual computer instructions for My Long Namespace and Type . By contrast if the type information My.Long.Namespace.Type was stored in an array index such as 223 then only one instruction to array address 223 would be required for the same type lookup. The present embodiment according to the present invention can replace these inefficient string lookups with a fast index or offset lookup for the data or object. Another advantage of the present embodiment is that method and constructor overloading instructions in the source byte code can be converted into a more efficient implementation in the target byte code . Conventionally overloaded methods and constructors programmed in object oriented languages require inefficient namespace lookups up the chain of parent objects to find the computer instructions and data to execute the method or constructor. In the present embodiment according to the invention overloaded methods and constructors simply occupy a different array index than the parent method or constructor allowing a single lookup instruction to find the method or constructor.

Additionally because data elements such as class members and variables can be stored in for example a single table operations or methods performed on multiple data elements can often be performed in a single table operation as opposed to individual byte code instructions. For example if CIL source byte code contained instructions to set twenty variables to zero upon execution the conversion process could create SWF target byte code containing a table structure further containing all twenty variables. Instead of executing multiple byte code instructions to set each variable to zero the SWF target byte code could contain one byte code instruction to set the twenty rows in the table structure representing the variables all to zero in a single table loop operation.

In another embodiment of the present invention identifying strings such as class names can be removed because an index is used for all data elements and objects. Class names in byte code can be used to discover portions of the structure and functionality of the instructions in byte code files . Removing such strings allows the target byte code to be obfuscated making it more difficult for end users to decompile disassemble or reverse engineer.

An alternate embodiment according to the invention to the table array conversion method is illustrated in . is an operational flow diagram illustrating one method in accordance with the present invention of converting byte code of a first type into an intermediate data structure which is then converted into byte code of a second type . In one embodiment byte code files of a first type are received by a byte code parser and converted in a converting step into an intermediate data structure . Alternately in another embodiment according to the present invention source code files of a first type can be compiled directly into an intermediate data structure. The intermediate data structure in these embodiments preserves and represents at least a portion of the semantics syntax and metadata contained in a compiled byte code in an organized structure. An intermediate data structure can be implemented as a graph data structure such as an abstract syntax tree or abstract semantic graph. Examples of intermediate data structures formed as graph data structures include implementations of the Document Object Model DOM from the World Wide Web Consortium W3C in languages such as XML or HTML. In a converting step the intermediate data structure is converted into byte code of a second type . In the embodiment illustrated in the converting step is carried out by a byte code parser that reads the byte code files directly and parses out the data elements into an intermediate data structure . Further details and alternative embodiments of the conversion from intermediate data structure to byte code are provided below.

One method of creating an intermediate data structure is illustrated in . is an operational flow diagram illustrating a method in accordance with one embodiment of the invention of disassembling byte code files into an intermediate language format which is parsed to produce an intermediate data structure . Byte code files are typically in binary format and thus are not easily read by human programmers or software applications aside from byte code interpreters. However byte code files can be changed into an intermediate language format which generally comprises a much more comprehensible and structured format than pure byte code. The phrase intermediate language format generally refers to the lowest level human readable language that can be derived from a byte code file typically intermediate language source code and includes code in ASCII text format. Compiled byte code can often be changed to and from intermediate language source code . For example the Common Language Infrastructure allows source code in higher level languages to be compiled into Common Intermediate Language which contains representations of the Common Language Infrastructure processing instructions as defined by ECMA 335 specification. Common Intermediate Language byte code can take digital forms including a source representation known as CIL Assembly Language and a binary representation as byte codes. CIL Assembly Language is one example of an intermediate language format according to aspects of the present invention and it textually represents the data and functionality in .Net Assembly and Common Intermediate Language byte code. As implied by the Common in Common Intermediate Language analogous programs written in different higher level languages should compile to fairly similar Common Intermediate Language byte code. Common Intermediate Language is an object oriented language and has a stack based structure. Common Intermediate Language byte code is typically packaged in a .Net Assembly file. Both Common Intermediate Language binary byte code and .Net Assemblies can be assembled from as well as disassembled into constituent CIL Assembly Language source code.

Byte code files can be converted into intermediate language files in a disassembly step . In one embodiment according to the invention byte code files can be disassembled by a byte code disassembler into intermediate language formats . Intermediate language source files are examined in a parsing step for structure and content that is used to create an intermediate data structure that preserves the syntax and attributes of the underlying compiled byte code and intermediate language source code . In a preferred embodiment the parsing step can be carried out by an intermediate language parser which is a software application that can read intermediate language source code and produce an intermediate data structure . The resulting intermediate data structure is then converted to byte code as explained previously and detailed further below.

An alternative method of creating an intermediate data structure is shown in . is an operational flow diagram illustrating a method in accordance with the present invention of converting higher level source code files into an intermediate data structure . The phrase source code refers to computer programs or instructions written in a human readable language format that in some cases loosely resembles human spoken language. Source code files are typically composed of ASCII text and are often compiled into machine specific or intermediate code formats to actually execute as programs. Higher level source code is typically compiled into byte code of a corresponding or native type. For example JAVA source code is natively compiled by the JAVA Compiler into JAVA byte code. Some development frameworks also allow multiple source languages to be natively compiled to a single type of byte code. For example as described previously any source code language within the Common Language Infrastructure can be compiled into Common Intermediate Language byte code. In contrast to these approaches as shown in a source code compiler can compile source code files directly into an intermediate data structure in a compiling step without converting the source code into byte code of a corresponding type. For example source code written in C programming language could be compiled directly into an abstract syntax tree without ever directly converting the code to Common Intermediate Language byte code or packaged code in a .Net Assembly.

One method of converting byte code of a first type into byte code of a second type is explored in further detail in . is an operational flow diagram illustrating a method in accordance with one embodiment of the present invention of mapping data elements from a first byte code to data elements of a second byte code . Byte code files are converted into data elements in a converting step . As used herein the phrase data element refers to any logical unit or grouping that comprises a part or portion of a software application. For instance data elements can include any objects instructions metadata variables type definitions classes functions or groupings thereof within a computer program. Sources such as byte code and markup language code may be comprised of one or more data elements. As an example the data elements of Common Intermediate Language byte code include namespaces types members fields constants events properties indexers methods constructors and Common Intermediate Language opcodes. Moreover each instance and type of Common Intermediate Language opcode could comprise individual data elements for the purpose of mapping. In a mapping step byte code of a first type is parsed into its constituent data elements . At least a portion of data elements of a first type can be mapped to data elements of a second type . For example a data element comprising an instruction to create an object in Common Intermediate Language byte code in a .Net Assembly could be mapped to an instruction to create a substantially equivalent object in SWF byte code. Using the results of the mapping step data elements of a second type can be assembled into the resulting byte code of a second type in a converting step .

Exploring the data element mapping step in further detail mapping step is carried out in one embodiment in accordance with the present invention by referencing byte code mapping libraries . The byte code mapping libraries can contain computer instructions or subprograms that take as input a data element of a first byte code type determine if any mapping exists from the data element of a first type to one or more data elements of a second type and return information indicating appropriate data elements of a second type or a status message indicating that no mapping was found. In one embodiment of the invention a byte code mapping library for mapping Common Intermediate Language data elements to SWF data elements could for example map the Common Intermediate Language opcodes to the SWF actions and return information indicating the designated SWF action.

The byte code mapping libraries can be implemented for example as statically linked dynamically linked or remote libraries. The byte code mapping libraries may comprise one or more reference data structures to facilitate the process of matching data elements of a first type to data elements of a second type including for example structures such as lookup tables hash tables associative arrays or arrays. In one preferred embodiment in accordance with the present invention the byte code mapping libraries contain a lookup table. The lookup table in this embodiment can index input values of data elements of a first type to stored return values of data elements of a second type . By using a data structure such as a lookup table one of ordinary skill in the art could increase the speed and efficiency with which the data element mapping step is carried out.

When converting between byte code based in similar languages such as C and Java the data elements between the source byte code and target byte code should substantially map in nearly a 1 1 ratio. Thus the data element mapping process can be relatively straightforward to perform for languages that contain analogous objects classes members types and other data elements. A more difficult situation is presented when the source and target languages differ substantially in available data elements . For example as described below in more detail and illustrated in and and and heterogeneous byte code source languages like .Net and SWF often lack single analogous data elements between the two languages. Thus in the case of heterogeneous byte code conversion the data element mapping step can map a first data element to a second data element that has been created to mimic an analogous data element in the destination byte code language or format. For example if a first data element has no direct matching data element in the destination language then one or more second data elements such as methods types etc. can be assembled to mimic the behavior or appearance of the first data element . For example a source CIL method call data element could be mapped to one or more destination SWF stack instruction data elements . In this case the data elements aren t exactly analogous but both exhibit the same functionality. Alternately first data elements may be mapped to remote second data elements eliminating the need for analogous specific second data elements to map to as described in further detail below and illustrated in . Additionally some first data elements may not be necessary in the target byte code and can safely be ignored in the mapping step . For example a source CIL byte code may contain a data element that is a byte code instruction for a string conversion method. When converting to a target SWF byte code the data element mapping step can be configured to ignore the string conversion data element because the SWF language and byte code interpreter automatically converts any data used as a string to a string format.

With further reference to additional embodiments in accordance with the present invention can aid the conversion step by inserting bridging byte code of a second type . As previously described not all byte code languages will have data elements that entirely match up to data elements of other languages. Moreover during the mapping step it might not always be possible to map a first data element to a contrived second data element internally comprised of two or more second data elements . In such a case the computer implemented process carrying out the data element mapping and or the second byte code conversion could abort the byte code conversion operation. Alternately the process may just ignore the data elements of a first type that could not be mapped and assemble a second byte code from the collection of second data elements that were successfully mapped. However the resulting second byte code from the latter exemplary scenario could potentially lack portions of data and or functionality from the first byte code due to the ignored data elements 

One solution to such a scenario is found in embodiments of the present invention that insert bridging byte code of a second type into the second byte code in an inserting step . In one embodiment according to the present invention in the case that not all first data elements are mapped to second data elements during the mapping step bridging byte code is generated automatically by a computer implemented process in response. The process that automatically inserts bridging byte code could be part of the same software application or applications performing the byte code conversion process or the process could be embodied in an external software application. For example in the case that not all first data elements are mapped an external software application could be called to examine unmapped first data elements or the resulting second byte code . A bridging second byte code could be created in response to enhance the functionality of the second byte code and or compensate for lost data or functionality in the second byte code . The generated bridging byte code of a second type is inserted into said second byte code in an inserting step .

In an alternate embodiment of the present invention custom bridging byte code could be inserted by an external computer program or by a programmer. In this embodiment for example a computer programmer familiar with the first byte code could examine the second byte code and discover any data or functionality lost in one or more of the conversion steps . The programmer could then program and compile custom bridging byte code of a second type and insert this code into the target byte code . Thus the optional step of inserting bridging byte code can enable embodiments of the present invention to overcome inherent structural differences between different byte code languages and may permit developers more control than they would otherwise have over the conversion process.

In addition a base set of bridging byte code can be inserted to provide additional functionality to the target byte code . Even in the scenario where all data elements have been successfully mapped ignored or substituted additional functionality not present in the first byte code may be desired for the second byte code . For example if it was desirable to have an added information dialog window available in all target byte code for a given software application bridging byte code containing byte code instructions for a dialog window could be inserted even if the original source byte code contained no such dialog window.

With reference to an intermediate data structure may be used in embodiments in accordance with the present invention to facilitate the step of mapping data elements of a first type to data elements of a second type . As previously described at least a portion of byte code of a first type is parsed in a parsing step into an intermediate data structure . Portions of the graph data structure comprising the intermediate data structure may be further processed into data elements of a first type . Because exemplary intermediate data structures typically have a graph or hierarchical object structure each object within the intermediate data structure is a logical unit of data and the relationships between objects facilitates grouping families of objects. Accordingly these logical units and or groupings of objects in an intermediate data structure facilitate converting step by presenting the underlying data of a first byte code in a discernible and differentiable structure that may more easily be parsed. The resulting data elements can be mapped to data elements of a second type and assembled into byte code of a second type as previously described. For example Common Intermediate Language byte code files could be parsed along with other files in a .Net Assembly into an XML DOM intermediate data structure wherein XML tags represent at least some of the semantics syntax and structure of the .Net Assembly. Each XML tag or hierarchical group of tags in the XML DOM intermediate data structure could be processed from which some or all could be mapped to SWF action or tag byte code instructions and assembled into a SWF byte code file .

Yet another embodiment according to the present invention that addresses complexities during a mapping step is presented in . is an operational flow diagram illustrating a method in accordance with one embodiment of the present invention of mapping data elements to data elements and of a second byte code . Byte code files of a first type are converted to data elements of a first type in a converting step . Similar to the method illustrated in data elements of a first type and are mapped to data elements and of a second type in a mapping step . However a mapping step can map at least a portion of data elements of a first type to local second data elements . Local data elements include data elements functionality objects or information that are natively included in a destination byte code language. For example if a first byte code comprising Common Intermediate Language byte code included a data element comprising the stack push operation the data element could be mapped to a local data element in SWF which similarly comprises a push operation. The push operation is natively included in the SWF byte code language. A mapping step can also map at least a portion of first data elements to remote data elements of a second type . Remote data elements include data elements functionality objects or information that are not natively included in a destination byte code language but may be available from network resource. For example if a first byte code comprising Common Intermediate language byte code included a data element comprising a regular expression operation the data element could be mapped to a remote second data element in SWF in the case that the SWF language did not natively implement regular expressions. The remote second data element could contain SWF instructions for connecting to one or more network resources to access regular expression functionality. Like the embodiment illustrated in a byte code mapping library can be used to map first data elements to local and remote data elements and respectively. The byte code mapping library of can further contain instructions indicating whether a given data element should be converted to a local or remote data element. Turning back to external data or information can optionally or additionally be used to determine whether a local or remote data element of a second type is appropriate during the mapping step . Optionally external data can include data or information stored in an entirely separate file. Or external data could for example include data or information that is part of the same greater file containing both the external data and first byte code . For example metadata contained in a .Net Assembly comprising Common Intermediate Language byte code could be used in part or in whole to determine whether a given Common Intermediate Language data element should be mapped to one or more local or remote SWF data elements and . In step local and remote data elements of a second type and are assembled into byte code of a second type . The second byte code contains both local functions and remote functions . Local functions can include functions methods or operations that are native to the second byte code language. Remote functions can include functions methods or operations that are not native to the second byte code language. Remote functions can act as stubs or proxies to connect to one or more network resources that can execute the desired function and then return the result to the calling second byte code at runtime.

One method of invoking a remote function in transformed second byte code is illustrated in . is diagram of a computer comprising a computer system containing a second byte code according to one embodiment of the present invention. The second byte code can contain both local functions and or remote functions created as described above for . Returning to when local functions are called from the second byte code the functions can be executed natively in a second byte code language on the computer system . When remote functions are called from the second byte code the functions can connect to one or more computers and across a network to execute a function on that computer. Examples of a network can include LANs WANs or the internet and topology of the network can include client server peer to peer or other network configurations as would be apparent to one of skill in the art. Remote functions can connect to one or more server computers as well as other types of computers including workstations laptops and other peer computers. Once a remote function has connected to a computer the computer can perform a requested function or operation retrieve data or invoke other computer processes. The computer can then optionally return a response to the remote function . Continuing a previous exemplary scenario if a converted SWF byte code application contains a remote function for a regular expression operation the remote function can connect to a server that implements the desired regular expression operation in Common Intermediate Language the original source byte code language or any additional compiled or byte code language which implements the desired functionality. The server can then optionally return a response such as text that matched the sought regular expression to the calling SWF remote function . One advantage of utilizing both local and remote data elements and constituent functions as illustrated in is that missing functionality or data from the transformation process can be substituted with analogous remote functionality which can allow the target second byte code to behave in a similar fashion to a fully native application comprising a second byte code.

It should be noted that the embodiment according to the present invention illustrated in is not limited in application to those scenarios where a first byte code cannot completely map to a second byte code. Additional scenarios where it may be desirable to map data elements of a first type to remote data types of a second type include situations where sensitive data or information should not be present in a local byte code file . For example if a first byte code contains a database connection function the username and password may be stored in the first byte code and retrievable by skilled computer programmers. One embodiment according to the present invention could take data elements of a first type containing such sensitive database information and map the data elements to remote data elements of a second byte code type. For example in the case that a second byte code executes a database call a remote data function can connect to a remote server . The remote server can securely store the database username and password and use it to retrieve data from the database directly. The remote server can return the database results to the remote function without the second byte code ever storing the database username and password. Thus another useful aspect of the present invention is the ability to keep sensitive information away from target byte code applications that can potentially be compromised.

Common Intermediate Language data elements can be broken down into several sub types including for example namespaces types attributes and members . Namespaces serve as a means of partitioning types within a .Net Assembly by preserving unique names and may be preserved or shortened to SWF namespace data elements in a mapping step . Common Intermediate Language types include classes enumerations interfaces and delegates . Common Intermediate Language classes comprise a namespace a name and zero or more members . Classes can map to SWF object and or function data elements in a mapping step . Enumerations associate names with integer values and may be mapped to SWF integer or object data elements in a mapping step . Interfaces define properties and methods to be implemented by classes . Interfaces can match overloaded names on classes that implement given interfaces in a matching step . Delegates define signatures for callback functions. In mapping step delegates map to SWF code that simulates Common Intermediate Language delegates using various combinations of SWF actions tags and or records.

Members comprise fields constants events properties indexers methods and constructors . Fields have names hold values and can be mapped to SWF object property data elements in a mapping step . Constants represent immutable values such as the number Pi or a string constant. Constants may be inserted as inline data elements into SWF byte code or mapped to SWF object property data elements during a mapping step . Events are capable of firing one or more delegates when a state change occurs within a class and may be mapped to SWF event methods during a mapping step . Programmer defined events can be mapped to one or more additional SWF Methods to simulate added event behavior. Properties are a special type of Common Intermediate Language methods that allow a developer to read and set states associated with a Common Intermediate Language object. Indexers are a special type of property in which parameters may be passed. Properties and indexers may be mapped to SWF object methods and SWF action data elements during a mapping step .

Methods have a name and zero or more parameters and contain instructions in the form of CIL opcodes. Constructors are a special type of method that are called when a new object is instantiated. Methods and constructors are mapped to SWF action data elements in a mapping step .

Mapping step is explored in further detail in and . and together illustrate an operational flow diagram in accordance with one embodiment of the present invention illustrating the mapping of Common Intermediate Language methods and constructors to SWF action data elements . As explained previously Common Intermediate Language methods and constructors include one or more Common Intermediate Language opcodes . Common Intermediate Language opcodes are separated into different types and mapped to SWF actions in a mapping step . Note also that in alternative embodiments according to the present invention Common Intermediate Language opcodes may additionally or alternatively map to one or more SWF tags or records.

Categories of Common Intermediate Language opcodes include instantiations stack operators field access operators method calls argument access operators comparison operators flow control bit operators mathematical operators casting and conversion operators and exception handlers . Instantiation opcodes create new instances of a class and map to SWF action data elements New Method NewObject InitObject and InitArray in a mapping step . Stack operator opcodes manipulate the stack machine in the Common Language Infrastructure Virtual Execution System and map to SWF action data elements Push Pop StackSwap and PushDuplicate in a mapping step . Field Access Operators control field values and map to SWF action data elements Get Variable SetVariable GetMember and SetMember in a mapping step . Method calls map to SWF action data elements CallFunction CallMethod and Call in a mapping step . Argument access operators provide access to the passed arguments in a method and map to SWF action data elements Arguments Array GetVariable and Push in a mapping step . Comparison operators map to SWF action data elements Equals Less Less2 StrictEquals Greater and StringGreater in a mapping step . Flow control opcodes control the flow of execution of byte code and map to SWF action data elements If Jump and Call in a mapping step . Bit operators can manipulate individual bits and map to SWF action data elements BitAnd BitLShift BitOr BitRShift BitURShift and BitXOR in a mapping step . Mathematical operators perform operations on numbers and map to SWF data elements Add2 Less2 Modulo Decrement Increment Add Divide Multiply and Subtract in a mapping step . Casting and conversion operators are not mapped in an ignoring step because the SWF Engine is type free. Exception handling opcodes map to SWF action data elements Try and Throw in a mapping step .

In one embodiment of the invention one or more markup language files are represented in ASCII text files. The text markup language files are converted into a binary markup language format. A binary markup language format often has a smaller file size because it does not require the overhead of textual semantics to designate structure and can be utilized more efficiently than text markup language because text markup language files can require more extensive parsing to use. For example as an intermediate step in a byte code conversion process a XAML text markup language file can be converted into a BAML binary markup language representation of the XAML file. The BAML file and a first byte code can then be converted into a second byte code as described for and further described below.

In another embodiment according to the present invention first byte code files and markup language files can be converted in the same or related processing step by a byte code converter application to produce a second byte code . In an alternate embodiment conversion of byte code files and markup language files may take place at different times and or as part of different computer processes. For example a computer user could request a first byte code file through a proxy application. The request could initiate the byte code conversion process and create a second byte code . The second byte code could then begin execution on a byte code interpreter as described previously. The second byte code could contain instructions or references to markup language files . The proxy application could dynamically load the markup language files and initiate further conversion of the markup language code into additional second byte code that could be loaded into the already running second byte code for further execution. An exemplary scenario can include a user request for Common Intermediate Language byte code from an application that can only execute SWF byte code . Upon request a proxy application can receive Common Intermediate Language byte code and convert it in a transformation step into SWF byte code . Execution of the SWF byte code could then reference or call a XAML markup language file . The proxy application can then receive the XAML markup language code and convert the markup into additional SWF byte code that is dynamically loaded into the already executing SWF byte code . Thus alternate embodiments of the present invention allow for dynamic byte code conversion of all or portions of a first byte code and markup language code .

Alternately or in addition markup language files can be received and converted to an object graph in a converting step . An object graph is typically a directed graph or tree data structure consisting of objects linked to other related or associated objects. Object graphs may be encapsulated in markup language files custom text based languages or in other binary formats. In context of an embodiment in accordance with the present invention an object graph can represent some or all markup language tags and constructs as objects within the graph structure. Further an object graph can reference a first byte code and serve as a serialization format that preserves typing for data elements of a first byte code type values and the relationship of types to other types. As an example a XAML markup language file containing references to data elements in a .Net Assembly comprising Common Intermediate Language byte code could be parsed to generate a Common Language Infrastructure object tree where at least a portion of the object tree objects correspond to Common Language Infrastructure classes in the Common Intermediate Language byte code and at least a portion of the object tree object properties correspond to class properties. The Common Language Infrastructure object tree and Common Intermediate Language byte code or .Net XML DOM intermediate data structure could then be converted in a converting step into byte code of a different type like for example SWF byte code . In yet another embodiment according to the present invention first byte code and an object graph of a first type can be converted into a second byte code as well as an object graph of a second type. Similar to the object graph illustrated in an object graph of a second type can reference data elements objects and other information in a second byte code as well as define an object hierarchy and object relationships.

One method of generating an object graph is illustrated in further detail in . is an operational flow diagram illustrating a method in accordance with one embodiment of the invention of parsing markup language files into an intermediate graph structure which is then traversed to produce an object graph . In a parsing step a markup language parser receives markup language files parses the markup language tag structure and creates an intermediate graph structure . The intermediate graph structure reflects the original structure of the markup language document and is typically a tree structure. The intermediate graph structure provides the underlying framework for creating an object graph . In a generating step an object graph generator traverses the intermediate graph structure and creates an object graph . During the generating step any markup language code references to data elements in byte code of a first type may be associated with objects and properties in the resulting object graph . For example an XML markup language source file could be parsed into an intermediate tree format representing the hierarchical structure of tags in the XML document. The intermediate tree format could then be traversed to generate objects and properties for an object graph and to associate each XML tag in the hierarchy byte code data elements where the XML markup language source file contained external byte code references.

A method of converting byte code of a first type and markup language code into byte code of a second type is examined in greater detail in . is an operational flow diagram illustrating a method in accordance with an embodiment of the present invention of mapping data elements from a first byte code and data elements from markup language code to data elements of a second byte code . In converting step byte code files of a first type can be converted into one or more byte code data elements . Similarly in a converting step markup language files can be converted into one or more markup language data elements . As described above data elements can include objects instructions and numerous other structural elements within a computer program. Turning to markup language data elements specifically markup language data elements most typically include information relating to the appearance and displayed structure of a computer program as well as references to data and functionality in a first byte code . For example markup language data elements could include data structures defining colors lines shapes text and layout positions in markup language code as well as many other data structures as would be apparent to one of ordinary skill in the art and as will be described in further detail below. In an exemplary embodiment a XAML markup language file could be parsed into a group of data elements including external file references colors brushes pens shapes text images animations transforms sound video and controls. It should also be noted that because many markup languages are extensible the list of constituent data elements comprising a markup language file is not bounded and extensible as well.

In a mapping step data elements of a first byte code and data elements of markup language are parsed from byte code and markup language files respectively. At least a portion of the data elements can be mapped to data elements of a second type . Information contained in the source byte code may also be used to assist the mapping process for markup language data elements and vice versa. Alternatively markup language data elements may be mapped to data elements of a second type without reference to the first byte code or byte code data elements and vice versa. In a converting step data elements of a second type can be received and assembled into a resulting byte code of a second type .

In one embodiment in accordance with the present invention the mapping step is carried out by referencing markup language mapping libraries . Markup language mapping libraries can contain instructions or subroutines that receive input from markup language data elements determine if any mapping exists to one or more data elements of a second type and return information indicating which if any data elements of a second type have matches. Markup language mapping libraries can comprise mapping instructions for mapping display and layout elements defined in the markup language code as well as mapping and association instructions for references to first byte code data elements in the markup language code . Markup language mapping libraries can be implemented in any similar digital format as byte code mapping libraries as previously described. In an embodiment in accordance with the present invention a markup language mapping library could contain instructions for mapping XAML tag data elements to SWF data elements as explained in further detail below.

In another embodiment in accordance with the present invention the mapping step is augmented by referencing byte code mapping libraries . Byte code mapping libraries as previously described can contain instructions or code for mapping first byte code data elements to one or more second byte code data elements

In another embodiment in accordance with the present invention the mapping step is carried out by referencing both byte code mapping libraries and markup language mapping libraries as individually explained above. Moreover information in one mapping library may be used to help data element matching for either or both forms of data elements . The mapping libraries may be stored and executed as part of the same library file or packaged set of libraries. In the alternative the mapping libraries may comprise physically separate digital files. In addition either or both of the mapping libraries may be implemented in preferred embodiments in accordance with the present invention as lookup tables as previously described in greater detail. Alternatively the mapping libraries could comprise data structures such as hash tables associative arrays or arrays.

Additional embodiments in accordance with the present invention illustrated in can carry out an insertion step to insert bridging byte code of a second type in the resulting second byte code . During the data element mapping step it is possible that either first byte code data elements and or markup language data elements will not be successfully mapped to second byte code data elements . As described above in such cases where not all data elements are mapped the resulting byte code may lack portions of functionality or data in source byte code or markup language code .

One method to redress this situation according to an embodiment in accordance with the present invention is to insert bridging byte code in an insertion step . The bridging byte code may comprise for example additional functional or data code in the case that one or more first byte code data elements failed to map. Alternately or in addition the bridging byte code may comprise for example layout instructions or display elements in the case that some of the markup language data elements were not mapped.

In one embodiment according to the present invention bridging byte code is generated automatically by a computer process in response to mapping step and or conversion step as described in detail above. The bridging byte code may be generated by a software application that is part of the one or more software applications executing the overall byte code conversion process or the bridging byte code may alternately be generated by a standalone software application that is called as necessary. The generated bridging byte code is then inserted into the resulting byte code .

In yet another embodiment according to the present invention a programmer or external software application can initiate the insertion step and insert custom bridging byte code . As described previously a developer may examine the second byte code and discover functionality or data missing that was originally contained in the first byte code and or markup language code . The developer may then create custom bridging byte code and insert the code into the second byte code in an insertion step . Alternately a computer program may be executed which performs the tasks of analyzing missing functionality generation of bridging byte code and insertion in an insertion step .

XAML data elements can be further categorized into various XAML data element types . It is important to note that because XAML XML and other extensible markup languages are extensible the set of different constituent tags categories types and data elements is potentially limitless. Thus the categories noted in this exemplary embodiment are provided for illustrative purposes and are not intended to limit the scope of the present invention. XAML data elements can comprise constructs such as colors brushes pens shapes text images animation transforms sound video and controls . XAML colors are represented as four bytes one for each color channel red green and blue and one for the alpha channel. In mapping steps XAML constructs are mapped where possible to analogous SWF constructs comprised of one or more SWF tags records and or actions. It should also be noted that although specific SWF tags records and or actions are specified for mapping XAML data elements XAML data element types can be mapped in respective mapping steps in varying combinations of SWF tags records and or actions. Where no direct analogous elements between XAML and SWF exist embodiments in accordance with the present invention may simulate XAML elements by substituting combinations of two or more SWF tags records and or actions that together approximate a given XAML element.

XAML colors can be mapped to SWF RGB or RGBA records in a mapping step . Brushes are used to fill regions of a vector graphic shape and typically comprise solid gradient or bitmap type brushes. Brushes are translated to SWF FillStyle records in a mapping step . Pens are used to draw the contours of shapes and comprise properties such as brush thickness starting line cap ending line cap dash array dash cap and line join. Pens can be translated to SWF LineStyle records in a mapping step . XAML shapes include for example ellipses lines paths polygons polylines rectangles and rounded rectangles and are translated to SWF Edge records in a mapping step . Specifically ellipses are converted to SWF CurvedEdge records. Lines polygons polylines and rectangles are converted SWF StraightEdge records. Paths and rounded rectangles are converted into series of SWF CurvedEdge and StraightEdge records. Text comprises a series of Unicode characters and is translated to SWF DefineFont2 DefineFontInfo2 DefineText2 or DefineEditText SWF tags in a mapping step . Images consist of a grid of pixel data that can be compressed or represented in a variety of formats including BMP EMG EXIF GIF JPEG PNG TIFF WMF and SWF. JPEG images are converted to SWF DefineBits DefineBitsJPEG2 and DefineBitsJPEG3 tags in a mapping step . The other exemplary formats mentioned above are converted to SWF DefineBitsLossless and DefineBitsLossless2 tags in a mapping step . XAML defines animation as values that change over time and will animate values including Boolean Byte Int16 Int32 Int64 Single Double Color Length Size Thickness Point Rect Vector Matrix and Path. SWF defines animation using frames and change values for each frame. The step of converting XAML animation to SWF animation comprises matching time based animation values to the target frame rate of the resulting SWF file. XAML transforms are used to place and modify objects fills text and buttons. XAML presently supports many transformation types including rotate scale skew and translate as well as concatenations of transforms using matrix multiplication. XAML transforms are converted to SWF Matrix records in a mapping step . SWF Matrix records may then be associated with tags and records for other SWF data elements to perform transformations on those data elements . XAML sound elements link to embedded or streaming sound files comprising series of samples at a given sample rate. In a mapping step XAML embedded sound references are converted to SWF DefineSound tags and XAML streaming sound references are converted to SWF SoundStreamHead and SoundStreamBlock tags. XAML video references link to video files comprising series of raster image frames. Video files are typically streamed from an external source. XAML streamed video references are converted to SWF DefineVideoStream tags in a mapping step .

XAML controls may comprise any of the XAML elements described in or other XAML elements. Examples of controls include Button Canvas CheckBox ComboBox Group Image Label ListBox Menu Panel RadioButton ScollBar TabControl TextBox Timer and Window. In addition custom controls may be created leading to an unbounded list of potentially applicable controls . Controls may contain both display elements and functionality typically by referring to external byte code such as Common Intermediate Language byte code in a .Net Assembly. In a conversion step controls can be converted into SWF data elements using the previously described techniques for mapping XAML to SWF data elements and mapping .Net Assemblies and Common Intermediate Language data elements to SWF data elements.

With reference to and an object graph may be utilized in embodiments in accordance with the present invention in the step of converting markup language files into data elements . Referring to and as described above markup language files may be converted into an object graph in a converting step . The resulting object graph comprises a graph structure of markup language tags and or first byte code associations. With reference to and as previously detailed in one embodiment in accordance with the present invention an object graph is optionally generated by first converting markup language code into an intermediate graph structure . Referring now to during a conversion step some or all of the individual objects in the object graph may be converted to markup language data elements . Because an object graph comprises an ordered structure of markup language objects it is more readily parsed into individual data elements.

Referring now to when an intermediate data structure is generated from first byte code and used in conjunction with an object graph the structure and contents of an overall software program become much more apparent and distinguishable. Thus with reference to a preferred embodiment in accordance with the present invention converts first byte code intermediate data structures into first byte code data elements and converts markup language object graphs into markup language data elements . In this preferred embodiment at least a portion of both the byte code and markup language code is already in a structured and ordered format prior to respective data element conversions .

In addition to embodiments converting byte code and markup language code into byte code of a second type further embodiments in accordance with the present invention can produce byte code of a second type as well as markup language of a different type. is an operational flow diagram illustrating a method of converting byte code of a first type and or markup language code of a first type into byte code of a second type and markup language code of a second type in a transforming step according to an alternate embodiment of the present invention. It should be noted that markup languages may be of different types while at the same time being sub or super sets of one another. For instance XAML and XML could be considered different types of markup languages despite the fact that XAML is an XML based language. As an exemplary scenario SWF byte code and optionally XML markup language code could be converted into Common Intermediate Language byte code and XAML markup language code wherein at least a portion of the objects data data descriptions display instructions and structures of the SWF and optional XML code are converted to either Common Intermediate Language or XAML data elements.

The method illustrated in can extend and enhance many of the various methods intermediate procedures and embodiments according to the present invention previously described. With reference to illustrates a method of converting a first byte code into an intermediate data structure . Similarly an embodiment in accordance with the method illustrated in may create an intermediate data structure corresponding to a second byte code type which is used to then create a second byte code . Turning to illustrates a method of converting byte code into an intermediate language format . Similarly in an embodiment in accordance with the illustration in an intermediate data structure of a second type may be further converted into an intermediate language format of a second byte code type. The intermediate language format of a second byte code type may be compiled into second byte code . With reference to discloses a method of mapping data elements of a first byte code type to data elements of a second byte code type . Similarly another embodiment in accordance with the method illustrated in can map data elements of a first byte code type to both data elements of a second byte code type and or data elements of a second markup language type. With reference now to in view of data elements of a first markup language type can also be mapped to both data elements of a second byte code type and or data elements of a second markup language type. The second byte code and second markup language data elements can be assembled into second byte code files and second markup language files respectively. Additionally bridging byte code of a second type or bridging markup language of a second type can be inserted into the resulting byte and markup language code as described for bridging byte code insertion above.

With reference to illustrates a method of converting a markup language file into an intermediate graph structure . The intermediate graph structure can be converted into an object graph for further conversion as illustrated in . Turning to an alternate embodiment of the method illustrated in can create an object graph of a second markup language type that can represent some or all markup language tags from an optional first markup language code as well as references to data and objects in a destination second byte code. Additionally a second markup language object graph may be further processed into an intermediate graph structure reflecting the structure of a destination markup language file . The object graph and or the intermediate data structures may be converted into markup language of a second type . With reference to the method illustrated in viewed in light of byte code and markup language mapping libraries can be optionally used to map input data elements to byte code data elements of a second type and markup language data elements of a second type.

With reference now to as a further exemplary scenario SWF byte code and optionally XML markup language code can be mapped to data elements of a Common Intermediate Language byte code type and data elements of a XAML markup language type. The Common Intermediate Language byte code data elements can be converted in step into a DOM or abstract syntax tree intermediate data structure. The intermediate data structure can be further converted into CIL assembly language an intermediate language format . The CIL assembly language files can be assembled into a resulting Common Intermediate Language byte code . The XAML markup language data elements may be assembled into an intermediate XAML graph structure and further assembled into a XAML object graph. The resulting XAML object graph can then be parsed into a XAML markup language file .

In one exemplary embodiment according the present invention a byte code converter application on a server performs the step of converting byte code of a first type into byte code components . Alternate embodiments that would be apparent to one of skill in the art upon reading the following description include byte code converting systems implemented on peer to peer networks and other network topologies as well as over mail web or other network protocols. Returning to the server embodiment the server computer can contain a byte code converter and serve second byte code files to client computers or other server computers as described more fully above for . The byte code converter could run as a stand alone application on a server or as a plug in as described in more detail below for . In the present embodiment a server computer can convert first byte code files into and serve second byte code files to other computers over a network. Ideally the server computer can serve a specific second byte code to one client while serving a different second byte code to another client based on factors such as the environment available applications and operating system of the receiving client computer.

In one exemplary configuration a client computer initiates a request to the server for a second byte code specific to the client. If the request is the first request then the byte code converter on the server converts the byte code of a first type into byte code components which are retained on the server computer and assembled into a client specific second byte code . The specific target byte code is then returned to the client. In a subsequent client request for the same target byte code the byte code can be assembled from the retained byte code components . If a subsequent client connects to the server computer and requests a different second byte code the server performs a determination step to see if the client request can be satisfied with target byte code comprised of the existing retained byte code components or if additional byte code components must be produced to create a client specific target byte code . In this fashion the present embodiment of the invention allows efficient reuse of common byte code components . In the current example the server computer determines that the target byte code requires byte code components which are already retained on the server and byte code component which has not yet been created. The server performs converting step to produce missing byte code component from source byte code . Byte code component is then retained by the server and combined with byte code components to form the client specific byte code of a second type . For example a server containing CIL source byte code could be configured to convert and serve SWF target byte code containing a Windows specific interface to a Windows operating system client computer. The server can then reuse the generic old byte code components from one or more earlier byte code conversions and create a new byte code component to server SWF target byte code to a Mac OS X specific interface on a Mac OS X operating system client computer.

In an alternate exemplary configuration a server can convert byte code files into one or more byte code components before receiving a client request requiring those specific components . Upon a client request for a specific target byte code the server can perform a determination step to decide if the necessary byte code components have already been created and retained among the pre created byte code components . If the necessary byte code components are present then the target byte code is assembled. If not the additional byte code components missing from the target byte code can then be converted from the source byte code . Thus in this configuration the server can be set up to accommodate the most likely target byte code files to be requested by client computers by predicting and compiling anticipated byte code components 

In another embodiment of the invention after receiving a target byte code a client computer from the client server example may cache the target byte code or individual byte code components . If the client computer requires an updated version of the target byte code it can initiate another request to the server. The server determines which byte code components the client already has by for example communicating with the client or referencing a log of byte code component transfers and optionally converts and sends only the different updated byte code components to the client computer. The client computer can then invoke the byte code application using the cached older byte code components that did not require updating and updated byte code components for the portion of the byte code application that did require updating. The assembling step may be required on the client end to produce a workable target byte code or the byte code components may already be able to interact without any assembling step . Moreover if certain byte code components are determined to regularly require updating the assembly step can be performed to make one or more groups of byte code files that remain substantially static and one or more other groups of byte code files expected to change over time. The static and dynamic groups are sent together to a client as a target byte code but remain replaceable in parts should the byte code require updating. Moreover in an alternate embodiment a byte code of a second type can be created from only a portion of the source byte code and or second byte code components and sent to another computer. When additional functionality or methods are needed from the invocation of the resulting byte code a communication can be made to the converting computer to convert additional source byte code or return other byte code components 

In one exemplary embodiment according to the invention the byte code components retained by a computer after a source byte code conversion step are stored in a database. For example a database reference to a byte code component could include such information as the byte code language the program definition the client operating system to which the byte code component targets and other information. The database can later be referenced for easy lookup of byte code components to reuse in assembling specific target byte code files . In alternate embodiments a flat file system or other data storage medium could be used to store byte code components 

Many types of applications such as graphics applications like Adobe Acrobat Adobe Illustrator and integrated development environments and multimedia servers such as audio and video streaming servers similarly allow for the use of plug ins ADOBE PHOTOSHOP and ILLUSTRATOR are either registered trademarks or trademarks of Adobe Systems Incorporated . A plug in application may comprise an application that accesses a separate byte converter application . Alternately a plug in application may be comprised within the same larger application as byte converter application .

Also a software application may be modified with software application extensions comprising similar functionality to a plug in . A software extension is typically created using extension APIs for a software application and allows modifications or additions to the functionality of an application usually with fewer restrictions than an application plug in . A software extension to a software application could contain or invoke a byte code converter for converting byte code and markup language files as previously described.

The byte code transforming step and markup language transforming step can be performed within an IDE. In one exemplary embodiment a byte code converter software application takes the form of an application plug in for an IDE. Upon compiling and producing native byte code and markup language files the IDE can communicate instructions to invoke the byte code converter plug in to carry out the transformation step . For example both Visual Studio and Eclipse have plug in architectures that enable developers to write software application plug ins that can be invoked from within the IDE. Turning to Visual Studio C source code can be natively compiled by the Visual Studio IDE into CIL byte code and packaged with XAML markup language code to form a .Net application. Following automatic instructions or user input Visual Studio can then invoke a byte code converting plug in according to the present invention which can convert the CIL byte code and XAML markup language code into target SWF byte code and optionally one or more target markup language files. Alternately computer instructions containing logic to convert byte code in transformation step may be natively built in to an IDE which could invoke the transformation instructions directly from the application. In a preferred embodiment a menu command graphical button or build instruction in the Visual Studio IDE graphical interface invokes or designates the execution of the byte code converting IDE plug in or native computer instructions. One advantage of allowing for development and testing in one language and producing a target byte code in another language as part of a build process is that debugging and coding in the native environment can be more useful and efficient. For example developers might have great expertise at the source code language and source byte code instructions but very little experience with the target byte code instruction set or intermediate language.

In optional step if further development is needed for the converted target application of a second type comprising second byte code and optional markup language files a developer or an automated IDE process can take further development steps such as building launching testing and debugging the converted application. Similar to the steps of testing a native application of a first type if testing reveals errors or possible improvements development step can be repeated with all subsequent development steps proceeding again as described above. In the case that no further development is needed an optional step can be performed wherein the target byte code of a second type may be launched. For example if SWF byte code is created in an exemplary byte code converter plug in a live instance of execution of the SWF byte code may be displayed. Additionally the resulting byte code may be displayed to a developer within an IDE so that a developer may review and edit the created target byte code further.

In an alternate embodiment according to the present invention the transformation step can take place at any time during the development of the first source code or markup language . Many conventional IDEs provide for a preview function in which at least some portion of source code or markup language is compiled during development and before explicit compilation into first byte code . Typically a background computer process can compile incremental portions of source code or markup language as the files are developed. When a developer invokes a preview command in the IDE or if an automatic preview window in an IDE is activated at least some portion of the compiled byte code and or markup language code is displayed. In the present embodiment according to the invention the preview process includes the additional step of converting at least a portion of the source byte code or markup language into target second byte code and or second markup language as described previously. The preview of an application or display executing converted byte code and or markup language code can be invoked explicitly such as with a developer pressing a preview graphical IDE button or implicitly such as every time first source code file is saved or edited. For example if a developer working with C source code and XAML markup language code in Visual Studio invoked the preview function according to the invention a byte code converting plug in could dynamically create a SWF byte code file from at least a portion of the C source code and XAML markup language using steps described above. The resulting SWF byte code file could then be executed and displayed graphically in a Visual Studio preview window. The byte code transformation step can run as a process that continually creates target byte code output or incrementally transforms source byte code when the preview functionality requires updated target byte code .

In yet another embodiment according to the invention the transforming step can adjust the target platform for the created second byte code . Byte code such as SWF can target a certain computer platform such as the Windows Mac OS X or Linux platforms and display graphical objects in the application in a manner consistent with the platform. A developer or automatic IDE process can select an appropriate target platform and step will transform first byte code into a second byte code targeting one or more specific computer platforms. Moreover some graphical IDEs include visual object editors containing a graphical user interface for programming an application. Typically a developer can manipulate application objects such as display items or controls using the visual editor and without resorting to typing text source code. An IDE visual object editor conventionally uses some similar functionality to the preview functionality described above in that graphical controls and display items are laid out in an analogous manner to how they will appear in a compiled native byte code application. The present embodiment of the invention extends the visual editor to graphically display visual objects as they will substantially appear in the converted target byte code . For example if a developer is programming C source code in Visual Studio and intending to target SWF byte code the Visual Studio visual object editor will display graphical objects as they will substantially appear in an executing instance of SWF byte code and not like an application executing native compiled CIL byte code which typically appears in accordance with the native System.Windows.Forms System.Drawing and System.Drawing.Drawing2D APIs from the .Net Framework.

In a further embodiment if the first source code is developed against development libraries of a second type such as those described for the native compiled first byte code can utilize one or more display elements to appear as will the second byte code . For example C source code developed against a SWF target development library can be compiled in Visual Studio to a first CIL byte code . However the resulting CIL byte code can appear when executed to display objects in substantially the same manner as an analogous SWF byte code application. The advantage of this embodiment is that a developer can develop a byte code application in a native first byte code format and observe the application display as it will when converted to a second byte code . This way a developer can perform nearly all program development using only native source code markup language and byte code and wait until the end of the development process to create a target byte code of a different type .

While various embodiments of the invention have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

