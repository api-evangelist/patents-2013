---

title: Integration flow database runtime
abstract: The present disclosure describes methods, systems, and computer program products for providing application integration functionality directly on a relational database according to an implementation. One computer-implemented method includes inserting relational data into a start table of a database, detecting a change in the start table, retrieving the inserted relational data from the start table, processing, using a computer, the relational data using a database integration flow runtime into result data, inserting the result data into an end table of the database, detecting a change in the end table, and retrieving the result data from the end table.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09411845&OS=09411845&RS=09411845
owner: SAP SE
number: 09411845
owner_city: Walldorf
owner_country: DE
publication_date: 20130613
---
Enterprise Application Integration EAI solutions attempt to facilitate communication between homogeneous heterogeneous applications. The EAI solutions often use a generic data exchange GDX format such as XML as their canonical data model and an EAI solution runtime is typically message oriented middleware MOM or an Enterprise Service Bus ESB built on top of an application server. If a system sender needs to send data in a message using a particular EAI solution to an application receiver the data may be converted multiple times between for example database relational format and GDX format and cross multiple system boundaries sender database to application server application server to EAI solution EAI solution to application server application server to receiver database resulting in high resource overhead per message to the receiver. The needed software hardware and support as well as system complexity increase a total cost of ownership for EAI solutions for both senders and receivers.

The present disclosure relates to computer implemented methods computer readable media and computer systems for providing application integration functionality directly on a relational database. One computer implemented method includes inserting relational data into a start table of a database detecting a change in the start table retrieving the inserted relational data from the start table processing using a computer the relational data using a database integration flow runtime into result data inserting the result data into an end table of the database detecting a change in the end table and retrieving the result data from the end table.

Other implementations of this aspect include corresponding computer systems apparatuses and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods. A system of one or more computers can be configured to perform particular operations or actions by virtue of having software firmware hardware or a combination of software firmware or hardware installed on the system that in operation causes or causes the system to perform the actions. One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that when executed by data processing apparatus cause the apparatus to perform the actions.

The foregoing and other implementations can each optionally include one or more of the following features alone or in combination 

A first aspect combinable with the general implementation further comprising selecting the relational data from a source table of the database.

A second aspect combinable with any of the previous aspects further comprising inserting the result data into a target table of the database.

A third aspect combinable with any of the previous aspects further comprising serializing the result data passing the serialized data to a transmission application and transmitting the serialized data.

A fourth aspect combinable with any of the previous aspects further comprising deserializing received data into relational data.

A fifth aspect combinable with any of the previous aspects serializing the result data for transmission passing the serialized data to a transmission application and transmitting the serialized data.

The subject matter described in this specification can be implemented in particular implementations so as to realize one or more of the following advantages. First all operations are database internal. No system boundaries are typically traversed and no data conversion is required between a relational format and a general data exchange GDX format resulting in a lower resource footprint. In case a sender and a receiver do not share the same database system data can be transported in relations format from the sender to the receiver database. Second all data intensive operations are executed in a database system where the database system acts as an integration runtime. Third the database runtime leverages well established database management system DBMS principles such as parallel query execution and scalability for high performance a rich set of abstract languages sequential query language SQL and stored procedures to define integration semantics ACID principles for transactional data processing and user role management for access control. Fourth a database based integration runtime inherits some of the characteristics of the database used including high availability stability persistence and bulk processing. Fifth the execution of application integration functionality directly on a relational database and the ability to forego the use of a dedicated application server results in a lower total cost of ownership for application integration. Other advantages will be apparent to those skilled in the art.

The details of one or more implementations of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims.

This disclosure generally describes computer implemented methods computer program products and systems for providing application integration functionality directly on a relational database. The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of one or more particular implementations. Various modifications to the disclosed implementations will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other implementations and applications without departing from scope of the disclosure. Thus the present disclosure is not intended to be limited to the described and or illustrated implementations but is to be accorded the widest scope consistent with the principles and features disclosed herein.

Enterprise Application Integration EAI solutions attempt to facilitate communication between homogeneous heterogeneous applications. EAI solutions often use a generic data exchange GDX format such as XML as their canonical data model and an EAI solution runtime is typically message oriented middleware MOM or an Enterprise Service Bus ESB built on top of an application server if a system sender needs to send data in a message using a particular EAI solution to an application receiver multiple simplified processing steps are typically necessary 1 the sender extracts sender relational format data to be sent from a sender database 2 the sender converts the extracted sender relational format data to an EAI compatible GDX formatted first message 3 the sender passes the converted data to a particular EAI solution which runs on its own software stack in the EAI compatible GDX formatted first message 4 the EAI solution processes the received data retrieved from the EAI compatible GDX formatted first message e.g. transformation receiver determination and the like using EAI solution logic EAI solution database 5 the EAI solution passes the data in a receiver compatible GDX formatted second message to the receiver 6 the receiver converts the data in the receiver compatible GDX formatted second message to a receiver compatible relational format and 7 the receiver inserts the data into its database using the receiver compatible relational format. In total the data is converted twice sender relational format to EAI compatible GDX format and receiver compatible GDX format to receiver relational format and crosses four system boundaries sender database to application server application server to EAI solution EAI solution to application server application server to receiver database resulting in high resource overhead per message to the receiver. The needed software hardware and support as well as system complexity increase a total cost of ownership for EAI solutions for both senders and receivers. The following described computer implemented methods computer readable media computer systems and components of an example distributed computer system ECDS provide functionality to execute engineering application integration EAI directly on a relational database and not on an application server. In some implementations the functionality can be provided with and or use one or more graphical user interfaces GUIs providing an efficient and user friendly data input capability and or presentation of data provided by or communicated within the EDCS .

At a high level the application server is an electronic computing device within the EDCS that is operable to receive transmit process store or manage data and information. According to some implementations the application server may be include and or be communicably coupled with an e mail server a web server a caching server a streaming data server and or other suitable server. The application server may operate in a cloud based computing environment.

In general the application server is a server that stores and or executes one or more applications responsive to requests responses sent by other application servers e.g. from a client application described below clients database servers and or other components whether illustrated or not within and communicably coupled to the illustrated EDCS . For example requests responses can in some implementations be messages. In some implementations the messages can be structured according to the extensible markup language XML and or other suitable format protocol etc. In some implementations application server can be accessed directly or using the network to perform programmed tasks or operations of a particular application and or associated component whether illustrated or not . Requests responses may also be sent to the application server from internal users external or third parties other automated applications as well as any other appropriate entities individuals systems or computers whether illustrated or not .

In some implementations any and or all components of the application server both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer neither illustrated . The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the EDCS . The functionality of the application server may be accessible for all service consumers using this service layer. Software services such as those provided by the service layer provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in extensible markup language XML format or other suitable format. The API and or service layer can be wholly or partial integral or stand alone in relation to the application server or components of the EDCS . Moreover any or all parts of the API and or the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module.

The application server includes an interface . Although illustrated as a single interface in two or more interfaces may be used according to particular needs desires or particular implementations of the EDCS . The interface is used by the application server for communicating with other systems in a distributed environment including within the EDCS connected to the network for example the client database server as well as other systems whether illustrated or not that may be communicably coupled to the network . Generally the interface comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with the network . More specifically the interface may comprise software supporting one or more communication protocols associated with communications such that the network or interface s hardware is operable to communicate physical signals within and outside of the illustrated EDCS .

The application server includes a processor . Although illustrated as a single processor in two or more processors may be used according to particular needs desires or particular implementations of the EDCS . The processor executes instructions and manipulates data to perform the operations of the application server and or functionality required to provide application integration functionality directly on a relational database.

The application server also includes a memory that holds data for the application server client database server and or other components of the EDCS whether illustrated or not . Although illustrated as a single memory in two or more memories may be used according to particular needs desires or particular implementations of the EDCS . While memory is illustrated as an integral component of the application server in alternative implementations memory can be external to the application server and or the EDCS . In some implementations the memory includes one or more instances of application data .

The application is any type of application that allows the client database server and or other component s of the EDCS to request view add edit delete manage and or consume content obtained from by the application server in response to a received request response. For example the application may be a portal application a business application and or other suitable application consistent with this disclosure. The application can also interface with other applications and or other suitable components of the EDCS to wholly or partially complete a particular task. For example the described components can provide functionality to provide and or support application integration functionality directly on a relational database.

In some implementations the application can also be associated with application data including objects and data user profiles processes content provider locations addresses data storage locations specifications content lists access requirements and or any other suitable data associated with an application . The application data can be represented by any type of suitable data structure s and in any suitable format s . For example the application data could be an executable module spreadsheet database flat file binary file multi part file linked list and or the like.

Once a particular application is launched a client and or database server may interactively process a task event or other information associated with the application server associated with the application . Additionally a particular application may operate in response to and in connection with at least one request received from other applications including applications or other components e.g. software and or hardware modules associated with another application server . In some implementations the application can be and or include a web browser. In some implementations each application can represent a network based application accessed and executed using the network e.g. through the Internet or using at least one cloud based service associated with the application . For example a portion of a particular application may be a web service associated with the application that is remotely called while another portion of the application may be an interface object or agent bundled for processing at a remote client . Moreover any or all of a particular application may be a child or sub module of another software module without departing from the scope of this disclosure. Still further portions of the particular application may be executed or accessed by a user working directly at the application server as well as remotely at a corresponding client and or database server . In some implementations the application server or any suitable component of application server or the EDCS can execute the application .

The client e.g. may be any computing device operable to connect to or communicate with at least the application server using the network . In some implementations the client can communicate directly with the database server or indirectly through another component of the EDCS . In general the client comprises an electronic computing device operable to receive transmit process and store any appropriate data associated with the EDCS . Typically the client will process and or respond both automatically and or by manual user interaction to requests and or responses generated by the application server for example software code received from the application . The client can also initiate requests to the application server and or database server . The client typically includes a client application processor a memory and or an interface .

The client application is any type of application that allows the client to navigate to from request view edit delete and or manipulate content on the client for example using an HTML 5 IOS or ANDROID based application. In some implementations the client application can be and or include a web browser. In some implementations the client application can use parameters metadata and other information received at launch to access a particular set of data from the application server database server and or other client . Once a particular client application is launched a user may interactively process a task event or other information associated with the application server database server and or other client . Further although illustrated as a single client application the client application may be implemented as multiple client applications in the client . In some implementations the client application may act as a GUI interface for the application database server and or other components whether or not illustrated of the EDCS .

The interface is used by the client for communicating with other computing systems within the EDCS using network . For example the client can use the interface to communicate with the application server database server as well as other clients and or systems not illustrated that can be communicably coupled to the network . The interface may be consistent with the above described interface of the application server or other interfaces whether illustrated or not within the EDCS . The processor may be consistent with the above described processor of the application server or other processors whether illustrated or not within the EDCS . Specifically the processor executes instructions and manipulates data to perform the operations of the client including the functionality required to send requests to the application server and or database server and to receive and process responses from the application server and or database server. The memory typically stores objects and or data associated with the purposes of the client but may also be consistent with the above described memory of the application server or other memories whether or not illustrated within the EDCS and can be used to store data similar to that stored in the other memories of the EDCS for purposes such as backup caching and the like.

Further the illustrated client includes a GUI . The GUI interfaces with at least a portion of the EDCS for any suitable purpose including generating a visual representation of a web browser and or other GUI interface. The GUI may be used to view and navigate among various web pages located both internally and externally to the application server database server view data associated with the application server database server and or the client or for any other suitable purpose. In particular the GUI may be used in conjunction with content from application server database server and or the client to provide application integration functionality directly on a relational database.

There may be any number of clients associated with or external to the EDCS . For example while the illustrated EDCS includes one client communicably coupled to the application server and database server using network alternative implementations of the EDCS may include any number of clients suitable to the purposes of the EDCS . Additionally there may also be one or more additional clients external to the illustrated portion of the EDCS that are capable of interacting with the EDCS using the network . Further the term client and user may be used interchangeably as appropriate without departing from the scope of this disclosure. Moreover while the client is described in terms of being used by a single user this disclosure contemplates that many users may use one computer or that one user may use multiple computers.

The illustrated client some example configurations illustrated as is intended to encompass any computing device such as a desktop computer laptop notebook computer wireless data port smart phone personal data assistant PDA tablet computing device one or more processors within these devices or any other suitable processing device. For example the client may comprise a computer that includes an input device such as a keypad touch screen or other device that can accept user information and an output device that conveys information associated with the operation of the application server or the client itself including digital data visual and or audio information or a GUI as shown with respect to the client .

In some implementations any and or all components of the client both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer neither illustrated . The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the EDCS . The functionality of the client may be accessible for all service consumers using this service layer. Software services such as those provided by the service layer provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in extensible markup language XML format or other suitable format. The API and or service layer can be wholly or partial integral or stand alone in relation to the client or components of the EDCS . Moreover any or all parts of the API and or the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module.

At a high level the database server is an electronic computing device within the EDCS that is operable to receive transmit process store or manage data and information using a relational database. According to some implementations the database server may be include and or be communicably coupled with an e mail server a web server a caching server a streaming data server and or other suitable server. The database server may operate in a cloud based computing environment.

In general the database server is a server that stores and or executes one or more IFC compilers and or modeling applications responsive to requests responses sent by an application server client other database server and or other component whether illustrated or not within and communicably coupled to the illustrated EDCS . The database server provides application integration functionality directly on an associated relational database . In some implementations database server can be accessed directly or using the network to perform programmed tasks or operations of a particular IFC compiler modeling application and or associated component whether illustrated or not . Requests responses may also be sent to the database server from internal users external or third parties other automated applications as well as any other appropriate entities individuals systems or computers whether illustrated or not .

In some implementations any and or all components of the database server both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer neither illustrated . The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the EDCS . The functionality of the database server may be accessible for all service consumers using this service layer. Software services such as those provided by the service layer provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in extensible markup language XML format or other suitable format. The API and or service layer can be wholly or partial integral or stand alone in relation to the database server or components of the EDCS . Moreover any or all parts of the API and or the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module.

The database server includes an interface . Although illustrated as a single interface in two or more interfaces may be used according to particular needs desires or particular implementations of the EDCS . The interface is used by the database server for communicating with other systems in a distributed environment including within the EDCS connected to the network for example the client application server as well as other systems whether illustrated or not that may be communicably coupled to the network . Generally the interface comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with the network . More specifically the interface may comprise software supporting one or more communication protocols associated with communications such that the network or interface s hardware is operable to communicate physical signals within and outside of the illustrated EDCS .

The database server includes a processor . Although illustrated as a single processor in two or more processors may be used according to particular needs desires or particular implementations of the EDCS . The processor executes instructions and manipulates data to perform the operations of the database server and or functionality required to provide application integration functionality directly on a relational database.

The database server also includes a relational database . The relational database can in some implementations hold data for the database server client application server and or other components of the EDCS whether illustrated or not . In some implementations the relational database in an in memory database. The in memory database is a high performance relational database management system RDBMS that primarily relies on volatile electronic memory such as random access memory RAM as opposed to magnetic optical removable or other suitable non electronic memory for storage retrieval and processing of data. The reliance on electronic memory allows in some implementations for near real time aggregation replication synchronization and processing of data. In some implementations a persistency layer ensures that a copy of the in memory database is maintained on non volatile magnetic optical removable or other suitable non electronic memory in the event of a power or other system failure in order to allow recovery of the in memory database. In some implementations the in memory database can be replicated to one or more conventional databases not illustrated for backup purposes. In some implementations data from the conventional database can be replicated to and used from the in memory database .

Although illustrated as a single relational database in two or more relational databases may be used according to particular needs desires or particular implementations of the EDCS . While the relational database is illustrated as an integral component of the database server in alternative implementations relational database can be external to the database server and or the EDCS . In some implementations the relational database includes one or more instances of enterprise integration pattern EIP constructs .

An EIP construct is and integration semantic or integration flow iFlow design pattern for the use of enterprise application integration and MOM. The iFlow is a description or template for how to solve a problem e.g. integrating two applications that can be used in many different situations and are often formalized best practices proven design paradigms that a software programmer implements in a particular application process etc. iFlows are often specified as a collaboration diagram where a sender receiver and the integration flow itself are participants. For example an iFlow could be created to count words within a message supplied by a first application sender and to supply the result to a second application receiver . The example iFlow could have multiple steps each step performing a different function. In some implementations iFlows can be described in business process modeling notation BPMN or other suitable notation. Although illustrated as integral to the database server in in alternative implementations the EIP constructs can be external to the database server and or the EDCS e.g. within a memory of the application server client and or separate server not illustrated . Examples of EIP constructs may include content based routing message mapping structure mapping filter split aggregate messages e.g. as illustrated in and the like.

EIP constructs are at least generated edited deleted stored and or retrieved by a modeling application . The modeling application provides a GUI interface for efficient user interaction with the modeling application and EIP constructs . Although illustrated as integral to the database server in in alternative implementations the modeling application can be external to the database server and or the EDCS e.g. executing on the application server the client and or a separate server not illustrated . In some implementations the GUI interface can allow specification of a BPMN model representing integration semantics of an iFlow. In other implementations the modeling application can have an interface that receives a particular iFlow in a textual representation e.g. program code or XML .

The integration flow compiler IFC is any type of application that compiles iFlows into database constructs for example database tables storing messages and intermediate results structured query language SQL statements integration operations stored procedures integration operations stored procedures capturing user defined code containing integration semantics database statements e.g. begin commit transaction to ensure transactional processing of the messages and to handle the lifecycle of a message and or stored procedures handling the lifecycle of a message. As the iFlow is expressed in database constructs the database system itself acts as an integration runtime. Note only integration problems that can be solved using database constructs can be executed in the database. In some implementations iFlows can be split and compiled into a combination of database and non database constructs. In some instances a database construct can be used to trigger the non database construct and to transmit data to receive data from the non database construct. Although illustrated as integral to the database server in in alternative implementations the IFC can be external to the database server and or the EDCS e.g. executing on the application server the client and or a separate server not illustrated .

At 2 the IFC generates a first non optimized version of database code to upload to the relational database from 2 method proceeds to 3 .

At 3 a simulator not illustrated in can be used to check the generated non optimized code for errors. Example checks can include comparing existing database artifacts against the generated code artifacts etc. If any errors are found a user can be notified and make corrections possibly requiring starting method from 1 . From 3 method proceeds to 4 .

At 4 a synthesizer not illustrated in optimizes correct generated non optimized code into optimized code a database integration flow DIF . The synthesizer then deploys the DIF to the relational database. After 4 method stops.

In some implementations the simulator of 3 and the synthesizer of 4 can be part of the IFC. In other implementations the simulator and or synthesizer can stand alone in relation to the IFC on the database server and or other component of the EDCS .

Referring to consistent with the description of the provided iFlow diagram is compiled optimized into optimized code and the optimized code deployed to the relational database as a scheduler and generated database code DIF runtime . Note that this example assumes that both the sender Application A and receiver Application B are sharing the same relational database refer to below for this category C 1 . Here sender writes data for example one or more messages containing text from database tables associated with Application A to a start table . The sender then issues a database commit. The scheduler detects the change to the start table triggers get messages from the start table reads data deletes data from the start table and passes the data to the splitter moves the messages according to the DIF puts outgoing messages result data into the end table and commits the transaction. The receiver detects the change to end table retrieves the result data from the end table and writes the retrieved result data to application B tables . Note that in some implementations the scheduler can execute outside the database e.g. on a separate server as a non database construct see description of IFC above in relation to and listens for new data to be written to the start table . In alternate implementations the scheduler can execute on the database as a form of application server or polling application. In other implementations the scheduler could be implemented as a database trigger or in any suitable way to permit detection of changes to the start table and the start of the DIF runtime logic.

A channel represents a unidirectional point to point P2P communication from sender to receiver . It usually contains integration logic by chaining EIPs e.g. and . The channel endpoints e.g. database start table and end table receive produce messages. The channel endpoints represent entry exit points for messages into the DIF runtime capture relational message body data and are generated by the IFC as persistent . The tables belong to the database integration flow of the DIF runtime . In some implementations a body can consist of zero to n records rows. The body is part of the message. Since the message is expressed in a relational model the body is able to carry zero to n records rows of a transient persistent table . In some implementations if the row count is zero an empty message is sent. Start table end table and the channel can be typed e.g. if the relational model of the payload is known or untyped e.g. data is represented as a character large object CLOB and or binary large object BLOB . In the illustrated example sender will fill the start table with a text from its application table and the receiver will read from the end table the result of the DIF runtime .

To decouple the sender receiver and the DIF runtime each participant has its own transaction context The sender puts a message on a channel by generating a new message instance and inserting the payload into a start table a ID text combination in our example . The sender then commits its transaction T S to make the new message visible to the DIF runtime left TA boundary in . The DIF runtime employs another transaction T R to process the message. T R removes the message from the start table does the processing and finally writes the result message as result data to the end table the resulting ID bag of words mapping . T R commits the transaction to make the message visible to the receiver right TA boundary in . The receiver takes the message from the channel by removing the payload from the end table and cleaning up entries from the message tables. The receiver then commits its transaction T E . Transactional decoupling among the participants ensures that channel processing does not affect application transactions. The IFC generates stored procedures for Applications A and B associated with sender and receiver respectively to simplify the send receive process and to avoid access to runtime internal tables. These procedures also create remove entries in from message header attachment tables.

The relational database constructs generated by the IFC result in a pipeline that implements message store and forward processing see below . A pipeline represents a message channel and consists of an ordered set of processing functions e.g. filter and mapping relations e.g. routing broadcasting and result sets of those functions. The result sets of a function or relation can be the input to the next function. The sequence of functions and result sets form the message channel. A database pipeline is an IFC generated implementation of a message channel. For its implementation stored procedures and SQL are used for the following two purposes 1 to express execute integration semantics of the iFlow diagram for which the pipeline was generated and 2 to handle the lifecycle of a message see below . The result sets of processing functions or relations can be transient persistent database tables. In some implementations functions and relations are relational algebra operators and produce result sets compliant with a suitable database message format.

Start and end tables and respectively are native persistence points. Messages are moved along the pipeline from one persistence point to the next. An example message lifecycle can be 1 a runtime transaction T reads a message from a persistence point source table and processes the message by executing the functions and relations on the pipeline until the next persistence point target table is reached implemented by a stored procedure purpose P1 in the previous section . Intermediate results can be captured in transient tables e.g. move as in . T stores the result message in a persistent target table e.g. write as in and removes the corresponding message from the persistent source table e.g. read delete as in . T then commits to make the change visible. This is implemented in a lifecycle procedure see purpose 2 above .

Transactional processing ensures that in any point in time a message is stored exactly in one persistence point as seen from an observing transaction T . Transactional processing also ensures the recoverability of the system In flight messages currently in progress on the channel are automatically rolled back to a consistent state to the last persistence point e.g. in the start table in case of a DB crash. EIPs on the channel might define further persistence points e.g. for monitoring that result in persistent channel tables. By default IFC tries to use transient in memory tables for intermediate results to reduce writes to the persistent store as illustrated in .

The IFC makes use of the access control capabilities of the relational database to control access to application and runtime tables. In the provided example Application A sender has access to its own tables and write access to the start table . Application B receiver has access to its own tables and read delete access on the end table . Remaining tables belong to the DIF runtime and neither application A nor application B has access. In some implementations the DIF runtime can be accessed by an IFC administrator.

Since a channel is an abstract construct the IFC has freedom to generate a relational database specific implementation for the channel. The IFC generates code that processes messages in bulk mode for which a database system is the ideal runtime. Furthermore the IFC can create multiple incarnations of the same channel to scale out channel processing if necessary. As will be apparent to those of skill in the art further system relevant characteristics such as stability high availability can be inherited from the relational database .

If a sender application for example Application A needs to send data to a receiver application for example Application B that uses the same relational database system the following steps occur 1 the sender selects the relational data to be sent and inserts the data into a database table 2 a DIF on the relational database system picks up the data from the database table and processes it transformation routing etc. 3 the DIF writes the data into a database table known by the receiver Application B 4 the receiver Application B reads the relational data and inserts the data into its own database tables. All operations are relational database internal. Note that no system boundaries are traversed no data conversion to from XML or other suitable messaging format is required no protocol transformations are necessary and no non relational operations need to be executed.

Configurations C 1 C2 and C 3 illustrate uses of DIF runtimes for integration functionality. In some implementations the use of DIF runtimes can replace or be complementary to existing EAI solutions e.g. MOM systems for particular database intensive database appropriate functionality by removing all or some need for application server based integration functionality.

At relational data from a source table on a database and associated with a sending first application is selected to be sent to a receiving second application. The second application has access to the same database. From method proceeds to .

At the selected relational data is inserted into a database start table on the database. In some implementations the sending application issues a commit operation to make the relational data visible to the database integration flow DIF runtime. From method proceeds to .

At the change to the start table is detected. For example a scheduling application internal and or external to the database can listen to detect the change to the start table. In other implementations a database trigger can be used. In still other implementations a polling application internal and or external to the database could poll the database start table for changes. As will be appreciated by those of skill in the art any suitable detection method may be used to detect the change to the start table. From method proceeds to .

At the relational data inserted into the start table is retrieved. For example the scheduler could issue get operations to retrieve the relational data. In some implementations the retrieved relational data is deleted from the start table once retrieved. The retrieved relational data is passed to the DIF runtime. From method proceeds to .

At The relational data is processed accordingly by the DIF runtime e.g. as illustrated by the splitter aggregator DIF runtime into result data. From method proceeds to .

At the result data is inserted into a database end table for access by the receiving application. In some implementations the DIF runtime issues a commit operation. From method proceeds to .

At the receiving application detects a change in the end table. In some implementations the receiving application can use detection methods similar to that at and or any other suitable method. From method proceeds to .

At the receiving application retrieves the result data from the end table. In some implementations the result data is deleted from the end table once retrieved. From method proceeds to .

At the receiving application inserts the retrieved result data into a target database table associated with the receiving application. After method stops.

At relational data from a source table on a database and associated with a sending first application is selected to be sent to a receiving second application. From method proceeds to

At the selected relational data is inserted into a database start table on the database. In some implementations the sending application issues a commit operation to make the relational data visible to the database integration flow DIF runtime. From method proceeds to

At the change to the start table is detected. For example a scheduling application internal and or external to the database can listen to detect the change to the start table. In other implementations a database trigger can be used. In still other implementations a polling application internal and or external to the database could poll the database start table for changes. As will be appreciated by those of skill in the art any suitable detection method may be used to detect the change to the start table. From method proceeds to

At the relational data inserted into the start table is retrieved. For example the scheduler could issue get operations to retrieve the relational data. In some implementations the retrieved relational data is deleted from the start table once retrieved. The retrieved relational data is passed to the DIF runtime. From method proceeds to

At The relational data is processed accordingly by the DIF runtime e.g. as illustrated by the splitter aggregator DIF runtime into result data. From method proceeds to

At the result data is inserted into a database end table to be sent to the receiving application. In some implementations the DIF runtime issues a commit operation. From method proceeds to

At a change is detected in the end table. In some implementations detection methods similar to that at and or any other suitable method can be used. From method proceeds to

At the result data is retrieved from the end table. In some implementations the result data is deleted from the end table once retrieved. From method proceeds to

At the retrieved relational data is serialized into a generic data exchange GDX format. In other implementations any suitable format structure etc. can be used to package the relational data for transmission. From method proceeds to

At the serialized data is passed to a transmission application e.g. a sending application associated message oriented middleware MOM or enterprise service bus ESB not illustrated in for transmission to the receiving application. From method proceeds to

At the transmission application transmits the serialized data to the receiving application. After method stops.

At serialized data is received by a reception application e.g. a receiving application associated MOM ESB not illustrated in . The received serialized data is deserialized into a relational format by the reception application. From method proceeds to

At the relational data is inserted into a database start table on the receiving application database. In some implementations the reception application issues a commit operation to make the relational data visible to the database integration flow DIF runtime. From method proceeds to

At the change to the start table is detected. For example a scheduling application internal and or external to the database can listen to detect the change to the start table. In other implementations a database trigger can be used. In still other implementations a polling application internal and or external to the database could poll the database start table for changes. As will be appreciated by those of skill in the art any suitable detection method may be used to detect the change to the start table. From method proceeds to

At the relational data inserted into the start table is retrieved. For example the scheduler could issue get operations to retrieve the relational data. In some implementations the retrieved relational data is deleted from the start table once retrieved. The retrieved relational data is passed to the DIF runtime. From method proceeds to

At The relational data is processed accordingly by the DIF runtime e.g. as illustrated by the splitter aggregator DIF runtime into result data. From method proceeds to

At the result data is inserted into a database end table for access by the receiving application. In some implementations the DIF runtime issues a commit operation. From method proceeds to

At the receiving application detects a change in the end table. In some implementations the receiving application can use detection methods similar to that at and or any other suitable method. From method proceeds to

At the receiving application retrieves the result data from the end table. In some implementations the result data is deleted from the end table once retrieved. From method proceeds to

At the receiving application inserts the retrieved result data into a target database table on the receiving application database. After method stops.

At serialized data is received from a first application by a reception application e.g. a MOM ESB not illustrated in . The received serialized data is deserialized into a relational format. From method proceeds to .

At the relational data is inserted into a database start table on the receiving application database. In some implementations the reception application issues a commit operation to make the relational data visible to the database integration flow DIF runtime. From method proceeds to .

At the change to the start table is detected. For example a scheduling application internal and or external to the database can listen to detect the change to the start table. In other implementations a database trigger can be used. In still other implementations a polling application internal and or external to the database could poll the database start table for changes. As will be appreciated by those of skill in the art any suitable detection method may be used to detect the change to the start table. From method proceeds to .

At the relational data inserted into the start table is retrieved. For example the scheduler could issue get operations to retrieve the relational data. In some implementations the retrieved relational data is deleted from the start table once retrieved. The retrieved relational data is passed to the DIF runtime. From method proceeds to .

At the relational data is processed accordingly by the DIF runtime e.g. as illustrated by the splitter aggregator DIF runtime into result data. From method proceeds to .

At the result data is inserted into a database end table for access by the receiving application. In some implementations the DIF runtime issues a commit operation. From method proceeds to .

At the receiving application detects a change in the end table. In some implementations the receiving application can use detection methods similar to that at and or any other suitable method. From method proceeds to .

At the receiving application retrieves the result data from the end table. In some implementations the result data is deleted from the end table once retrieved. From method proceeds to .

At the retrieved relational data is serialized into a generic data exchange GDX format. In other implementations any suitable format structure etc. can be used to package the relational data for transmission. From method proceeds to .

At the serialized data is passed to a transmission application e.g. a MOM ESB not illustrated in for transmission to a second application. From method proceeds to .

At the transmission application transmits the serialized data to the second application. After method stops.

Although the concepts herein have been described primarily in terms of an in memory database the use of in memory database technologies describe only one possible implementation and is not intended to limit the disclosure in any way. Those of skill in the art will appreciate that various non in memory database technologies can be substituted and appropriate changes made to the described technology without deviating from the spirit and scope of the disclosure. The present disclosure is not intended to be limited to the described and or illustrated implementations but is to be accorded the widest scope consistent with the principles and features disclosed herein.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry in tangibly embodied computer software or firmware in computer hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Implementations of the subject matter described in this specification can be implemented as one or more computer programs i.e. one or more modules of computer program instructions encoded on a tangible non transitory computer storage medium for execution by or to control the operation of data processing apparatus. Alternatively or in addition the program instructions can be encoded on an artificially generated propagated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine readable storage device a machine readable storage substrate a random or serial access memory device or a combination of one or more of them.

The term data processing apparatus refers to data processing hardware and encompasses all kinds of apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can also be or further include special purpose logic circuitry e.g. a central processing unit CPU a FPGA field programmable gate array or an ASIC application specific integrated circuit . In some implementations the data processing apparatus and or special purpose logic circuitry may be hardware based and or software based. The apparatus can optionally include code that creates an execution environment for computer programs e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. The present disclosure contemplates the use of data processing apparatuses with or without conventional operating systems for example LINUX UNIX WINDFLOWS MAC OS ANDROID IOS or any other suitable conventional operating system.

A computer program which may also be referred to or described as a program software a software application a module a software module a script or code can be written in any form of programming language including compiled or interpreted languages or declarative or procedural languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program may but need not correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network. While portions of the programs illustrated in the various figures are shown as individual modules that implement the various features and functionality through various objects methods or other processes the programs may instead include a number of sub modules third party services components libraries and such as appropriate. Conversely the features and functionality of various components can be combined into single components as appropriate.

The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. a CPU a FPGA or an ASIC.

Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors both or any other kind of CPU. Generally a CPU will receive instructions and data from a read only memory ROM or a random access memory RAM or both. The essential elements of a computer are a CPU for performing or executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio or video player a game console a global positioning system GPS receiver or a portable storage device e.g. a universal serial bus USB flash drive to name just a few.

Computer readable media transitory or non transitory as appropriate suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM DVD R DVD RAM and DVD ROM disks. The memory may store various objects or data including caches classes frameworks applications backup data jobs web pages web page templates database tables repositories storing business and or dynamic information and any other appropriate information including any parameters variables algorithms instructions rules constraints or references thereto. Additionally the memory may include any other appropriate data such as logs policies security or access data reporting files as well as others. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display or plasma monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse trackball or trackpad by which the user can provide input to the computer. Input may also be provided to the computer using a touchscreen such as a tablet computer surface with pressure sensitivity a multi touch screen using capacitive or electric sensing or other type of touchscreen. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

The term graphical user interface or GUI may be used in the singular or the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interface. Therefore a GUI may represent any graphical user interface including but not limited to a web browser a touch screen or a command line interface CLI that processes information and efficiently presents the information results to the user. In general a GUI may include a plurality of user interface UI elements some or all associated with a web browser such as interactive fields pull down lists and buttons operable by the business suite user. These and other UI elements may be related to or represent the functions of the web browser.

Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of wireline and or wireless digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN a radio access network RAN a metropolitan area network MAN a wide area network WAN Worldwide Interoperability for Microwave Access WIMAX a wireless local area network WLAN using for example 802.11 a b g n and or 802.20 all or a portion of the Internet and or any other communication system or systems at one or more locations. The network may communicate with for example Internet Protocol IP packets Frame Relay frames Asynchronous Transfer Mode ATM cells voice video data and or other suitable information between network addresses.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

In some implementations any or all of the components of the computing system both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer. The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the computing system. The functionality of the various components of the computing system may be accessible for all service consumers via this service layer. Software services provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in extensible markup language XML format or other suitable format. The API and or service layer may be an integral and or a stand alone component in relation to other components of the computing system. Moreover any or all parts of the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module without departing from the scope of this disclosure.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any invention or on the scope of what may be claimed but rather as descriptions of features that may be specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation and or integration of various system modules and components in the implementations described above should not be understood as requiring such separation and or integration in all implementations and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Particular implementations of the subject matter have been described. Other implementations alterations and permutations of the described implementations are within the scope of the following claims as will be apparent to those skilled in the art. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

Accordingly the above description of example implementations does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure.

