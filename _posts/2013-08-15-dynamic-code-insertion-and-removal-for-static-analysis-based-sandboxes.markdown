---

title: Dynamic code insertion and removal for static analysis based sandboxes
abstract: Methods and apparatus for dynamically adding and deleting new code to previously validated application executing in a secured runtime. New code is written to a portion of secured memory not executable by application. New code is validated to ensure it cannot directly call operating system, address memory outside of secured memory, or modify secured memory state. Indirect branch instructions may only target addresses aligned on fixed size boundaries within the secured memory. Validated code is copied to portion of secured memory executable by application in two stage process that ensures partially copied segments cannot be executed. Validated new code can be deleted once all threads reach safe execution point, provided code was previously inserted as unit or contains no internal targets that can be called by code not also being deleted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08997225&OS=08997225&RS=08997225
owner: Google Inc.
number: 08997225
owner_city: Mountain View
owner_country: US
publication_date: 20130815
---
This application is a continuation application of and claims priority to U.S. patent application Ser. No. 12 956 860 which was filed on Nov. 30 2010 and which claims the benefit of U.S. Provisional Application No. 61 266 500 filed Dec. 3 2009 and titled Dynamic Code Insertion and Removal for Static Analysis Based Sandboxes which applications are incorporated here by reference in their entirety.

This application relates in general to computer security. More specifically this application relates to a method and apparatus for dynamically adding and validating untrusted code to previously validated untrusted code and safely executing the dynamically added and previously validated untrusted code.

As an application platform the modern web browser brings together a remarkable combination of resources including seamless access to Internet resources high productivity programming languages such as JavaScript and the richness of the Document Object Model DOM for graphics presentation and user interaction. While these strengths put the browser in the forefront as a target for new application development browser based applications often remain handicapped in the critical dimension of computational performance when compared to native client applications.

Modern web browsers provide various extension mechanisms such as ACTIVEX and NPAPI plug ins to allow native code to be loaded and run in a browser as part of a web application. While such architectures allow browser based applications to achieve the performance characteristics of native applications they do so at expense of allowing the browser based applications to circumvent the security mechanisms otherwise applied to web content. Recent measures such as validating and isolating or sandboxing native client code have allowed native code to be run within a browser in a secure and safe fashion. Such methods have been described for example in the following applications all of which are hereby incorporated by reference in their entirety Method for Validating an Untrusted Native Code Module application Ser. No. 12 117 634 filed May 8 2008 Method for Safely Executing an Untrusted Native Code Module on a Computing Device application Ser. No. 12 117 650 filed May 8 2008 Native Code Module Security for ARM Instruction Set Architectures application Ser. No. 12 621 286 filed Nov. 18 2009 and Native Code Module Security for 64 bit Instruction Set Architectures application Ser. No. 12 621 266 filed on Jul. 31 2009.

The methods and apparatus disclosed in the aforementioned applications including the disclosed code layout rules and static code analysis allow arbitrary and untrusted code to be safely run as a browser application by reliably disassembling the code and generating a control flow supergraph. However once the untrusted code is disassembled and a control flow supergraph is generated no new code may be added. This prohibits many types of code from being safely sandboxed and run as a browser application. In particular many current native applications rely on the use of dynamically linked libraries DLLs or just in time JIT code generation to provide flexibility and coding efficiency. In addition many modern programming languages such as GO JAVA and JAVASCRIPT employ dynamic code generation for the same reasons. Methods that allow the validation and sandboxing of untrusted code that uses DLLs and JIT code generation can further extend the browser s use as a platform to run native applications.

Computer implemented methods and apparatus are disclosed for dynamically inserting a new piece of code into a sandboxed application that is written to a secured memory and executed within a secure runtime environment. An instruction to insert the new piece of code into the sandboxed application is received. The new piece of code is written to a portion of the secured memory that cannot be written to or executed by the sandboxed application. It is then validated and copied to a portion of the secured memory that cannot be written to but that can be executed by the sandboxed application.

When the validated new piece of code is written to a portion of the secured memory it can be written in fixed sized instruction bundles such that no instructions in the instruction bundles span fixed size boundaries within a portion of the secured memory. The portion of the secured memory to which instruction bundles are written can initially contain one or more fixed sized halt instructions. Validated new code can be written to the secured memory in a two stage process in which a tail portion of a new instruction bundle is first written to the secured memory followed by a header portion where the header portion is the size of the halt instruction and the tail portion is the size of the fixed sized instruction bundle less the size of the halt instruction. An instruction to flush changes to the d cache and i cache portions of the secured memory can be executed after writing the tail portion and the header portions of the new code instruction bundles.

Validated new code is not permitted to directly call the operating system modify the state of the secured memory or directly address a memory location that is outside of the secured memory. Branch instructions in the validated new code must target valid addresses. In particular indirect or non statically determinable branch instructions in the sandboxed application must target addresses that are aligned on fixed sized boundaries within the secured memory.

Dynamically added new code can be deleted from the sandboxed application running in the secured memory. An instruction to delete a dynamically added code bundle can be received. The dynamically added code bundle can be safely deleted if it was inserted as a unit into the sandboxed application or if it does not contain an intra bundle address that is a control flow transfer target of an instruction contained in another dynamically inserted instruction bundle unless that instruction bundle will also be deleted. If the dynamically added code bundle can be safely deleted it is deleted after all threads of the sandboxed application reach a secure execution point. After the dynamically added code bundle is safely deleted all threads are permitted to execute beyond the secure execution point.

When a user navigates to a website containing an application written in untrusted code to be run in browser browser loads and executes the application s JavaScript components and the NaCl plug in loads the untrusted code into a NaCl container . The NaCl container is an area of secured memory that exists within the address space of a service runtime . The service runtime is a trusted application that is native to the user s computer and that can communicate with the browser user interface and NaCl through the IMC service. The service runtime provides memory management operations thread creation and destruction and other system level services for the untrusted application that is loaded into NaCl container .

In addition to initializing the trusted text portion of the address space of the NaCl container the service runtime can write the untrusted code s UC instructions to a second or UC text portion of the NaCl container s address space and the UC s data to a third or UC data portion or the NaCl container s address space. Between the UC text and the UC data the service runtime can include a fourth or dynamic text portion that can be used to dynamically add new code to the untrusted code that is initially loaded in the NaCl container . The dynamic text region is a portion of the address space of the NaCl container that the service runtime can use to sandbox or isolate code that is dynamically created by or added to the untrusted application for example through the use of just in time programming or by linking to a dynamically linked library DLL .

When it initializes the trusted text portion UC text portion dynamic text portion and UC data portion of the address space of NaCl container which is within the service runtime s address space the service runtime does so in a way that all machine code instructions are written so they do not overlap fixed byte boundaries. The machine code instructions existing between any two fixed byte boundaries are dubbed instruction bundles and the boundaries themselves are dubbed edges. The service runtime copies machine code to the trusted text portion UC text portion dynamic text portion and UC data portion such that all indirect or non statically determinable targets of machine code branch instructions e.g. goto and switch statements are aligned i.e. begin on the edge of an instruction bundle. An used herein an indirect or non statically determinable target of a machine code branch instruction is a target whose address cannot be determined from data within the machine code instruction itself. By contrast a statically determinable target of a machine code instruction is a target whose address can be determined from data in the machine code instruction. Writing machine code instructions so that the targets of all indirect branch instructions are aligned on the edge of an instruction bundle may require padding portions of the machine code instructions with noop statements or replacing indirect machine code branch instructions with pseudo instructions that are designed to target the edge of an instruction bundle. This is more fully explained in U.S. application Ser. No. 12 117 634 filed May 8 2008 U.S. application Ser. No. 12 117 650 filed May 8 2008 U.S. application Ser. No. 12 621 266 filed Jul. 31 2009 and U.S. application Ser. No. 12 621 286 filed Nov. 18 2009 all of which were previously incorporated by reference. In one implementation the instruction bundles within the address space of the NaCl container are 32 bytes wide. Other instruction bundle sizes are possible however including but not limited to 16 byte 64 byte and 128 byte instruction bundles.

In a number of instruction bundles are shown in the dynamic text portion of the NaCl container . While not explicitly shown in the instruction for trampoline in trusted text portion begins on the edge of a first instruction bundle while the instruction for trampoline begins on the edge of a third instruction bundle. The untrusted code may not call the springboard which returns control to the untrusted code and may only call the trampolines and at the edge of their respective instruction bundles. To ensure security the untrusted code may not call or address the middle of the instruction bundles for trampolines or or for springboard . In one implementation the first 64 K bytes of memory in the address space of the NaCl container is not used and the edge or first byte of the first instruction bundle occurs at byte 64K of NaCl container . This implementation is useful for detecting NULL pointer dereference bugs. And as noted above in 64 bit x86 and ARM architectures springboard may be present but is not needed.

When the service runtime creates the UC text portion and the UC data portion of the NaCl container it first analyzes the untrusted code before it allows it to be executed. The analysis that is performed is more fully set forth in U.S. application Ser. No. 12 117 634 filed May 8 2008 U.S. application Ser. No. 12 117 650 filed May 8 2008 U.S. application Ser. No. 12 621 266 filed Jul. 31 2009 and U.S. application Ser. No. 12 621 286 filed Nov. 18 2009 all of which were previously incorporated by reference. Briefly the service runtime uses static code analysis to detect security threats in the untrusted code. A set of alignment and structural rules are applied to the data and code that is contained in the trusted text portion UC text portion dynamic text portion and UC data portion of the NaCl container to allow the machine code to be reliably disassembled and analyzed. The alignment and structural rules require that a the trusted text portion begins at address 64K in the NaCl container and ends at an address that is an integral multiple of the fixed size instruction bundles b the UC text portion begins immediately after the trusted text portion ends at an address that is an integral multiple of the fixed size instruction bundles and is not writable once it is loaded c all indirect or non statically determinable control transfers from the untrusted code use a NaCl jump pseudo instruction that ensures that the target of the control transfer begins on the edge of an instruction bundle d the machine code is padded up to the nearest page in memory with halt instructions e the untrusted code contains no instructions or pseudo instructions that straddle the edge of a fixed size instruction bundle i.e. that are written across two or more instruction bundles f all valid instruction addresses can be reached by a fall through disassembly beginning with the address of the UC text portion and g all direct or statically determinable control transfers target valid instructions. As used herein a halt instruction is any instruction that will generate a fault and that is no larger than the fixed sized instruction bundles.

With the implementation of these structural and alignment rules a validator module within the service runtime can check the untrusted code to ensure that i no data is directly loaded from or stored outside the sandboxed memory space of the Native Client container ii no unsafe instructions are called and iii the control flow for the untrusted code safely targets only valid instruction addresses within the memory space of the Native Client container including the addresses for the service runtime trampolines and springboards if any which as explained above begin on the edges of instruction bundles. The types of unsafe instructions in the untrusted code that are disallowed can include for example instructions that directly call the operating system and instructions that could modify the memory state of the NaCl container or the service runtime . All indirect or non statically determinable branch instructions within the untrusted code must be implemented or replaced with pseudo instructions that ensure that the targets of the branch instructions begin on the edges of a fixed sized instruction bundles. For a given indirect branch instruction this is achieved by applying a mask to the native code address of the branch instruction and jumping to the masked address. Further information on the types of unsafe instructions that are disallowed in the untrusted code and on the methods used to mask native code addresses and jump to the masked addresses can be found in U.S. application Ser. No. 12 117 634 filed May 8 2008 U.S. application Ser. No. 12 117 650 filed May 8 2008 U.S. application Ser. No. 12 621 266 filed Jul. 31 2009 and U.S. application Ser. No. 12 621 286 filed Nov. 18 2009 all of which were previously incorporated by reference.

When the service runtime creates and initializes the dynamic text portion of the NaCl container it does so by writing an integer number of fixed sized instruction bundles onto the dynamic text portion such as bundles shown in where each instruction bundle contains one or more halt instructions. As previously noted a halt instruction is used herein to identify any instruction in any computer architecture that will generate a fault or otherwise reliably cause untrusted code running in the NaCl container to abort should it attempt to interpret and execute data in the dynamic text portion that has not been validated. For example in x86 implementations the halt instruction may be an HLT instruction that immediately stops the CPU from executing further instructions. In general the size of the halt instruction will be less than the size of the instruction bundle and the instruction bundle will contain a plurality of halt instructions not shown . The halt instruction is initially written to the dynamic text portion of the NaCl container to prevent the inadvertent interpretation and execution of any data that may be in the dynamic text portion . is a flowchart illustrating a method for dynamically inserting new code into untrusted code that has previously been validated and sandboxed in a Native Client container. As discussed above many native applications rely on the ability to generate or link to new code during runtime to increase their flexibility or coding efficiency. Examples include applications that rely on dynamically linked libraries DLLs and applications that create just in time JIT code i.e. code that is generated at runtime but only if and when it is needed . The method allows such applications to be safely run as browser applications by allowing the new code to be added to the already validated application code that is sandboxed in a Native Client container.

As shown in when a thread of the previously validated but untrusted application wants to insert new code into the application it sends a request to the service runtime . The service runtime receives the request . In one implementation the request to insert new code is received at a trampoline e.g. trampoline in the trusted text portion of the NaCl container and includes a pointer to the new code the untrusted application wishes to insert and an address in the dynamic text portion of the NaCl container where the new code should be inserted. The service runtime retrieves the new code and writes it to an area of memory that is neither executable by nor write accessible to the untrusted application . The area of memory can be for example an area that is outside the address space of the NaCl container but within the address space of service runtime . This prevents the untrusted application from changing the new code while it is being validated by the service runtime .

In one implementation when writing the new code to the area of memory that is not write accessible to or executable by the untrusted application the service runtime applies the same set of alignment and structural rules that were originally applied to the untrusted application code as explained more fully above. These include writing the new code so that no instructions overlap the boundaries of fixed sized instruction bundles and so that all indirect or non statically determinable branch instructions target the edge of instruction bundles. This is done to allow the new code to be easily and reliably disassembled and analyzed. In other implementations the service runtime need not apply these structural and alignment rules when writing the new code to the area of memory that is not write accessible to or executable by the untrusted application. While the new code can still be validated in these other implementations it requires the service runtime to validate the code as if it were written in a way that did in fact apply the alignment and structure rules originally applied to the untrusted application code written to the UC text region . Once the new code is written to an area of memory that is neither executable by nor write accessible to the untrusted application the service runtime tries to validate the new code . If the validation is not successful no branch the service runtime rejects the new code . If the validation is successful yes branch however the service runtime copies the new code to an area of the dynamic text portion that is executable by but not write accessible to the untrusted application . For example in one implementation the service runtime copies the new code to the address in the dynamic text region that was requested by the untrusted application. The new code is copied into the dynamic text region in a two stage process explained below in reference to that ensures that no partially copied code is accessible to or executable by the untrusted application.

The validation process that the service runtime runs on the new code is nearly identical to the validation process discussed above that the service runtime performed on the untrusted application code when it was first loaded into the NaCl container . The same set of alignment and structural rules are applied to the new code to ensure it can be reliably disassembled as explained above. The same validation rules are also applied namely that i no data is directly loaded from or stored outside of the address space of the Native Client container ii no unsafe instructions as defined above are called and iii the control flow for the new code safely targets only valid instruction addresses within the address space of the Native Client container . To ensure the safe targeting of instruction addresses within the Native Client container all indirect or non statically determinable branch instructions within the new code are replaced with NaCl jump pseudo instructions. This ensures that the targets of the branch instructions lie on the edges of fixed sized instruction bundles within the address space of the NaCl container .

In addition the validation process allows the new code to make any statically determinable jump or branch to an address that targets the middle of a new code instruction bundle. In one implementation the validation process prohibits the new code from making a statically determinable jump or branch to an address that targets the middle of an instruction bundle of previously validated code whether that code was the initial untrusted application code or dynamic code that had previously been validated and added to the initial untrusted application code. In an alternative implementation the validation process allows the new code to make some statically determinable jumps or branches to addresses that target the middle of an instruction bundle of previously validated code. This is explained more fully below in reference to .

As shown in before the service runtime copies the new code segment into the dynamic text portion it first segments the new code segment into a plurality of fixed sized instruction bundles each of which corresponds to a respective fixed sized instruction bundle in the dynamic text portion e.g. instruction bundles . Further the service runtime segments each fixed sized instruction bundle into a header portion and a tail portion which respectively correspond with the header portion and tail portion of the instruction bundles in dynamic text portion .

As shown in once the service runtime segments the new code segment into a plurality of fixed sized instruction bundles each of which is further segmented into a header portion and a tail portion it copies the tail portion of each of the fixed sized instruction bundles into the tail portion of the corresponding instruction bundles in dynamic text region . Each of the instruction bundles in the dynamic text region now consist of a header portion that contains a halt instruction and a tail portion that contains the tail portion of a corresponding fixed sized instruction bundle of the new code segment . In one implementation if the last instruction bundle e.g. instruction bundle of the new code segment is smaller than its corresponding instruction bundle in the dynamic text region either the end of instruction bundle is padded with halt instructions before being copied to instruction bundle or the space remaining in instruction bundle after instruction bundle is copied into it is padded with halt instructions as shown.

As shown in in the second phase of the copy operation the service runtime copies the header portion of each of the instruction bundles of the new code segment into the header portion of the corresponding instruction bundles in dynamic text region . This overwrites the halt instructions in the header portions of the instruction bundles in the dynamic text region . At this point the entire validated new code segment has been copied into the dynamic text region and is available to and becomes part of the sandboxed untrusted application code in the NaCl container .

When the service runtime has copied the fixed size instruction bundles into the instruction bundles in dynamic text region the changes made to the data cache d cache of the processor that is executing the service runtime are flushed i.e. written to memory RAM . This causes the processor s instruction cache i cache to be first invalidated and then updated to store the instructions contained in the newly written instruction bundles . In some implementations the instructions stored in the i cache are invalidated via explicit command. In other implementations employing snoopy caches the i cache automatically notices the changes that are made to the d cache when the service runtime writes the fixed sized instruction bundles to the d cache. In these implementations the i cache can invalidate the currently stored instructions and obtain updated instructions that include the instructions contained in the dynamically generated and validated fixed sized instruction bundles .

The two phase copy operation disclosed in is performed to prevent a thread of the untrusted application from loading and executing instructions in a partially written instruction bundle from the dynamic text region e.g. by snooping the d cache before the entire instruction bundle is written and automatically transferring the snooped changes from d cache to i cache . Since all partially written instruction bundles begin with a halt command any thread of the untrusted application that attempts to load and execute an instruction from a partially written instruction bundle will be immediately terminated.

When the service runtime receives a request from an application thread to delete a block of code it checks whether the block of code to be deleted lies entirely within the dynamic text portion of the NaCl container . This ensures that only application code that has been dynamically inserted into the NaCl container as explained above can be deleted from the container. If the service runtime determines that some or all of the block of code to be deleted has been loaded to a memory location that is outside of the dynamic text portion of the NaCl container the service runtime denies the request to delete the block of code and returns execution to the application thread that called it. If the service runtime determines that the block of code to be deleted exists entirely within the dynamic text portion of the NaCl container it then determines if the block of code was previously inserted as an atomic unit i.e. as a whole block of code . If the service runtime determines that the block of code was previously inserted as an atomic unit it accepts the request to delete the block of code . If however the service runtime determines that the block of code was not previously inserted as an atomic unit it determines whether the block of code contains any internal addresses that are targeted i.e. called by any untrusted application code that is not also being deleted . If it does the service runtime again denies the request to delete the block of code and returns execution to the application thread that called it. If however the service runtime determines that the block of code does not contain any internal addresses that are targeted by untrusted application code that is not also being deleted it accepts the request to delete the block of code .

Once the service runtime accepts the request to delete the block of code it waits until all currently executing application threads suspend execution or enter a safe execution mode . As used herein a safe execution mode is an execution mode in which the untrusted code executes a limited set of instructions that do not call or try to execute any of the dynamically added code. This is done to ensure that no currently executing application threads call any of the code that is about to be deleted. In one implementation application threads can enter safe execution mode by calling a trampoline or to the service runtime . In this implementation the service runtime can determine that all application threads have entered safe execution mode by counting the number of threads that call the trampoline or and comparing that count to the total number of application threads. In another implementation application threads can enter safe execution mode by setting a safe execution flag and executing a limited set of instructions that do not call any dynamically inserted code. In this implementation the service runtime can determine that all application threads are in safe execution mode by counting the number of threads that have set the safe execution flag and comparing that count to the total number of threads.

Once the service runtime determines that all of the executing threads have either suspended execution or entered a safe execution mode it writes one or more halt instructions over the entire block of code to be deleted . It then returns control to the application thread that requested the deletion of the block of code returns execution control to those application threads that had suspended execution and signals application threads that had entered safe execution mode that they can exit safe execution mode . This can be done for example by calling a springboard to those application threads that had suspended their execution by calling a trampoline to the service runtime or by clearing a safe execution flag that had been set by those application threads that entered a safe execution mode. It should be noted that upon resuming execution or exiting safe execution mode some of the application threads may call the block of code that has just been deleted. If they do they will execute the halt instruction that the service runtime wrote over the deleted block of code causing the CPU to immediately halt execution. Thus while this method of deletion ensures the safe execution of the untrusted application code it does not ensure the correct execution of the code.

In the methods and apparatus described above untrusted new code was permitted to be added to a memory container containing a previously validated but untrusted application by applying certain structural and alignment rules to both the previously validated untrusted application code and the new code to be inserted. This permitted the untrusted application code and new code to be reliably disassembled. In other implementations the complexity of applying such structural and alignment rules can be avoided by writing the untrusted application and new code to memory pages that are interpreted and understood by the operating system rather than to aligned instruction bundles within the NaCl container that are interpreted and understood by the service runtime . In this implementation the service runtime can write untrusted application code or new code to non executable memory pages before attempting to validate the code. If the service runtime subsequently validates the code it can set the execution bits of the memory page to allow the code to be executed and can map the page to a location within the dynamic text region that is readable and executable by the untrusted code but that cannot be written to by the untrusted code. When code is to be deleted the service runtime can first wait for all running threads to suspend execution or enter a safe execution mode as explained above then clear the execution bits of the memory page on which the code is written to safely delete the code and prevent its further execution by the untrusted application. Alternatively the memory page can be overwritten with halt instructions.

Implementations of the various techniques described herein may be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Implementations may implemented as a computer program product i.e. as a computer program tangibly embodied in a machine readable storage device for execution by or to control the operation of a data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program such as the computer program s described above can be written in any form of programming language including compiled or interpreted languages and can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communications network.

Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method steps also may be performed by and an apparatus may be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer may also include or be operatively coupled to receive data from and or transfer data to one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory may be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations may be implemented on a computer having a display device e.g. a cathode ray tube CRT or liquid crystal display LCD monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Implementations may be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation or any combination of such back end middleware or front end components. Components may be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

While certain features of the described implementations have been illustrated as described herein many modifications substitutions changes and equivalents will now occur to those skilled in the art. It is therefore to be understood that the appended claims are intended to cover all such modifications and changes as fall within the scope of the embodiments.

