---

title: Method and system for specifying and enforcing extensibility of software applications
abstract: The method includes generating at least one base object, and generating at least one extendable object associated with the base object, the extendable object defining an insertion point and is configured to enable addition of new functionalities to an application including the at least one base object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09311054&OS=09311054&RS=09311054
owner: SAP SE
number: 09311054
owner_city: Walldorf
owner_country: DE
publication_date: 20130830
---
Extensibility is generally a requirement in modern software applications. In the context of business applications extensibility is a common selection criteria from a customer perspective. Therefore software providers seek to provide support for extensibility to meet customer needs. However there are some challenges that face software developers with respect to the specification and enforcement of extension possibilities of their software. The term extension interface typically refers to the extension possibilities offered by a software application. More specifically an extension interface defines the resources of a base application that are allowed to be extended how the software application is extended e.g. on the programming level what resources of the base application an extension developer and or extension object is allowed to access as well as where and when the extension code will run.

While concepts for such interfaces are a considered with regard to traditional software which is constructed using a single programming language. However extension interfaces are completely missing for complex applications consisting of several abstraction or architectural layers. In addition state of the art approaches are limited with respect to the specification of extension interfaces. Further extension interfaces do not support providing different extension interfaces for different stakeholders. Furthermore the software provider has to manually provide the code that is responsible for providing an extension interface. This code is typically mixed with the functional code of the application which limits the quality of the software and makes software maintenance difficult.

Accordingly typical approaches for specifying and enforcing extension interfaces for software systems have at least the following problems. First typical approaches provide a one size fits all extension interface. In typical approaches specifying different extension interfaces for different groups of extension developers and or extension objects is typically not possible. Second typical approaches do not support the multi layered nature of software applications which involve multiple layers and multiple artifacts on these layers e.g. UI models business process models code artifacts database tables etc. . All existing approaches express extension possibilities on the technical code layer although an extension typically spans several layers. As a result an extension developer and or extension object cannot assess the feasibility of a simple UI form extension or a business process extension without diving deeply into the implementation layer and going through documentation materials and tutorials for some provided Application Programming Interface API .

Third typical approaches lack declarative means to specify the allowed extension possibilities and their types for the different artifacts of the base application e.g. new methods attributes UI elements process artifacts new columns in a database table and the like . Fourth when supporting extensibility on different layers it is necessary to capture the dependencies between the extension possibilities available on these layers. In fact tools are needed to express dependencies such as if the extension developer and or extension object adds a new field of some UI form then the extension developer and or extension object also needs to extend the respective Java class with a new attribute and the respective database table with a new column. The inter layer dependencies impose constraints on the way extension possibilities are expressed and also on the way an extension is developed.

Fifth typical approaches lack tools to specify how to extend e.g. on the programming level the base software. Sixth existing approaches lack tools to express what artifacts or data of the core software can be accessed by the extension developer and or extension object and the respective access rights e.g. giving access to limiting access to and or preventing access to software assets . This covers for example the definition of class attributes of the core software application that are visible to the extension developer and or extension object as well as methods that can be called by the extension developer and or extension object when writing code for an extension. Finally typical approaches do not specify when and where the extension code will be run e.g. if the extension code be executed before or after some method of the base application .

Some approaches manually implement an extension interface through coding without specifying such interface explicitly. For example the software provider can decide the interfaces or abstract classes for use as entry points for the extension developer and or extension object. However the support e.g. loading and executing the code implementing these extension artifacts may be manually implemented by the software provider. In this way the technical realization of the extension interface gets coupled with the functional code of the base software. This manual approach increases the application complexity and makes software maintenance more difficult. As a result the extensibility rationale intents and decisions taken by the application provider get lost.

Further in this manual approach the extension interfaces are not explicit in definition. As a result the software provider may have difficulty e.g. without a comprehensive and up to date documentation finding the exact methods classes and interfaces that make up the extension interface. In addition an extension developer will have a hard time identifying the extension interface and the extension possibilities as they are not expressed explicitly. Instead the extension developer will have to read documentation and tutorials and to understand the whole provided APIs to assess the feasibility of some extension scenario. This gets even more difficult as the functional API of the application and its extensibility API are mixed.

Accordingly there is a need to address the aforementioned problems by introducing a system and a method for specifying and enforcing extension interfaces in multilayered software applications.

One embodiment includes a method. The method includes generating at least one base object and generating at least one extendable object associated with the base object the extendable object defining an insertion point and is configured to enable addition of new functionalities to an application including the at least one base object.

Another embodiment includes a non transitory computer readable storage medium. The non transitory computer readable storage medium having stored thereon computer executable program code which when executed on a computer system causes the computer system to generate at least one base object and generate at least one extendable object associated with the base object the extendable object defining an insertion point and is configured to enable addition of new functionalities to an application including the at least one base object.

It should be noted that these Figures are intended to illustrate the general characteristics of methods structure and or materials utilized in certain example embodiments and to supplement the written description provided below. These drawings are not however to scale and may not precisely reflect the precise structural or performance characteristics of any given embodiment and should not be interpreted as defining or limiting the range of values or properties encompassed by example embodiments. For example the positioning of structural elements may be reduced or exaggerated for clarity. The use of similar or identical reference numbers in the various drawings is intended to indicate the presence of a similar or identical element or feature.

While example embodiments may include various modifications and alternative forms embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood however that there is no intent to limit example embodiments to the particular forms disclosed but on the contrary example embodiments are to cover all modifications equivalents and alternatives falling within the scope of the claims. Like numbers refer to like elements throughout the description of the figures.

For example the method steps may be performed by an application specific integrated circuit or ASIC. For example the ASIC may be configured as one or more of the blocks or elements of the blocks e.g. the extendable object development module described below and or the system . Although the steps described below are described as being executed by a processor the steps are not necessarily executed by a same processor. In other words at least one processor may execute the steps described below with regard to .

As shown in in step S a processor e.g. at least one processor generates base object s or at least one base object. Base objects may be associated with or included in an application e.g. software application configured to support a set of standard processes e.g. core functionality or primary functions of the application . For example base objects may be associated with applications e.g. software applications targeted for a large scale and a wide range of customers such as business applications and may be configured to support a set of standard business processes e.g. sales order processing recruitment and the like . The base objects may be generated e.g. by a software provider in an integrated development environment IDE e.g. Oracle JDeveloper NetBeans Microsoft Visual Studio and the like using a programming language e.g. C visual basic Java and the like .

The IDE may implement some form of Aspect Oriented Programming AOP . AOP complements object oriented programming by facilitating another type of modularity that pulls together the widespread implementation of a crosscutting concern into a single unit. These units are termed aspects. The base objects may be objects that can not or should not be extended e.g. add new functions . In other words the base object is an object that is not configured to include extendable functionality. For example in a sales order processing application or process the base objects may include functions associated with taxes e.g. tax calculations that should not be modified.

In step S the processor generates extendable object s or at least one extendable object associated with the base objects. For example extendable objects may enable the addition of new functionalities to the base objects e.g. as a software system to support new requirements. For example in a sales order processing application or process the base objects may be extended to allow for approval of sales orders. The extendable objects may include insertion points. For example a function e.g. subroutine may be extended by adding code following the execution of the function. The extendable objects may be generated e.g. by a software provider in an IDE. The IDE may be a same IDE as used for the base objects. Alternatively or in addition to the IDE may be a different IDE as used for the base objects.

In an example implementation the extendable object may be marked for define or include an insertion point at least one of before a function after a function and or between a first and a second function. For example in a sales order processing application or process the base objects may include an add new order function and a new order confirmed function. The sales order processing application or process may be extended by adding an extendable object. The extendable object may be marked for define or include an insertion point between the add new order function and the new order confirmed function. Therefore if a sales order approval extension is desired code may be generated for a sales order approval routine and added at the insertion point between the add new order function and the new order confirmed function. However example embodiments are not limited thereto. For example a user interface UI insertion point may be defined and or included.

In an example implementation the extendable objects may include at least one control constraint. The control constraint may include attribute constraint s or at least one attribute constraint. For example an access to an attribute e.g. variable object function data structure and the like may be limited e.g. giving access to limiting access to and or preventing access to software assets . The access to an attribute may be group limited e.g. by administrator user group of users e.g. managers third party developers and the like . For example attributes may be read write read only public private and the like. Therefore if a sales order approval extension is desired access to one or more attributes may be allowed or restricted. For example the aforementioned sales order approval routine may only have access to a sales order number as a read only variable. However example embodiments are not limited thereto. For example visibility and access rights to classes methods and or the like may be limited through the use of a control constraint.

Example embodiments may generate define the available extension points on for example different architectural layers of a base or core application control the access and visibility of the base application including the base object s to the extension constrains the interplay between extension points across for example different layers. One or more extension interfaces may be overlaid over the same base application. As a result multiple extension developer and or extension object views may co exist. Further a software provider may generate e.g. automatically generate the code and artifacts to provide and enforce the extension interface. Alternatively or in addition to the software provider may provide a manual implementation of the extension interface.

According to example embodiments an artifact may be the result of any activity in the software life cycle such as a requirement an architecture model a design specification source code and test scripts. An artifact may also include a piece of information that is used or produced by a software development process. In addition an artifact can be a model a description or software.

In a typical business software application the software provider does not give the source code of an application to stakeholders e.g. customers or partners that may desire to develop extensions. However the software provider may provide extension developers access to artifacts such as API libraries frameworks and the like as well as documentation tutorials and other materials to help an extension developer understand what extension possibilities exist and how to develop and integrate extensions. The extensions are likely to interact with the core software e.g. access internal data resources and may affect the main execution stream. In the case of business applications especially those that implement strict legal regulations e.g. with respect to tax calculations controlling extensibility is desirable if not necessary. For example controlling extensibility may be necessary to prevent undesirable system behavior data inconsistencies and restrict access of extension developers and or extension objects to sensitive system information.

According to example embodiments two perspectives with regard to extensibility should be considered. The two perspectives are from the software provider perspective and from the extension developer perspective. For example from the perspective of the software provider an application typically consists of several logical layers e.g. user interface UI business process business object database etc. containing many artifacts that may be made extensible for the extension developer. However in the context of complex software applications a software provider may have several extension developer groups that can build extensions for the base software application. For example the groups may include internal development teams in the same company that build a solution for a particular industry on top of a standard application an external partner company e.g. third party that specializes in extending the standard software to support the needs of some domain and or the IT department of a customer organization that extends a standard software to cover their specific needs.

The software provider and the extension developer may require appropriate tools to express the extension interface. These tools for specifying extension interfaces should support the following constraints or requirements 

R1 Multiple Extension interfaces the software provider should be able to specify multiple extension interfaces for the same base software application 

R2 Extensible artifacts on multiple layers specifying the available extension possibilities on the different layers of the core application e.g. extension possibilities in UI forms business process models database tables etc. should be possible 

R3 Extension possibilities specifying the types of extensions that are allowed on the application artifacts e.g. new methods attributes UI elements process artifacts columns in a database table etc. should be possible 

R4 Extension interdependencies specifying the relationships and constraints that exist between extension possibilities from different extensible artifacts should be possible 

R5 Extension method specifying the required coding or configuration elements and how to extend these artifacts e.g. inheritance plug ins etc. should be possible 

R6 Extension control specifying the resources of the base application that are available for the extension code e.g. variables methods etc. as well as their access rights and usage rules should be possible and or

R7 Extension integration and execution specifying when and where the extension code may run should be possible.

The constraints e.g. R1 R7 should be specified as part of the extension interface. The extension developer on the other hand should understand the extension interface of the base software as well as correct usage of the extension interface to successfully develop and integrate an extension with the base software application.

Accordingly example embodiments include a system configured to specify and enforce extension interfaces in multi layered applications. The system may include modules software and or hardware providing a tool and a language for defining extension interfaces supporting different groups of extension developers and a tool for enforcing extension interfaces through automatic code generation based on one or more strategies.

In the example of the system may be at least one computing device and should be understood to represent virtually any computing device configured to perform the methods described herein. As such the system may be understood to include various standard components which may be utilized to implement the techniques described herein or different or future versions thereof. By way of example the system is illustrated as including the at least one processor as well as the at least one memory e.g. a non transitory computer readable storage medium respectively.

Thus as may be appreciated the at least one processor may be utilized to execute instructions stored on the at least one memory so as to thereby implement the various features and functions described herein or additional or alternative features and functions. Of course the at least one processor and the at least one memory may be utilized for various other purposes. In particular it may be appreciated that the at least one memory may be understood to represent an example of various types of memory and related hardware and software which might be used to implement any one of the modules described herein. Systems and or methods described below may include data and or storage elements. The data and or storage elements e.g. data base tables may be stored in for example the at least one memory .

As shown in the at least one memory includes an application development module an extension object development module a code storage module and a combiner module . The application development module includes a base object development module and an extendable object development module .

The application development module may be configured to generate base objects and extendable objects. The base objects and the extendable objects may be generated e.g. by a software provider using an IDE. Therefore the application development module may include and or be associated with an IDE.

The base object development module may be configured to generate base objects. For example base objects may be associated with applications e.g. software applications targeted for a large scale and a wide range of customers such as business applications and may be configured to support a set of standard business processes e.g. sales order processing recruitment and the like . The base objects may be objects that can not or should not be extended e.g. add new functions . For example in a sales order processing application or process the base objects may include functions associated with taxes e.g. tax calculations that should not be modified.

The extendable object development module may be configured to generate extendable objects associated with the base objects. For example extendable objects may enable the addition of new functionalities to the base objects e.g. as a software system to support new requirements. For example in a sales order processing application or process the base objects may be extended to allow for approval of sales orders. The extendable objects may include insertion points. For example a function e.g. subroutine may be extended by adding code following or preceding the execution of the function. The extendable objects may be generated e.g. by a software provider in an IDE.

For example in a sales order processing application or process the base objects may include an add new order function and a new order confirmed function. The sales order processing application or process may be extended by adding an extendable object. The extendable object may be marked for define and or include an insertion point between the add new order function and the new order confirmed function.

In an example implementation the extendable objects may include a control constraint s . Control constraint s may include attribute constraint s . For example an access to an attribute e.g. variable object function data structure and the like may be limited. The access to an attribute may be group limited e.g. by administrator user group of users e.g. managers third party developers and the like . For example attributes may be read write read only public private and the like. Therefore if a sales order approval extension is desired access to one or more attributes may be allowed or restricted. However example embodiments are not limited thereto. For example visibility and access rights to classes methods and or the like may be limited through the use of a control constraint.

The extension object development module may be configured to read an extendable object and show e.g. on a display associated with system all or substantially all of the insertion points associated with the extendable object. The extension object development module may be configured to read an extendable object and show all or substantially all of the attribute constraints. In other words the extension object development module may be configured to generate a list based on the at least one extension object. The list may include the associated insertion point and the associated at least one attribute constraint. The list may be displayed on for example a display associated with system . The extension object development module may be configured to show the insertion points e.g. as a list of insertion points and the attribute constraints as a list of attribute constraints together and or separately. The extension object development module may be configured to show the constraint associated with an attribute. For example the extension object development module may be configured to show an attribute as read write read only public private and the like.

The extension object development module may be configured to provide an interface to add code as an extension of an object. Alternatively or in addition to the extension object development module may include an IDE configured to generate and or modify code as an extension of an object or extension object . In other words the extension object development module may be configured to generate at least one extension object based on at least one extendable object in order to extend at least one function of the application. Accordingly continuing the above example if a sales order approval extension is desired code may be generated and or added for a sales order approval routine and added at the insertion point between the add new order function and the new order confirmed function.

The code storage module may be configured to store code associated with the base object development module the extendable object development module and or the extension object development module . For example the code storage module may be configured to store code e.g. source code associated with the base object development module the extendable object development module and or the extension object development module . Further the code storage module may be configured to store source code after a combination operation performed by the combiner module . Still further the code storage module may be configured to store executable code generated by a compiler not shown following the generation of an executable using the source code after a combination operation performed by the combiner module .

The combiner module may be configured to combine code e.g. source code associated with the base object the extendable object and the extension object. For example the combiner module may read code generated by the base object development module the extendable object development module and or the extension object development module and generate combined code. The combined code may become the source code that may be compiled as customized e.g. customer specific executable code for use by an end user customer.

Accordingly example embodiments include a system and method to specify and enforce extension interfaces in multi layered applications. The method may include defining an extension interface either separately or as part of the core software application defining different extension interfaces for different kinds of extension objects for one software application defining interdependent extension possibilities on artifacts from the same layer or from different layers of an application controlling the access and usage permissions of extension developers and or extension objects to the artifacts of the base software application and manually implementing or automatically generating code and or configuration artifacts to support and enforce the extension interface based on different strategies.

The source binary code of the software system block may be for example the code e.g. source code generated by the base object development module . The source binary code of the software system block may be for example the code e.g. source code stored in the code storage module . The extendable object development module may read the source binary code from the source binary code of the software system block as part of an initialization step for generating extension interface definitions.

The extension interface definition tool may be configured to generate and or define an extension interface . The extension interface definition tool may be configured to generate define different extension interfaces for different kinds of extension objects. For example the extension interface can include the definition of the application layers the extensibility relevant artifacts the extension possibilities that are offered on those artifacts the inter dependencies that exist between these extension points and the access and usage rights of the extension developer and or extension object to the artifacts of the base software system for each extension possibility. Further the extension interface may also specify the extension methods to be used and information about where and when the extension code will be executed.

The generation definition of the extension interface can be separate from the base or core software system e.g. using a textual language . Alternatively or in addition to the generation definition of the extension interface can be part of the base or core software system source code e.g. using comments or annotations in the source code . The extension interface definition tool may also validates the extension interface definition.

The definition of the extension interface may be done using a code editor associated with the extension interface definition tool . Further the extension interface definition tool may generate the definition of the extension interface separately from the generating the source code of the base or core application e.g. using the base object development module . For example using the extension interface definition tool e.g. as a software editor a software provider can define and generate the extension interface such that the extension interface supports a set of criteria or requirements e.g. R1 R7 described above . In the extension interface the software provider can specify the provided extension possibilities interdependencies supported extension types and control constraints that are offered by the base software. One or more extension interfaces can be defined for a software system.

The extension interface enforcement tool takes as inputs the defined extension interface s and the source code of the base software e.g. from the source binary code of the software system block and the extension interface enforcement tool generates the necessary code to provide those extension interfaces based on different strategies such as aspect oriented programming and design patterns . Using the extension interface an extension developer can identify the available extension possibilities and use the extension interface as a guide to identify the right coding elements generated by the extension interface enforcement tool to develop an extension.

The extension interface enforcement tool generates the source binary code of the software system complemented with support for extensibility block based on the extension interface s and the source binary code of the software system block .

Within an extension interface several layers e.g. application layers can be defined corresponding to the architectural layers of the base application. Each layer consists of one or more extensible artifacts that are made available to an extension developer and or extension object. For example each extension interface may declare the base code artifacts that are extensible e.g. classes methods components etc. . According to example embodiments extension possibilities within each artifact may be declared through an extension point. Extension artifacts may be viewed as containers of extension points. Each extension point may have a type and a set of parameters. The set of parameters may specify the base class artifacts to generate the appropriate extension interface. As a result example embodiments may declare extension possibilities as first class entities and hence explicitly express extension possibilities.

Listing 1 below is an example extension interface for a business object layer of a business application. The extension interface declares the SalesQuote business object as an extensible artifact with the extension point EXP1 of type afterMethodCall that allows the extension developer and or extension object to insert custom logic after the execution of the sendToApproval method.

Extension points can be further grouped within the same or a different layer via for example extension point groups. A group of extension points implies that the extension possibilities offered by these extension points are related. Groups may be used with or without control constraints. Control constraints on extensible artifacts and extension points may restrict the access visibility and or usage of the base application artifacts by the extension developers and or extension objects. The purpose of control constraints is to provide a fine grained access control of the extensions to the core application resources. For example the example in Listing 1 shows a control constraint for EXP1 in the form of a permission set or at least one usage permission that allows the extension developer and or extension object a READ access to the total attribute and hides all methods of the class from the extension developer and or extension object.

The control constraints may also be defined on a group to control how an extension realizing the member extension points within a group should be implemented. In extension scenarios where an extension spans several layers e.g. UI and business object a valid extension may require the implementation of several extension points from the same or multiple layers.

As an example the following describes extensions for business applications including three logical layers e.g. a business process layer a business object layer and a UI layer although example embodiments are not limited thereto. Listings including classes are shown as implemented in Java. However example embodiments are not limited thereto. The example presents example constructs that can exist in business applications e.g. the extensible artifacts extension point types and the like . However example embodiments are not limited thereto. For example in other possible constructs may be implemented in other multilayered application domains.

On the business object layer the following types may be supported. AfterConstructor may enable the definition of extension specific logic to be executed after the constructor of a business object. BeforeMethodCall and AfterMethodCall enable the definition of extension specific logic before or after a certain method is called. AfterBOAttributeChange enables the definition of extension specific logic to be executed after the value of a certain business object attribute changes. AllowNewBOLogic enables the definition of new business logic for example a new custom method that is not associated with the base logic of the business object. AllowBOAttributes enables the extension of a business object with a maximum number of attributes with a certain type.

On the UI layer the following types may be supported. BeforeForm and AfterForm may enable extending the form flow of a certain application. BeforeForm and AfterForm may be used to insert a custom UI before or after a certain displayed UI. BeforeUIEventHandler and AfterUIEventHandler may enable the definition of custom logic to be inserted before or after a certain event handler is called. AllowUIAttributes may enable extending the data model of a UI with a maximum number of attributes of a certain type.

On the business process layer more types may be supported. BeforeActivity AfterActivity and ParallelActivity may declare the possibility of extending an activity before after or parallel to a process activity execution. BeforeEvent and AfterEvent may allow the extension developer and or extension object to insert an extension before or after an event. AfterDecision defines the possibility of inserting an extension after a certain decision result from a gateway. ExtensibleMessage may allow the extension of the message content or type used in the process data extension . ExtensibleDecision may allow extending the result set of a gateway.

In the example control constraints may be realized as permission sets which restrict the access visibility and usage rights of the base application resources e.g. supports the principle of least privilege to the extension developer and or extension object. For example the permission sets can be defined on the extensible artifact level e.g. container level and or on the extension point level. Extension points may inherit the permission set of their container. An extension point that declares its own permission set can further override or refine the permission set of its container.

For the business object and UI layers permission sets may support method and attribute permissions of the extensible artifact. For example attributes can be declared as either READ WRITE READWRITE or HIDDEN. Methods can be declared as CALLABLE or HIDDEN. Extensible artifacts that do not declare a permission set get the default extension and usage interface. The permission sets defined on the business process layer may define the visibility of the business process elements e.g. activity tasks lanes and data are currently supported . Each element may be declared as HIDDEN or VISIBLE to an extension developer and or extension object.

In the example one control constraint ExtendAll requiring that a valid extension should provide an extension for all extension points within the group may be supported. For example requiring an extension developer and or extension object to extend the data model of the business object when adding a new input text field for a UI may be supported. In the example expressing whether the extension code will be executed on the client side the server side or on another system such as a third party cloud system may be supported. For example using keywords Client Server Other may define where the extension code will be executed.

As another example the following describes extensions for business applications including three logical layers e.g. a business process layer a business object layer and a UI layer although example embodiments are not limited thereto. Listings including classes are shown as implemented in Java. However example embodiments are not limited thereto. The example presents example constructs that can exist in business applications e.g. the extensible artifacts extension point types and the like . However example embodiments are not limited thereto. For example in other possible constructs may be implemented in other multilayered application domains.

This example extends a sales quote business object as shown in . According to a sales quotation management module is illustrated as an example of a multilayered business application. shows a sales quotation business process e.g. a business process layer . The process starts upon receiving a request for a quotation for a specific set of products from a customer. A sales representative analyzes the request and creates a sales quotation block and fills in the necessary data. Then the sales representative sends the quotation for approval block to a manager. The manager can either approve the quotation block or request a revision block . Based on that decision the sales representative may edit the quotation block and resubmit the quotation for approval block . At the end the approved sales quotation is sent to the inquiring customer block .

In this example external developers who are allowed to perform some custom logic before a SalesQuote business object is saved but are not allowed to modify any attribute. This group of extension developers and or extension objects may also be allowed to read all attributes of the SalesQuote and display a message in a label with the outcome of their logic in a SalesQuotation form. Further this group may not see any method of the SalesQuote business object. Listing 2 below shows a specification for the extension interface for an example extension developer and or extension object group. This extension interface spans two layers e.g. business object and UI .

As shown in Listing 2 Line 1 declares the external developer extension interface. Line 3 declares the business object and Line 12 declares the UI as the containers of extensible artifacts. In this example there are two artifacts declared as being extensible which are com.sap.SalesQuote and com.sap.SalesQuoteForm Line 4 and Line 13 . Extension possibilities may be defined through extension points. Each extension point may have a type a unique identifier e.g. EPBO1 a set of parameters and or a reference to a permission set.

Line 5 shows the declaration of the extension point EPBO1 of type beforeMethodCall and Line 14 shows the extension point EPUI1 of type allowUIComponent. The parameters of EPBO1 may declare the extension possibility before the method saveSalesQuote . The parameters of EPUI1 may specify that the extension developer and or extension object can add a new component of type JLabel on the parent component salesQuotePanel. The SalesQuote business object artifact has a reference to the artifact permission set default1 Lines 7 10 . This permission set may declare that all attributes should be available only in READ mode and methods should be hidden to all extension points within the artifact. The SalesQuoteForm UI artifact has a reference to the artifact permission set default2 Lines 16 19 . This permission set may declare all attributes and methods to be hidden from the extension developer and or extension object.

The last part of the interface Line 21 declares a group called extensionScenario that contains two extension points EPBO1 and EPUI1. This may indicate that the two extension points are related. At the end of the group declaration an ExtendAll constraint is declared indicating that a valid extension should extend both extension points.

As still another example the following describes extensions for business applications including three logical layers e.g. a business process layer a business object layer and a UI layer although example embodiments are not limited thereto. Listings including classes are shown as implemented in Java. However example embodiments are not limited thereto. The example presents example constructs that can exist in business applications e.g. the extensible artifacts extension point types and the like . However example embodiments are not limited thereto. For example in other possible constructs may be implemented in other multilayered application domains.

In the example a group of extension developers and or extension objects working on the provider side to realize industry specific solutions on top of the standard application. These extension developers and or extension objects may be allowed to define extensions that span multiple layers. More specifically these extension developers and or extension objects may be allowed to extend the business process after the approval step for example to realize a second approval step. Accordingly some relevant business process activities should be made visible while hiding the rest of the process details. Further these extension developers and or extension objects may also be allowed to extend the SalesQuote business object with new attributes and extend the business object logic after the SalesQuote has been sent for approval. The extension developers and or extension objects may also be allowed to read and write values to the attributes products and customerInfo as well as to call the method calculateTotal. Listing 3 below shows a specification for the extension interface for an example extension developer and or extension object group.

In this example of an extension interface there are three layers defined business object UI and business process . In business object layer Lines 3 17 the SalesQuote business object is declared as extensible. The permission set defview expresses that the extension developer and or extension object cannot call any method and has a read only access to all attributes Lines 14 17 . There are two extension points defined Lines 5 6 EPBO1 and EPBO2 which declare two extension possibilities to allow the addition of a maximum of 10 new attributes of type String that will be persisted in the database and to extend the logic after the sendToApproval method. EPBO2 has a reference to permission set intdev that refines the permission set of the parent which allows a read write access to the attributes products and customerInfo and allows the method calculateTotal to be called Lines 8 12 .

The next part of the example extension interface Lines 19 27 declares the SalesQuoteForm as extensible with the allowUIComponent extension possibility EPUI1 that allows the extension developer and or extension object to add a new panel in the sales quote approval panel. The artifact permission set defview hides all methods and attributes of the class from the extension developer and or extension object. The following part Lines 29 43 defines the business process layer and the sales quotation business process as an extensible artifact. The EPB1 extension point declares the possibility of adding an activity after the sales quote approval activity and the underlying class SQProcessing that processes the logic of the activity through the method approveQuote . The defview permission set declares the whole lane that contains the sales quotation business process as hidden Lines 41 43 . The permission set view referenced by EPBP1 makes the main activities of the business process visible to the extension developer and or extension object.

The last part of the example extension interface Line 45 declares a group called extensionScenario that contains three extension points EPUI1 EPBP1 and EPBO2. This requires the extension developer and or extension object to extend all extension points.

As yet another example the following describes the extension interface enforcement tool . The extension interface enforcement tool may use aspect oriented programming as default enforcement strategy. In other words the extension interface enforcement tool may generate separate aspect code in order to provide and enforce the defined extension interfaces. Other enforcement strategies such as design patterns may also partly supported.

The code generated from an extension interface e.g. extension interface using a default strategy may consist of three main parts. The parts may include a generated interface e.g. an interface written in Java which acts as an entry point for the extension developer and or extension object a proxy class that controls the access visibility and usage rights of the methods and attributes of the base class e.g. the proxy class that will be passed to the class of the extension developer and or extension object implementing the interface and may be initialized once an extension is loaded and an aspect code which injects into the base application the necessary logic for supporting the execution of the implemented extension e.g. the aspect code enriches the base class with methods and data structures necessary to load and initialize an implemented extension in a plug in like fashion . Listing 4 below shows a code framework for the extension interface enforcement tool.

In this example Lines 3 9 of listing 4 show the generated extension interface. The extension interface includes two parts. The first part is needed by the code framework to initialize the extension Line 6 . Moreover a reference to the corresponding proxy classes is provided that may be used by the developer during the implementation of the extension. The second part is the extension point specific part The extension developer and or extension object may implement the method yourEPBO1Logic for the extension point EPBO1 and the method yourEPUI1JLabel for the extension point EPUI1.

The EPBO1 proxy class Lines 13 23 contains the generated list of getter methods required to provide a READ access to the SalesQuote class attributes. Note that no setter methods have been generated and no methods have been exposed as defined in the permission set default1 Listing 3 Lines 7 10 . The proxy class generated for EPUI1 is empty since all methods and attributes were declared as hidden by the permission set default2 Listing 3 Lines 16 19 . The last part of the code framework generated is the aspect code for EPBO1 Lines 31 84 and EPUI1 86 100 .

In the EPBO1 aspect the first part Lines 35 53 of the aspect code are inter type declarations which enrich the base class with data structures and methods necessary to load the extensions implementing the ExtensionScenarioInterface in a plug in like fashion e.g. the extensions of type ExtensionScenarioInterface may be loaded with a class loader and they are passed an instance of the proxy . The second part of the aspect code Lines 56 65 enriches the base class in a similar fashion with methods to support the proxy class EPBO1Proxy calls. The last part of the aspect Lines 69 84 generates the advice that will load the extension after the constructor e.g. trigger the plug in load mechanism of the SalesQuote business object and the saveSalesQuote method pointcut within the base class where the extension code will run as well as the advice that will run the extension code. The EPUI1 aspect contains a similar body to the EPBO1 aspect however the generated pointcut and advice Lines 91 100 will add the JLabel component from the extension to the salesQuotePanel.

Transitioning to a method related to defining generating an extension interface according to example embodiments the software provider may first develop the software system while focusing mainly on the functional aspects. During this process the software provider may not enhance the source code of the software system with any code associated with enforcing and realizing extensibility. Then the software provider may use a tool e.g. the extension interface definition tool to define different extension interfaces for different kinds of extension objects. Finally the software provider can either implement the extension interface manually. Alternatively or in addition to the software provider can use an interface enforcement tool e.g. the extension interface enforcement tool .

For example the method steps may be performed by an application specific integrated circuit or ASIC. For example the ASIC may be configured as one or more of the blocks or elements of the blocks e.g. the extendable object development module and or the system . Although the steps described below are described as being executed by a processor the steps are not necessarily executed by a same processor. In other words at least one processor may execute the steps described below with regard to .

As shown in in step S a processor e.g. at least one processor generates a software system focusing on functional aspects for the system. For example generating functional aspects for the system may include generating base objects associated with the system. As discussed above base objects may be associated with applications e.g. software applications targeted for a large scale and a wide range of customers such as business applications and may be configured to support a set of standard business processes e.g. sales order processing recruitment and the like . The base objects may be objects that can not or should not be extended e.g. add new functions . For example in a sales order processing application or process the base objects may include functions associated with taxes e.g. tax calculations that should not be modified.

In step S the processor defines and or generates an extension interface for each kind of extension object. For example extendable objects may enable the addition of new functionalities to the base objects e.g. as a software system to support new requirements. For example in a sales order processing application or process the base objects may be extended to allow for approval of sales orders. The extendable objects may include insertion points. For example a function e.g. subroutine may be extended by adding code following the execution of the function. The extendable objects may be generated e.g. by a software provider in an IDE. The IDE may be a same IDE as used for the base objects. Alternatively or in addition to the IDE may be a different IDE as used for the base objects.

The extension interface can include the definition of the application layers the extensibility relevant artifacts the extension possibilities that are offered on those artifacts the inter dependencies that exist between these extension points and the access and usage rights of the extension developer and or extension object to the artifacts of the core software system for each extension possibility. Moreover the extension interface can also specify the extension methods to be used and information about where and when the extension code will be executed.

Within an extension interface several layers e.g. application layers can be defined corresponding to the architectural layers of the base application. Each layer may include one or more extensible artifacts that are made available to an extension developer and or extension object. According to example embodiments as discussed above extension possibilities within each artifact may be declared through an extension point and or containers of extension points. Each extension point may have a type and a set of parameters.

Extension points can be further grouped within the same or a different layer via for example extension point groups. A group of extension points indicates that the extension possibilities offered by these extension points are related. An extension interface may include control constraints. As discussed above control constraints on extensible artifacts and extension points may restrict the access visibility and or usage of the base application artifacts by the extension developers and or extension objects.

The control constraints may also be defined on a group to control how an extension realizing the member extension points within a group should be implemented. In extension scenarios where an extension spans several layers e.g. UI and business object a valid extension may require the implementation of several extension points from the same or multiple layers. For example control constraints may be realized as permission sets which restrict the access visibility and usage rights of the base application resources e.g. supports the principle of least privilege to the extension developer and or extension object. For example the permission sets can be defined on the extensible artifact level e.g. container level and or on the extension point level. Extension points may inherit the permission set of their container. An extension point that declares its own permission set can further override or refine the permission set of its container.

For the business object and UI layers permission sets may support method and attribute permissions of the extensible artifact. For example attributes can be declared as either READ WRITE READWRITE or HIDDEN. Methods can be declared as CALLABLE or HIDDEN. Extensible artifacts that do not declare a permission set get the default extension and usage interface. The permission sets defined on the business process layer may define the visibility of the business process elements e.g. activity tasks lanes and data are currently supported . Each element may be declared as HIDDEN or VISIBLE to an extension developer and or extension object.

As described in an example above extensions for business applications including a business process layer may include several types of extension interfaces. For example BeforeActivity AfterActivity ParallelActivity BeforeEvent AfterEvent AfterDecision ExtensibleMessage and or ExtensibleDecision may be supported.

As described in an example above extensions for business applications including a business object layer may include several types of extension interfaces. For example AfterConstructor BeforeMethodCall AfterMethodCall AfterBOAttributeChange AllowNewBOLogic and or AllowBOAttributes may be supported.

As described in an example above extensions for business applications including a UI layer may include several types of extension interfaces. For example BeforeForm AfterForm BeforeUIEventHandler AfterUIEventHandler and or AllowUIAttributes may be supported.

In step S the processor generates using an extension interface enforcement tool code artifacts to enforce the defined extension interfaces. For example the extension interface enforcement tool may be used to generate the code artifacts. In generating the code artifacts the extension interface enforcement tool may only expose artifacts linked to the defined extension interfaces. As a result an extension developer and or extension object can only be added based on the exposed artifacts. For example the software provider may choose an enforcement strategy e.g. using Aspect Oriented Programming using Design patterns using Proxies and the like and the software provider may provide inputs to the interface enforcement tool. For example the inputs may include a defined extension interfaces and or a source or binary code of the core software system. As output the interface enforcement tool may enhance the code of the base system with code to provide and enforce the defined extension interfaces. The extensibility enforcement code can be generated as part of the base system source code and or as a separate module e.g. when using aspect oriented programming techniques .

Alternatively or in addition to the code artifacts to enforce the defined extension interfaces may be enforced manually. For example the software provider may manually write similar code to the generated code e.g. using aspect code design patterns or some additional proxy classes that exposes the extension possibilities defined in the extension interface to the extension developer and or extension object.

Once the base software system is developed with complimentary support for extensibility e.g. a base software system with defined and enforced extension interfaces extension objects may be developed to refine the software based on for example a customer s needs. The three objects e.g. base software object s extension interface object s and extension object s can be combined as a finished software object to be used by the customer e.g. following a compilation of the finished software object .

The extension object development module may be configured to read an extendable object and show e.g. on a display associated with system all or substantially all of the insertion points associated with the extendable object. The extension object development module may be configured to read an extendable object and show all or substantially all of the attribute constraints. The extension object development module may be configured to show the insertion points and the attribute constraints together and or separately.

The extension object development module may be configured to show the constraint associated with an attribute. For example the extension object development module may be configured to show an attribute as read write read only public private and the like. The extension object development module may be configured to provide an interface to add code as an extension of an object. Alternatively or in addition to the extension object development module may include an IDE configured to generate and or modify code as an extension of an object.

As shown in the source binary code of the software system complemented with support for extensibility block is generated by the extension interface enforcement tool based on the extension interface s and the source binary code of the software system block .

The combiner module may be configured to combine code e.g. source code associated with the base object the extendable object and the extension object. For example the combiner module may read code generated by the base object development module the extendable object development module and or the extension object development module and generate combined code. The combined code may be the Source Binary code of the software system complemented with extended code block which may be compiled as customized e.g. customer specific executable code for use by an end user customer.

For example the method steps may be performed by an application specific integrated circuit or ASIC. For example the ASIC may be configured as one or more of the blocks or elements of the blocks e.g. the extendable object development module and or the system . Although the steps described below are described as being executed by a processor the steps are not necessarily executed by a same processor. In other words at least one processor may execute the steps described below with regard to .

As shown in in step S a processor e.g. at least one processor generate base object s . As discussed above base object s may be associated with applications e.g. software applications targeted for a large scale and a wide range of customers such as business applications and may be configured to support a set of standard business processes e.g. sales order processing recruitment and the like . The base object s may be objects that can not or should not be extended e.g. add new functions . For example in a sales order processing application or process the base objects may include functions associated with taxes e.g. tax calculations that should not be modified.

The base object s may be generated e.g. by a software provider in an integrated development environment IDE e.g. Oracle JDeveloper NetBeans Microsoft Visual Studio and the like using a programming language e.g. C visual basic Java and the like . The IDE may implement some form of Aspect Oriented Programming AOP . AOP complements object oriented programming by facilitating another type of modularity that pulls together the widespread implementation of a crosscutting concern into a single unit. These units are termed aspects. The base objects may be objects that can not or should not be extended e.g. add new functions . Base objects are described above in more detail and will not be discussed further for the sake of brevity.

In step S the processor generates extendable object s associated with the base object s . The extendable object s may include insertion points and attribute constraints. For example extendable objects may enable the addition of new functionalities to the base objects e.g. as a software system to support new requirements. For example in a sales order processing application or process the base objects may be extended to allow for approval of sales orders. The extendable objects may include insertion points. For example a function e.g. subroutine may be extended by adding code following the execution of the function. The extendable objects may be generated e.g. by a software provider in an IDE. The IDE may be a same IDE as used for the base objects. Alternatively or in addition to the IDE may be a different IDE as used for the base objects. Extendable objects as for example an extension interface insertion points and attribute constraints are described above in more detail and will not be discussed further for the sake of brevity.

In step S the processor generates extension object s based on the extendable object s . The extension object s may be code generated as an extension of an object. The code may add functionality to the base object as allowed by an extension interface.

In step S the processor combines the base objects the extendable objects and the extension objects. For example as discussed above the combiner module may read code generated by the base object development module the extendable object development module and or the extension object development module and generate combined code. The combined code may become the source code that may be compiled as customized e.g. customer specific executable code for use by an end user customer.

In step S the processor generates an executable from the combined objects. For example the processor may compile the code generated in step S using any known compiler.

Some of the above example embodiments are described as processes or methods depicted as flowcharts. Although the flowcharts describe the operations as sequential processes many of the operations may be performed in parallel concurrently or simultaneously. In addition the order of operations may be re arranged. The processes may be terminated when their operations are completed but may also have additional steps not included in the figure. The processes may correspond to methods functions procedures subroutines subprograms etc.

Methods discussed above some of which are illustrated by the flow charts may be implemented by hardware software firmware middleware microcode hardware description languages or any combination thereof. When implemented in software firmware middleware or microcode the program code or code segments to perform the necessary tasks may be stored in a machine or computer readable medium such as a storage medium. A processor s may perform the necessary tasks.

Specific structural and functional details disclosed herein are merely representative for purposes of describing example embodiments. Example embodiments however be embodied in many alternate forms and should not be construed as limited to only the embodiments set forth herein.

It will be understood that although the terms first second etc. may be used herein to describe various elements these elements should not be limited by these terms. These terms are only used to distinguish one element from another. For example a first element could be termed a second element and similarly a second element could be termed a first element without departing from the scope of example embodiments. As used herein the term and or includes any and all combinations of one or more of the associated listed items.

It will be understood that when an element is referred to as being connected or coupled to another element it can be directly connected or coupled to the other element or intervening elements may be present. In contrast when an element is referred to as being directly connected or directly coupled to another element there are no intervening elements present. Other words used to describe the relationship between elements should be interpreted in a like fashion e.g. between versus directly between adjacent versus directly adjacent etc. .

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of example embodiments. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises comprising includes and or including when used herein specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

It should also be noted that in some alternative implementations the functions acts noted may occur out of the order noted in the figures. For example two figures shown in succession may in fact be executed concurrently or may sometimes be executed in the reverse order depending upon the functionality acts involved.

Unless otherwise defined all terms including technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art to which example embodiments belong. It will be further understood that terms e.g. those defined in commonly used dictionaries should be interpreted as having a meaning that is consistent with their meaning in the context of the relevant art and will not be interpreted in an idealized or overly formal sense unless expressly so defined herein.

Portions of the above example embodiments and corresponding detailed description are presented in terms of software or algorithms and symbolic representations of operation on data bits within a computer memory. These descriptions and representations are the ones by which those of ordinary skill in the art effectively convey the substance of their work to others of ordinary skill in the art. An algorithm as the term is used here and as it is used generally is conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of optical electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

In the above illustrative embodiments reference to acts and symbolic representations of operations e.g. in the form of flowcharts that may be implemented as program modules or functional processes include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types and may be described and or implemented using existing hardware at existing structural elements. Such existing hardware may include one or more Central Processing Units CPUs digital signal processors DSPs application specific integrated circuits field programmable gate arrays FPGAs computers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise or as is apparent from the discussion terms such as processing or computing or calculating or determining of displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Note also that the software implemented aspects of the example embodiments are typically encoded on some form of non transitory program storage medium or implemented over some type of transmission medium. The program storage medium may be magnetic e.g. a floppy disk or a hard drive or optical e.g. a compact disk read only memory or CD ROM and may be read only or random access. Similarly the transmission medium may be twisted wire pairs coaxial cable optical fiber or some other suitable transmission medium known to the art. The example embodiments not limited by these aspects of any given implementation.

Lastly it should also be noted that whilst the accompanying claims set out particular combinations of features described herein the scope of the present disclosure is not limited to the particular combinations hereafter claimed but instead extends to encompass any combination of features or embodiments herein disclosed irrespective of whether or not that particular combination has been specifically enumerated in the accompanying claims at this time.

