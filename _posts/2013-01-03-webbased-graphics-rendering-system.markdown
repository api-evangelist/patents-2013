---

title: Web-based graphics rendering system
abstract: Some embodiments of the present invention provide a system that renders graphics in a computing system that includes a plugin associated with a web browser in the computing system and a web application configured to execute in the web browser. During operation, the web application specifies a graphics model and provides the graphics model to the plugin. Next, the plugin generates a graphics-processing unit (GPU) command stream from the graphics model. Finally, the plugin sends the GPU command stream to a GPU of the computing system, which renders an image corresponding to the graphics model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08723875&OS=08723875&RS=08723875
owner: Google Inc.
number: 08723875
owner_city: Mountain View
owner_country: US
publication_date: 20130103
---
The subject matter of this application is also related to the subject matter in a co pending non provisional application by J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008.

The subject matter of this application is also related to the subject matter in a co pending non provisional application by J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008.

Embodiments of the present invention relate to graphics rendering techniques. More specifically embodiments of the present invention relate to a system that facilitates web based rendering of graphics.

Computer systems often include a number of native applications that require complex three dimensional 3D scenes to be rendered such as computer games and computer aided design CAD systems To render 3D graphics these native applications may use graphics application programming interfaces APIs that direct calculations related to graphics rendering to dedicated graphics processing units GPUs . The additional computational power provided by these GPUs can greatly improve graphics quality and throughput.

Web applications which have become more prevalent in recent years are typically written in scripting languages that are unable to utilize low level graphics APIs that provide graphics hardware acceleration. Instead graphics rendering for web applications is typically performed by CPUs instead of GPUs. The software based nature of web based graphics rendering may thus limit the graphics capabilities of web applications. However unlike native applications web applications provide a number of advantages. For example web applications are capable of executing on multiple platforms do not require installation and can be more secure than native applications.

Hence what is needed is a web based graphics rendering system that enables graphics hardware acceleration for web based applications.

Some embodiments of the present invention provide a system for rendering graphics in a computing system. The system includes a plugin associated with a web browser which operates in the computer system and a web application configured to execute in the web browser. During operation the web application specifies a graphics model and provides the graphics model to the plugin. Next the plugin generates a graphics processing unit GPU command stream from the graphics model. Finally the plugin sends the GPU command stream to a GPU of the computing system which renders an image corresponding to the graphics model.

In some embodiments the plugin includes an editing thread that loads the graphics model into a scene graph. In these embodiments the plugin also includes a render thread that creates a render graph for the graphics model from the scene graph and renders the image using the render graph.

In some embodiments the scene graph includes a set of parameters a set of transform nodes and a set of Shape nodes. In these embodiments each of the shape nodes is associated with one of the transform nodes and the shape nodes and the transform nodes are associated with the parameters by subscribing to the parameters.

In some embodiments the render graph includes a set of one or more render managers and a set of mesh renderers. In these embodiments each of the mesh renderers corresponds to one of the shape nodes from the scene graph each of the mesh renderers is associated with one of the render managers and each of the render managers is configured to specify a rendering order for the associated mesh renderers.

In some embodiments each of the render managers corresponds to a priority render manager a z order render manager a group render manager or a performance render manager.

In some embodiments each of the buffers is at least one of a frame buffer a vertex buffer an index buffer and a texture buffer.

In some embodiments the plugin includes a rendering engine that communicates with the GPU using the GPU command stream.

In some embodiments the plugin also includes a software renderer configured to render the image using a central processing unit CPU of the computing system.

In some embodiments the graphics model is specified using at least one of an input file and a method call from the web application to the plugin.

In some embodiments the system also includes a plugin interface configured to process the method call from the web application to the plugin.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore the methods and processes described below can be included in hardware modules. For example the hardware modules can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

Embodiments of the present invention provide a method and system for rendering graphics in a computing system. The computing system may be for example a personal computer PC a mobile phone a personal digital assistant PDA a graphing calculator a portable media player a global positioning system GPS receiver and or another electronic computing device. The graphics may be rendered by specifying a graphics model and rendering the graphics model using a graphics pipeline. One or more stages of the graphics pipeline may be executed using a graphics processing unit GPU of the computing system. An image corresponding to the graphics model may then be displayed on a display screen of the computing system.

More specifically embodiments of the present invention provide a method and system for web based graphics rendering. A web application loaded from a web browser is used to specify the graphics model and provide the graphics model to a plugin associated with the web browser. The plugin then generates a GPU command stream from the graphics model and sends the GPU command stream to the GPU which renders the image within the web browser or within a plugin window associated with the plugin. As a result embodiments of the present invention enable graphics hardware acceleration for cross platform web applications that execute within a web browser and do not require installation.

Computing system may correspond to an electronic device that provides one or more services or functions to a user. For example computing system may operate as a mobile phone personal computer PC global positioning system GPS receiver portable media player personal digital assistant PDA and or graphing calculator. In addition computing system may include an operating system that coordinates the use of hardware and software resources on computing system as well as one or more applications e.g. web browser web application that perform specialized tasks for the user. For example computing system may include applications such as an email client address book document editor web browser and or media player. To perform tasks for the user applications may obtain the use of hardware resources e.g. processor memory I O components wireless transmitter etc. on computing system from operating system as well as interact with the user through a hardware and or software framework provided by operating system as described below.

Those skilled in the art will appreciate that computing system may include functionality to execute both native applications and non native applications. In other words computing system may include native applications such as web browser that are locally installed on computing system and specific to operating system and or one or more hardware devices e.g. GPU on computing system . Such applications may communicate directly with the hardware devices through operating system and or libraries that are compatible with the hardware devices. However the installation of native applications may compromise computing system and private data stored on computing system .

Computing system may also include functionality to execute platform independent non native applications. For example computing system may obtain web application from server e.g. an application server using a network connection with server and load web application within web browser . Once loaded web application may provide features and user interactivity comparable to that of native applications on computing system . For example web application may function as an email client document editor media player computer aided design CAD system and or computer game. Web application may also include dynamic user interface elements such as menus buttons windows sub windows icons animations and or other graphical objects that emulate analogous user interface elements in native applications. In other words web application may correspond to a rich Internet application RIA .

Furthermore web application may execute on computing system regardless of the type of platform e.g. operating system drivers etc. associated with computing system . Though platform independent applications such as web application may be more portable and secure than native applications such cross platform applications may lack certain performance capabilities of native applications.

More specifically non native applications such as web application may be written using scripting languages that are interpreted rather than compiled such as Javascript Javascript is a registered trademark of Sun Microsystems Inc. . The interpretive nature of web application and or other non native applications may preclude the non native applications from accessing low level libraries and or application programming interfaces API that are available for use by native applications. Consequently non native applications may be unable to utilize hardware resources on computing system that are available to native applications through such low level APIs.

In particular web application may be unable to use graphics libraries that enable communication with GPU such as Direct3d Direct3d is a registered trademark of Microsoft Corp. and OpenGL OpenGL is a registered trademark of Silicon Graphics Inc. . The low level nature of such graphics libraries may require a large number of method calls to implement graphics rendering thus precluding efficient and or practical use by interpreted languages such as Javascript. As a result graphics rendering in web application may be limited to software that executes on a central processing unit CPU of computing system or to compiled languages such as C .

Because web application may be unable to utilize graphics hardware acceleration in computing system graphics e.g. three dimensional 3D graphics in web application may be slow and or suboptimal compared to graphics in native applications that employ graphics hardware acceleration. For example web application may be unable to use vertex and or pixel shaders in CPU based graphics rendering. On the other hand writing portions of web application in compiled languages such as C may introduce problems experienced by native applications such as lack of portability and security. Moreover compiled code modules may not integrate into web content as well as scripted web applications. As a result implementation of applications such as video editors CAD systems 3D computer games photo editors and or 3D model catalogs may be difficult slow or unwieldy using current web development techniques.

To enable graphics support and graphics hardware acceleration for web application operations related to graphics processing may be offloaded to plugin which may execute separately from web application . More specifically web application may transfer both the storage and processing of data associated with graphics processing to plugin . In turn plugin may expose the capabilities of GPU to web application including the use of vertex and pixel shaders in graphics rendering.

In one or more embodiments of the invention plugin corresponds to a browser plugin that is associated with web browser . For example plugin may correspond to an ActiveX ActiveXT is a registered trademark of Microsoft Corp. control a Netscape Plugin Application Programming Interface NPAPI plugin a Cross Platform Component Object Model XPCOM plugin and or another component based plugin that is compatible with web browser . Furthermore communications between plugin and web browser and or web application may be facilitated by a plugin interface .

In one or more embodiments of the invention plugin interface is generated using an interface description language IDL such as Common Object Request Broker Architecture CORBA XPCOM and or Component Object Model COM . In particular plugin interface may be generated from an IDL description that allows web application which may be written in one programming language e.g. Javascript to communicate with plugin which may be written in another programming language e.g. C . In other words plugin interface may implement an API between web application and plugin . For example plugin interface may carry out method calls to plugin from web application by executing code from plugin corresponding to the methods called from web application . Such method calls may extend both the capabilities and processing power of web application by providing web application access to resources on computing system through plugin .

Those skilled in the art will appreciate that the functionality of plugin may be accessed through a variety of other interfaces. For example plugin interface may implement APIs to allow communication between multiple web based and or scripting languages and plugin . Furthermore methods provided by plugin may be directly accessed by applications that utilize a plugin API provided by plugin instead of by plugin interface . Such applications may be written in languages supported by the plugin API such as C or C . As a result plugin interface may allow some or all of web application to be written using compiled languages such as C . Those skilled in the art will also appreciate that plugin interface may be created using non IDL based mechanisms. For example plugin interface may be provided by a library that exposes methods and objects in plugin to web application and vice versa.

In one or more embodiments of the invention web application specifies a graphics model to be rendered and provides graphics model to plugin . In particular web application may include a reference e.g. hyperlink to an input file that describes graphics model using a scene description language. For example graphics model may be described using a Collaborative Design Activity COLLADA file. The input file may be stored on a host e.g. server and obtained by web application using a network connection with the host. Alternatively the input file may be obtained from a disk on computing system and or another storage medium. The input file may then be loaded into plugin by a method call e.g. loadColladaURL from web application to plugin .

On the other hand graphics model may be specified using a set of method calls from web application to plugin . As mentioned above the method calls may be facilitated by plugin interface . For example web application may make method calls that describe shapes e.g. triangle meshes in graphics model modeling transformations to be applied on the shapes light sources a camera position and orientation a camera perspective and or rendering effects e.g. textures materials shaders etc. for graphics model . Web application may also issue a method call corresponding to a render command to plugin to initiate rendering of graphics model . In other words web application may issue requests for the execution of code to process and render graphics model . In one or more embodiments of the invention such requests are fulfilled by plugin on behalf of web application .

More specifically once graphics model and the render command are obtained by plugin plugin may generate a GPU command stream from graphics model and send the GPU command stream to GPU . In particular plugin may execute a graphics pipeline that renders graphics model by making system calls to operating system which in turn communicates with GPU using a device driver not shown corresponding to GPU . For example plugin may generate GPU commands that perform modeling viewing and projection transformations on objects within graphics model clipping and culling of geometric primitives vertex shading rasterization and interpolation and texturing and fragment shading. Furthermore plugin may manage both the data e.g. buffers effects etc. and the operations in the graphics pipeline on behalf of web application to minimize the graphics processing burden on web application .

In one or more embodiments of the invention plugin includes a rendering engine that includes functionality to communicate with GPU using a device driver associated with GPU . For example the rendering engine may correspond to a Direct3d or OpenGL renderer that translates graphics model and the render command from web application into graphics processing instructions for GPU . Alternatively the rendering engine may interface directly with GPU by issuing hardware instructions to GPU . Plugin may further include a software renderer that processes and renders graphics model using a CPU on computing system if computing system does not include GPU . Plugin is discussed in further detail below with respect to .

Once processing of graphics model by plugin and or GPU is complete an image corresponding to graphics model is displayed in a plugin window associated with web browser . More specifically GPU may transmit a bitmap or raster image corresponding to graphics model to a frame buffer that drives display screen . Image may then be displayed on display screen within a plugin window associated with web browser . For example plugin window may be displayed as a sub window or child window within web browser . Alternatively plugin window may be displayed separately from web browser e.g. as a full screen . However the state of plugin window may still be based on the state of web browser since the execution of web application and or plugin is based on the execution of web browser . Consequently the rendering of image within plugin window may only occur if web browser is running.

Graphics model may continue to be processed updated and or rendered within computing system according to the functionality provided by web application . For example web application may correspond to a computer game that updates i.e. animates graphics model based on input provided by the user. Alternatively web application may correspond to a CAD program that allows the use to create and modify both graphics model and the view of graphics model in web browser .

In one or more embodiments of the invention web application uses a native code module to update graphics model . Furthermore the combination of the native code module and plugin may enable real time 313 graphics rendering and animation in web application . Execution of native code modules is described in a co pending non provisional application by inventors J. Bradley Chen Matthew T. Harren Matthew Papakipos David C Sehr Bennet S. Yee and Gregory Dardyk entitled Method for Safely Executing an Untrusted Native Code Module on a Computing Device having Ser. No. 12 117 650 and filing date 8 May 2008 which is incorporated herein by reference. Validation of native code modules is described in a co pending non provisional application by J. Bradley Chen Matthew T. Harren Matthew Papakipos David C. Sehr and Bennet S. Yee entitled Method for Validating an Untrusted Native Code Module having Ser. No. 12 117 634 and filing date 8 May 2008 which is incorporated herein by reference.

As shown in plugin includes an editing thread and a render thread . Editing thread is responsible for creating a scene graph from a graphics model e.g. graphics model of provided to plugin by the web application. Editing thread may also update scene graph to change the image rendered from the graphics model. For example editing thread may edit scene graph to animate one or more objects in the graphics model or change the camera perspective in the graphics model.

Scene graph includes a set of transform nodes e.g. transform node transform node x that specify geometric transformations in the graphics model. Scene graph also includes a set of shape nodes e.g. shape node shape node y that specify shapes e.g. objects in the graphics model. Finally scene graph contains a set of parameters e.g. parameter parameter z that may be associated with transform nodes and or shape nodes through subscriptions to the parameters by the transform and or shape nodes. The parameters may be used to modify the rendering of the graphics model by providing attributes in the form of Boolean values floating point values integer values arrays matrices strings and or textures to nodes in scene graph . For example the parameters may rotate scale and or translate one or more shape nodes in scene graph specify the color and or texture of shape nodes in scene graph and or provide light source and camera locations within scene graph . Scene graph is described in further detail with respect to A and B.

Editing thread is responsible for creating a render graph for the graphics model from scene graph . Render thread may then render the graphics model by traversing render graph and transmitting data and commands from nodes in render graph to a rendering engine . As mentioned previously rendering engine may correspond to a graphics renderer that executes by communicating with a GPU such as GPU of . For example rendering engine may correspond to an OpenGL or Direct3d renderer that sends a GPU command stream to a device driver associated with the GPU.

Furthermore plugin may include multiple rendering engines for compatibility with different platforms. For example plugin may include an OpenGL renderer and a Direct3d renderer. The renderer used is based on the platform on which plugin is installed and may be selected by plugin . In other words plugin may provide a platform independent rendering system that is implemented using multiple rendering engines for multiple platforms and that executes cross platform without intervention by the web applications.

Alternatively rendering engine may interface directly with the GPU by emitting hardware commands to registers and memory on the GPU. As a result rendering engine may execute one or more stages of a graphics pipeline using the GPU including the use of fragment and or pixel shaders in the graphics pipeline. On the other hand if a GPU is unavailable for use by rendering engine a software renderer may be used by render thread to render images corresponding to the graphics model using a CPU.

In one or more embodiments of the invention nodes in render graph are ordered differently from nodes in scene graph . More specifically render graph may include a set of mesh renderers e.g. mesh renderer mesh renderer y corresponding to shape nodes e.g. shape node shape node y in scene graph . Render graph may also include a set of parameters e.g. parameter parameter z corresponding to parameters e.g. parameter parameter z in scene graph . However render graph contains a set of render managers e.g. render manager render manager n that do not map to transform nodes e.g. transform node transform node x in scene graph .

Instead the render managers may be used to execute the mesh renderers in a specific rendering order. The render managers may be included in render graph to ensure that rendering of objects from the graphics model is both optimized and correct. For example render graph may render opaque objects by the shader s associated with the opaque objects and transparent objects by each object s distance from the camera i.e. z order . Render graph is described in further detail below with respect to A and B.

In one or more embodiments of the invention editing thread and render thread execute concurrently within plugin . Furthermore editing thread and render thread may also execute in parallel if the computer system on which plugin is installed includes hardware that supports parallelism e.g. multiple CPUs multiple CPU cores etc. . As a result pipelining may be implemented using editing thread aid render thread .

More specifically a single threaded graphics rendering system may render a graphics model in between edits to the graphics model. In other words a single thread may edit a frame of the graphics model and then draw the frame after editing is complete. After the frame is finished rendering the thread edits the next frame of the graphics model and draws the next frame after editing of the next frame is finished thus producing the following sequence 

As a result the frame rate of the rendering system may correspond to the sum of the editing rate for the graphics model and the rendering rate for the graphics model. For example if editing and rendering the graphics model both occur at 60 Hertz the frame rate of the single threaded rendering system may be 30 frames per second.

However if editing and rendering are handled by separate threads e.g. editing thread and render thread the graphics model may be rendered by one thread while edits to the next frame are made by another thread as shown in the following sequence 

In other words the first frame of the graphics model may be produced by sequential editing and rendering of the graphics model. However once edits to the first frame are complete editing thread may proceed immediately with editing the second frame while render thread draws the first frame. Because editing and drawing occur concurrently the frame rate of plugin may be increased to the slower of the editing rate and the rendering rate rather than the combination of the editing rate and the rendering rate. For example if editing the graphics model runs at 30 Hertz and rendering the graphics model operates at 40 Hertz the frame rate of plugin may be 30 frames per second. However if editing and rendering both run at 40 Hertz the frame rate of plugin may be 40 frames per second. Consequently pipelining between editing thread and render thread may increase the frame rate of plugin to double that of a single threaded system under optimal conditions.

Root node may correspond to a transform node at the top of the scene graph. Root node and other transform nodes may include both transform nodes and shape nodes as children. Root node and transform nodes may also include one or more transformation matrices such as a local matrix and a world matrix. In other words root node and transform nodes may provide modeling transformations for objects in the graphics model such as rotations translations and scaling. Transform nodes are described in further detail below with respect to .

Shape nodes may correspond to nodes that contain data used to render objects in the graphics model. More specifically shape nodes may include a set of buffers that describe the geometry of the objects e.g. vertices triangles etc. and or attributes of the objects e.g. colors textures etc. . Each shape node may also include an associated effect that specifies shaders culling blending and or other settings for a graphics pipeline used to render the objects in the shape node. Shape nodes are described in further detail below with respect to .

Parameters may be used to store values that affect the rendering of objects in the graphics model. As described above parameters may correspond to a variety of data types including Boolean values integers floating point numbers arrays matrices strings and or textures. Parameters may further be associated with a variety of nodes in the scene graph. In particular parameter is associated with shape nodes parameter is associated with transform node and shape node and parameter is associated with shape nodes .

Parameters may also be bound to other parameters in the scene graph using unary or binary operators as described in further detail below with respect to . For example parameter may be bound to parameter with a unary binding that copies the value of parameter to parameter . As a result changes in the value of parameter may be passed onto parameter . Those skilled in the art will appreciate that parameters may also support other types of bindings and or operators. For example parameters may support ternary and n ary operators. Parameters may also support configurations and bindings by programming languages. For example the value of a parameter and or the operation provided by a binding may be described using code rather than conventional data types and or operators.

Furthermore associations between nodes in the scene graph and parameters may be established by the creation of a parameter from a node and or by subscribing to a parameter from a node. In particular parameter may be created from a transformation matrix in transform node . However parameter is not automatically inherited by children of transform node e.g. transform node shape node . Instead other nodes in the scene graph must subscribe to parameter to be affected by parameter . More specifically shape node is subscribed to parameter while transform node is not. As a result the rendering of shape node may be based on the value of parameter while the rendering of shape nodes which are children of transform node may be independent of the value of parameter .

Because nodes may be required to explicitly subscribe to parameters regardless of the structure of the scene graph the scene graph may lack global parameters and or global state thus allowing flexibility in the creation and rendering of the graphics model. For example parameters may correspond to light sources transformation matrices and or view matrices in the graphics model. Each parameter may only be applied to nodes that subscribe to parameter . The independence of nodes and parameters in the scene graph thus allows a scene that contains multiple perspectives to be rendered with each object in the scene taking part in a perspective by subscribing to a set of parameters corresponding to the perspective.

For example the scene graph of may be used to produce a scene from a computer game such as a flight or driving simulator. The scene may contain multiple perspectives corresponding to a front view of the outside world a rear view of the outside world a view of the space inside a car or aircraft and or a view of a heads up display HUD that provides instructions statistics scores and or other information related to game play. Objects associated with each perspective may subscribe to the perspective s camera light sources transformation matrices and or other parameters. Consequently the rendered scene may contain objects that are rendered from multiple camera views and that interact with the user in different ways. For example objects associated with the outside world may change as the aircraft or car is steered by the user while objects associated with the space inside the vehicle may maintain their positions on the display screen regardless of the vehicle s trajectory.

As shown in transform node includes a local matrix and a world matrix . In one or more embodiments of the invention local matrix and world matrix correspond to 4 4 matrices. Local matrix may contain the geometric transformation associated with transform node . In particular local matrix may define a scale rotate or translate along one or more axes to be applied to objects e.g. vertices associated with transform node .

World matrix provides a geometric transformation from the coordinate system of transform node to the world coordinate system. World matrix may be obtained by multiplying the world matrix from a parent node of transform node with local matrix . As a result transformations may be applied to shape nodes by concatenating transformation matrices e.g. local matrix between the root node of the scene graph e.g. root node of and the shape nodes. Furthermore world matrices may be stored at each transform node of the scene graph to facilitate the calculation of world matrices in child nodes.

Transform node also contains a set of parameters e.g. parameter parameter . The parameters may modify local matrix and or world matrix . For example the parameters may specify angles of rotation along one or more axes translations in one or more dimensions and or scaling in one or more directions. Transform node may also contain a variety of parameters that are associated with child nodes of transform node . For example transform node may include parameters that affect the shading and blending of shape nodes below transform node . Finally transform node may create a parameter from local matrix and or world matrix . The parameter may be provided to shape nodes to apply the transformation properties of transform node to the rendering of objects in the shape nodes.

As shown in shape node includes a set of buffers an effect a state and a set of parameters . Each buffer may represent a one or two dimensional array of vectors. Each vector may include one to four components and each component may include a floating point or integer value. More specifically buffers may be used to define the geometry of one or more objects associated with shape node . For example buffers may include one or more vertex buffers that specify the coordinates normals tangents binormals colors relative light positions texture coordinates and or other attributes of 3D or four dimensional 4D vertices in shape node . Buffers may also contain one or more index buffers that specify polygons to be built from vertices in the vertex buffers. In addition buffers may include one or more texture buffers that contain texture maps to be applied to the polygons during fragment shading.

Effect may include settings for a graphics pipeline used to render the object. More specifically effect may correspond to an atomic rendering description of the object. The description may include one or more shaders e.g. pixel shaders vertex shaders to be used in the graphics pipeline. The shaders may correspond to programs that are executed by a GPU e.g. GPU of to alter pixel and or vertex attributes at various points in the graphics pipeline. In addition effect may include a set of shader parameters that modify the behaviors of the shaders. For example the shader parameters may specify light sources colors and or textures that are used by the shaders to render the object. Effect may further create and initialize one or more parameters within shape node using the shader parameters and their associated values. The newly created parameters may then be bound to other parameters in the scene graph such as parameters for transformation matrices view matrices and or projection matrices.

Effect may also include a set of states associated with the graphics pipeline. The states may include render state information associated with shape node . In particular the states may indicate differences from the default graphics pipeline to be applied to shape node . For example states within effect may specify blending operations depth culling rules texture formats and or other render settings.

As with transform nodes in the scene graph shape node includes a set of parameters . Parameters may be created from internal parameters associated with effect Parameters may also be bound to parameters from other nodes in the scene graph such as parameters for transformation matrices view and projection matrices colors and or other attributes that may affect the rendering of the object. Values for parameters may then be passed to effect to execute the graphics pipeline using the mesh renderer associated with shape node .

As mentioned previously mesh renderers may be created from shape nodes in a scene graph such as shape nodes of . More specifically mesh renderers may include copies of or references to information stored in the corresponding shape nodes. The information may then be used by the mesh renderers to render objects corresponding to the shape nodes. Furthermore each mesh renderer may also be tracked by the corresponding shape node and updated based on changes to the shape node. As a result deletion of a shape node and or toggling of a shape s visibility may be reflected in the render graph by deleting or updating the mesh renderer tracked by the shape node. Mesh renderers are described in further detail below with respect to .

In one or more embodiments of the invention render managers specify the order in which objects are rendered by mesh renderers . To render the objects the render graph may be traversed beginning with the root node or render manager . Render manager may then dictate the order of traversal among its children based on parameters associated with the children. In particular render manager may specify a rendering order for render manager and mesh renderers according to a render context associated with render manager . The render context may be based on parameters such as priority z order and or other parameters that affect the performance and accuracy of rendering objects in the scene. The remainder of the render graph may then be traversed according to the ordering of child nodes provided by render manager as well as subsequent orderings of child nodes by other render managers in the render graph e.g. render manager . Render managers are described in further detail below with respect to .

For example render manager may specify the rendering order of its child nodes as mesh renderer render manager and mesh renderer . In other words mesh renderer may render its associated object first. Next render manager may execute by specifying a rendering order of its children as mesh renderer mesh renderer and mesh renderer . Finally after mesh renderers and have completed rendering in that order mesh renderer may render the final object in the scene. As a result mesh renderers are rendered in order of mesh renderer mesh renderer mesh renderer mesh renderer and mesh renderer . Furthermore the rendering order of mesh renderers may be changed by altering the structure of the render graph and or changing the render contexts associated with render managers .

In one or more embodiments of the invention render manager includes a type that affects the rendering order of its children. In other words type specifies the rendering context of render manager . Moreover type may be set to one of several rendering contexts. First type may cause render manager to be a priority render manager that sorts its children based on a priority parameter of each child node. A priority render manager may be used when rendering of objects is to happen in a specific order. For example a priority render manager may be used to clear the screen before rendering other objects in the scene or create a full screen effect after all other objects are rendered. Furthermore priority may be set in render manager to change the rendering order of its children with respect to other nodes in the render graph.

Render manager may also be a z order render manager that orders its children by a z value parameter of each child node. In one or more embodiments of the invention z value corresponds to the node s z coordinate or depth from a camera in the scene. A z ordered render manager may be used to order transparent objects which may require rendering from back to front for accurate rendering of the scene. Those skilled in the art will appreciate that z value may be defined in a variety of ways for both render managers and mesh renderers. For example z value for a mesh renderer may be set as the local origin of the mesh renderer. Similarly z value in render manager may be based on the z values of its Child nodes and or assigned a value to affect the rendering order of Objects in the render graph.

Render manager may further correspond to a group render manager that renders its children in a non specific order. However children of the group render manager may not be rendered if a visibility of the group render manager is set to false or a cull setting of the group render manager indicates that the group render manager is to be culled.

Finally render manager may be a performance render manager that orders its children to optimize the rendering process. In particular a performance render manager may perform back face culling and or occlusion culling to remove polygons that do not need to be drawn. The performance render manager may also order its children by attributes such as effect to increase the rendering speed of objects in the scene.

Consequently mesh renderer may include or reference all data stored in the shape node such as a set of buffers and an effect . Mesh renderer also includes a set of parameters that correspond to parameters found in the shape node as well as parameters bound to mesh renderer to enable rendering of the object. For example mesh renderer may include parameters that are required by effect to fully encapsulate the graphics pipeline for the object such as world view and projection matrices.

Mesh renderer may additionally include parameters that affect the order in which mesh renderer is visited in the render graph if such parameters are not already defined in the corresponding shape node. As shown in the parameters include a priority a visibility a cull setting and a z value .

Priority may correspond to a value that is manually set for mesh renderer . In other words priority may be used to manipulate the rendering order of mesh renderer with respect to other nodes in the render graph. In addition priority may be examined by a priority render manager in ordering its children as discussed above. As a result priority may be used to create certain rendering effects such as clearing a screen or generating a full screen effect.

Visibility may correspond to a parameter that is set to enable or prevent the rendering of the object associated with mesh renderer . For example if the shape node from which mesh renderer is constructed is invisible visibility may be set to false to reflect the object s invisibility. Visibility may thus stop mesh renderer from rendering the object during traversal of the render graph.

Cull setting may correspond to a Boolean value that specifies whether the object stored in mesh renderer should be culled. Cull setting may be set by performing calculations that check for back face occlusion and or bounding box culling. As with visibility cull setting may prevent mesh renderer from rendering the object during traversal of the render graph.

Z value may indicate the object s distance from a camera along the z axis. As mentioned previously z value may be based on the local origin of mesh renderer . Z value may also be arbitrarily set or calculated based on other parameters e.g. parameters in mesh renderer such as vertex coordinates. Z value may be examined by a z order render manager to render objects e.g. transparent objects based on their depth.

As shown in parameter includes a name a type and a value . Name may allow parameter to be identified by its role in the scene graph and or render graph. For example name may be set to ball color if parameter corresponds to the color of a ball in the graphics model. Similarly name may be set to turret angle if parameter specifies an angle at which a turret mesh is rotated within the graphics model.

Type may correspond to the type of data stored in parameter In particular type may correspond to a Boolean value one or more floating point numbers one or more integers an array a matrix a string and or texture. As a result parameter may provide either numeric or non numeric input to the rendering of objects in the graphics model. For example parameter may specify the size of an object in the graphics model by providing a 4 4 scaling matrix or a descriptive string such as large medium or small .

Value stores a data value corresponding to type . Value may be set by a transform node or shape node of the scene graph. For example value may store a transformation matrix from a transform node or a texture used by a shape node. Because parameter may be associated with multiple transform nodes shape nodes and or mesh renderers value may affect the rendering of multiple objects in the graphics model. For example value may be used as an input to a modeling transformation or a shader. In addition parameter may be bound to one or more other parameters as an input or output. Consequently value may be updated based on one or more parameters bound to parameter as inputs. Similarly value may be used to update other parameters bound to parameter as outputs.

As described above other types of bindings e.t. ternary n ary etc. may exist between parameters. Furthermore parameters and or bindings may be programmable. In other words parameters and or bindings may be specified using code rather than conventional operators or data types.

As shown in the graphics pipeline begins with a set of triangles formed from vertices in a vertex buffer and triangle indices in an index buffer . Next vertex processing is applied to triangles . In one or more embodiments of the invention vertex processing corresponds to geometric operations on triangles such as modeling viewing and projection transformations clipping culling lighting and primitive assembly lighting and texture coordinate generation. Parameters and or states associated with each geometric operation may be provided by effect . For example effect may include a state that sets culling rules for triangles and or a parameter that moves a light source.

Vertex processing may additionally involve a vertex shader that is specified by effect . In particular vertex shader may correspond to a software program that is written in a shading language such as High Level Shader Language HLSL OpenGL Shading Language GLSL and or C for Graphics Cg . Vertex shader may further be executed by the GPU to perform mathematical operations on vertex data e.g. colors textures coordinates etc. obtained from a vertex buffer . In addition vertex shader may execute using a set of shader parameters obtained from effect to ensure that vertex shader produces the desired effect. For example vertex shader may use the shader parameters to perform operations such as procedural geometry advanced vertex blending texture generation camera effects and or advanced lighting models.

After vertex operations are complete vertex data is converted into pixel data in rasterization . During rasterization vertices and edges of triangles are mapped to pixels on a display screen . In addition pixel values e.g. color depth etc. within the triangles are interpolated based on values at the vertices. Rasterization may also involve a fragment shader that is specified by effect .

As with vertex shader fragment shader may be a software program that is written in HLSL GLSL Cg and or another shading language. Furthermore fragment shader may be executed by the GPU to perform pixel operations. In particular fragment shader may combine the pixel values from a fragment with one or more interpolated texture coordinates from a texture buffer . Pixel values may further be modified using multi texturing fog blending compositing bump mapping shadow mapping and or other pixel level operations specified by effect . As with other stages of the graphics pipeline the behavior of fragment shader and or other rasterization operations may be affected by shader parameters and or states provided by effect . Finally pixel values may be written to a frame buffer for display on display screen .

First a web application is loaded within a web browser operation . The web application may be obtained from a server by the web browser. Furthermore the web application may be used to render graphics e.g. 3D graphics within the web browser. However the web application may be written in a scripting language such as Javascript that is unsuitable for communication with a GPU in the computing system. As a result the web application may only include functionality to render graphics using a CPU in the computing system. Alternatively the web application may use compiled code to process graphics. However compiled code may lack portability security and integrability with other components in the web application.

To enable graphics hardware acceleration using the GPU the web application may specify a graphics model operation to be rendered. For example the web application may provide an input file such as a COLLADA file that describes the graphics model. Alternatively the graphics model may be specified using one or more method calls from the web application to a plugin associated with the web browser. The graphics model may then be provided to the plugin operation for rendering using the GPU.

To render the graphics model the plugin loads the graphics model into a scene graph operation . A render graph may then be created from the scene graph operation . As described above the scene graph and render graph may be created by an editing thread in the plugin.

Finally an image corresponding to the graphics model is rendered using the render graph operation . More specifically a render thread may render the graphics model by traversing the render graph as the graphics model is edited by the editing thread. As a result pipelining may be implemented using the editing thread and the render thread thus increasing the frame rate associated with rendering the graphics model.

The render thread may provide rendering instructions to a rendering engine in the plugin which communicates with the GPU using a GPU command stream. The rendering instructions may include the loading of one or more shaders such as pixel or fragment shaders into the GPU. The rendering engine may communicate with the GPU through a device driver for the GPU or the rendering engine may emit hardware commands directly to the GPU. Furthermore if no GPU is available on the computing system a software renderer provided by the plugin may be used to render the graphics model on a CPU of the computer system. The rendered image may then be displayed within a plugin window associated with the web browser.

As described above the GPU may perform calculations related to rendering the image from the graphics model. In particular the GPU may execute one or more stages of a graphics pipeline associated with an object in the graphics model. The graphics pipeline may further include one or more vertex shaders one or more pixel shaders and or other computationally intensive vertex or pixel operations. As a result the plugin may allow complex 3D graphics to be rendered in a web environment using graphics hardware acceleration from the GPU.

Embodiments of the present invention may facilitate graphics related functionality for web applications. More specifically embodiments of the present invention provide integrated mechanisms for graphics support particularly 3D graphics support in scripting languages such as Javascript. Embodiments of the present invention also provide graphics hardware acceleration for web applications including the use of shaders in the GPU. In addition embodiments of the present invention enable the loading and rendering of 3D graphics models in standard file formats such as COLLADA from web applications. Some embodiments may also provide a variety of APIs for development in various languages and environments.

As a result embodiments of the present invention provide a method and system for implementing a variety of applications using web applications. Such applications may include for example video editors CAD editors 3D computer games photo editors and or catalogs of 3D models. In particular web applications may implement these applications by interfacing with a platform independent plugin that executes separately from the web applications and exposes GPU resources to the web applications. The features provided by the plugin to the web applications may allow the graphics performance of native applications to be provided by cross platform web applications that do not require installation.

The foregoing descriptions of embodiments of the present invention have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.

