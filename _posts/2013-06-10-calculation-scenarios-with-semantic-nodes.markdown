---

title: Calculation scenarios with semantic nodes
abstract: A calculation engine is described that executes calculation scenarios comprising a plurality of calculation nodes that each specify operations to be performed to execute the query. One of the nodes can be a semantic node that is used to modify the query for operations requiring special handling. Related apparatus, systems, methods, and articles are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09213737&OS=09213737&RS=09213737
owner: SAP SE
number: 09213737
owner_city: Walldorf
owner_country: DE
publication_date: 20130610
---
The subject matter described herein relates to the use of calculation scenarios with semantic nodes that provide special handling operations for queries.

Structured Query Language SQL is a common application programming interface API for databases. SQL can be used by applications to access reporting views and extract the appropriate information. In most cases data is read in an aggregated manner which means the SQL statements issued by the applications contain a GROUP BY clause and aggregation functions on keyfigures e.g. sum min max .

The models views used by the HANA applications are created by the SAP HANA Modeler. This is a tool beside the standard HANA Administration console in eclipse just a different perspective . As this tool is decoupled from the HANA applications that display the data additional metadata information about the views like ViewAttribute and Keyfigures are stored in HANA tables that are read by such clients.

This concept gives the end user the freedom to create a reporting view once and consume it by different HANA applications. Due to this generic approach the HANA applications do not have the ability and logic to post process the extracted information. Therefore the HANA database must provide the correct result for all type of queries to guarantee a correct handling in all HANA applications. In most of the case this is done easily because the views and the SQL queries behave relational like it is defined in the SQL standard but in some case the HANA database must handle the queries differently in order to provide the correct expected result to the HANA applications. Typically those special cases occur when more complex operations like Exception Aggregation Count Distinct non summable calculated keyfigures or currency conversion are used in the views. Now the challenge is to embed the handling of these special cases into the given concept and the implementation of the calculation engine.

In one aspect a database server receives a query from a remote application server. The query is associated with a calculation scenario that defines a data flow model that includes a plurality of calculation nodes. Each calculation node defines one or more operations to execute on the database server and at least one of the nodes is a semantic node specifying an operation requiring special handling. Thereafter the database server modifies the query using the semantic node and additionally the calculation scenario based on the modified query. The modified calculation scenario can then be instantiated by the database server. The database server can then execute operations defined by the calculation nodes of the modified calculation scenario to result in at least one result set which can be provided to the application server.

The received query can specify an aggregation function on a calculated attribute such that the special handling specified by the semantic node overrides the aggregation function on the calculated attribute.

At least a portion of paths and or attributes defined by the calculation scenario can in some cases not be not required to respond to the query. In such cases the instantiated calculation scenario omits the paths and attributes defined by the calculation scenario that are not required to respond to the query.

At least one of the calculation nodes can filter results obtained from the database server. At least one of the calculation nodes can sort results obtained from the database server. The calculation scenario can be instantiated in a calculation engine layer by a calculation engine. The calculation engine layer can interact with a physical table pool and a logical layer. The physical table pool can include physical tables containing data to be queried and the logical layer can define a logical metamodel joining at least a portion of the physical tables in the physical table pool.

An input for each calculation node can include one or more of a physical index a join index an OLAP index and another calculation node. Each calculation node can have at least one output table that is used to generate the final result set. At least one calculation node can consume an output table of another calculation node.

In some variations the query can be forwarded to a calculation node in the calculation scenario that is identified as a default node if the query does not specify a calculation node at which the query should be executed.

The calculation scenario can include database metadata. The calculation scenario can be exposed as a database calculation view. In such cases a SQL processor can invoke the calculation engine to execute the calculation scenario behind the database calculation view. The calculation engine can invoke the SQL processor for executing set operations. The SQL processor can invoke the calculation engine when executing SQL queries with calculation views.

Computer program products are also described that comprise non transitory computer readable media storing instructions which when executed one or more data processors of one or more computing systems causes at least one data processor to perform operations herein. Similarly computer systems are also described that may include one or more data processors and a memory coupled to the one or more data processors. The memory may temporarily or permanently store instructions that cause at least one processor to perform one or more of the operations described herein. In addition methods can be implemented by one or more data processors either within a single computing system or distributed among two or more computing systems. Such computing systems can be connected and can exchange data and or commands or other instructions or the like via one or more connections including but not limited to a connection over a network e.g. the Internet a wireless wide area network a local area network a wide area network a wired network or the like via a direct connection between one or more of the multiple computing systems etc.

The subject matter described herein provides many advantages. For example the current subject matter provides a flexible extendible and powerful approach for special query handling. In particular the current subject matter can be used to ensure that database applications are always provided with the correct result even if a special query handling is required.

The details of one or more variations of the subject matter described herein are set forth in the accompanying drawings and the description below. Other features and advantages of the subject matter described herein will be apparent from the description and drawings and from the claims.

With reference to diagram of at a query is received by a database server from a remote application server. The query is associated with a calculation scenario that defines a data flow model that includes a plurality of calculation nodes. Each calculation node defining one or more operations to execute on the database server and at least one of the nodes is a semantic node specifying an operation requiring special handling. Thereafter at the database server modifies the query using the semantic node. In addition at the database server modifies the calculation scenario based on the modified query. The modified calculation scenario is at then instantiated so that at the database server can execute the operations defined by the calculation nodes of the modified calculation scenario to result in at least one result set. The at least one result set is then at provided by the database server to the application server.

The subject matter described herein can enable an application developer to define a data flow model to push down a high level algorithm to a database. A developer can define a calculation scenario which describes this algorithm in a general way as data flow consisting of calculation nodes. A calculation node as used herein represents a operation such as a projection aggregation join union minus intersection and the like. Additionally as described below in addition to a specified operation calculation nodes can sometimes be enhanced by filtering and or sorting criteria. In some implementations calculated attributes can also be added to calculation nodes.

During query time i.e. the time in which a database is queried the data flow specified by a calculation scenario is instantiated. During instantiation the calculation scenario is compacted to only include queries requirements by removing useless pathes and attributes that are not requested within the calculation scenario. This compaction reduces calculation time and also minimizes the total amount of data that must be processed.

As stated above calculation scenarios can include individual calculation nodes which in turn each define operations such as joining various physical or logical indexes and other calculation nodes e.g. CView 4 is a join of CView 2 and CView 3 . That is the input for a calculation node can be one or more physical join or OLAP views or calculation nodes.

In calculation scenarios two different representations can be provided. First a pure calculation scenario in which all possible attributes are given. Second an instantiated model that contains only the attributes requested in the query and required for further calculations . Thus calculation scenarios can be created that can be used for various queries. With such an arrangement calculation scenarios can be created which can be reused by multiple queries even if such queries do not require every attribute specified by the calculation scenario.

Every calculation scenario can be uniquely identifiable by a name i.e. the calculation scenario can be a database object with a unique identifier etc. . This means that the calculation scenario can be queried in a manner similar to a view in a SQL database. Thus the query is forwarded to the calculation node for the calculation scenario that is marked as the corresponding default node. In addition a query can be executed on a particular calculation node as specified in the query . Furthermore nested calculation scenarios can be generated in which one calculation scenario is used as source in another calculation scenario via a calculation node in this calculation scenario . Each calculation node can have one or more output tables. One output table can be consumed by several calculation nodes .

Further details regarding calculation engine architecture and calculation scenarios can be found in U.S. Pat. No. 8 195 643 the contents of which are hereby fully incorporated by reference.

The calculation scenario can be a directed acyclic graph with arrows representing data flows and nodes that represent operations. Each calculation node has a set of inputs and outputs and an operation that transforms the inputs into the outputs. In addition to their primary operation each calculation node can also have a filter condition for filtering the result set. The inputs and the outputs of the operations can be table valued parameters i.e. user defined table types that are passed into a procedure or function and provide an efficient way to pass multiple rows of data to the application server . Inputs can be connected to tables or to the outputs of other calculation nodes. Calculation scenarios can support a variety of node types such as i nodes for set operations such as projection aggregation join union minus intersection and ii SQL nodes that execute a SQL statement which is an attribute of the node. In addition to enable parallel execution a calculation scenario can contain split and merge operations. A split operation can be used to partition input tables for subsequent processing steps based on partitioning criteria. Operations between the split and merge operation can then be executed in parallel for the different partitions. Parallel execution can also be performed without split and merge operation such that all nodes on one level can be executed in parallel until the next synchronization point. Split and merge allows for enhanced automatically generated parallelization. If a user knows that the operations between the split and merge can work on portioned data without changing the result he or she can use a split. Then the nodes can be automatically multiplied between split and merge and partition the data.

A calculation scenario can be defined as part of database metadata and invoked multiple times. A calculation scenario can be created for example by a SQL statement CREATE CALCULATION SCENARIO USING . Once a calculation scenario is created it can be queried e.g. SELECT A B C FROM etc. . In some cases databases can have pre defined calculation scenarios default previously defined by users etc. . The calculation scenarios can be persisted in a repository coupled to the database server or in transient scenarios the calculation scenarios can be kept in memory.

Calculation scenarios are more powerful than traditional SQL queries or SQL views for many reasons. One reason is the possibility to define parameterized calculation schemas that are specialized when the actual query is issued. Unlike a SQL view a calculation scenario does not describe the actual query to be executed. Rather it describes the structure of the calculation. Further information is supplied when the calculation scenario is executed. This further information can include parameters that represent values for example in filter conditions . To obtain more flexibility it is also possible to refine the operations when the model is invoked. For example at definition time the calculation scenario may contain an aggregation node containing all attributes. Later the attributes for grouping can be supplied with the query. This allows having a predefined generic aggregation with the actual aggregation dimensions supplied at invocation time. The calculation engine can use the actual parameters attribute list grouping attributes and the like supplied with the invocation to instantiate a query specific calculation scenario . This instantiated calculation scenario is optimized for the actual query and does not contain attributes nodes or data flows that are not needed for the specific invocation.

When the calculation engine gets a request to execute a calculation scenario it can first optimize the calculation scenario using a rule based model optimizer . Examples for optimizations performed by the model optimizer can include pushing down filters and projections so that intermediate results are narrowed down earlier or the combination of multiple aggregation and join operations into one node. The optimized model can then be executed by a calculation engine model executor a similar or the same model executor can be used by the database directly in some cases . This includes decisions about parallel execution of operations in the calculation scenario . The model executor can invoke the required operators using for example a calculation engine operators module and manage intermediate results. Most of the operators are executed directly in the calculation engine e.g. creating the union of several intermediate results . The remaining nodes of the calculation scenario not implemented in the calculation engine can be transformed by the model executor into a set of logical database execution plans. Multiple set operation nodes can be combined into one logical database execution plan if possible.

The calculation scenarios of the calculation engine can be exposed as a special type of database views called calculation views. That means a calculation view can be used in SQL queries and calculation views can be combined with tables and standard views using joins and sub queries. When such a query is executed the database executor inside the SQL processor needs to invoke the calculation engine to execute the calculation scenario behind the calculation view. In some implementations the calculation engine and the SQL processor are calling each other on one hand the calculation engine invokes the SQL processor for executing set operations and SQL nodes and on the other hand the SQL processor invokes the calculation engine when executing SQL queries with calculation views.

The attributes of the incoming datasets utilized by the rules of model optimizer can additionally or alternatively be based on an estimated and or actual amount of memory consumed by the dataset a number of rows and or columns in the dataset and the number of cell values for the dataset and the like.

Calculation scenarios as described herein can include a new type of node referred to herein as a semantic node or sometimes semantic root node . A database modeler can flag the root node output in a graphical calculation view to which the queries of the database applications directed as semantic node. This arrangement allows the calculation engine to easily identify those queries and provide a proper handling of query in all cases.

In calculation views of a database modeler it can be possible to create calculated keyfigures at the semantic node that are not summable e.g. expressions such as keyfigure A divided by keyfigure B or keyfigure A plus a constant value etc . Those formulas can have different results depending at which aggregation level the formula is evaluated. In most cases the correct expected result is obtained when formulas are calculated at latest possible instance within the nodal hierarchy.

The current subject matter can help address those situations in which generic metadata information provided by the database to the database application s does not contain such highly specified information and additionally most of consumer developer of the database application do not have a complete understanding of such semantics. Hence the database application treats aggregation operations involving such a keyfigure like every standard keyfigure even though this might result in an incorrect result set. However with the use of the semantic node the calculation engine knows about the different semantic and changes the query which in turn requires the calculation scenario to be modified in a way that it creates the correct results.

As stated above the semantic node can be the top most node in a calculation scenario. If the top node in a calculation node is an aggregating node the calculation engine can distinguish between keyfigures measures which have an aggregation function like SUM MIN MAX . . . and the ViewAttributes which forms the GROUP BY.

If the top node is an aggregation with keyfigure SALES aggregation function SUM then a SELECT SALES COUNTRY FROM MY CALCSCEN will return 

This is equivalent to the query SELECT sum SALES COUNTRY FROM MY CALCSCEN because the sum is already defined in the calculation scenario.

Assume that the calculation scenario is queried with SELECT MIN SALES COUNTRY FROM MY CALCSCEN the result would be the same.

SELECT min SALES COUNTRY FROM SELECT sum SALES COUNTRY FROM MY CALCSCEN . So first SALES is summed up and afterwards min is applied which does not change the result anymore.

The semantic node now has the task to overwrite the aggregation function by modifying the query and using the modified query to modify the calculation scenario from to top most node of with the query an aggregation function is provided 

With reference to diagram of a database modeler can specify that a semantic node of a calculation scenario can provide the following 

With regard to the above can be characterized as a placeholder such as MY CALCSEN in the examples above.

The specified query using the semantic node is modified see diagram B of by the calculation engine will be as follows which will result in the corresponding calculation scenario being correspondingly modified 

With further reference to B because the upper node is switched to projection as operation the attribute CALC can also be characterized as a view attribute. Keyfigures can in some implementations only be allowed on operation nodes that aggregate somehow on all other nodes they can be handled as view attributes.

The current subject matter can be used to hide such complex operations essential for analytic reporting by using the semantic node in the database and to automatically provide the expected result to the user without having to specify such complex operations. Stated differently the semantic node can be used to override an aggregation function pre defined by the query. Additionally the function of the semantic node can be bound to a specific area of operation like business warehouse BW SAP PlanningScenarios or SAP MDX. So a semantic node in a BW scenario can allow for overwriting of aggregation functions of keyfigures but not in MDX scenarios. The advantage of the current approach is that the logic can be implemented once within the database and can be consumable by every database application. Further the use of a semantic node as described herein provides enhanced usability as deep knowledge of modeling is not required. Additionally such approach scales very well because such complex logic need not be distributed to broad audiences.

One or more aspects or features of the subject matter described herein may be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations may include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device e.g. mouse touch screen etc. and at least one output device.

These computer programs which can also be referred to as programs software software applications applications components or code include machine instructions for a programmable processor and can be implemented in a high level procedural language an object oriented programming language a functional programming language a logical programming language and or in assembly machine language. As used herein the term machine readable medium refers to any computer program product apparatus and or device such as for example magnetic discs optical disks memory and Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor. The machine readable medium can store such machine instructions non transitorily such as for example as would a non transient solid state memory or a magnetic hard drive or any equivalent storage medium. The machine readable medium can alternatively or additionally store such machine instructions in a transient manner such as for example as would a processor cache or other random access memory associated with one or more physical processor cores.

To provide for interaction with a user the subject matter described herein can be implemented on a computer having a display device such as for example a cathode ray tube CRT or a liquid crystal display LCD monitor for displaying information to the user and a keyboard and a pointing device such as for example a mouse or a trackball by which the user may provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well. For example feedback provided to the user can be any form of sensory feedback such as for example visual feedback auditory feedback or tactile feedback and input from the user may be received in any form including but not limited to acoustic speech or tactile input. Other possible input devices include but are not limited to touch screens or other touch sensitive devices such as single or multi point resistive or capacitive trackpads voice recognition hardware and software optical scanners optical pointers digital image capture devices and associated interpretation software and the like.

The subject matter described herein may be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user may interact with an implementation of the subject matter described herein or any combination of such back end middleware or front end components. The components of the system may be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

The computing system may include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

The subject matter described herein can be embodied in systems apparatus methods and or articles depending on the desired configuration. The implementations set forth in the foregoing description do not represent all implementations consistent with the subject matter described herein. Instead they are merely some examples consistent with aspects related to the described subject matter. Although a few variations have been described in detail above other modifications or additions are possible. In particular further features and or variations can be provided in addition to those set forth herein. For example the implementations described above can be directed to various combinations and subcombinations of the disclosed features and or combinations and subcombinations of several further features disclosed above. In addition the logic flow s depicted in the accompanying figures and or described herein do not necessarily require the particular order shown or sequential order to achieve desirable results. Other implementations may be within the scope of the following claims.

