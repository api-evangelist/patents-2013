---

title: System, method, and computer program product for compression of a bounding volume hierarchy
abstract: A system, method, and computer program product for compressing a bounding volume hierarchy is disclosed. The method includes the steps of receiving a bounding volume hierarchy and encoding the bounding volume hierarchy to generate an encoded bounding volume hierarchy, wherein each node in the encoded bounding volume hierarchy indicates whether the node inherits zero or more values from a parent node. The bounding volume hierarchy includes a plurality of nodes, each node in the plurality of nodes is associated with a bounding volume.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09224235&OS=09224235&RS=09224235
owner: NVIDIA Corporation
number: 09224235
owner_city: Santa Clara
owner_country: US
publication_date: 20130320
---
The present invention relates to computer rendering and more particularly to the representation of computer models in a bounding volume hierarchy.

Some computer graphics rendering algorithms particularly ray tracing algorithms utilize bounding volumes to make certain calculations more efficient. For example instead of intersecting a ray with a triangle the ray may be intersected with a cube or sphere that bounds the triangle. The calculations for intersecting the ray with the cube or sphere shaped bounding volume may be much simpler to perform than the calculations for intersecting the ray with the triangle. In order to easily access the objects in a 3D model bounding volumes may be organized in abounding volume hierarchy. The bounding volume hierarchy commonly takes the form of a binary tree or a quad tree. The leaf nodes of the tree store objects e.g. triangles in the model or bounding volumes associated with a single object and the parent node of two or more leaf nodes store bounding volumes that enclose each of the objects in the leaf nodes. The root node stores a bounding volume that encloses every object represented by the bounding volume hierarchy.

The bounding volume hierarchy may become quite large for complex models used in computer rendering algorithms. The models may contain hundreds of thousands or millions of individual graphics objects i.e. triangles . In addition to the data required to store each of the objects the bounding volume hierarchy must also store coordinates that represent the dimensions of the bounding volumes within the hierarchy. Commonly an uncompressed bounding volume hierarchy may be hundreds of megabytes MB or gigabytes GB in size. These bounding volume hierarchies are typically utilized by graphics processing units that include a dedicated local memory i.e. Random Access Memory or RAM . Local RAM sizes may only be 512 MB or 1 GB thereby limiting the size of bounding volume hierarchies that may be stored entirely on the local memory without implementing a backing store associated with long latencies for reading and writing. Long latency access to a backing store reduces the efficiency of the computer rendering algorithm thereby increasing the time it takes to render a scene. However reducing the size of the bounding volume hierarchy by limiting the number of objects in a model may reduce the quality of the rendering generated because the model is of lower resolution. Thus there is a need for more efficient compression of bounding volume hierarchies that addresses this issue and or other issues associated with the prior art.

A system method and computer program product for compressing a bounding volume hierarchy is disclosed. The method includes the steps of receiving a bounding volume hierarchy and encoding the bounding volume hierarchy to generate an encoded bounding volume hierarchy wherein each node in the encoded bounding volume hierarchy indicates whether the node inherits zero or more values from a parent node. The bounding volume hierarchy includes a plurality of nodes each node in the plurality of nodes is associated with a bounding volume.

It should be noted that while various optional features are set forth herein in connection with compressing bounding volume hierarchies such features are for illustrative purposes only and should not be construed as limiting in any manner. In one embodiment the method described above is implemented by a parallel processing unit.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using nip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The BVH includes leaf nodes e.g. nodes and that represent a single object. In one embodiment the leaf nodes include a pointer to a graphics object such as a primitive e.g. a triangle that is included in the model represented by the BVH . In another embodiment the leaf nodes include data that represents a bounding volume that bounds a single graphics object and a link or pointer to the graphics object that is stored in a separate location in memory. In yet another embodiment the leaf nodes include a graphics object i.e. rather than a pointer to the graphics object the node stores the graphics object itself . Each parent node e.g. node represents abounding volume that encloses every object represented by the parent node s child nodes. As shown in the parent node represents a bounding volume that encloses the graphics objects represented by child nodes and .

In one embodiment a bounding volume comprises an axis aligned rectilinear volume that completely encloses one or more graphics objects in the model space. For example a model may be defined as a set of triangles in a three dimensional 3D space. The 3D space is associated with a coordinate system having three orthogonal axes i.e. an x axis a y axis and a z axis . Bounding volumes are defined by the enclosed volume within six bounding planes perpendicular to one of the axes of the coordinate system. In other words a bounding volume is enclosed by the planes given by the equations x x x x y y y y z z and z z.

The size of the BVH can be quite large. As described each node includes at least 24 bytes of floating point values i.e. 6 single precision floating point values to describe the bounding volume associated with the node. A typical BVH may represent hundreds of thousands or millions of graphics objects. Assuming that the leaf nodes include at least 24 bytes of data for a bounding volume that encloses the graphics object associated with the leaf node a BVH for a model having 5 000 000 graphics objects has at least 120 MB of data just in specifying bounding volumes associated with the leaf nodes. In addition each parent node for every four leaf nodes in the case of a quad tree implementation has an additional bounding volume defined by six additional coordinates. Those parent nodes have additional parent nodes that include more bounding volumes and so forth. In addition to the data for storing bounding volume information the BVH may also include data for the graphics object e.g. a pointer to the graphics object in a separate data structure or the data the represents the graphics object as well as pointers and other information related to the hierarchical structure of the BVH . Thus the BVH may become quite large sometimes surpassing the available local memory of a PPU configured to render a scene.

In another embodiment each node includes the coordinates for the bounding volumes associated with each child node associated with the node. For example in a binary tree implementation of the BVH a root node may include six values associated with a first bounding volume for a left child node and six values associated with a second bounding volume for a right child node. Then each child node may include six values for a left grand child node and six values for a right grand child node where a grand child node is a child node of a child node. Although the format of each node is different than the format described above the structure of the hierarchy is the same i.e. each node is associated with a bounding volume that encloses each of the bounding volumes associated with a child node. The only difference is that the root node in this embodiment does not include one bounding volume that encloses every graphics object but includes two separate bounding volumes that enclose all of the graphics objects associated with a left child node and all of the graphics objects associated with aright child node respectively.

Each bounding volume may share one or more planes of the bounding volume with a bounding volume associated with a child node. In other words a bounding volume that encloses four other bounding volumes may share each of the six planes that comprise the bounding volume with one or more planes of one or more of the child nodes assuming that the bounding volume is a minimum bounding volume. Some of the child nodes may not share any planes with the bounding volume of the parent node. Other child nodes may share one plane e.g. x x with the bounding volume of the parent node. Yet other child nodes may share two or three planes with the bounding volume of the parent node. provide examples that show different cases where child nodes share zero or more planes with the bounding volume of a parent node using a two dimensional 2D example.

As shown in the bounding box shares a top surface y y a bottom surface y y and a left surface x x with the bounding box . The bounding box also shares a right surface x x with the bounding box . As makes clear the parent node i.e. the node associated with bounding box can inherit values for the surfaces of the bounding box from the child nodes associated with the bounding boxes and . Three values can be inherited from the child node associated with bounding box and one value can be inherited from the child node associated with bounding box . Conversely the parent node may store each of the values for the bounding box and the child nodes may inherit values from the parent node. For example the child node associated with bounding box may inherit three values from the parent node and the child node associated with bounding box may inherit one value from the parent node.

As shown in the bounding box shares all four surfaces with a bounding box . Note that the bounding box is not explicitly shown in because bounding box completely obscures the representation of bounding box in . It will be appreciated that the bounding box completely encloses the bounding box . Cases where the bounding box of one child node associated with a parent node completely enclose a bounding box of another child node associated with the parent node are uncommon and are typically avoided by properly balancing the BVH such that the bounding box is not on the same level of the BVH as the bounding box .

As shown in the bounding box does not share any surfaces with the bounding box or the bounding box . The bounding box may not be implemented as a minimum bounding box and therefore the surfaces of the bounding box may be beyond the extents of the surfaces of either of the bounding boxes and . Although not shown explicitly a child may also inherit no values from the bounding box of a parent node even when minimum bounding boxes are implemented when more than two child nodes are included within a parent node. In such cases e.g. when the BVH implements a quad tree or an octree one or more of the child nodes may be positioned such that two or more other child nodes share surfaces of the bounding box for the parent node which completely enclose the one or more child nodes without sharing any surfaces with the bounding box for the parent node.

Similarly provide examples using a binary tree implementation of a BVH . In some embodiments the BVH can be expanded to implement a quad tree or an octree as described above. In such cases four or eight bounding boxes associated with the child nodes respectively may be enclosed by the bounding box for the parent node. The binary tree implementation of the BVH illustrated in is described for illustrative purposes and is not to be construed as limiting in any manner.

In addition the data structure for a node may include a third field i.e. an offset field that indicates an offset from the base address for the node to the location of the child nodes associated with the node. For example following the data structure for the node additional data structures for one or more other nodes may be included in the data structure for the encoded BVH . If the data structure for a node is associated with a root node of a quad tree then four data structures associated with the child nodes of the root node may follow the data structure for the root node. The offset field indicates the offset from the base address of the node to the base address of the first child node associated with the node. Because each node may inherit a different number of values from a parent node the size of the data structure representing each node is variable. Thus the offset field provides an easy mechanism to quickly traverse the encoded BVH without decoding each and every node within the encoded BVH . In alternative embodiments the data structure for a node may include additional fields in lieu of or in addition to the fields described above in conjunction with .

In one embodiment the size of the data structure for a node may be adjusted based on the number of values for a bounding box associated with the node that are inherited from the bounding box of the parent node. The type of data structure implemented for the node may then be encoded in the inheritance field or an additional field of the data structure for the node. illustrates a data structure for a node that inherits two values from a parent node in accordance with one embodiment. As shown in if the node inherits two values from the parent node then the first field may include only four values e.g. and that represent the four new values for the bounding box for the node. The inheritance field indicates whether the values representing the planes of the bounding volume for the node are stored in the current node e.g. in values and or stored in the parent node as an inherited value . For example if the first bit in the inheritance field is 0 then the value for the minimum x coordinate of the bounding volume is stored in the first value of the first field . However if the first bit in the inheritance field is 1 then the value for the minimum x coordinate of the bounding volume is inherited from the parent node i.e. either stored in the first value of the first field of the parent node or inherited from the parent node of the parent node and so forth . Similarly if the second bit in the inheritance field is 0 then the value for the maximum x coordinate of the bounding volume is stored in either the second value of the first field if the first bit in the inheritance field was 0 or the first value of the first field if the first bit in the inheritance field was 1 . If the second bit in the inheritance field is 1 then the value for the maximum x coordinate of the bounding volume is inherited from the parent node. The values for the minimum and maximum y coordinates and z coordinates for the bounding box are read from the remaining values e.g. or 614 of the first field for the node or inherited from the parent node as indicated by the bits of the inheritance field .

As described above the data structure for a node that inherits two values from the bounding volume of the parent node is smaller than the data structure for a node that stores all six values for the bounding volume of the node. Using two bits for encoding the node type in the inheritance field enables each node within the BVH to have a variable width. Using two bits four different fixed length nodes may be defined. For example a first type of node may encode all six values for the bounding volume. A second type of node may encode four values for the bounding volume a third type of node may encode three values for the bounding volume and a fourth type of node may encode zero values for the bounding volume. In one embodiment the inheritance field may be located at the first byte at the base address for a node such that reading the first byte of the data structure for a node may indicate the length in bytes of the encoded node.

As shown in a bounding box is associated with a parent node and encloses a first bounding box associated with a first child node and a second bounding box associated with a second child node. Again although only two child nodes are associated with the parent node in corresponding to a binary tree implementation of the BVH in other embodiments more than two child nodes may be associated with each parent node e.g. in a quad tree implementation of the BVH . It will be appreciated that the bounding box for the parent node is associated with a left surface at x xand a right surface at x x. Similarly the bounding box for the first child node is associated with a left surface at x xand a right surface at x x and the bounding box for the second child node is associated with a left surface at x xand a right surface at x x. It will be appreciated that the first child node inherits a value from the bounding box such that x xand that similarly the second child node inherits a value from the bounding box such that x x.

The BVH may be compressed even beyond the use of inherited values by approximating the value for coordinates of the child bounding volumes. An interval between a minimum and maximum coordinate of the parent bounding box may be equally divided into a plurality of sub intervals. A value at the extents of each sub interval may be encoded using a lower number of bits than the number of bits used to encode the exact value. For example the interval between xand xmay be divided into seven intervals and the values at the edges of the intervals may be encoded using a fewer number of bits than the number of bits used to represent single precision floating point values i.e. 32 bits . Using seven intervals each of the floating point values can be approximately encoded using 3 bits i.e. eight codes representing eight different floating point values on the interval between xand xinclusive .

As shown in a line graph of the interval between xand xis equally divided into a number of intervals based on a number of bits chosen to use for encoding the values. Then a particular code is selected to approximate a value within the interval. In one embodiment each coordinate for the bounding volume associated with the selected axis is encoded based on whether the coordinate is associated with a plane of the bounding volume that represents a minimum coordinate or a maximum coordinate for the bounding volume. In other words a maximum coordinate is encoded using the next higher encoded value within the interval and a minimum coordinate is encoded using the next lower encoded value within the interval. The result of using the next higher or next lower encoded value is to generate loosely fitting bounding volumes that approximate the bounding volumes specified in the BVH .

As shown in a minimum coordinate x for the bounding box associated with the first child node is equal to x which is encoded using the 3 bit value 0b000 and the maximum coordinate x for the bounding box associated with the first child node is included within the fourth interval. Because xis a maximum coordinate for the bounding box the maximum coordinate is encoded using the code for the value at the upper end of the fourth interval which is encoded using the 3 bit value 0b100. Similarly a maximum coordinate x for the bounding box associated with the second child node is equal to x which is encoded using the 3 bit value and the minimum coordinate x for the bounding box associated with the second child node is included within the fifth interval. Because xis a minimum coordinate for the bounding box the minimum coordinate is encoded using the code for the value at the lower end of the fifth interval which is encoded using the 3 bit value 0b100.

For given floating point values of xand x the encoded values associated with a particular code c is given by Equation 1 where n is the number of bits and c is the decimal value of the n bit code.

So for the example illustrated in given a value of xequal to 32.6 and a value for xequal to 129.7 the encoded value corresponding to the code 0b100 is approximately equal to 88.1. Even though the original value for maximum x coordinate of the bounding box may have been something like 78.3 the value may be encoded as 88.1 using only 3 bits instead of the 32 necessary to encode the actual floating point number. Similarly even though the original value for the minimum x coordinate of the bounding box may have been something like 94.2 the value may be encoded as 88.1 using only 3 bits instead of the 32 necessary to encode the actual floating point number. Given that in ray tracing algorithms the BVH is typically utilized to determine an approximation of whether a ray intersects with a particular graphics object encoding the bounding volumes using a looser set of coordinates will typically not affect the results of the ray tracing algorithm. Although the use of encoded bounding volumes in certain algorithms may indicate that a ray intersects the encoded bounding volume where the ray would not have intersected the original uncompressed bounding volume this result typically only causes a small number of additional calculations. However some of these additional calculations may be offset by the fact that results of intersection calculations performed for a parent node may be reused in cases where the bounding volume for a child node inherits a value from the bounding box of the parent node. Consequently the reduction in memory requirements for the compressed BVH and the increase in model complexity that is enabled typically outweighs any concerns over processing inefficiency added to the algorithm due to the approximations of the encoding technique.

In one embodiment an algorithm for encoding the BVH may encode each node using a different number of bits to ensure that the accuracy of the encoding is within some threshold k. A constant may be chosen that represents an error threshold. The threshold k may be based on the value of the constant such as shown by Equation 2 where m is the level of the node in the BVH and f m is a function that returns a factor based on the level of the node. Eq. 2 

In other words a number of bits are chosen for encoding each node at a particular level of the BVH such that the maximum error resulting from the encoding is below a threshold value k. As shown in the error for the maximum x coordinate of the bounding box is eand the error for the minimum x coordinate of the bounding box is e. If the error is above the threshold k then one or more additional bits may be used to encode the values for the node. For example if is 3.4 and the value of f m for the first child node is 2 then additional bits may be used to encode the coordinates for the first child node if eis greater than 6.8. Given the previous example using 78.3 and 88.1 for the maximum x coordinate of the bounding box and the encoded value respectively the error is approximately 9.8 which is greater than the threshold value k of 6.8. Therefore in this example additional bits may be used to encode the interval between xand x. Using four bits instead of three bits generates fifteen intervals instead of only seven intervals resulting in a potentially smaller error between a given value and a corresponding encoded value at the expense of a greater number of bits used to encode the node.

In one embodiment the threshold k is larger for nodes closer to the base level of the BVH . In other words the approximation should be tighter the closer the node is to a leaf node. A less accurate approximation may be appropriate at nodes closest to the root node because calculations involving the nodes are intended to be coarse in nature. For example the root node may be associated with a bounding volume that encloses the entire model space. Each of four child nodes is associated with a bounding volume that encloses a different portion of the graphics objects within the model space. Therefore calculations involving the bounding boxes of the child nodes of the root node are only intended to indicate whether a ray may intersect one or more of a large portion e.g. of the graphics objects in the model and is not intended to identify whether a particular object is intersected by the ray. As the traversal of the BVH continues and the child nodes are closer to the leaf nodes that represent the actual graphics objects the bounding volume should represent approximately a minimum bounding volume such that calculations involving the encoded bounding volume approximate whether the ray actually intersects a particular graphics object.

In one embodiment the number of bits used to encode each coordinate associated with the node is included in a field at the beginning of the node. In such embodiments each node may be encoded with a variable number of bits for each value. In another embodiment a number of bits selected for encoding is constant for every node within the BVH . Thus a suitable number of bits for encoding is selected such that the error of every node within each level of the BVH is less than a threshold k associated with that level. In yet another embodiment the number of bits used to encode each coordinate for each node may be similar for particular groups of nodes. The groups of nodes may be defined at a boundary e.g. a particular level of the BVH . For example a special type of node may be encoded that specifies the number of bits used to encode coordinates for the group of nodes. Every subsequent node in the group is then encoded using the number of bits without specifying the number of bits in a field of each node. The same number of bits will be used until the next special type of node is encountered in the BVH hierarchy where the special types of nodes that include information about the number of bits defines a boundary between groups of nodes. In other words additional compression can be achieved by not encoding information about the number of bits used to encode coordinates with each node as the information for one node may be reused for one or more subsequent nodes.

In one embodiment the inheritance between nodes may be reset at a particular level of the encoded BVH . In other words at a particular level of the encoded BVH none of the nodes inherit any values from the bounding volumes of a parent node. Instead each node will store all six values for the bounding volume associated with the node and the inheritance field will indicate that none of the values are inherited from the parent node. In particular at such levels the full floating point values for the coordinates of the bounding volumes for the nodes may be stored in the encoded BVH . Having particular levels of the encoded BVH that aren t encoded ensures that the approximations based on the encoding and thus the error involved in the encoded values does not propagate fully from the root node down to each of the leaf nodes. In one embodiment in addition to the base level of the root node two additional levels of the encoded BVH may be selected where nodes do not inherit any values from a parent node and where the nodes are not encoded using approximate values for the single precision floating point values.

In one embodiment the data structure for a node includes a plurality of fields including a first field that represents zero or more coordinates for a bounding volume associated with the node. For example the first field may include one or more of a minimum x coordinate a maximum x coordinate a minimum y coordinate a maximum y coordinate a minimum z coordinate and a maximum z coordinate. The coordinates are encoded using a number of bits. Each coordinate is encoded based on the comparison of the coordinate to a number of equally divided intervals between a minimum coordinate for a bounding volume of a parent node and a maximum coordinate for abounding volume of the parent node. If the coordinate represents a minimum coordinate for the bounding volume of the node then the coordinate is encoded based on a value at the lower end of a sub interval corresponding to the coordinate. If the coordinate represents a maximum coordinate for the bounding volume of the node then the coordinate is encoded based on a value at the upper end of a sub interval corresponding to the coordinate. The plurality of fields may include a second field that indicates the inheritance characteristics of the node. The second field may also include one or more bits that indicate a type of the node. The plurality of fields may also include a third field that represents an offset from a base address for the node to a base address for one or more child nodes associated with the node.

At step the processing unit determines whether the error for each encoded coordinate of the node is below a threshold value. If the error is above the threshold value then at step the processing unit increases the number of bits used to encode the coordinates and the node is re encoded at step . However if the error is below the threshold value then at step the processing unit adds the data structure for the node to the data structure for the encoded BVH and determines whether the BVH includes more nodes. If the BVH includes more nodes the method returns to step where the next node is encoded and added to the data structure for the encoded BVH . Otherwise the method terminates.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU . In one embodiment the BVH may be encoded using either the processor or the graphics processor .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

