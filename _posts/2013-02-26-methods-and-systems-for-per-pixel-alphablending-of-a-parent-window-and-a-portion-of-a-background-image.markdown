---

title: Methods and systems for per pixel alpha-blending of a parent window and a portion of a background image
abstract: A system for alpha blending at least a portion of an image of a window with a background image, where the image of the window is captured by an alpha blender and blended together with an image of the background also captured by the alpha blender. The resulting alpha-blended image is then displayed within the window to give at least a portion of the window the appearance of smooth, anti-aliased edges.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08723887&OS=08723887&RS=08723887
owner: Citrix Systems, Inc.
number: 08723887
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20130226
---
This U.S. patent application is a continuation of U.S. patent application Ser. No. 12 556 540 titled Methods and Systems for Per Pixel Alpha Blending of a Parent Window and a Portion of a Background Image filed on Sep. 9 2009 which claims priority to U.S. Provisional Patent Application Ser. No. 61 095 610 filed on Sep. 9 2008 the disclosure of which is considered part of the disclosure of this application and is herein incorporated by reference in its entirety.

This application generally relates to methods and systems for alpha blending images. In particular this application relates to methods and systems for alpha blending a window and a portion of a background image.

Newer operating systems often times feature transparent window borders and in some cases transparent windows. Window transparency can often interfere with alpha blending because of the difficulties posed by trying to alpha blend an image to the desktop. In fact most alpha blending techniques do not interact with the desktop or other windows but rather alpha blend two images. Therefore it can be difficult to anti alias the corners of windows so that they appear smooth when contrasted against a background or other windows.

This disclosure describes methods and systems for alpha blending a window to a background image that can comprise any of the following a desktop one or more additional windows an image or any other object. Alpha blending techniques typically cannot be used to alpha blend one window to another window. Furthermore alpha blending techniques typically cannot be used to alpha blend one window to a desktop. The methods and systems described herein address these deficiencies by providing methods and systems for alpha blending at least portions of a window to a background image which can contain an image of a desktop or an image of a window.

In one aspect described herein is an embodiment of a method for alpha blending sections of a window with sections of a background region. A window manager executing on a computing machine obtains the coordinates of a window located over a background region. An alpha blender executing on the computing machine captures the window overlapping at least a portion of the captured background region image and then alpha blends the image of the window with a section of the background region image to generate a third image. A rendering agent executing on the computing machine then displays the third image within the window.

In one embodiment the alpha blender can capture an image of the background region where the size of the image is derived from the obtained window coordinates.

In other embodiments the alpha blender captures an image of the background region where the window wholly overlaps the background region image.

In one embodiments the alpha blender captures an image of the window while in other embodiments the alpha blender captures the image of a background region comprising a desktop and or the alpha blender captures an image of a background region comprising at least a second window.

The alpha blender in some embodiments captures an image of the background region where the background region image has a size and a location determined using the obtained window coordinates. In still other embodiments the alpha blender alpha blends an image of a portion of the window.

In one embodiment the alpha blender determines a first pixel in the window image that includes a first alpha channel value and a second pixel in the section of the background image that includes a second alpha channel value where the first alpha channel value is different than the second alpha channel value. The alpha blender then selects one of the first alpha channel value and the second alpha channel value and includes the selected alpha channel value in the generated third image.

In another aspect described herein is a system for alpha blending sections of a window with sections of a background region. Included in the system is a computing machine comprising a processor and memory and a window manager executing on a computing machine to obtain coordinates of a window located over a background region. Also included in the system is an alpha blender executing on the computing machine to capture an image of the background region the window overlapping at least a portion of the captured background region image and alpha blend an image of the window with a section of the background region image to generate a third image. Still further included is a rendering agent executing on the computing machine to display the third image within the window.

In some environments involving graphics processing two or more images may be merged together to produce a composite image. In one of these environments a technique may be employed to create an appearance of partial transparency where some or all of one image is visually superimposed over a second image while the occluded portion of the second image remains partially discernable in the composite image. One process for producing such a transparency effect is referred to as alpha blending or alpha compositing.

In some embodiments alpha blending in the area of computer graphics typically involves an alpha channel value ranging from 0 to 255. In one of the embodiments a value of 0 represents full transparency whereas a value of 255 indicates complete opaqueness when applied to an image or a pixel. In other embodiments taking a pixel of an bitmap image expressed in RGB triplets for example where R G and B represents the red green and blues color intensities respectively the pixel is typically represented as R G B . An alpha channel may be added to the pixel so that the pixel is now represented as an RGBA quartet R G B . In further embodiments when a first pixel R G B of a first image with an alpha channel is super imposed over a second pixel r g b of a second image without an alpha channel the composite image will then become 255 255 255 255 255 255 .

In one embodiment the resulting visual effect is a partially transparent first pixel on top of the second pixel. In another embodiment the alpha blending process can be extended to additional pixels of the two images super imposed over each other.

Alpha blending may be applied to bitmap images or any image represented by pixels or similar discrete elements. A bitmap may also be referred to as a pixmap. Examples of image file formats using bitmap are BMP and MICROSOFT DIB. Many other image file formats such as TIFF PNG JPEG and GIF store bitmap images but may additionally apply compression for efficient storage. Other non bitmap image file formats may also support alpha blending. Portions of bitmap images down to each discrete element may be characterized by their own distinct value. Therefore generally any bitmap image associated with any object in an object oriented programming environment may be alpha blended to another bitmap image.

A client machine within the computing environment may in some embodiments be referenced by any one of the following terms client machine s client s client computer s client device s client computing device s local machine remote machine client node s endpoint s endpoint node s or a second machine. The server in some embodiments may be referenced by any one of the following terms server s local machine remote machine server farm s host computing device s or a first machine s .

The client machine can in some embodiments execute operate or otherwise provide an application that can be any one of the following software a program executable instructions a web browser a web based client a client server application a thin client computing client an ActiveX control a Java applet software related to voice over internet protocol VoIP communications like a soft IP telephone an application for streaming video and or audio an application for facilitating real time data communications a HTTP client a FTP client an Oscar client a Telnet client or any other type and or form of executable instructions capable of executing on client machine . Still other embodiments may include a computing environment with an application that is any of either server based or remote based and an application that is executed on the server on behalf of the client machine . Further embodiments of the computing environment include a server configured to display output graphical data to a client machine using a thin client or remote display protocol where the protocol used can be any one of the following protocols the Independent Computing Architecture ICA protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. or the Remote Desktop Protocol RDP manufactured by the Microsoft Corporation of Redmond Wash.

In one embodiment the client machine can be a virtual machine C such as those manufactured by XenSolutions Citrix Systems IBM VMware or any other virtual machine able to implement the methods and systems described herein.

The computing environment can in some embodiments include more than one server A N where the servers A N are grouped together as a single server entity logically grouped together in a server farm geographically dispersed and logically grouped together in a server farm located proximate to each other and logically grouped together in a server farm . Geographically dispersed servers A N within a server farm can in some embodiments communicate using a WAN MAN or LAN where different geographic regions can be characterized as different continents different regions of a continent different countries different states different cities different campuses different rooms or any combination of the preceding geographical locations. In some embodiments the server farm may be administered as a single entity or in other embodiments may include multiple server farms . The computing environment can include more than one server A N grouped together in a single server farm where the server farm is heterogeneous such that one server A N is configured to operate according to a first type of operating system platform e.g. WINDOWS NT manufactured by Microsoft Corp. of Redmond Wash. while one or more other servers A N are configured to operate according to a second type of operating system platform e.g. Unix or Linux more than one server A N is configured to operate according to a first type of operating system platform e.g. WINDOWS NT while another server A N is configured to operate according to a second type of operating system platform e.g. Unix or Linux or more than one server A N is configured to operate according to a first type of operating system platform e.g. WINDOWS NT while more than one of the other servers A N are configured to operate according to a second type of operating system platform e.g. Unix or Linux .

The computing environment can in some embodiments include a server or more than one server configured to provide the functionality of any one of the following server types a file server an application server a web server a proxy server an appliance a network appliance a gateway an application gateway a gateway server a virtualization server a deployment server a SSL VPN server a firewall a web server an application server or as a master application server a server configured to operate as an active direction a server configured to operate as application acceleration application that provides firewall functionality application functionality or load balancing functionality or other type of computing machine configured to operate as a server . In some embodiments a server may include a remote authentication dial in user service such that the server is a RADIUS server. Embodiments of the computing environment where the server comprises an appliance the server can be an appliance manufactured by any one of the following manufacturers the Citrix Application Networking Group Silver Peak Systems Inc Riverbed Technology Inc. F5 Networks Inc. or Juniper Networks Inc. Some embodiments include a server with the following functionality a first server A that receives requests from a client machine forwards the request to a second server B and responds to the request generated by the client machine with a response from the second server B acquires an enumeration of applications available to the client machines and address information associated with a server hosting an application identified by the enumeration of applications presents responses to client requests using a web interface communicates directly with the client to provide the client with access to an identified application receives output data such as display data generated by an execution of an identified application on the server .

The server can be configured to execute any one of the following applications an application providing a thin client computing or a remote display presentation application any portion of the CITRIX ACCESS SUITE by Citrix Systems Inc. like the METAFRAME or CITRIX PRESENTATION SERVER MICROSOFT WINDOWS Terminal Services manufactured by the Microsoft Corporation or an ICA client developed by Citrix Systems Inc. Another embodiment includes a server configured to execute an application so that the server may function as an application server such as any one of the following application server types an email server that provides email services such as MICROSOFT EXCHANGE manufactured by the Microsoft Corporation a web or Internet server a desktop sharing server or a collaboration server. Still other embodiments include a server that executes an application that is any one of the following types of hosted servers applications GOTOMEETING provided by Citrix Online Division Inc. WEBEX provided by WebEx Inc. of Santa Clara Calif. or Microsoft Office LIVE MEETING provided by Microsoft Corporation.

In one embodiment the server may be a virtual machine B such as those manufactured by Citrix Systems IBM VMware or any other virtual machine able to implement the methods and systems described herein.

Client machines may function in some embodiments as a client node seeking access to resources provided by a server or as a server providing other clients A N with access to hosted resources. One embodiment of the computing environment includes a server that provides the functionality of a master node. Communication between the client machine and either a server or servers A N can be established via any of the following methods direct communication between a client machine and a server A N in a server farm a client machine that uses a program neighborhood application to communicate with a server in a server farm or a client machine that uses a network to communicate with a server A N in a server farm . One embodiment of the computing environment includes a client machine that uses a network to request that applications hosted by a server A N in a server farm execute and uses the network to receive from the server A N graphical display output representative of the application execution. In other embodiments a master node provides the functionality required to identify and provide address information associated with a server hosting a requested application. Still other embodiments include a master node that can be any one of the following a server A N within the server farm a remote computing machine connected to the server farm but not included within the server farm a remote computing machine connected to a client but not included within a group of client machines or a client machine .

The network between the client machine and the server is a connection over which data is transferred between the client machine and the server . In some embodiments the connection between the client and the server can be multiple connections. Although the illustration in depicts a network connecting the client machines to the servers other embodiments include a computing environment with client machines installed on the same network as the servers . Other embodiments can include a computing environment with a network that can be any of the following a local area network LAN a metropolitan area network MAN a wide area network WAN a primary network comprised of multiple sub networks located between the client machines and the servers a primary public network with a private sub network a primary private network with a public sub network or a primary private network with a private sub network . Still further embodiments include a network that can be any of the following network types a point to point network a broadcast network a telecommunications network a data communication network a computer network an ATM Asynchronous Transfer Mode network a SONET Synchronous Optical Network network a SDH Synchronous Digital Hierarchy network a wireless network a wireline network a network that includes a wireless link where the wireless link can be an infrared channel or satellite band or any other network type able to transfer data from client machines to servers and vice versa to accomplish the methods and systems described herein. Network topology may differ within different embodiments possible network topologies include a bus network topology a star network topology a ring network topology a repeater based network topology a tiered star network topology or any other network topology able transfer data from client machines to servers and vice versa to accomplish the methods and systems described herein. Additional embodiments may include a network of mobile telephone networks that use a protocol to communicate among mobile devices where the protocol can be any one of the following AMPS TDMA CDMA GSM GPRS UMTS or any other protocol able to transmit data among mobile devices to accomplish the systems and methods described herein.

Illustrated in is an embodiment of a computing device where the client machine and server illustrated in can be deployed as and or executed on any embodiment of the computing device illustrated and described herein. Included within the computing device is a system bus that communicates with the following components a central processing unit a main memory storage memory an input output I O controller display devices A N an installation device and a network interface . In one embodiment the storage memory includes an operating system software routines and a client agent . The I O controller in some embodiments is further connected to a key board and a pointing device . Other embodiments may include an I O controller connected to more than one input output device A N.

Embodiments of the computing machine can include a central processing unit characterized by any one of the following component configurations logic circuits that respond to and process instructions fetched from the main memory unit a microprocessor unit such as those manufactured by Intel Corporation those manufactured by Motorola Corporation those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor such as those manufactured by International Business Machines a processor such as those manufactured by Advanced Micro Devices or any other combination of logic circuits capable of executing the systems and methods described herein. Still other embodiments of the central processing unit may include any combination of the following a microprocessor a microcontroller a central processing unit with a single processing core a central processing unit with two processing cores or a central processing unit with more than one processing cores.

One embodiment of the computing machine includes a central processing unit that communicates with cache memory via a secondary bus also known as a backside bus while another embodiment of the computing machine includes a central processing unit that communicates with cache memory via the system bus . The local system bus can in some embodiments also be used by the central processing unit to communicate with more than one type of I O devices A N. In some embodiments the local system bus can be any one of the following types of buses a VESA VL bus an ISA bus an EISA bus a MicroChannel Architecture MCA bus a PCI bus a PCI X bus a PCI Express bus or a NuBus. Other embodiments of the computing machine include an I O device A N that is a video display that communicates with the central processing unit via an Advanced Graphics Port AGP . Still other versions of the computing machine include a processor connected to an I O device A N via any one of the following connections HyperTransport Rapid I O or InfiniBand. Further embodiments of the computing machine include a communication connection where the processor communicates with one I O device A using a local interconnect bus and with a second I O device B using a direct connection.

Included within some embodiments of the computing device is each of a main memory unit and cache memory . The cache memory will in some embodiments be any one of the following types of memory SRAM BSRAM or EDRAM. Other embodiments include cache memory and a main memory unit that can be any one of the following types of memory Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM Ferroelectric RAM FRAM or any other type of memory device capable of executing the systems and methods described herein. The main memory unit and or the cache memory can in some embodiments include one or more memory devices capable of storing data and allowing any storage location to be directly accessed by the central processing unit . Further embodiments include a central processing unit that can access the main memory via one of either a system bus a memory port or any other connection bus or port that allows the processor to access memory .

One embodiment of the computing device provides support for any one of the following installation devices a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device a bootable medium a bootable CD a bootable CD for GNU Linux distribution such as KNOPPIX a hard drive or any other device suitable for installing applications or software. Applications can in some embodiments include a client agent or any portion of a client agent . The computing device may further include a storage device that can be either one or more hard disk drives or one or more redundant arrays of independent disks where the storage device is configured to store an operating system software programs applications or at least a portion of the client agent . A further embodiment of the computing device includes an installation device that is used as the storage device .

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 SNA DECNET broadband connections e.g. ISDN Frame Relay ATM Gigabit Ethernet Ethernet over SONET wireless connections or some combination of any or all of the above. Connections can also be established using a variety of communication protocols e.g. TCP IP IPX SPX NetBIOS Ethernet ARCNET SONET SDH Fiber Distributed Data Interface FDDI RS232 RS485 IEEE 802.11 IEEE 802.11a IEEE 802.11b IEEE 802.11g CDMA GSM WiMax and direct asynchronous connections . One version of the computing device includes a network interface able to communicate with additional computing devices via any type and or form of gateway or tunneling protocol such as Secure Socket Layer SSL or Transport Layer Security TLS or the Citrix Gateway Protocol manufactured by Citrix Systems Inc. Versions of the network interface can comprise any one of a built in network adapter a network interface card a PCMCIA network card a card bus network adapter a wireless network adapter a USB network adapter a modem or any other device suitable for interfacing the computing device to a network capable of communicating and performing the methods and systems described herein.

Embodiments of the computing device include any one of the following I O devices A N a keyboard a pointing device mice trackpads an optical pen trackballs microphones drawing tablets video displays speakers inkjet printers laser printers and dye sublimation printers or any other input output device able to perform the methods and systems described herein. An I O controller may in some embodiments connect to multiple I O devices A N to control the one or more I O devices. Some embodiments of the I O devices A N may be configured to provide storage or an installation medium while others may provide a universal serial bus USB interface for receiving USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. Still other embodiments of an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire 800 bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

In some embodiments the computing machine can connect to multiple display devices A N in other embodiments the computing device can connect to a single display device while in still other embodiments the computing device connects to display devices A N that are the same type or form of display or to display devices that are different types or forms. Embodiments of the display devices A N can be supported and enabled by the following one or multiple I O devices A N the I O controller a combination of I O device s A N and the I O controller any combination of hardware and software able to support a display device A N any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . The computing device may in some embodiments be configured to use one or multiple display devices A N these configurations include having multiple connectors to interface to multiple display devices having multiple video adapters with each video adapter connected to one or more of the display devices A N having an operating system configured to support multiple displays A N using circuits and software included within the computing device to connect to and use multiple display devices A N and executing software on the main computing device and multiple secondary computing devices to enable the main computing device to use a secondary computing device s display as a display device A N for the main computing device . Still other embodiments of the computing device may include multiple display devices A N provided by multiple secondary computing devices and connected to the main computing device via a network.

In some embodiments of the computing machine an operating system may be included to control task scheduling and access to system resources. Embodiments of the computing device can run any one of the following operation systems versions of the MICROSOFT WINDOWS operating systems such as WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE WINDOWS XP and WINDOWS VISTA the different releases of the Unix and Linux operating systems any version of the MAC OS manufactured by Apple Computer OS 2 manufactured by International Business Machines any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. One embodiment of the computing machine has multiple operating systems installed thereon.

The computing machine can be embodied in any one of the following computing devices a computing workstation a desktop computer a laptop or notebook computer a server a handheld computer a mobile telephone a portable telecommunication device a media playing device a gaming system a mobile computing device a device of the IPOD family of devices manufactured by Apple Computer any one of the PLAYSTATION family of devices manufactured by the Sony Corporation any one of the Nintendo family of devices manufactured by Nintendo Co any one of the XBOX family of devices manufactured by the Microsoft Corporation or any other type and or form of computing telecommunications or media device that is capable of communication and that has sufficient processor power and memory capacity to perform the methods and systems described herein. In other embodiments the computing machine can be a mobile device such as any one of the following mobile devices a JAVA enabled cellular telephone or personal digital assistant PDA such as the i55sr i58sr i85s i88s i90c i95c1 or the im1100 all of which are manufactured by Motorola Corp the 6035 or the 7135 manufactured by Kyocera the i300 or i330 manufactured by Samsung Electronics Co. Ltd the TREO 180 270 600 650 680 700p 700w or 750 smart phone manufactured by Palm Inc any computing device that has different processors operating systems and input devices consistent with the device or any other mobile computing device capable of performing the methods and systems described herein. Still other embodiments of the computing environment include a mobile computing device that can be any one of the following any one series of Blackberry or other handheld device manufactured by Research In Motion Limited the iPhone manufactured by Apple Computer any handheld or smart phone a Pocket PC a Pocket PC Phone or any other handheld mobile device supporting Microsoft Windows Mobile Software.

Referring now to together the servers comprise a farm or server farm where each server can include a network side interface and a farm side interface . The network side interface can be in communication with one or more clients or a network . The network can be a WAN LAN or any other embodiment of a network such those networks described above.

Each server has a farm side interface connected with one or more farm side interface s of other servers in the farm . In one embodiment each farm side interface is interconnected to other farm side interfaces such that the servers within the farm may communicate with one another. On each server the farm side interface communicates with the network side interface . The farm side interfaces can also communicate designated by arrows with a persistent store and in some embodiments with a dynamic store . The combination of servers the persistent store and the dynamic store when provided are collectively referred to as a farm . In some embodiments a server communicates with the persistent store and other servers communicate with the server to access information stored in the persistent store.

The persistent store may be physically implemented on a disk disk farm a redundant array of independent disks RAID writeable compact disc or any other device that allows data to be read and written and that maintains written data if power is removed from the storage device. A single physical device may provide storage for a plurality of persistent stores i.e. a single physical device may be used to provide the persistent store for more than one farm . The persistent store maintains static data associated with each server in farm and global data used by all servers within the farm . In one embodiment the persistent store may maintain the server data in a Lightweight Directory Access Protocol LDAP data model. In other embodiments the persistent store stores server data in an ODBC compliant database. For the purposes of this description the term static data refers to data that does not change frequently i.e. data that changes only on an hourly daily or weekly basis or data that never changes. Each server uses a persistent storage subsystem to read data from and write data to the persistent store .

The data stored by the persistent store may be replicated for reliability purposes either physically or logically. For example physical redundancy may be provided using a set of redundant mirrored disks each providing a copy of the data. In other embodiments the database itself may be replicated using standard database techniques to provide multiple copies of the database. In further embodiments both physical and logical replication may be used concurrently.

The dynamic store i.e. the collection of all record tables can be embodied in various ways. In one embodiment the dynamic store is centralized that is all runtime data are stored in the memory of one server in the farm . That server operates as a master network node with which all other servers in the farm communicate when seeking access to that runtime data. In another embodiment each server in the farm keeps a full copy of the dynamic store . Here each server communicates with every other server to keep its copy of the dynamic store up to date.

In another embodiment each server maintains its own runtime data and communicates with other servers when seeking to obtain runtime data from them. Thus for example a server attempting to find an application program requested by the client may communicate directly with every other server in the farm to find one or more servers hosting the requested application.

For farms having a large number of servers the network traffic produced by these embodiments can become heavy. One embodiment alleviates heavy network traffic by designating a subset of the servers in a farm typically two or more as collector points. Generally a collector point is a server that collects run time data. Each collector point stores runtime data collected from certain other servers in the farm . Each server in the farm is capable of operating as and consequently is capable of being designated as a collector point. In one embodiment each collector point stores a copy of the entire dynamic store . In another embodiment each collector point stores a portion of the dynamic store i.e. it maintains runtime data of a particular data type. The type of data stored by a server may be predetermined according to one or more criteria. For example servers may store different types of data based on their boot order. Alternatively the type of data stored by a server may be configured by an administrator using an administration tool Not Shown. In these embodiments the dynamic store is distributed amongst two or more servers in the farm .

Servers not designated as collector points know the servers in a farm that are designated as collector points. A server not designated as a collector point may communicate with a particular collector point when delivering and requesting runtime data. Consequently collector points lighten network traffic because each server in the farm communicates with a single collector point server rather than with every other server when seeking to access the runtime data.

Each server can operate as a collector point for more than one type of data. For example server can operate as a collector point for licensing information and for loading information. In these embodiments each collector point may amass a different type of run time data. For example to illustrate this case the server can collect licensing information while the server collects loading information.

In some embodiments each collector point stores data that is shared between all servers in a farm . In these embodiments each collector point of a particular type of data exchanges the data collected by that collector point with every other collector point for that type of data in the farm . Thus upon completion of the exchange of such data each collector point and possesses the same data. Also in these embodiments each collector point and also keeps every other collector point abreast of any updates to the runtime data.

Browsing enables a client to view farms servers and applications in the farms and to access available information such as sessions throughout the farm . Each server includes an ICA browsing subsystem to provide the client with browsing capability. After the client establishes a connection with the ICA browser subsystem of any of the servers that browser subsystem supports a variety of client requests. Such client requests include 1 enumerating names of servers in the farm 2 enumerating names of applications published in the farm 3 resolving a server name and or application name to a server address that is useful the client . The ICA browser subsystem also supports requests made by clients running a program neighborhood application that provides the client upon request with a view of those applications within the farm for which the user is authorized. The ICA browser subsystem forwards all of the above mentioned client requests to the appropriate subsystem in the server .

In one embodiment each server in the farm that has a program neighborhood subsystem can provide the user of a client with a view of applications within the farm . The program neighborhood subsystem may limit the view to those applications for which the user of the client has authorization to access. Typically this program neighborhood service presents the applications to the user as a list or a group of icons.

The functionality provided by the program neighborhood subsystem can be available to two types of clients 1 program neighborhood enabled clients that can access the functionality directly from a client desktop and 2 non program neighborhood enabled clients e.g. legacy clients that can access the functionality by running a program neighborhood enabled desktop on the server.

Communication between a program neighborhood enabled client and the program neighborhood subsystem may occur over a dedicated virtual channel that is established on top of an ICA virtual channel. In other embodiments the communication occurs using an XML service. In one of these embodiments the program neighborhood enabled client communicates with an XML subsystem such as the XML service described in connection with below providing program neighborhood functionality on a server .

In one embodiment the program neighborhood enabled client does not have a connection with the server with a program neighborhood subsystem . For this embodiment the client sends a request to the ICA browser subsystem to establish an ICA connection to the server in order to identify applications available to the client . The client then runs a client side dialog that acquires the credentials of a user. The credentials are received by the ICA browser subsystem and sent to the program neighborhood subsystem . In one embodiment the program neighborhood subsystem sends the credentials to a user management subsystem for authentication. The user management subsystem may return a set of distinguished names representing the list of accounts to which the user belongs. Upon authentication the program neighborhood subsystem establishes the program neighborhood virtual channel. This channel remains open until the application filtering is complete.

The program neighborhood subsystem then requests the program neighborhood information from the common application subsystem associated with those accounts. The common application subsystem obtains the program neighborhood information from the persistent store . On receiving the program neighborhood information the program neighborhood subsystem formats and returns the program neighborhood information to the client over the program neighborhood virtual channel. Then the partial ICA connection is closed.

For another example in which the program neighborhood enabled client establishes a partial ICA connection with a server consider the user of the client who selects a farm . The selection of the farm sends a request from the client to the ICA browser subsystem to establish an ICA connection with one of the servers in the selected farm . The ICA browser subsystem sends the request to the program neighborhood subsystem which selects a server in the farm . Address information associated with the server is identified and returned to the client by way of the ICA browser subsystem . The client can then subsequently connect to the server corresponding to the received address information.

In another embodiment the program neighborhood enabled client establishes an ICA connection upon which the program neighborhood virtual channel is established and remains open for as long as the ICA connection persists. Over this program neighborhood virtual channel the program neighborhood subsystem pushes program neighborhood information updates to the client . To obtain updates the program neighborhood subsystem subscribes to events from the common application subsystem to allow the program neighborhood subsystem to detect changes to published applications.

Referring now to in more detail the computing machine can be any computing machine . In some embodiments the computing machine can be any computing machine described herein. The computing machine can comprise a processor and a memory and in some embodiments can execute a window manager a rendering agent and an alpha blender .

The window manager in some embodiments controls the placement and appearance of windows within a windowing system in a graphical user interface GUI. In one embodiment the window manager draws the desktop and communicates with the rendering agent a graphical processing unit Not Shown and any other applications or components used to render graphics windows text and other objects displayed on the desktop. A window manager can carry out for the user various operations pertaining to windows in a desktop environment such as opening closing minimizing maximizing resizing and moving windows. A window manager can also track which windows are running and window decorations in a desktop environment. Window decorations provided by a window manager generally improve the usability of a window desktop environment by providing features such as a title bar for each running window and a minimal border around the window. The border may contain buttons to perform functionality pertaining to the window such as minimizing maximizing and closing the window.

Generally a windowing environment of a computing machine can in some embodiments provide functionality for grouping and overlaying objects on a display. A plurality of windows may also overlay each other in a z ordering system. The overlay portion of at least one object or window can be clipped on the display when obscured by another object or window above it in the z ordering system. In some embodiments the window manager can be a stacking window manager that allows windows to overlap by drawing them in a specific order one at a time. The stacking window manager renders an image of each window directly over the desktop and any other windows that may already have been drawn. Generally the process usually begins with the desktop and each window and any child windows are drawn from back to front until the foreground window is drawn.

In some embodiments the window manager can be a tiling window manager that organizes the screen into mutually non overlapping windows. In other embodiments the window manager is a hybrid of the different types of window managers described herein.

In still other embodiments the window manager can be a compositing window manager that draws windows and their borders. A compositing window manager provides that each program outputs to a separate and independent buffer or other temporary location within the computing device . The data in the buffer can then be manipulated prior to being displayed by the computing device . The output of the multiple buffers is then processed and combined by the compositing window manager onto a common desktop resulting in the windows behaving as independent objects and allowing overlapping of the objects. The compositing windows manager in some embodiments provides advanced visual effects such as transparency fading scaling bending duplicating contorting shuffling and redirecting applications.

A window manager in many embodiments is a program application agent client or software executing on a computing machine . The window manager can mange or monitor window messages and in some embodiments can intercept window messages. In still another embodiment the window manager monitors a message queue that stores a list or array of messages generated by any one of the following an application executing within a window a process executing within a window the operating system in response to actions performed by a user or application or a graphical data interface.

Windows messages in some embodiments are system calls to the operating system. In other embodiments window messages are generated when a window is moved resized created killed or otherwise manipulated by a user an application another object or an operating system. In another embodiment some of the window messages are generated when a user activates an object in the WINDOWS environment such as clicking on a button with a pointing device. In still another embodiment some of the window messages are generated when any graphical data on the screen changes. In one embodiment one of the window messages includes a command to erase graphical data associated with an object. In another embodiment one of the window messages includes a command to load graphical data associated with an object for example to populate a screen region associated with a window with a bitmap image. In other embodiments one of the window messages can prompt the window manager to take any of the actions described below.

Still referring to in one embodiment the window manager communicates with an alpha blender executing on the computing machine . The alpha blender can execute within a rendering agent or can execute outside of the rendering agent on the computing machine . The alpha blender can be a part of the rendering agent yet in other embodiments the alpha blender may execute on a different computing machine than the rendering agent . In some embodiments the alpha blender communicates with the rendering agent such that the alpha blender forwards display data and alpha blended images to the rendering agent for rendering and display. In some embodiments the alpha blender is implemented in hardware while in other embodiments the alpha blender is a program application client or agent executing on the computing machine by a processor within the computing machine . In some embodiments the alpha blender is implemented using a combination of software and hardware.

The alpha blender communicates with the window manager to obtain the location and size of a window. Using the information received from the window manager the alpha blender generates an image of the window. If the window spans multiple displays multiple window images are generated for each portion of the window shown on a different display. The alpha blender also generates a background image of the desktop environment displayed beneath the window. In some embodiments the background image may include only the desktop including any icons docks task bars program launchers and wallpaper. In other embodiments the background image may include the desktop and another window. In still other embodiments the background image may include the desktop and multiple windows. When multiple displays are used the alpha blender generates multiple background images where a background image is generated for each display a portion of the window is shown.

Upon generating images of the window to be alpha blended and the background underneath the window the alpha blender can use standard alpha blending techniques such as those discussed above to blend the window image and the background image. In some embodiments the window image is sub divided into multiple portions and in other embodiments the background image is sub divided into multiple portions. The portions of the background image in some embodiments can correspond to the portions of the window image. The alpha blender in one embodiment can determine which portions of the window image correspond to the sub divided portions of the background image and then alpha blends those matching portions together. The size of the portion of the window image and the portion of the background image that are alpha blended together by the alpha blender in some embodiments is a predetermined size that can be designated by an application a user an administrator configuration settings of the alpha blender the alpha blender the rendering agent or the system .

The rendering agent in some embodiments receives the alpha blended image comprised of a portion of the window image and a portion of the background image and renders a display. In one embodiment the rendering agent generates display data and forwards the data to window manager which displays the display data on the desktop. In some embodiments the rendering agent can be an application program agent client or other set of executable instructions executed by the computing machine . In other embodiments the rendering agent can be a hardware device such as a graphical processing unit. In still other embodiments the rendering agent can be a combination of hardware and executable instructions.

Referring now to illustrated is a block diagram that depicts an embodiment of a per pixel alpha blending of a window image and a portion of a background image . In brief overview the diagram includes a background image under a window image and the portion of the background image used during to alpha blend. The portion of the window image that is alpha blended to the portion of the background image is also depicted.

In one embodiment the window manager extracts at least a portion of the background image from the background image stored in a storage component of the computing machine . Extraction of the portion of the background image can include generating a snapshot of the background and selecting a portion of the resulting image. A snapshot in some embodiments can be a picture image capture or screen shot of a display background or desktop. The resulting image in some embodiments can comprise a graphical representation of the objects displayed on the desktop. These objects can include a window a desktop a mouse pointer or any other object or window displayed on the desktop. In some embodiments the window manager can extract a portion of the background image while in other embodiments the alpha blender can extract a portion of the background image. The background image can be in any image format such as JPEG GIF TIFF or BMP.

The window manager in some embodiments can receive a portion of the background image from a frame buffer containing the background image . In still another embodiment the window manager extracts the portion of the background image by removing graphical data associated with the window image to temporarily expose the desktop graphical data in the identified screen region and then captures the desktop graphical data in the identified screen region. In still even another embodiment the capturing mechanism leverages a Print Screen handler provided in a WINDOWS environment to capture an image of the background.

The window manager in some embodiments stretches the plurality of bitmap images according to the size of the window image . In another embodiment the stretching of the plurality of bitmap images is a manual process. In still another embodiment the window manager generates a window image from the plurality of bitmap images. In still another embodiment the window manager generates a third image comprising the second image alpha blended with the first image . In yet another embodiment the window manager performs at least one of the functions described above through at least one application programming interface API provided by an operating system or an application.

In one embodiment the background image may span the entire screen display or may be a desktop wallpaper or a tiled image. In still other embodiments the background image can span an entire display which in some embodiments can include one or more display screens e.g. a dual triple or quadruple screen display. In some embodiments the desktop image can be an expanded version of an image file provided by an operating system an application or a user. In some of these embodiments some of the imported images may be vector images represented by mathematical description rather than bitmaps. In one embodiment the imported image or images forming the desktop image may be stored as separate files. In another embodiment the imported image or images forming the desktop may be stored in their own native image file formats. In still another embodiment the desktop image is not a single bitmap image but assembled on screen using the imported images.

Referring now to a diagram illustrates an embodiment of the per pixel alpha blending system. In brief overview the illustration includes a desktop environment executing on a computing machine . The desktop environment includes various desktop icons and a desktop wallpaper. A window image is generated by the alpha blender capturing the window and an image of a portion of the background is generated by capturing the desktop environment . The alpha blender alpha blends the images and a resulting alpha blended image is generated. The resulting alpha blended image is rendered to the display by the rendering agent described herein.

Included in the background image generated by either the window manager or the alpha blender are the images displayed on the desktop. Thus when the alpha blender alpha blends the portion of the background image to an image of the window what results is the alpha blended image . Alpha blending can enhance the transparency of certain aspects of an image. Thus when at least a portion of the image of the window is alpha blended with the background image what may result is a semi transparent image that comprises shading and or smooth rounded corners. This image can be displayed within the window to mask the sharp contrast between the window edge and the desktop.

Illustrated in is an embodiment of a method for per pixel alpha blending. The method includes first determining the location and size of a window Step . Then once the location and size of a window are determined the information is transmitted Step . The alpha blender receives the location and size of the window Step and uses the information to create an image or images of the window Step . Once the creation of the window image is complete an image of at least a portion of the background is also created Step . The images are alpha blended to generate a third alpha blended image Step . Then the alpha blended image is transmitted to the rendering agent Step that then renders the third image to a display Step .

In one embodiment alpha blending of a pixel painted in the background area to the desktop is triggered for example by a movement of the window on the screen. In another embodiment the movement may generate at least one window message received by the window manager . In still another embodiment responsive to the at least one window message received the window image described above is generated. In still even another embodiment the window manager also generates a second image representing desktop graphical data associated with the screen region . In yet another embodiment the window manager then instructs the graphics card to alpha blend the first image with the second image to generate a third image and to display the third image . When alpha blending occurs images may be alpha blended according to the methods described in .

Further referring to and in more detail the window manager can first determine the location and size of a window displayed on a desktop Step . In some embodiments the location and size of a window can be determined by obtaining the x coordinates and y coordinates of the origin of the window and the length of the sides of the window. The origin of the window in some embodiments can be defined by the operating system as the upper left corner of the window. In other embodiments the operating system can define the origin as the lower left corner of the window the center of the window or any other location within the window. The length of the sides of the windows are obtained as x coordinates and y coordinates and using these measurements together with the origin of the window the window manager can calculate the size and location of the window. In some embodiments the window manager can receive a message from the operating system that includes the location and size of the window. In this embodiment the window manager would no longer need to calculate the size and position of the window.

In another embodiment the window manager determines the location and size of the window by obtaining the x coordinates and y coordinates of the points representing the two opposing corners in a window such as the upper left corner and lower right corner or upper right corner and lower left corner of the window. The window manager can then calculate the location and size of the window using the obtained coordinates. In still another embodiment the window manager determines the location and size of the window by obtaining four values minimum X value minimum Y value maximum X value and maximum Y value. The minimum X value is the value representing the smaller x coordinate value of the window while the maximum X value is the value representing the greater x coordinate value of the window. The minimum Y value is the value representing the smaller y coordinate value of the window while the maximum Y value is the value representing the greater y coordinate value of the window. The window manager can use the obtained values to determine the size and location of the window.

In embodiments where a window spans multiple displays desktops or display devices the window manager determines the size of the portion of the window shown on each display and obtains the size and location of the portion of the window for that display. Upon making these determinations the window manager can determine an overall window size and location relative to each display.

Upon obtaining both the size and location of the window the window manger can then transmit this information Step to the alpha blender . In some embodiments the window manager can transmit the window size and the window location in response to a request issued by the alpha blender . This request or message may instruct the window manager to send the alpha blender message containing the size and location of the window. In yet another embodiment the window manager can store the window size and location information in a storage repository on the computing machine . Thus when the alpha blender requires the window location and size information the alpha blender can retrieve such information from the storage repository.

Once the alpha blender either receives the location and size of the window Step or retrieves this information from memory or a storage repository the alpha blender can generate or create one or more images of the window Step . In one embodiment the alpha blender can generate a snapshot of the entire desktop including the window. Upon generating the desktop snapshot the alpha blender can then use the window s size and location to crop the snapshot so that what remains is an image of the window. In another embodiment the alpha blender can intercept draw commands issued to a desktop renderer and using coordinates associated with at least a portion of the draw commands the alpha blender can group or temporarily store draw commands for the portion of the screen corresponding to the location of the window. Upon selecting these particular draw commands the alpha blender can send the draw commands to a rendering agent so that the rendering agent can generate an image of the window using the draw commands. In some embodiments the alpha blender can create a single image of the window. In other embodiments the alpha blender can create multiple images that when combined form an aggregate image of the entire window. In embodiments where the window spans multiple displays the alpha blender can generate at least an image for each portion of the window visible in each display. For example if the window spans two displays a first image of the window is created for the portion of the window displayed in the first display and a second image of the window is created for the portion of the window displayed in the second display.

Once the alpha blender completes generating images representative of the window the alpha blender then proceeds to create a background image Step of the background behind the window. As stated previously this background can include a desktop another window or other objects. In one embodiment the alpha blender can use any of the above described methods to generate an image of the background. These methods can include generating a snapshot of the entire desktop and cropping the image to generate an image of the background immediately behind the window generating a snapshot of just the background immediately behind the window intercepting the draw commands for each element displayed in the background and permitting a rendering agent to render only those commands corresponding to an area of the background immediately behind the window. The area or image immediately behind the window can be some area surrounding the window by a predetermined amount. For example the background area may comprise a border extending approximately 100 pixels from the edge of the window or the background area may be the same shape as the window but may have dimensions that are 20 larger than the window. In still other embodiments the alpha blender may select a random sized area behind the window. In at least one embodiment the alpha blender creates a single image of the background and crops the single image to generate an image of only a portion of the background. In embodiments where the window spans multiple displays the alpha blender can generate at least one image for the portion of the window visible in each display.

Upon generating the background image the alpha blender can then blend the image of the window with the background image to generate a third image Step . The alpha blender can use any alpha blending methods or algorithms to blend the two images. In some embodiments the alpha blender can use any of the alpha blending methods described herein.

The alpha blender then transmits the third image to the rendering agent for rendering Step and the rendered third image is displayed in the window Step . In some embodiments the third image is displayed such that it masks the edge of the drawn window. This can be accomplished by constructing a window that includes an image or graphic placed within the window such that when the window is displayed the image is rendered to the display rather than the true window edge. In effect the third alpha blended image can be used to replace at least a portion of the displayed window. This third image may comprise a smoother anti aliased image that gives the window edges the appearance of a rounded edge. In one embodiments of the method the third image can be an edge of a window. In other embodiments the third image can be a button displayed within the window. In still other embodiments the third image can comprise a single pixel while in other embodiments the third image can comprise a group of pixels. A group of pixels in some embodiments can include pixels adjacent to one another and pixels that are not adjacent to one another.

In one embodiment the method can further include a window manager or alpha blender that can identify a first pixel in the window image. In some embodiments this first pixel can be a first alpha channel value. An alpha channel value in some embodiments is a value that represents the color of a particular pixel in an image. In one embodiment an alpha channel value is also used to represent the transparency or opacity of a particular pixel. For example a pixel having an alpha channel value of 0.0 0.5 0.0 1 is a green pixel that is fully opaque. In this channel value the first three values i.e. 0.0 0.5 0.0 identifies the RGB Red Green Blue values of the pixel which in this alpha channel value represents the color green. The last value i.e. 1 represents the opacity or transparency of the pixel. A value of 0 is a fully transparent pixel while a value of 1 is a fully opaque pixel. The window manager or alpha blender can then identify a second pixel in a section of the background image and determine the second alpha channel value for that second pixel. Thus the alpha channel value in some embodiments is a numeric value or group of numeric values that identifies both the color of a pixel and the opacity or transparency of the pixel. The alpha blender can use multiple alpha channel values to determine which color pixel to display and whether the transparency or opacity level of that pixel.

In one embodiment once both the first and second alpha channel values have been determined a third alpha channel value is calculated using the first and second alpha channel values. In one embodiment the third alpha channel value is calculated using any type of alpha blending algorithm. In another embodiment the third alpha channel value is calculated using the alpha blending algorithm s described herein. The third alpha channel value in some embodiments is used in the third image in lieu of the first alpha channel value or the second alpha channel value.

The methods and systems described herein may be provided as one or more computer readable programs embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk a hard disk a compact disc a digital versatile disc a flash memory card a PROM a RAM a ROM or a magnetic tape. In general the computer readable programs may be implemented in any programming language. Some examples of languages that can be used include C C C or JAVA. The software programs may be stored on or in one or more articles of manufacture as object code.

While the present disclosure has described multiple embodiments of systems and methods for launching an application into an existing isolation environment it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the following claims.

