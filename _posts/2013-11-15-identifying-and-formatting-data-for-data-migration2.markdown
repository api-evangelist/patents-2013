---

title: Identifying and formatting data for data migration
abstract: Data formatting, migration and corresponding application acceptance for cloud-based applications may include various operations. One example operation may include identifying a data object eligible for migration to a cloud application and identifying a number of field groups linked to the data object, each of the field groups may include at least one data field. The operation may further provide receiving the field groups at a data formatting application operated on a remote cloud application server. Also, a format of the field group may be converted to a format associated with a simple data set of the cloud application for data migration purposes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09613116&OS=09613116&RS=09613116
owner: Workday, Inc.
number: 09613116
owner_city: Pleasanton
owner_country: US
publication_date: 20131115
---
This application relates to identifying and formatting data prior to transmitting the data to a data migration cloud application or accessing cloud applications which require access to the data in a specified format.

Conventionally data migration to the cloud and related cloud applications are unorganized and often lead to data loss data corruption unorganized data sets and other problematic scenarios that cost the organizations money and time to correct. Specific applications exist today that provide a workable solution to establishing an application programming interface API receiving data required by the application and eventually forwarding the data to a cloud based application in a format that is compatible with the application s .

However those programs and applications that exist as portals or user interfaces to format and upload data are not easy to use and require a certain level of user expertise. The rules programming nomenclature and other fine details create hardship for the users who are attempting to access and comply with formats require by outsourced applications operating in the cloud.

One embodiment of the present application may include a method that includes identifying at least one data object eligible for migration to a cloud application stored on a computer network device identifying a plurality of field groups linked to the at least one data object each of the plurality of field groups including at least one data field receiving the plurality of field groups at a data formatting application operated on a remote cloud application server identifying at least one of the plurality of field groups received at the remote cloud application server converting a format of the at least one field group to a format associated with a simple data set of the cloud application modifying the simple data set to include the at least one data field and storing the modified simple data set on the remote cloud application server.

Another example embodiment may provide apparatus that includes a processor configured to identify at least one data object eligible for migration to a cloud application stored on a computer network device and identify a plurality of field groups linked to the at least one data object each of the plurality of field groups including at least one data field. The apparatus may also include a receiver configured to receive the plurality of field groups at a data formatting application operated on a remote cloud application server. The processor is further configured to identify at least one of the plurality of field groups received at the remote cloud application server convert a format of the at least one field group to a format associated with a simple data set of the cloud application modify the simple data set to include the at least one data field and store the modified simple data set on the remote cloud application server.

It will be readily understood that the components of the present application as generally described and illustrated in the figures herein may be arranged and designed in a wide variety of different configurations. Thus the following detailed description of the embodiments of a method apparatus and system as represented in the attached figures is not intended to limit the scope of the application as claimed but is merely representative of selected embodiments of the application.

The features structures or characteristics of the application described throughout this specification may be combined in any suitable manner in one or more embodiments. For example the usage of the phrases example embodiments some embodiments or other similar language throughout this specification refers to the fact that a particular feature structure or characteristic described in connection with the embodiment may be included in at least one embodiment of the present application. Thus appearances of the phrases example embodiments in some embodiments in other embodiments or other similar language throughout this specification do not necessarily all refer to the same group of embodiments and the described features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In addition while the term message has been used in the description of embodiments of the present application the application may be applied to many types of network data such as packet frame datagram etc. For purposes of this application the term message also includes packet frame datagram and any equivalents thereof. Furthermore while certain types of messages and signaling are depicted in exemplary embodiments of the application the application is not limited to a certain type of message and the application is not limited to a certain type of signaling.

Example embodiments of the present application provide data gathering for specific types of data objects. Large numbers of fields may be associated with a particular object. The relationships between objects may be established to provide a data lookup type and navigation among those objects. A user interface may be offered as a software application tool for a user to edit and add certain data. Once the data is gathered in an optimal manner the data may be formatted and downloaded and potentially inserted and or updated upserted to a remote database processing system.

The objects may support a rapid entry mode of operation and a wizard mode that enables optimal data organization and related support. The field groups will be created to support field management. Object information may be edited through the user interface or through the mass data edit functionality and or by downloading and upserting information which modifies the object. Relationships may be established based on the object name instead of identifier to support flexibility in the data manipulation. In one example the object support interface may enable the downloading of only the fields on the field group however upserting may be performed on any fields of the object. Upserting may include updating information by inserting new data entries into existing fields to create an update to the existing field. However populating new information into an existing field may not cause an update until a periodic or manually controlled update operation is initiated. Therefore upserting identifies two operations insert and update which may simultaneous contemporaneous or near real time to each other.

Every object may have an ID field and a Name field. The ID is unique for a given class and will be used for upserts and delete operations. The Name and or the ID Name will be displayed on the UI as illustrated in . Each class will have an attribute that controls how the data is displayed Name or ID Name . Every object has an ID the users can either select an identifier ID or have the application automatically select an ID during manual data entry or during an upsert operation. If the user populates the ID field with a save operation the application will use that ID. If it is blank the system will auto generate an ID. Each class will contain the next object ID and sequence generator mask. The mask will determine the format of the object ID N 000001 . Relationships between objects are matched up by object name. Fields on an object can be tagged which will be tested during validation of the data i.e. Emplid National ID . Object fields are divided into groups Field Groups with no more than 10 fields to a group. Fields can be on more than one group. A download will be based on the filter and the field group. The options Add Upsert and Delete see of will be based on all fields on a given object as all fields on the employee object may be upserted in one load. Column headings on the EXCEL spreadsheet and .csv file types will map to field names on the object.

An object or data object may represent a large amount of data with multiple field groups and multiple data fields or data elements as part of each field group. For example the data object Employees may be an important enterprise data element behind which is all of the information for each of the employees from projects organization human resource information title salary benefits experience credentials etc. Each sub menu or item behind the employee data object represent a field group such as addresses phone numbers etc. The field groups may have multiple data fields such as phone number phone number office phone home phone cell phone emergency contact phone etc.

Example actions may include the field groups the related setup items the related seed items major batch functions including auto build which creates the ID and names of related child objects to the object running the auto build function and validate relationships which validates if data is in a lookup table and sets an item to a color red if there is not a lookup option otherwise the value may be formatted as a link and as validate data which validates required fields and other data validations.

Classes are the definition of an object similar to a table in a relational database. Objects are instances of classes similar to rows in table in a relational database. Example objects may be setup and seed . The setup data is data to be loaded by the user. The seed data is data that already exists within the tool. The relationships illustrate the relationship between classes such as between a parent class and field and a child class. Relationships will help related item navigations and lookup edits for users. For example when a user double clicks on the location name and clicks a drop down option the application will use the relationship definition to map the location class to produce a drop down list of values. The relationship will also be used to validate the lookup field data type. For example when Austin Tex. is displayed the application will use the relationship to determine if the value exists in the child object instance location and will format the data accordingly. The application will display red if no relationship exists and create a link if the relationship does exist. Fields represent data elements on attributes of a class. Field groups are groups of fields used to determine how data is navigated on the object page. The application will support the following 4 types of data such as text number date and lookup . Lookup data types are defined by the existence of a relationship and may be based on a pointer or link to another information source.

An Auto Build option permits automatic resolution of relationships between parent and child objects by creating ID and name entries in child object tables for data that exists in the parent object but does not currently exist in the child object. The functionality is provided by the relationship object which defines fields so the parent objects are look up fields to the child object. The pagelet lists all the setup objects related to the selected object. If the object is a parent object it is tagged with a P and is not included in the auto build function. Clicking on an object link opens the object page. The related seed data is a pagelet list of all the seed objects related to the selected object.

According to one example use case an initial load of data may provide configuration of the field groups. illustrates an example initial data load selection user interface according to example embodiments of the present application. Referring to the user interface may include a way to configure field groups by selecting a field group and then selecting a download option . Next a user may select another menu to include a Format as illustrated in for a data upsert operation and a Sample Data option as a data type. The various field groups may be specified to be downloaded. This operation will create an EXCEL spreadsheet or .csv file with the appropriate columns and sample data.

The application may then obtain legacy data and have it provided into the template. If the user does not have an ID the application will create one automatically that can be used for subsequent upserts or delete operations. Column names map to field names on the object. Field names may be uploaded as needed. Next an upsert operation may be performed to have the data upserted accordingly. Data will now appear as part of the application system. illustrates an example interface of the compiled errors that may occur after an upsert attempt such as an invalid record number format. The errors may prompt a change to occur so the record can be upserted again correctly.

Data may be upserted item by item. First names may be uploaded as illustrated in the user interface of and Job Orgs may be uploaded from the mega tab menu option of user interface of by selecting the item and selecting download and format with no data as identified in menu of . The spreadsheet created at download may now be opened and populated with data from the legacy system as illustrated in the user interface of . Certain data items may appear in red since those fields are lookup data types that have no matching value based on the relationship. For example the Location Name field may have been populated on the Employee object but there is no corresponding location object that matches. The results of the upload may appear in the application as illustrated in the user interface of .

In another example use case data relationships may be setup among the various objects that have been loaded. Both a parent object and a child object may be manually entered upserted and or autoloaded then upserted. One way to quickly load data and address related child items is to load the employee level data first and then create the ID and Name on all child objects automatically using the auto build feature. This will create a data configuration in the application and resolve all relationship errors and update the field to show a valid link to the object. A user may select a location on the related setup items pagelet or use the human resources menu to navigate to the location object. Here the user can repeat the process of downloading and upserting and or performing manual entries of data. The letter P may be set after the identifier Employee indicates it is a parent object and may not be eligible for an auto build. In the case where there are no related setup items eligible for the auto build the Auto build button is hidden or grayed out.

There are two ways to resolve seed data relationships. One way is to manually enter or upsert the seed data name fields on the parent object. illustrates an example user interface where an object ID is selected to reveal an object detail page s for that object by displaying all the fields organized by field group for that given object.

According to one example embodiment of the user interface of in rapid data entry mode a user can double click on any field and change it on the field group page. If the field is a related field a drop down menu may provide a list of values in the setup data to select. However a user can always type in a value that is not on the drop down list and auto build it or manually update it at a later time. Selecting the add button brings up the object detail page so editing can be performed.

In one example operation the legacy application may organize and identify certain data that is a candidate to be transmitted to a data conversion application . The data conversion application may receive and process data and generate a list of formatted data for user review and approval. The conversion application may also retrieve the data and format the data for exporting to an enterprise application . Simple data sets and spreadsheet formats may be automatically created to expedite data conversion and export efforts to the enterprise application . The data may be retrieved and scheduled for a data forwarding event to a remote server . The data may then be sent to the remote server stored in a remote data processing facility i.e. a cloud server network . The data migration application tools may be setup as APIs and user interface applications through a JavaScript object notation JSON language based application or via other web enabled and high level languages such as XML.

The method of may also include receiving the field groups at a data formatting application operated on a remote cloud application server and identifying at least one of the plurality of field groups among the field groups to be migrated to the remote cloud application server at operation . The method may also include converting a format of the field group to a format associated with a simple data set of the cloud application at operation and linking the one or more data fields of the at least one field group to a display interface associated with the simple data set and modifying the simple data set to include the at least one data field and storing the modified simple data set on the remote cloud application server at operation .

The links and pointers between a field group and the actual raw data stored in the corresponding data file s may include a one to many ratio where the field group represents a particular column or row of data as a destination for multiple data fields from multiple different documents. For example the field group may be identified by a destination pointer such as FG and the data fields may be from various different data files and columns and rows of data such as filename ABC DF filename ABD DF etc. In this case if the FG is the destination for the data in the data fields of different files then one pointer may have multiple links to other objects or pointers in order to retrieve and populate the field group for the corresponding simple data set result from the conversion procedure. The simple data set may also be referred to as a simple data object SDO which is what results from a conversion process and the field groups are a way of grouping the fields on the object The data structure of the SDO is based on the process for converting that format into the more complex original ILOAD format.

The application may apply a fixed number of data fields of the field group to the at least one simple data set. A field group may have multiple instances of data fields which represent a column or row or multiples thereof in a database spreadsheet file. The fixed number of data fields of the field group that are applied to the simple data set may be fewer in number than an original number of data fields of the field group. The field group identifies at least one data column in a database file and or a spreadsheet file. The field group may instead be based on a number of data columns from a plurality of different corresponding database files or spreadsheet files.

The processing module may perform converting a format of the field group to a format associated with a simple data set of the cloud application by identifying a total number of available data columns in the data formatting application and reducing a number of actual data columns to a lesser number of actual data columns prior to converting the format of the field group via the data formatting application. Lastly the data may be formatted and upserted to the application. The fields associated with the upserting operation may be updated automatically via a key field of the data formatting application which is a designated field in the formatting application that receives updates automatically as new data is inserted into at least that particular key field thereby automating the upsert function.

The data object model of the simple data set is designed to be a template or data model for the client to adapt the migration data to be moved to the cloud. The data object model or the corresponding simple data set format may be customized to the particular data migration used by the client to migrate data to the cloud. The simple data set SDO or object model may be identified as metadata or a data structure which is designed to receive data and to be populated with data but in of itself the data object can be a format that can be used to convert raw data e.g. field groups data fields etc. to a finalized simple data set that is ready for migration.

The plurality of data records being formatted into a corresponding plurality of simple data sets may include identifying a total number of data columns available in the data formatting application and reducing the number of available data columns to a lower number of data columns used to format the data in the data formatting application. For example 40 potential data columns in a spreadsheet may be reformatted into 15 in the simple data set. The plurality of data records may be upserted at any time by receiving updated data in a key field of the data formatting application after the plurality of data records have been received. The key field is a designated field that may receive updates automatically from the computer network device as new data is inserted into at least one existing field associated with at least one of the plurality of records.

The field groups may include data objects i.e. Employee that have upwards of 80 fields that potentially need to be loaded with data sets related to each field. Field groups organize and link those data fields into logical manageable groups that help the user focus on loading one field group at a time. In operation complex data structures are de normalized and the user is limited to a fixed number of elements i.e. phone numbers . Any system data may be filtered i.e. reference IDs . The simple data set employee is predefined and broken down into field groups and the field groups breaks the data into workable data segments and also provides the structure to enter the data using a Wizard . Upserting data and the use of spreadsheet applications such as EXCEL provide a way to download data from the data migration application into EXCEL manipulate it then upsert the data back into the migration application.

As for data entry modes of operation there may be a rapid data entry option and a Wizard application tool to enter data. The tool may permit two standard modes of entry rapid data entry in which the user can enter data in a tabular format and the wizard mode where a process will guide the user through data entry. The type of data and experience level of the user will help determine which mode will be most appropriate. Data format validations may occur during API data loads i.e. date formats and must be correct or the data load will fail. Upsert operations permit the users to update or insert data at the same time based on a key field. The process will update records where the key exists and will add new records where the key does not exist. This process provides the ability to download data from the tool as an attachment .csv or EXCEL format .

Data preparation for loading into the cloud may require that the data be mapped that is already configured for loading. For example a county may already exist in the tenant field but we need to designate the country code on an employees work address which will be provided by the client. Data that will be pre populated in the tool may be denoted as Seed Data .

A data object should either be seed data or configuration data but not both types. It may be too complicated to determine on a record by record basis the source of an item. For example a client may load cost centers into the tool then go to the cloud migration tool to update data and then require the tool to extract a cost center from the tenant into the data migration tool. Reference ID s should not be assigned until a predefined load output time. Auto generation of configuration data and upserting may provide a particular migration implementation. Employee level data may be loaded first configuration key data is generated based on that data then configuration data is updated by downloading adding values then upserting the data. API s will be used for loading data to the data migration application.

The simple data sets may also be referred to as simple data set objects SDOs . As part of implementing the application conversion and migration functions of the present application in one example only a small subset of the data object raw data is actually required from the customer application and the remainder of the data can be derived from other subsequent data seeking operations. It is the SDO application interface and the accompanying data transformations that are isolated from the customer to obtain those simple data sets into a migration ready format.

The application interfaces of the present application are data staging interfaces in which a user can organize the data from a legacy system review validate and fix any problems or errors before loading the data into a target system. Separation of data gathering skill sets permits functional users to work on obtaining the data they understand to be correct while technical users can focus on the system information and complexities of loading the data. A self service aspect of configuring data may initiate dynamic process wizards or automated instruction applications that guide question answer and enable users to setup and execute the creation of configuration data.

According to other examples the deferred referential integrity and deferred edit checks may be an additional function in which data is permitted to be entered or submitted in an unformatted and or unorganized format with the subsequent operation of having a user modify the data in the application with the help of a validation process to report on issues. Most applications today require data to pass referential integrity and edit checks before it is saved within the system. This feature would allow one to fix data within the interface application instead of using some other data conversion tool. Since the application is accessed or processed in the cloud it permits for the collaboration of loading reviewing and fixing data all in one interface application and also permits for standard conversion programs that can convert specific source legacy system data into simple data set format. For example if the source system is known e.g. PEOPLESOFT ADP etc. a conversion program can be created that extracts their data into the present data migration application interface where the data can be reviewed fixed augmented until it passes all centric validations so that it can be loaded into the migration cloud application.

The operations of a method or algorithm described in connection with the embodiments disclosed herein may be embodied directly in hardware in a computer program executed by a processor or in a combination of the two. A computer program may be embodied on a computer readable medium such as a storage medium. For example a computer program may reside in random access memory RAM flash memory read only memory ROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM registers hard disk a removable disk a compact disk read only memory CD ROM or any other form of storage medium known in the art.

An exemplary storage medium may be coupled to the processor such that the processor may read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. The processor and the storage medium may reside in an application specific integrated circuit ASIC . In the alternative the processor and the storage medium may reside as discrete components. For example illustrates an example network element which may represent any of the above described network components etc.

As illustrated in a memory and a processor may be discrete components of the network entity that are used to execute an application or set of operations. The application may be coded in software in a computer language understood by the processor and stored in a computer readable medium such as the memory . The computer readable medium may be a non transitory computer readable medium that includes tangible hardware components in addition to software stored in memory. Furthermore a software module may be another discrete entity that is part of the network entity and which contains software instructions that may be executed by the processor . In addition to the above noted components of the network entity the network entity may also have a transmitter and receiver pair configured to receive and transmit communication signals not shown .

Although an exemplary embodiment of the system method and computer readable medium of the present application has been illustrated in the accompanied drawings and described in the foregoing detailed description it will be understood that the application is not limited to the embodiments disclosed but is capable of numerous rearrangements modifications and substitutions without departing from the spirit or scope of the application as set forth and defined by the following claims. For example the capabilities of the system of can be performed by one or more of the modules or components described herein or in a distributed architecture and may include a transmitter receiver or pair of both. For example all or part of the functionality performed by the individual modules may be performed by one or more of these modules. Further the functionality described herein may be performed at various times and in relation to various events internal or external to the modules or components. Also the information sent between various modules can be sent between the modules via at least one of a data network the Internet a voice network an Internet Protocol network a wireless device a wired device and or via plurality of protocols. Also the messages sent or received by any of the modules may be sent or received directly and or via one or more of the other modules.

One skilled in the art will appreciate that a system could be embodied as a personal computer a server a console a personal digital assistant PDA a cell phone a tablet computing device a smartphone or any other suitable computing device or combination of devices. Presenting the above described functions as being performed by a system is not intended to limit the scope of the present application in any way but is intended to provide one example of many embodiments of the present application. Indeed methods systems and apparatuses disclosed herein may be implemented in localized and distributed forms consistent with computing technology.

It should be noted that some of the system features described in this specification have been presented as modules in order to more particularly emphasize their implementation independence. For example a module may be implemented as a hardware circuit comprising custom very large scale integration VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices graphics processing units or the like.

A module may also be at least partially implemented in software for execution by various types of processors. An identified unit of executable code may for instance comprise one or more physical or logical blocks of computer instructions that may for instance be organized as an object procedure or function. Nevertheless the executables of an identified module need not be physically located together but may comprise disparate instructions stored in different locations which when joined logically together comprise the module and achieve the stated purpose for the module. Further modules may be stored on a computer readable medium which may be for instance a hard disk drive flash device random access memory RAM tape or any other such medium used to store data.

Indeed a module of executable code could be a single instruction or many instructions and may even be distributed over several different code segments among different programs and across several memory devices. Similarly operational data may be identified and illustrated herein within modules and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set or may be distributed over different locations including over different storage devices and may exist at least partially merely as electronic signals on a system or network.

It will be readily understood that the components of the application as generally described and illustrated in the figures herein may be arranged and designed in a wide variety of different configurations. Thus the detailed description of the embodiments is not intended to limit the scope of the application as claimed but is merely representative of selected embodiments of the application.

One having ordinary skill in the art will readily understand that the application as discussed above may be practiced with steps in a different order and or with hardware elements in configurations that are different than those which are disclosed. Therefore although the application has been described based upon these preferred embodiments it would be apparent to those of skill in the art that certain modifications variations and alternative constructions would be apparent while remaining within the spirit and scope of the application. In order to determine the metes and bounds of the application therefore reference should be made to the appended claims.

While preferred embodiments of the present application have been described it is to be understood that the embodiments described are illustrative only and the scope of the application is to be defined solely by the appended claims when considered with a full range of equivalents and modifications e.g. protocols hardware devices software platforms etc. thereto.

