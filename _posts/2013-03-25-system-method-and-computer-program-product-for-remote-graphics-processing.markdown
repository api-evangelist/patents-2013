---

title: System, method, and computer program product for remote graphics processing
abstract: A system, method, and computer program product are provided for remote rendering of computer graphics. The system includes a graphics application program resident at a remote server. The graphics application is invoked by a user or process located at a client. The invoked graphics application proceeds to issue graphics instructions. The graphics instructions are received by a remote rendering control system. Given that the client and server differ with respect to graphics context and image processing capability, the remote rendering control system modifies the graphics instructions in order to accommodate these differences. The modified graphics instructions are sent to graphics rendering resources, which produce one or more rendered images. Data representing the rendered images is written to one or more frame buffers. The remote rendering control system then reads this image data from the frame buffers. The image data is transmitted to the client for display or processing. In an embodiment of the system, the image data is compressed before being transmitted to the client. In such an embodiment, the steps of rendering, compression, and transmission can be performed asynchronously in a pipelined manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08581917&OS=08581917&RS=08581917
owner: Silicon Graphics International Corp.
number: 08581917
owner_city: Fremont
owner_country: US
publication_date: 20130325
---
This application is a continuation of U.S. patent application Ser. No. 11 892 627 filed Aug. 24 2007 which is also a continuation of U.S. patent application Ser. No. 09 629 458 filed Jul. 31 2000 now U.S. Pat. No. 7 274 368 which are incorporated herein in their entireties by reference.

The present invention relates to computer graphics and more particularly to graphics computing architecture.

Today a user of a graphics processing host such as an INFINITE REALITY system by Silicon Graphics Inc. of Mountain View Calif. runs a graphics application locally. Rendering in response to the graphics instructions is also performed locally. The distance from the host to a user can be extended to a distance of for example one to three kilometers by the use of fiberoptic cables to connect the user s monitor and keyboard with the graphics processing host. More important the host is the dedicated resource of a single person. It can only be shared if someone else takes the place of the current user. While a dedicated resource is convenient for the user it may not be economical. The cost of a graphics processing host is considerable less than full usage of such a host lowers its cost effectiveness. This lower cost effectiveness could deter an organization from procuring a graphics processing host.

Hence there is a need for a system and method by which additional users can utilize a remote graphics processing host. This would improve the cost effectiveness of the host. Specifically a system and method are needed where a user can execute a graphics application at a remote graphics processing host causing rendering to be performed at the host such that the resulting images are returned to the user.

The invention described herein is a system method and computer program product for remote rendering of computer graphics. The invention includes a graphics application program resident at a remote server. The graphics application is invoked by a user or process located at a client. At the server the invoked graphics application proceeds to issue graphics instructions. The graphics instructions are received by a remote rendering control system. Given that the client and server differ with respect to graphics context and image processing capability the remote rendering control system modifies the graphics instructions in order to accommodate these differences. The modified graphics instructions are sent to graphics rendering resources which produce one or more rendered images. Data representing the rendered images is written to one or more frame buffers. The remote rendering control system then reads this image data from the frame buffers. The image data is transmitted to the client for display or processing. In an embodiment of the invention the image data is compressed before being transmitted to the client. In such an embodiment the steps of rendering compression and transmission can be performed asynchronously in a pipelined manner.

The invention described herein has the feature of allowing a user to invoke a graphics application at a remote server. The invention also has the feature of allowing the graphics application to send graphics instructions to graphics rendering resources located with the server so that rendering is performed at the host and not at the user s machine. The invention also has the feature of returning rendered image data to the user.

The invention has the advantage of allowing a user to utilize graphics resources that are not co located with the user but are instead located at a distance from the user. The invention also has the advantage of allowing greater utilization of graphics resources since users other than local users can take advantage of graphics resources.

The foregoing and other features and advantages of the invention will be apparent from the following more particular description of a preferred embodiment of the invention as illustrated in the accompanying drawings.

A preferred embodiment of the present invention is now described with reference to the figures where like reference numbers indicate identical or functionally similar elements. Also in the figures the left most digit of each reference number corresponds to the figure in which the reference number is first used. While specific configurations and arrangements are discussed it should be understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other configurations and arrangements can be used without departing from the spirit and scope of the invention. It will be apparent to a person skilled in the relevant art that this invention can also be employed in a variety of other systems and applications.

The invention described herein is a system method and computer program product for remote rendering of computer graphics. The invention allows a user or process at a client computer to access remotely located rendering resources such as a graphics processing host embodied in or co located with a remotely located server. According to the invention a graphics application executing at the server sends graphics instructions to a remote rendering control system. The remote rendering control system can be embodied in software running on the server. The instructions sent from the application are not sent to the client. Hence the client does no rendering. The instructions are modified by the remote rendering control system and sent to graphics rendering resources. Rendering consequently takes place at the graphics resources. The image data that is produced by the graphics resources are then sent to the client.

The basic architecture of an embodiment of the present invention is illustrated in . A user or process at a client machine wishes to have rendering performed remotely. Accordingly client issues commands to a remotely located server . In an embodiment of the invention connectivity between client and server is established and maintained through a communications network such as the Internet. Commands are received at server by a graphics application . In response to commands application generates graphics instructions . Graphics instructions may for example be in the OPENGL language.

Graphics instructions are sent to a remote rendering control system . Remote rendering control system accepts graphics instructions and modifies them to create modified graphics instructions . An example of a remote rendering control system is the VIZSERVER software system produced by Silicon Graphics Inc. As will described in greater detail below the modifications to graphics instructions are performed to take into account the differences between server and client with respect to their imaging processing capabilities and graphics contexts. In response to modified graphics instructions graphics resources render one or more images and return image data to remote rendering control system . In an embodiment of the invention image data is then compressed to form compressed image data . Compressed image data is then sent to client via network . In alternative embodiments of the invention compression is not implemented.

A more detailed logical illustration of remote rendering control system is shown in . Remote rendering control system accepts graphics instructions through an interface which is transparent to the graphics application . Graphics application is effectively sending graphics instructions to local rendering resources instead of to client . Because of the transparency of interface graphics application need not be aware of this redirection. Transparent interface performs a variety of modifications to graphics instructions to produce modified graphics instructions . The modifications performed by transparent interface will be described in greater detail below. Modified graphics instructions are then sent to graphics resources not shown in to effect rendering.

After rendering has been performed remote rendering control system accepts the resulting image data . As described above in an embodiment of the invention image data undergoes compression before transmission to client . Compression of the data is performed by a data compression module which produces compressed image data . Various methods of data compression are known to persons of ordinary skill in the art. In an embodiment of the invention color cell compression is used. In alternative embodiments of the invention data compression module can perform alternative compression algorithms such as the process described in U.S. patent application Ser. No. 09 458 011 Image Data Compression and Decompression incorporated herein by reference in its entirety. In an embodiment of the invention data compression module is capable of performing any of a plurality of data compression algorithms.

The overall process of an embodiment of the invention is illustrated in . Process starts at step . At step a graphics session between a client and a remote server is initialized. Initialization step includes the client s initial access to and protocol handshake with the server. In addition step includes the starting of the graphics application. Step also includes reconciling the differences between the client and server with respect to graphics processing capability and graphics context. Such reconciliation is necessary to allow processing of an image at the server and display or further processing of the image at the client. Initialization will be described in greater detail below.

In step the graphics application generates graphics instructions for the remote rendering control system. In step parameters specific to the client are imposed. This step includes for example interception by the transparent interface of function calls and references that occur in the graphics instructions and the modification of those function calls and references to make them suitable to the client. In particular adjustments may have to be made given that the client and server can have different graphics processing capabilities and contexts. Step is described in greater detail below.

In step the remote rendering control system sends modified graphics instructions to the graphics resources. The modified instructions of this step correspond to the graphics instructions generated in step and modified in step . In step the graphics resources render one or more images according to the modified instructions of step .

In step after rendering is completed the remote rendering control system reads the resulting image data from a frame buffer. In an embodiment of the invention the graphics application can have one or more specific instructions that force the reading of the frame buffer. If for example OPENGL is being used the instruction glflush causes the frame buffer to be flushed i.e. read. The OPENGL instruction glswapbuffers also serves this purpose where two frame buffers are used. Here the buffers will be swapped. A first buffer to which image data has most recently been written will be read. Writing meanwhile now takes place into the second buffer. Likewise at the next glswapbuffers instruction the second buffer will be read and the first buffer will begin receiving new image data.

In step the image data is enqueued for purposes of compression. In step the image data is compressed so that in step the image data can be transmitted to the client efficiently. In step a determination is made as to whether additional rendering is necessary. If so the process returns to step . If no additional rendering is required in step the process concludes at step .

The initialization step according to an embodiment of the invention is illustrated in greater detail in . The process begins at step . In step a user or process at the client machine begins logging on to the server. As a result in step a client server handshake takes place. The handshake includes the initial contact and protocol establishment between the server and client. Step also includes an agreement process between the client and server as to which data compression algorithm will be used if there are more than one available. The client server handshake process is described in greater detail below with respect to . In step the client exports to the server a list of the client s graphics capabilities. A list of specific graphics capabilities is known as a visual. Examples of capabilities that may be included in a visual are the ability to perform stenciling or represent opacity. Another component of a visual is the color mapping range of a device e.g. 48 bit versus 24 bit color representation.

In step the user or process starts a console window at the client computer. In step the user or process starts the graphics application resident at the server. In step the transparent interface to the graphics application opens the client display and the server display. In step the transparent interface merges the visual of the client with the visual of the server. Because a graphics application typically deals with a single output device the graphics application must see a single visual. This merger allows the graphics application to see a single visual while in reality presenting visuals for both client and server. In step the transparent interface associates the client display with the graphics application. In step the transparent interface overlays the server visual with a routine that allows conversion of visual capabilities appearing in function calls of the graphics application. The routine converts these visual capabilities to capabilities appropriate to the client i.e. capabilities in the client s original visual. The development and application of such a routine would be obvious to one of ordinary skill in the art given this description.

In step the client window is returned to the graphics application. This step includes the conversion by the transparent interface of the merged visual list into a visual appropriate to the client. Step also includes creation of an internal data structure for tracking the position of the client window in the client display. The process of receiving the client window is described in greater detail below with respect to .

In step the application receives a graphics context. This step detailed below with respect to includes definition of a server context by the transparent interface. Step also includes the return of an internal context to the application. In step the application binds the internal context to the client window which has the effect of binding the server context to the server window. The initialization process concludes with step .

An embodiment of the client server handshake step is illustrated in greater detail in . This process begins with step . In step the server connects to the client. In step the server in particular the application identifies an address or source from which updates of image data are provided. It is from this source that updates will be sent to the client. In step the server and client identify their respective available compression algorithms to each other. In step the client chooses a compression algorithm and identifies it to the server. The process concludes with step .

The step by which a client window is returned to the application step is illustrated in greater detail in according to an embodiment of the invention. The process begins with step . In step the transparent interface produces a visual appropriate for the client from the merged visual list. This is done by taking only those visual capabilities which were originally the client s. Definition of such a visual is required for an image to be displayed properly at the client. In step the transparent interface defines a window for the client. In step the transparent interface creates an internal data structure for tracking the position of the client window on the client display. In step the transparent interface returns the client window to the application. The process concludes with step .

An embodiment of the process by which a graphics context is returned to the application step is illustrated in greater detail in . The process begins with step . In step the transparent interface produces a server visual from the merged visual. This is done by taking only those visual capabilities which were originally the server s. In step the transparent interface defines a server context. The server context represents the context settings to be applied in rendering for the server s display. In step the transparent interface returns an internal context to the application program where the internal context includes the server context and any additional information that may be necessary to allow the transparent interface to properly interpret references to the server context. An example of such additional information is the identity of specific visual capabilities that correspond to a given element of the server context. The process concludes with step .

The step of binding a context to a server window step is illustrated in greater detail in according to an embodiment of the invention. The process begins with step . In step the transparent interface extracts the server context from the internal context. In step the transparent interface requests a window allocation from the session manager. The session manager is logic e.g. software responsible for managing the allocation of resources in a graphics session. The implementation of a session manager is known to persons of ordinary skill in the art. In step the transparent interface binds the server context to the server window. The process concludes with step .

Returning to the overall process illustrated in once initialization is completed in step the graphics application generates graphics instructions in step as discussed above. This is followed by step the step of imposing client parameters on the rendering process. An embodiment of step is illustrated in greater detail in . The process begins with step . In step the transparent interface intercepts graphics instruction function calls that include a visual. In step the transparent interface converts the visuals to corresponding client visuals. In step the transparent interface intercepts every graphics instruction reference to a context. In step the transparent interface converts the reference to a reference consistent with the client s context. The process concludes at step .

Steps through rendering enqueuing compression and transmission are collectively illustrated in according to an embodiment of the invention. This figure illustrates how blocks of image data are rendered compressed then transmitted. In the illustrated embodiment these operations are performed in pipeline fashion. The rendering compression and transmission steps are identified collectively as processes . These steps take place sequentially during successive blocks of time . During time t a block A of image data is rendered. During the next interval time t block A is compressed. Simultaneously the next segment of image data block B is rendered. At the next time interval t block A is transmitted after having been compressed during the previous time period. While block A is being transmitted block B is compressed. Simultaneously the next block of image data block C is being rendered. Successive blocks of image data are processed in this manner.

In an embodiment of the invention the steps of rendering compression and transmission are asynchronous. In such an embodiment the compression of block B may not be completed at the same time as the rendering of block C referring to the example above. To deal with this blocks of image data may be discarded. Any given step will take only the most recent block from the previous step. If for example rendering of block B takes place faster than the compression of block A the compression module is not yet ready for block B when rendering of block B is done. Block B will therefore be discarded. The compression module will finish compressing block A then wait for the next and newest block to emerge from rendering. Multiple blocks may be discarded if rendering is significantly faster than compression. The transmission process will likewise accept only the newest compressed block of image data. If compression of a block is completed before the previous block has been transmitted that compressed block will be discarded.

An embodiment of the remote rendering process from the perspective of the client is illustrated in . The process starts with step . In step the client server handshake takes place as described above. In step the client sends one or more commands to the graphics application to begin execution. In step after the graphics resources at the server have completed rendering the client receives image data via the network. In an embodiment of the invention the image data is compressed for purposes of transmission efficiency. In step the image data is decompressed at the client and in step the appropriate image is drawn to a window at the client. In step a determination is made as to whether an additional image is to be drawn. If so the process continues at step . Otherwise the process concludes at step .

Server of the present invention may be implemented as a computer system or other processing system. Remote rendering control system and graphics application program can be implemented as computer programs executing on such a computer system. Graphics resources can be any type of graphics subsystem linked to a communication infrastructure such as a bus or network. An example of such a computer system is shown in . The computer system includes one or more processors such as processor . The processor is connected to communication infrastructure . Various software implementations are described in terms of this exemplary computer system. After reading this description it will become apparent to a person skilled in the relevant art how to implement the invention using other computer systems and or computer architectures.

Computer system also includes a main memory preferably random access memory RAM and may also include a secondary memory . The secondary memory may include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive etc. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit represents a floppy disk magnetic tape optical disk or other storage medium which is read by and written to by removable storage drive . As will be appreciated the removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In alternative implementations secondary memory may include other means for allowing computer programs or other instructions to be loaded into computer system . Such means may include for example a removable storage unit and an interface . Examples of such means may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer system .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices. Examples of communications interface may include a modem a network interface such as an Ethernet card a communications port a PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . Commands and compressed image data are examples of signals . These signals are provided to communications interface via a communications path i.e. channel . This channel carries signals and maybe implemented using wire or cable fiber optics a phone line a cellular phone link an RF link and other communications channels.

In this document the terms computer program medium and computer usable medium are used to generally refer to media such as removable storage units and a hard disk installed in hard disk drive and signals . These computer program products are means for providing software to computer system .

Computer programs also called computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Remote rendering control system and graphics application program can be implemented as computer programs. Such computer programs when executed enable the computer system to implement the present invention as discussed herein. In particular the computer programs when executed enable the processor to implement the present invention. Accordingly such computer programs represent controllers of the computer system . Where the invention is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive hard drive or communications interface .

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example and not limitation. It will be apparent to persons skilled in the relevant art that various changes in detail can be made therein without departing from the spirit and scope of the invention. Thus the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

