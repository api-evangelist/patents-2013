---

title: Messaging middleware processing thread count based events
abstract: A message queuing system implemented by at least one computer. The system comprises a performance queue to keep event status related to performance of non-performance queues, threads, which are sequences of programmed instructions, launched by the queue managers to transmit and receive messages over connections between individual queues, and an external monitoring application or a monitoring application within a queue manager. The monitoring application monitors threads, channels, and events in the message queuing system, polls the performance queue periodically and counts the number of threads in the case of the external monitoring application, directly gathers current event information in the case of the monitoring application within the queue manager, determines whether both the thread/threads and channel have failed when all threads of an application are missing, and restarts channels that failed after determining that both channels and all threads have failed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959530&OS=08959530&RS=08959530
owner: Sprint Communications Company L.P.
number: 08959530
owner_city: Overland Park
owner_country: US
publication_date: 20130507
---
Large business enterprises typically benefit from reliable and secure communications both within the enterprise and with clients partners and suppliers around the globe via the Internet. Middleware helps enterprises achieve this goal by integrating applications on different platforms or with diverse technologies. Asynchronous communication with a message queuing mechanism may ensure reliable communications among different parties. Message queues typically receive store and forward messages and requests for information and services. Message queuing is a method of process to process or application to application communication such as communication between an application that services a user and an application that retrieves data from a database. Message queuing middleware implements various components to realize message queuing services. Applications may communicate by writing and reading application specific data or messages to and from queues without having a dedicated synchronous link between the applications. The asynchronous feature of the message queuing middleware allows the application to continue processing after making a middleware service request.

In an embodiment a message queuing system implemented by at least one computer is disclosed. The message queuing system comprises two thread counters at least two queues to which messages can be sent a performance queue to keep event status related to performance of non performance queues at least two queue managers and threads which are sequences of programmed instructions launched by the queue managers to transmit and receive messages over connections between individual queues. The message queuing system further comprises at least one message queue interface channel launched by the queue managers to provide a communication path between one application and one queue manager at least one message channel launched by the queue managers to provide a communication path between two queue managers and an external monitoring application or a monitoring application within a queue manager. The monitoring application monitors threads channels and events in the message queuing system polls the performance queue periodically and counts the number of threads in the case of the external monitoring application directly gathers current event information in the case of the monitoring application within the queue manager determines whether both the thread threads and channel have failed when all threads of an application are missing and restarts channels that failed after determining that both channels and all threads have failed.

In an embodiment a method of managing a message queuing system implemented by a monitoring application executed by a computer is disclosed. The method comprises monitoring channels in the message queuing system monitoring threads between individual queues in the message queuing system and counting the numbers of new thread connections closed threads and total active threads for any given queue. The method further comprises restarting channels that failed after determining that both channels and all threads have failed based on thread counts identifying and restarting missing threads when the number of threads is below a predefined low threshold recording the number of total restart times and if the number of restart times exceeds a predefined number in a predefined time period throwing an error indicating the application is problematic that is associated with the thread.

In an embodiment a method of monitoring events in a message queuing system implemented by a computer is disclosed. The method comprises monitoring channels and threads in the message queuing system sending a count of an event to be summed when a new thread connection is established or a thread connection is closed for any given queue and maintaining a sum with which the count of the number of active threads is kept for any given queue. The method further comprises restarting a queue when a message in a queue has exceeded the maximum number of delivery attempts to the receiving party and restarting channels that failed after determining that both channels and all threads have failed.

These and other features will be more clearly understood from the following detailed description taken in conjunction with the accompanying drawings and claims.

It should be understood at the outset that although illustrative implementations of one or more embodiments are illustrated below the disclosed systems and methods may be implemented using any number of techniques whether currently known or not yet in existence. The disclosure should in no way be limited to the illustrative implementations drawings and techniques illustrated below but may be modified within the scope of the appended claims along with their full scope of equivalents.

Problems may be caused by periodic disconnection of applications from a queue in a message queuing system which causes messages in the queue not to be processed. The problems may result from bad messages in the queue associated with the application. For example messages that entail many failed delivery attempts may cause the entire queue to collapse. In some contexts a message that experiences a plurality of failed delivery attempts may be referred to as a poison message. The application s associated with the queue may also be caused to fail by the poison message for example because of one or more queue collapses caused by the poison message. The present disclosure teaches a system and method for proactively monitoring queue object channel object or another messaging queue middleware object behavior and restoring communication services under predefined circumstances.

For example a monitoring application may monitor the status of different variables and events in the message queuing system for example the status of events and the number of channels new thread connections closed threads and total active threads maintain the counts of active threads and use the event information including the number of thread counts to detect when threads are missing crashed or disconnected that are associated with a queue or an application with unprocessed messages. Threads are fairly good indicators of problems that would affect the health of a queue and so it makes sense to count the number of threads associated with a queue or an application. One specific channel may have all connections between two certain queues so it is reasonable to monitor both channels and threads. Events typically provide information about errors warnings and other significant occurrence in a queue manager or a message queuing system.

For example if three applications are connected to a queue each with three threads inputting into the queue and three threads writing from the queue the total number of active threads is eighteen. When the number of active threads falls from eighteen to twelve the monitoring application may trigger an alert and take proactive action. When abnormal behavior is detected the monitoring application can take a variety of proactive steps to respond to abnormal behavior.

For example the monitoring application may identify the missing threads and try to restart the missing threads when the total number of active threads is detected to be below a predefined number. The total number of attempts to restart the missing threads may be recorded. When the total number of attempts to restart the missing threads exceeds a predefined threshold the monitoring application may flag an error indicating that the application is problematic that is associated with the missing threads. The monitoring application may restart a message queue interface channel after determining that both the message queue interface channel that provides a two way communication path between a message queue interface client and a queue manager on different systems computers and all threads that are associated with a single application have failed. Additionally the monitoring application may restart a queue when certain messages are detected at the queue. When the message that causes problems is the type of message whose number of delivery attempts has exceeded a predefined limit which may cause the queue and even the application associated with the queue to collapse the message may be moved to a specific type of queue.

Turning now to a message queuing system is described. In an embodiment the system comprises an application server a server computer and a back end server . The application server may comprise a sender application a message queue interface MQI an application queue manager QM a first monitoring application a first thread counter a first performance queue a first back out queue and an application queue . The sender application may send messages through the MQI an application queue manager and a message channel to a queue manager QM on the server computer . The message channel may comprise any combination of private and public networks and may employ any communication protocol such as example transmission control protocol and internet protocol TCP IP .

The queue manager may store the messages into a transmission queue TX Q . The queue manager may be for example IBM WebSphere MQ queue manager Java Message Service JMS queue manager Amazon simple queue service queue manager or another queue manager. The transmission queue may be located in the same computer in this case the server computer as the queue manager . The server computer may comprise the transmission queue a local queue a second performance queue a second monitoring application a second thread counter a second back out queue and the queue manager . When the messages from the sender application are directed to the receiver application a back end application the messages stored on the server computer may be retrieved by the back end application through the message queue interface client on the back end server . The back end server may comprise the message queue interface client and the back end application . A message queue interface MQI channel may provide a two way communication path between a message queue interface client and a queue manager on different systems computers for example an MQI channel between the message queue interface client on the back end server and the queue manager on the server computer . In an embodiment the message channel and the MQI channel are the two categories of channels in a typical message queuing system.

It is understood that the message queuing system may comprise any number of the application server any number of the server computer and any number of the back end server . The application server and the server computer may be two different computers or one and the same computer. The application server and the back end server may be two different computers or one and the same computer. Furthermore the application server the server computer and the back end server may be different computers or one and the same computer. In the case where the application server the server computer and the back end server are one and the same computer the sender application and the back end application are two applications within the same computer that communicate with each other through the message queuing system . The sender application may be any application that may desire to communicate with another application the back end application . For example the sender application may be a web server application and the back end application may be a web browser application.

In an embodiment a queue may be a data structure that stores messages until the messages are retrieved by the applications that service the queue. Messages stored in the queue may accumulate on the queue until the messages are retrieved. Messages may encapsulate service requests or service responses. The sender application may send messages that may encapsulate service requests to the application queue to be sent to the receiver application the back end application . The sender application may access the application queue by using the message queue interface . One application may send messages to the application queue . Alternatively multiple applications may send messages to the same queue the application queue . In an embodiment the application queue belongs to the application queue manager . The application queue manager may organize the messages and place them in the appropriate queue. The application queue may be physically managed by the application queue manager and this process may not be apparent to the sender application .

The messages stored in the application queue intended for the back end application may be managed by the application queue manager and the application queue manager may decide where the messages will be initially sent. For example the application queue manager sends a first message from the application queue for the sender application to the transmission queue . The queue manager may evaluate messages received on the transmission queue and determines whether each message can be serviced locally by the local queue or needs to be forwarded to another queue. In this example the queue manager takes the first message from the transmission queue and puts the first message on the local queue which makes the message available to the back end application through the MQI client . Subsequently the back end application may check the local queue for messages that can be serviced locally and provide the data requested by the message. After the back end application provides the data requested by the message the queue manager may transfer the message that may encapsulate service responses from the local queue back to the transmission queue . The transmission queue may return the message with the requested data back to the application queue for the sender application .

In another example the application queue manager may send a second message from the application queue for a second application to the transmission queue . If the queue manager determines that the message cannot be serviced locally by the local queue which may happen with this example the queue manager may forward the message in the transmission queue to another queue. The queue manager may forward the message to a transmission queue associated with a local queue that directly services the message or to a transmission queue that forwards the message on to yet another transmission queue. The local queue that directly services the message may be referred to the destination queue for the message.

The message channel may be a one way communication path between two queue managers the application queue manager and the queue manager . If two way communication between the two queue managers and is needed two message channels may be implemented. The message channels may be logical addresses in the message queuing system. It may depend on the message queuing system product and the implementation of the message queuing system product how the message channels are implemented. A variety of existing communications protocols for example TCP IP may be integrated into the message channel . Alternatively other communications protocols may be specifically developed and provided by the message queuing system venders to be integrated into the message channel . Different channels may be utilized by the messaging middleware for different types of information that the sender application intends to communicate. For example when the application sends information the sender application may not randomly add the information to any message channel available. Alternatively the sender application may add the information to the message channel whose specific purpose is to serve that kind of information. Likewise the back end application that intends to receive information may not randomly fetch information from a random message channel . Instead the back end application may fetch information from some specific type of channel. The selection of the specific type of channel may be done based on the type of information the back end application intends to receive.

The MQI channel may be established by a command an administrator issues from the MQI client application . The MQI channel may be a two way link used for the transfer of MQI calls and responses only. The MQI calls and responses the MQI channel may handle comprise the MQI calls that comprise message data and MQI calls that result in the return of message data. One specific channel may have all connections between two certain queues so it is reasonable to monitor both channels and threads instead of just threads.

In most cases the sender application and the application queue manager may not be able to directly communicate to each other without some kind of common application programming interface such as the MQI . The MQI may provide a common interface between the sender application and the application queue manager . In an embodiment the MQI is the common application programming interface API for the messaging middleware. The messaging middleware may offer four major interoperable APIs for example message queue interface MQI Java message service JMS application messaging interface AMI common messaging interface CMI or another API. The MQI may connect to multiple queue managers on different systems. Alternative message channels using different communications protocols may be utilized with the MQI . The MQI may connect open or attach to the message queuing system . Alternatively the MQI may close or detach from the message queuing system . The sender application may send messages to or receive messages from the back end application or another application that the sender application may communicate with through the MQI . For example the MQI may send a message to the application queue and send a message to or receive a message from the local queue .

The application queue manager may provide messaging services to the sender application . The queue manager may provide messaging services to the back end application . In an embodiment the queue manager is the main component in a message queuing system. The queue manager may provide an application programming interface in this case the MQI client so that the back end application can put messages on and get messages from the local queue . In an embodiment for the application to use the queue manager the back end application may establish a connection to the queue manager the MQI channel . Queue managers may be able to communicate to other queue managers for one application to send messages to another application that is connected to another queue manager. For example the queue manager may be able to communication to the application queue manager so that the back end application that is connected to the queue manager may be able to send messages to the sender application that is connected to the application queue manager . For example the message queuing middleware from IBM WebSphere MQ implements a store and forward protocol to ensure the safe delivery of messages between applications that are connected to different queue managers. The queue manager may send messages to the correct local queue or route messages to another queue manager. The queue manager may process the MQI client calls issued to the queue manager and commands submitted to the queue manager from any source. In addition the queue manager may launch and host the other objects in the message queuing system for example the queue the message channel or another object in the message queuing system . For example the queue manager may start channels and and create delete and alter the queues and the channel and definitions.

The first thread counter may be hosted by the application queue manager or the first monitoring application . The second thread counter may be hosted by the queue manager or by the second monitoring application . In an embodiment threads or processing threads are sequences of programmed instructions launched by the queue managers and to transmit and receive messages between the queues over connections within channels. In an embodiment threads are fairly good indicators of problems that would affect the health of a queue rather than problems that would just affect the load on the queue. Hence it makes sense to count the number of threads associated with a queue or an application. The thread counters and may be utilized to count the number of threads for any given queue or or any given application or .

The performance queues and may be exploited to store event status information related to performance of the queues and including results from the thread counters and . Events typically provide information about errors warnings and other significant occurrences in a queue manager or a message queuing system . For example when a thread begins the process of reading from or writing to the local queue an event may be triggered. When a monitoring application gathers current event information from the queue manager an event may be triggered. Additionally in the case where the second monitoring application is an external monitoring application instead of a component within the queue manager when the external monitoring application polls the status of the queues and and counts the numbers of threads in each state an event may be triggered. The performance queues and may also store information from the thread counters and . The monitoring application or may periodically poll the performance queue or and count the number of threads. Additionally the monitoring application or may check other statistics stored in the performance queue or . For example the monitoring application or may parse the event types of the non performance queues and stored in the performance queue or and gains the event status of the non performance queues and . The performance queue or may handle the calculation for net numbers of threads and keep statistics on the way. The messaging middleware the queue manager in this case may be able to do the calculation and fire events as long as the middleware established and maintains connections to the queue.

In an embodiment the monitoring application or tracks different variables and events to reduce the risk that the applications and may not be able to accomplish intended communication. The second monitoring application may be an application within the queue manager or an external application outside of the queue manager . The monitoring application may monitor threads channels and events in the message queuing system . For example when the second monitoring application is an external monitoring application the second monitoring application may periodically poll the second performance queue . Alternatively when the second monitoring application is a monitoring application within the queue manager the second monitoring application may directly gather current event information. A particular application may have only one type of connection. The second monitoring application may parse the event types and the application types of a connection.

For example the monitoring applications and may monitor the behavior of the queues and . The monitoring applications and may monitor the behavior of the channels and . The monitoring applications and may take action when certain activities behaviors of the queues and and channels and are detected. For example the monitoring application or may trigger certain events based upon the number of the threads. For example the second monitoring application may restart one or more of the queues and based upon the number of threads associated with the queues and . The second monitoring application may be able to restart one or more of the threads. The second monitoring application may be able to restart one or more of the channels and . In addition the second monitoring application may throw errors under certain circumstances for example when an back end application tries to open a thread over a predefined number of times.

The second monitoring application may function in a synchronous way polling or an asynchronous way watching . When the second monitoring application works in the synchronous way by polling a call may be made to the second performance queue to collect the specified information and the function does not return until the operation is complete. Alternatively when the second monitoring application works in the asynchronous way by watching a call may be made to the API MQI client to register interest in specified variables or events. The function may return immediately. Whenever the specified event happens a monitoring message may be sent asynchronously to the second monitoring application . Typically the second monitoring application may use callbacks to process the information. Both polling and watching may be used within the same second monitoring application .

In an embodiment the monitoring application or monitors the number of threads for any given queue. For example the monitoring application or may monitor new connections to a queue. When a new thread connection is established the monitoring application or may send a count of a new thread connection to be summed by the thread counter or for the queue of the new connection. The monitoring application or may monitor closed connections of a queue. For example when a thread connection is closed or fails the heartbeat mechanism and is presumed dead the monitoring application or may send a count of the thread connection to be deducted by the thread counter or for the queue associated with the closed connection. In addition the total number of active threads for any given queue is maintained by the thread counter and the monitoring application or may access the thread counter to gain the total number of active threads. The total number of threads for a single queue comprises both threads that are in the process of reading from the queue and threads that are in the process of writing to the queue.

A normal number or a range of normal number of threads associated with a single application or may be determined. For example the monitoring application or may abstract connection lists for each queue identify the threads by applications. The monitoring application or may identify the threads as which ones are open exclusive open shared and so on. A single application may connect to a single queue while more than one application may connect to a queue. For example a minimum of two threads per queue for an application is typical for production purposes and usually more than two threads per queue are observed. For example router applications typically have three threads per queue. For some applications up to forty instances of threads per queue may be observed. The range of normal number of threads of a specific application may be determined based on different time or date. For example the range of normal number of threads of the sender application may be determined based on different time period of the day the week the month the year or some other time interval. The range of normal number of threads of the sender application may be determined based on some date of the week the month the year or some other date. The range of normal number of threads of the sender application may be determined based on different time intervals for example every minute every hour every five hours or some other time interval.

When the number of threads falls outside the range of the normal number an event may be triggered. For example if the normal number of threads connected to a queue is five at that moment if it goes up to ten or goes down to one an event alarm may be triggered. When the number of threads falls outside a range with a deviation from the range of the normal number of threads an alarm may be triggered. For example if in the last week seven days a range of five to eight active threads was detected for the sender application then the range of five to eight active threads may be determined as the range of the normal number of threads for the sender application . When a deviation of is used to determine when the number of total active threads falls outside the range of the normal number of the threads if less than two threads or more than twelve threads are detected an event alarm may be triggered. The message queuing system may be more alerted when the sender application loses all the connections to the application queue .

When the total number of threads falls below a predefined low threshold for example the lower bound of the range with a deviation from the range of the normal number of threads the second monitoring application may try to identify the missing threads after an alert is generated. The second monitoring application may further restart threads that are identified as missing threads. The total number of attempts to restart a missing thread may be recorded and updated in a timely manner. A count of the number of attempts to restart the missing thread may be maintained. In an embodiment the count of restart attempts may be maintained in such a way that old counts are removed from the count. Alternatively a plurality of counts for a subject thread that correspond to different time intervals may be maintained. When the total number of attempts to restart a missing thread exceeds a predefined number during a predefined time period the second monitoring application may throw an error indicating the back end application is problematic that is associated with the thread and take action. For example if the second monitoring application has tried twenty times which is a predefined limit for restart attempts to restart a missing thread during an hour which is a predefined time period the second monitoring application may throw an error message and reboot the back end application or even begin start up steps. When the total number of threads exceeds a predefined high threshold the second monitoring application may also try to find out the reason.

The range of normal numbers of inputting threads to a local queue and the range of normal numbers of outputting threads from the local queue associated with the back end application may be determined. Furthermore the range with a predefined deviation from the range of the normal numbers of inputting and outputting threads associated with the back end application may also be determined. Thus the high and low threshold of the range of the number of inputting and outputting threads of the local queue associated with the back end application may be determined. The high and low thresholds may be set manually by a system administrator or may be adjusted automatically by the second monitoring application in a self healing manner.

When all threads of the back end application connected to the local queue are determined to be missing the second monitoring application may check the status of the MQI channel and determine whether the MQI channel has failed. The second monitoring application may restart the MQI channel after determining that both the threads and the MQI channel have failed. Particular threads may also check the status of the MQI channel and restart the MQI channel when both the MQI channel and all threads of the back end application are determined to have failed. When no queue depth which is the number of messages on the local queue and lost threads are detected no alarm should be generated. When no queue depth or no active thread is detected no alarm should be generated. The second thread counter may be set not to monitor the thread anymore or at least for a predefined period.

The second monitoring application may take action when certain messages are detected at a queue for example when a message is detected at a queue that has exceeded the predefined limit maximum number of delivery attempts for a single message to the receiving party. This kind of message is typically called a poison message. In an embodiment the process of identifying the poison message is triggered based on thread counts instead of the traditional time out method. The poison message may cause the local queue that the poison message is associated with to collapse the connection from the back end application to the local queue to fail and even the back end application to fail resulting in the failure in delivery for other messages in the local queue . The second monitoring application may check whether it is configured for the second monitoring application to move the last message which has exceeded the predefined maximum number of delivery attempts to the second back out queue . If this function is configured the second monitoring application may simply move the message to the second back out queue . If this function is not configured the second monitoring application may add that function and move the message to the second back out queue . Thus the predefined limit time of delivery attempts for a message may be called a back out count threshold. When the local queue dies and the threads fail but none of the messages in the queue has exceeded the limit of the delivery attempts the second monitoring application may not move any message to the second back out queue because the back out count threshold was not hit. By restarting the local queue the second monitoring application may assure the delivery of other messages in the local queue .

In an embodiment the back end application may restart the threads when the poison message is moved to the second back out queue . The restarting process may happen instantaneously when the back end application makes a new request response. Please note that the back end applications that reconnect in existing message queuing systems are the applications that are writing a lot at the moment. In a current typical message queuing system server applications may not be able to restart the threads at this type of problem or even discover this type of problem because the server applications may only be waiting for one message in the queue and the server applications may put an infinite weight on the queue.

Turning now to a message queuing system is described. In an embodiment the message queuing system comprises two applications and two MQIs and at least two queues and two queue managers and and a message channel . The message queuing system is symmetric in but in another embodiment the message queuing system may not be symmetric. The message flows shown in the message queuing system are symmetric showing messages transmitted from the two applications and but only one message flow will be discussed. In an embodiment one of the two message flows starts at the application from which the message is sent. The sender application sends a message via the MQI the queue manager and the message channel to the queue at the receiver application side. The queue may be a local queue to the queue manager while the queue may be a remote queue to the queue manager . The queue manager may have set up the queue so that the queue manager can locate the queue manager associated with the receiver application . The messages sent by the application may accumulate in the queue until the receiver application retrieves them. In an embodiment the receiver application then retrieves the message stored in the queue via the queue manager and the MQI .

Turning now to a method is described. At block channels in the message queuing system are monitored by a monitoring application in the message queuing system. The monitoring application may be within a queue manager or an external monitoring application outside of the queue manager. At block threads between individual queues in the message queuing system are monitored. Threads may be processing threads that operate within channels to connect individual queues. At block the numbers of new thread connections closed threads and total active threads for any given queue are counted. The thread counter maintains the total number of active threads. The monitoring application sends a notification to the thread counter when a new thread connection or a closed thread connection occurs. At block channels that failed are restarted after it is determined that both the channel and all threads of the application in that channel have failed. At block based on thread counts missing threads are identified and restarted when the number of threads is below a predefined low threshold. At block the number of total restart times of threads is recorded. A count of the number of attempts to restart the missing threads may be maintained. In an embodiment the count of restart attempts may be maintained in such a way that old counts are removed from the count. Alternatively a plurality of counts for thread restarts that correspond to different time intervals may be maintained. At block if the number of restart times exceeds a predefined number in a predefined time period an error is thrown indicating the application is problematic that is associated with the thread.

It is understood that by programming and or loading executable instructions onto the computer system at least one of the CPU the RAM and the ROM are changed transforming the computer system in part into a particular machine or apparatus having the novel functionality taught by the present disclosure. It is fundamental to the electrical engineering and software engineering arts that functionality that can be implemented by loading executable software into a computer can be converted to a hardware implementation by well known design rules. Decisions between implementing a concept in software versus hardware typically hinge on considerations of stability of the design and numbers of units to be produced rather than any issues involved in translating from the software domain to the hardware domain. Generally a design that is still subject to frequent change may be preferred to be implemented in software because re spinning a hardware implementation is more expensive than re spinning a software design. Generally a design that is stable that will be produced in large volume may be preferred to be implemented in hardware for example in an application specific integrated circuit ASIC because for large production runs the hardware implementation may be less expensive than the software implementation. Often a design may be developed and tested in a software form and later transformed by well known design rules to an equivalent hardware implementation in an application specific integrated circuit that hardwires the instructions of the software. In the same manner as a machine controlled by a new ASIC is a particular machine or apparatus likewise a computer that has been programmed and or loaded with executable instructions may be viewed as a particular machine or apparatus.

The secondary storage is typically comprised of one or more disk drives or tape drives and is used for non volatile storage of data and as an over flow data storage device if RAM is not large enough to hold all working data. Secondary storage may be used to store programs which are loaded into RAM when such programs are selected for execution. The ROM is used to store instructions and perhaps data which are read during program execution. ROM is a non volatile memory device which typically has a small memory capacity relative to the larger memory capacity of secondary storage . The RAM is used to store volatile data and perhaps to store instructions. Access to both ROM and RAM is typically faster than to secondary storage . The secondary storage the RAM and or the ROM may be referred to in some contexts as computer readable storage media and or non transitory computer readable media.

I O devices may include printers video monitors liquid crystal displays LCDs touch screen displays keyboards keypads switches dials mice track balls voice recognizers card readers paper tape readers or other well known input devices.

The network connectivity devices may take the form of modems modem banks Ethernet cards universal serial bus USB interface cards serial interfaces token ring cards fiber distributed data interface FDDI cards wireless local area network WLAN cards radio transceiver cards such as code division multiple access CDMA global system for mobile communications GSM long term evolution LTE worldwide interoperability for microwave access WiMAX and or other air interface protocol radio transceiver cards and other well known network devices. These network connectivity devices may enable the processor to communicate with the Internet or one or more intranets. With such a network connection it is contemplated that the processor might receive information from the network or might output information to the network in the course of performing the above described method steps. Such information which is often represented as a sequence of instructions to be executed using processor may be received from and outputted to the network for example in the form of a computer data signal embodied in a carrier wave.

Such information which may include data or instructions to be executed using processor for example may be received from and outputted to the network for example in the form of a computer data baseband signal or signal embodied in a carrier wave. The baseband signal or signal embedded in the carrier wave or other types of signals currently used or hereafter developed may be generated according to several methods well known to one skilled in the art. The baseband signal and or signal embedded in the carrier wave may be referred to in some contexts as a transitory signal.

The processor executes instructions codes computer programs scripts which it accesses from hard disk floppy disk optical disk these various disk based systems may all be considered secondary storage ROM RAM or the network connectivity devices . While only one processor is shown multiple processors may be present. Thus while instructions may be discussed as executed by a processor the instructions may be executed simultaneously serially or otherwise executed by one or multiple processors. Instructions codes computer programs scripts and or data that may be accessed from the secondary storage for example hard drives floppy disks optical disks and or other device the ROM and or the RAM may be referred to in some contexts as non transitory instructions and or non transitory information.

In an embodiment the computer system may comprise two or more computers in communication with each other that collaborate to perform a task. For example but not by way of limitation an application may be partitioned in such a way as to permit concurrent and or parallel processing of the instructions of the application. Alternatively the data processed by the application may be partitioned in such a way as to permit concurrent and or parallel processing of different portions of a data set by the two or more computers. In an embodiment virtualization software may be employed by the computer system to provide the functionality of a number of servers that is not directly bound to the number of computers in the computer system . For example virtualization software may provide twenty virtual servers on four physical computers. In an embodiment the functionality disclosed above may be provided by executing the application and or applications in a cloud computing environment. Cloud computing may comprise providing computing services via a network connection using dynamically scalable computing resources. Cloud computing may be supported at least in part by virtualization software. A cloud computing environment may be established by an enterprise and or may be hired on an as needed basis from a third party provider. Some cloud computing environments may comprise cloud computing resources owned and operated by the enterprise as well as cloud computing resources hired and or leased from a third party provider.

In an embodiment some or all of the functionality disclosed above may be provided as a computer program product. The computer program product may comprise one or more computer readable storage medium having computer usable program code embodied therein to implement the functionality disclosed above. The computer program product may comprise data structures executable instructions and other computer usable program code. The computer program product may be embodied in removable computer storage media and or non removable computer storage media. The removable computer readable storage medium may comprise without limitation a paper tape a magnetic tape magnetic disk an optical disk a solid state memory chip for example analog magnetic tape compact disk read only memory CD ROM disks floppy disks jump drives digital cards multimedia cards and others. The computer program product may be suitable for loading by the computer system at least portions of the contents of the computer program product to the secondary storage to the ROM to the RAM and or to other non volatile memory and volatile memory of the computer system . The processor may process the executable instructions and or data structures in part by directly accessing the computer program product for example by reading from a CD ROM disk inserted into a disk drive peripheral of the computer system . Alternatively the processor may process the executable instructions and or data structures by remotely accessing the computer program product for example by downloading the executable instructions and or data structures from a remote server through the network connectivity devices . The computer program product may comprise instructions that promote the loading and or copying of data data structures files and or executable instructions to the secondary storage to the ROM to the RAM and or to other non volatile memory and volatile memory of the computer system .

In some contexts the secondary storage the ROM and the RAM may be referred to as a non transitory computer readable medium or a computer readable storage media. A dynamic RAM embodiment of the RAM likewise may be referred to as a non transitory computer readable medium in that while the dynamic RAM receives electrical power and is operated in accordance with its design for example during a period of time during which the computer is turned on and operational the dynamic RAM stores information that is written to it. Similarly the processor may comprise an internal RAM an internal ROM a cache memory and or other internal non transitory storage blocks sections or components that may be referred to in some contexts as non transitory computer readable media or computer readable storage media.

While several embodiments have been provided in the present disclosure it should be understood that the disclosed systems and methods may be embodied in many other specific forms without departing from the spirit or scope of the present disclosure. The present examples are to be considered as illustrative and not restrictive and the intention is not to be limited to the details given herein. For example the various elements or components may be combined or integrated in another system or certain features may be omitted or not implemented.

Also techniques systems subsystems and methods described and illustrated in the various embodiments as discrete or separate may be combined or integrated with other systems modules techniques or methods without departing from the scope of the present disclosure. Other items shown or discussed as directly coupled or communicating with each other may be indirectly coupled or communicating through some interface device or intermediate component whether electrically mechanically or otherwise. Other examples of changes substitutions and alterations are ascertainable by one skilled in the art and could be made without departing from the spirit and scope disclosed herein.

