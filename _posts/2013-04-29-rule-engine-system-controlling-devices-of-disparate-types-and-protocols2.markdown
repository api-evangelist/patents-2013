---

title: Rule engine system controlling devices of disparate types and protocols
abstract: A rule engine system works with physical systems monitored by Internet-enabled endpoints on one hand and developer custom applications on the other. Endpoints operate in both the domain specific language of the rule engine, and communicate with participating applications in the native protocols thereof. Whether new or legacy, whether hardware, software, or firmware, whether having much, little, or no digital processing or communication capacity, the participating application may be monitored and controlled by an endpoint that communicates over the Internet with the rule engine. Individual developers prepare rule language files, containing data and instructions for the rule engine to implement through the end point. Any apparatus, whether exclusively mechanical, electrical, electronic, highly sophisticated electronic, or some combination may be monitored and controlled. Any participating application, from a mechanical lawn sprinkler to an Internet commerce server may be implemented thus.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09652206&OS=09652206&RS=09652206
owner: Pico Labs, LLC
number: 09652206
owner_city: Lindon
owner_country: US
publication_date: 20130429
---
This application is a continuation of co pending U.S. patent application Ser. No. 12 818 056 filed Jun. 17 2010 which claims the benefit of U.S. Provisional Patent Application Ser. No. 61 187 968 filed Jun. 17 2009 and U.S. Provisional Patent Application Ser. No. 61 262 056 filed Nov. 17 2009 all of which are incorporated herein by reference in their entirety.

This invention relates to databases for storing information and executable applications and more particularly to novel systems and methods for providing individual control of information distribution and use by applications and databases operating over a network.

Much legacy equipment is decades old. Hardware may be mechanical electrical digital or otherwise. A simple and cost effective retrofit capability has heretofore been largely unavailable to implement automatic control Internet enabled control or the like for much of such legacy equipment. Moreover even a device that is new may be completely mechanical and non communicative. A method and apparatus are needed to implement such devices in systems where other devices are processor controlled over the Internet. A generalized simple reliable system and method of upgrading automating and networking such devices by those unaffiliated with the original producer of such devices is needed

Likewise the Internet makes information available. Some say too much information is available without adequate means to search and sort it out. Likewise as information is collected the people who own or control that information desire to know more about how to use the information as well as collecting more of it. Meanwhile much of that information trammels on individual privacy.

On the other hand it would be an advance in the art to provide a system and method for collecting integrating and using information about a person the physical world the person s habits and wishes as well as location activities and the like and relate that to marketing presentations. However a secure system and method for serving and using such information stripped of personal identification information is needed while yet permitting use of specific information identified with the individual but only known to the holder as an anonymous actor.

In view of the foregoing in accordance with the invention as embodied and broadly described herein a method and apparatus are disclosed in one embodiment of the present invention as including a method for controlling a participating application may be based on facts corresponding to the entity controlling the participating application.

The Internet has historically been comprised of a large number of servers and a large number of clients with clients requesting services or data from the servers. In the case of the world wide web the servers provide web pages to the clients upon request. Those pages may contain a wide variety of functionality but typically clients are able to use only the services of one server at a time and not mix the capabilities of different servers to accomplish something new.

Providers of servers may expose application programming interfaces APIs to their servers which allow access by other servers. In accordance with the inventions other servers may invoke functionality to create a combined service. Moreover they are no longer limited by the fact that the client connects to one server at a time. That limitation on the possible functionality and the focus on the server rather than the client are removed. The client is usually operated by the end user who may now make and implement decisions about the value of the services to which he or she is connecting. Additionally the user is no longer forced to continue to interact with silos of functionality that don t take into account the user s individual context.

In accordance with the invention the user is generating data that may be used to make the available services more intelligent. Thus a system in accordance with the invention makes use of that data and interact with the user in the environments in which the user resides such as an internet browser smart phone other mobile device or the like.

The architecture that makes such solutions possible may include a new architectural layer that spans the internet and enables the scripting thereof. It creates a system and method for developers to describe functionality and account for data in their applications that was not previously possible. A system and method in accordance with the invention may include a platform that allows disparate events from disparate systems to be evaluated in the context of the user whether the user is a device a machine an entity or even a person and to deliver functionality to the user s client devices correlated to those events and systems. The context of individuals can now be used as input for scripting the behavior applications or devices and the correlation of that context across devices and data sets is also now possible.

The method may include providing an endpoint module executing on a first processor operably connected to the Internet. A data system may be included receiving general data and a rule engine executing on a second processor and comprising an interpreter effective to process a language. The language may be domain specific to the rule engine executable exclusively by the rule engine and may define a set of rules by which the rule engine evaluates requests received thereby.

The system may include identifying a participating application characterized by a type and comprising operations each characterized by some functionality thereof. Each may have its own participating protocol native thereto and supporting communication therewith. One may operably connect the endpoint module to the participating application and the rule engine to the endpoint module.

The endpoint may communicate with the participating application in accordance with the native participating protocol. A developer may create and provide a file in the language identifying salient events corresponding to activity of the participating application. Likewise a developer s file may define conditions relating to control of the participating application. These may be based on facts corresponding to the entity owning or controlling the participating application.

Salient events may be identified by the rule engine from the KRL Kynetx Rule Engine file and the rule engine may communicate this information to the end point. The end point monitors and thereby detects and reports or otherwise acts on the occurrence in the participating application of at least one of the salient events. Reporting by the end point to the rule engine is possible because both are Internet enabled. The participating application need not be.

Upon receiving by the rule engine the reporting from the endpoint module the data reflecting the salient event certain selected data may be selected out of the general data by the data system. This is in accordance with instructions from the rule engine and based on the content of the KRL file for that endpoint. The KRL file contains executables programs if you will written by a developer for the endpoint. Evaluation instructions are also found in the KRL file for controlling operation of the rule engine.

Receiving by the rule engine from the data system the selected data from the general data it evaluates a set of conditions reflecting the selected data. It also contains information representing at least one of a state of the participating application and values of parameters recognizable by the rule engine as relating to control of the participating application. Therefore the rule engine may generate based on the occurrence directives corresponding to actions to be executed by the participating application.

The rule engine does not communicate directly with the participating application for a number of reasons. Instead the rule engine sends instructions to the endpoint module to invoke the functionality of the participating application by way of directives to the end point module. The end point module then instructs the participating application in the native protocol of the participating application.

All the participating application needs to be is a thing that can be monitored in some way. It simply needs to receive instructions in its native protocol whatever that may be in mechanical electrical electronic digital chemical pneumatic fluidic or other form. If it is processor based it may know it is polled or otherwise monitored but otherwise may be unaware it is being monitored.

The processes include creation of KRL application a KRL file by the developer. Installation of an end point in connection with the participating application may be by a user of the KRL application. Operation of the Kynetx rule engine KRE is by the owner or controller of the KRE system. Operation of the endpoint and participating application may or may not be by the same entity. The participating application will have an owner responsible for its operation. The monitoring thereof and control thereof by the endpoint may be done by a contractor or other agent or may be by the owner of the participating application.

The system delivers to a user substantially the complete functionality of two systems by late binding of two systems under the control of the user and without the participation of the developer of either of the two systems.

The system thus provides to the user a new upgraded computerized and internet enabled control of the participating application. It does not require participation knowledge or consent of the developer of the participating application. Thus a post production enablement of upgrading occurs at the behest of the owner or purchaser of the participating application. This upgrading of the process may occur years even decades or more after initial installation. True retrofit and Internet enablement become available.

In one embodiment an article of manufacture comprises a computer readable medium storing executable and non executable data structures. The data structures may include an endpoint module connected to the Internet and effecting communication between a rule engine and a participating application. The rule engine receives requests from the endpoint module the requests each being encapsulated in an API call. Requests each contain data reflecting occurrence of a salient event corresponding to the participating application.

The rule engine is characterized by a language that is domain specific and defines a set of rules by which the rule engine evaluates the requests. The participating application is characterized by a type and includes participating executables each of which may be characterized by its functionality. It does something.

The participating application may have its own protocol native to itself and of any variety. It may even be a non communicative physical thing that is simply observed somehow by its endpoint which can communicate. The endpoint module is programmed to communicate or otherwise interact with the participating application in the participating protocol thereof. Meanwhile the rule engine is programmed to generate directives and send the directives to the end point module.

The directives are controlled by an evaluation occurring in the rule engine and effective to instruct the endpoint module to invoke the functionality of the participating application. The rules effectively constitute or include an interpreter to process the domain specific language unique to the rule engine.

A developer may define every aspect of a KRL application KRL file desired. In proper syntax a KRL file defines salience data for endpoints corresponding to participating applications what events it cares about. The KRL file defines code structures and contains individual rules selected based on event criteria defined for each specific rule. The end point is provided knows what is salient for its participating application as told to it by the rule engine. The Participating App is simply monitored by or reports data to the end point which then passes on the salient data to the rule engine.

In certain embodiments the article s end point type may be selected from a network proxy server a browser an email server an email client a mobile platform or the like. That type may typically be effective to process executable instructions. It may even include or be a telephony platform or any special function Internet connected processor.

If the end point is a browser its type may be a browser extension a combination of a browser extension with an information card selector a book marklet effective to implement user originated manual invocation of the rule engine a site tag effective to invoke the rule engine directly and automatically from a web page or the like.

The participating application may be configured to communicate with a plurality of endpoint types a plurality of endpoint modules or both. Each is connected to the Internet and characterized by at least one type of a plurality of types.

Salient events correspond to data processable for use in monitoring or controlling the participating application. Thus the endpoint module is further programmed to request of the rule engine an identification of the salient events it should watch for corresponding to the participating application. The endpoint is configured to communicate substantially exclusively with a specific type of participating application. Therefore the protocol of the participating application may be a mechanical or electrical hardware configuration a digital communication protocol a software compatibility requirement any means of rendering detectable a characteristic of the participating application or any combination thereof.

It will be readily understood that the components of the present invention as generally described and illustrated in the drawings herein could be arranged and designed in a wide variety of different configurations. Thus the following more detailed description of the embodiments of the system and method of the present invention as represented in the drawings is not intended to limit the scope of the invention as claimed but is merely representative of various embodiments of the invention. The illustrated embodiments of the invention will be best understood by reference to the drawings wherein like parts are designated by like numerals throughout.

Referring to an apparatus or system for implementing the present invention may include one or more nodes e.g. client computer . Such nodes may contain a processor or CPU . The CPU may be operably connected to a memory device . A memory device may include one or more devices such as a hard drive or other non volatile storage device a read only memory ROM and a random access and usually volatile memory RAM or operational memory . Such components may exist in a single node or may exist in multiple nodes remote from one another.

In selected embodiments the apparatus may include an input device for receiving inputs from a user or from another device. Input devices may include one or more physical embodiments. For example a keyboard may be used for interaction with the user as may a mouse or stylus pad . A touch screen a telephone or simply a telecommunications line may be used for communication with other devices with a user or the like. Similarly a scanner may be used to receive graphical inputs which may or may not be translated to other formats. A hard drive or other memory device may be used as an input device whether resident within the particular node or some other node connected by a network . In selected embodiments a network card interface card or port may be provided within a node to facilitate communication through such a network .

In certain embodiments an output device may be provided within a node or accessible within the apparatus . Output devices may include one or more physical hardware units. For example in general a port may be used to accept inputs into and send outputs from the node . Nevertheless a monitor may provide outputs to a user for feedback during a process or for assisting two way communication between the processor and a user. A printer a hard drive or other device may be used for outputting information as output devices .

Internally a bus or plurality of buses may operably interconnect the processor memory devices input devices output devices network card and port . The bus may be thought of as a data carrier. As such the bus may be embodied in numerous configurations. Wire fiber optic line wireless electromagnetic communications by visible light infrared and radio frequencies may likewise be implemented as appropriate for the bus and the network .

In general a network to which a node connects may in turn be connected through a router to another network . In general nodes may be on the same network adjoining networks i.e. network and neighboring network or may be separated by multiple routers and multiple networks as individual nodes on an internetwork. The individual nodes may have various communication capabilities. In certain embodiments a minimum of logical capability may be available in any node . For example each node may contain a processor with more or less of the other components described hereinabove.

A network may include one or more servers . Servers may be used to manage store communicate transfer access update and the like any practical number of files databases or the like for other nodes on a network . Typically a server may be accessed by all nodes on a network . Nevertheless other special functions including communications applications directory services and the like may be implemented by an individual server or multiple servers .

In general a node may need to communicate over a network with a server a router or other nodes . Similarly a node may need to communicate over another neighboring network in an internetwork connection with some remote node . Likewise individual components may need to communicate data with one another. A communication link may exist in general between any pair of devices.

Referring to a system may host one or more executables. The system may communicate with an application management system by which developers create applications in the language a domain specific language pertaining to the system . The system may rely on a data access system managing data stores pertinent to the applications originating from the application management system and pertinent to the participating applications and their respective endpoints . An account system may operate to verify authorizations and control access to data applications hardware or all thereof.

The system may include one or more processors connected to or over a network or the internet . The system may host for example a rule engine system communicating with participating applications through endpoints . Endpoints are Internet enabled and aware. Participating applications may or may not be but are connected to be monitored by their respective endpoints .

Referring to an apparatus may host a Kynetx system in which applications may participate. One may refer to these applications as such as apps or as Kynetx rule language files or KRL files . Herein a participating application is in a form that it qualifies as a KRL file . Thus such designations may be regarded as largely equivalent terms since a participating application should typically be a KRL file in current embodiments of apparatus and methods in accordance with the invention. Relaxing that requirement may be done but may lose many of the advantages of the system in the process.

Typically in a Kynetx rule engine system or simply the rule engine system the components and functions operable for a Kynetx Virtual Appliance KVA to function are a Kynetx Rule Engine KRE or rule engine along with communications between a KRE and a parser to parse Kynetx Rule Language files KRL files . KRL may also be thought of as Kynetx Rule Language files characterized by the rules protocols formats and so forth of the KRE . A state machine will typically be generated whenever a KRL file is invoked.

Communications will travel between the rule engine and application data while communications travel between the rule engine and user data . Meanwhile communications will pass between the rule engine and the log files along with communications between the log files and the reporting system . Communications also pass between the reporting system and the warehouse storing data.

Likewise the typical components and functions operating for a Kynetx Amazon Master Image KAMI to function are a KRE communications between the KRE and a KRL parser and the state machine generated upon invocation of a KRL or log file .

A participating application may be and typically is any internet connected application device module or routine participating in the Kynetx system through connection to an endpoint . Participating applications can be commercial off the shelf COTS or custom built applications with integrated endpoints .

Communication between the participating application and the endpoint may be in native language for each . For example if the participating application is a browser then the communication is done through Javascript. If the participating application is a mail server then the communication is SMTP IMAP Simple Mail Transfer Protocol Internet Message Access Protocol . For IP based telephony systems the communication may be SIP Session Initiation Protocol and so forth.

The endpoint is a program or application designed specifically as an intermediary for a specific type of participating application . The endpoint is executable to register itself with the Kynetx Rules Engine and receives instructions that govern its behavior. The endpoint also watches for salient events occurring in or on the participating application and generates calls to the Kynetx Rules Engine passing events to the Kynetx Rules Engine to be evaluated thereby.

The KRE functions in response to the Kynetx Rule Language KRL as found in KRL files . The endpoint receives directives from the Kynetx Rules Engine which instruct it what to tell the participating application in order to execute the instructions encountered in the KRL applications encapsulated within the KRL Files . The endpoint also interacts with a controller responsible to manage the user s experience across multiple endpoints with multiple participating applications . Endpoints are typically attached to participating applications either through user opt in processes e.g. downloads or through an initial system configuration. The endpoint thus becomes the interface between the participating application and the Kynetx Rules Engine .

Events are the occurrences events occurring in or on the participating application that the endpoint identifies as being of particular significance to salient to the associated KRL applications . The endpoint is responsible for observing salient events and passing them on to the Kynetx Rules Engine .

The Kynetx Rule Engine may be considered in many respects to be a central heart of the Kynetx system . It is the component that evaluates KRL applications encapsulated in KRL files communicates with endpoints communicates with controllers and generates and stores data as application data or app data user data and log files . The KRE validates KRL applications by invoking the KRL parser and manages internal state machines . It is responsible to interact with KPDS and PDX to retrieve data for evaluation. The KRE is hosted in a server in the illustrated embodiment an Apache server .

Many Kynetx Rule Engines may be operating within a single Kynetx system . The number of Kynetx Rule Engines is determined by the load placed on the system . The Kynetx Rule Engine specifically executes KRL applications and understands KRL natively. Thus the KRE provides the facility that makes the abstractions in KRL possible. It also connects to and utilizes data sources such as Geo IP mappings census data weather data and sources for core KRL functionality. The Kynetx Rule Engine operates memcached technology and manages caching for datasets and KRL applications .

Communication between the Kynetx Rule Engine and the KRL files relies on the KRE to connect to the rule repository to retrieve or pull rules in at runtime. The KRE may use the application programming interface API or other API provided by the rule repository . The Kynetx Rule Engine caches KRL files until the cache is reset by the rule repository when a new production version of a KRL file is created.

KRL files as Kynetx rule language files encapsulate executable code constituting Kynetx rule language based applications. These files may be generated by developers using any number of different tools available and currently deployed to the Kynetx system through the application management API .

Communication between the Kynetx Rule Engine and the KRL Parser occurs when the KRE is ready to evaluate a KRL file that it does not have cached. The KRE may have many KRL files readily available in one or more caches available to it at various levels of proximity. The KRL parser checks the validity of the KRL files usually returning either a pass or fail designation. The KRE passes the entire KRL file to the parser which then parses the file and returns a result back to the KRE indicating whether the KRL File is correct. If malformed by content context syntax or other detectable error the KRE may identify the fact that the file is non functional or may additionally characterize the error or failing of the file .

State machines are generated by the KRE whenever a KRL file is invoked. State machines are actually user specific and track their associated user s progress through out the application as endpoints pass salient events back to the KRE . State machines that have reached completion their pre defined completed state trigger further evaluation in the KRE of the KRL file . They also typically trigger evaluation of other conditions of interest to the user through the application and may be programmed to trigger one or more actions being transmitted by directives back to the endpoint .

Directives are the instructions sent from the KRE to the endpoint when a KRL file is evaluated and all conditions are met for an action to be executed. Formats of directives may typically be made specific to the type of endpoint to which directed. Likewise directives may be formatted in a default JSON structure.

The controller is a user specific application that interacts with all of the endpoints deployed in the behalf of a specific user. The controller provides direction to the different endpoints on action execution and data source management. The user can see all of the applications and endpoints installed for that user. The controller also communicates with the application marketplace module which may be shortened to marketplace or application marketplace which will determine which applications a user has access to.

Communication between the endpoint and the controller often involves the controller communicating parameters to the endpoints such as those indicating which applications are active for the user. Meanwhile communications between the controller and the marketplace . The controller communicates with the marketplace to determine application ownership for individual users. Likewise communication between the KRE and application data involves the KRE generating data associated with each application at runtime. The KRE writes that data out to disk or some other memory device on a server . The application data is specific to an individual KRL file or application typically embedded therein.

Communication between the KRE and the user data results from the KRE generating data associated with each user at application runtime and writing that data out to disk or a memory device associated with typically regarded as on a server such as an Apache server . The user data is specific to individual users for individual KRL files or applications. Communication between the KRE and the log files generated by the KRE to document the execution of KRL files by the KRE are thereby written out to memory such as to disk on the server . Log files contain records for each individual evaluation of a KRL file by the KRE whether or not any action is taken by the application embedded in the KRL file .

Communication between the log files and the reporting system occurs because the reporting system has ETL processes connecting to the log files on the server hosting the KRE . These ETL processes remove log files for the KRE as they are processed thereby. The reporting system is comprised of ETL processes and applications that process log files and store the data in a warehouse actually a data warehouse e.g. a memory device associated with a database engine . The reporting system can output data to other systems or generate reports for human consumption.

Communication between the reporting system and the warehouse may result from the reporting system connecting to the warehouse using database access technologies to store retrieve and modify data stored in records in the warehouse . The data warehouse stores reporting data from the operation of the system centered around the KRE .

A ruleset manager or rule repository application shorthanded as repository is responsible for managing KRL files submitted to the platform or system through the application management application programming interface API . Thus the repository stores KRL files on disk as records or files in memory and manages a database for application version data control updating verification or all thereof. Storage of KRL files occurs whenever the rule repository application writes the KRL files out to disk .

The communication between the rule repository application and the version database originates with the rule repository application connecting to the version database to store version information corresponding to KRL files . The version database stores that version information for all the KRL files recognized by the system . It reflects which version of a particular application is production and which versions may exist that are not production qualified. The data in this database corresponds to KRL files being managed by the rule repository application .

Communication between the KRL Parser the rule repository application and the application management API provides these services at specific points in their operation an opportunity to validate the syntax of the Kynetx rule language KRL contained in KRL files transiting through to other points in the system . The parser responds indicating whether the KRL syntax is correctly formed. Meanwhile the application management API provides an interface for external applications to interact with the rule repository application to create store and edit KRL files .

The use of the application management API is authorized using OAuth . Applications using the application management API must be authorized through their account with a consumer token generated using OAuth token production .

The application builder or app builder is the application development tool provided by the Kynetx system . Users log in and obtain authorization of their use of appbuilder using OAuth . Users of appbuilder must have a Kynetx account and authorize the use of appbuilder using Oauth .

Similarly ruby gem encapsulates the functionality offered by the app management API in a way that simplifies for developers of KRL management apps the task of integrating connectivity to the Kynetx system into any arbitrary proprietary development or management tool. The developer typically must provide an OAuth consumer token for Oauth to grant access to the app management API for that developer s KRL management application .

A KRL management app using Ruby Gem is a proprietary application developed by a third party independent from the system for the purpose of managing specific products services or applications deployed on the Kynetx platform . KRL management apps using the App Management API apply in cases where developers of KRL management apps do not wish to use the Ruby Gem . Developers can invoke the app management API directly in their KRL management applications . The application serves basically the same purpose as the application but the method of access changes.

The accounts application allows users to create accounts manage user information and manage access to different resources. Kynetx provides a global accounts system used across the Kynetx system relying on OAuth token production to generate OAuth consumer tokens on behalf of users. These tokens are used in authorizing access to use system components. The accounts application stores account data in a relational or other database .

Communication between the KRE and various Kynetx sources KPDS and PDX facilitates use by the KRE of data from various sources in the evaluation of KRL files . For data sets not integrated natively into KRL other data services may allow the KRL developer to use external data sources. The KRE and KRL provide facilities to name data sources within a KRL file . Sometimes those data sources will be fronted by a Kynetx provided service such as a Kynetx personal data store KPDS or personal data exchange PDX . This communication layer can use OAuth to authorize the use of data.

A layer of authorization to access data elements may form an important part of the Kynetx data access layers. The system embodiment illustrated relies on an OAuth module a user managed access UMA module or UMA like services to allow users to control the access of their data by Kynetx applications. Such emerging technologies allow a user to control access by others to specific data elements related to that user. The KPDS technology allows developers to connect to local data and non PDX data . Similarly the PDX lets people store data in PDSs controlled by themselves. A PDX provides the standards and protocols for the exchange of data in a PDS .

Communication between a local data store and a KPDS may rely on a relational or other database for storing data that cannot be obtained from any other source. The KPDS may connect to the database through normal RDBMS Relational Database Management System connectivity technologies. Thus the database may be used by KPDS for storing local data. Communication between KPDS and data shims may provide access to and communications with non standard or non PDX data sources .

These shims translate the source data API from its existing standard to REST representational state transfer a standard for web services. Thus a shim may be thought of as a custom program providing a translation layer between a data source and REST. The communication between shims and data sources is accomplished using the native technology implemented in the Non PDX data source itself. In these cases of non PDX data the Kynetx system or platform benefits from accepting data from as many sources as possible. Data non conformal to REST or PDX standards can thus still be used in Kynetx applications .

Communication between Kynetx PDX facilities and PDX data sources typically takes place using PDX standards including OAuth and UMA or technical equivalents . PDX data may be contained in PDSs across the Internet.

An application marketplace module provides a location and manner whereby developers can sell and distribute their applications configured to work with the Kynetx system . Communication between the marketplace module and application meta data refers to communication with a data store storing data about applications available. This data may be accessed through standard RDBMS access technologies. The marketplace module may store application meta data in a standard database for display to application shoppers accessing the marketplace module .

Communication between the accounts module and account data may rely on standard RDBMS access technology. Similarly communication between the Ruby Gem and the application management API may implements native application management API calls over HTTPS Hypertext Transfer Protocol Secure . Oauth meanwhile may authorize the KRL management applications to manage applications.

Communication between the KRL management application and the management application API may rely on HTTPS and use native application management API calls as authorized using Oauth . Similarly communication between the appbuilder module and the application management API may occur over HTTPS using native application management API calls authorized using Oauth.

Communication between the application management API and the rule repository application typically occurs using system level access and native rule repository application function calls. At the opposite side of the system communication between an endpoint and the KRE obtains salience data for installed participating applications using KRE APIs. Also communication between the controller and the KRE allow the controller to identify the endpoints associated with the installed applications for a user.

Thus KRL allows a developer to define every aspect of a KRL application embedded in a KRL file . A properly formed KRL file defines salience data for endpoints corresponding to participating applications what events it cares about. The KRL file defines code structures e.g. global code blocks accessible from any KRL file and contains individual rules selected based on event criteria defined for each specific rule.

Each specific rule contains a prelude block wherein a developer can place code snippets to be implemented in accordance with that rule or in other words defining conditions that are evaluated to determine whether action is to be taken. There exists a hierarchy for a Kynetx rule to fire trigger or take action. An API call occurs. A dispatch block defines in broad terms what is salient for a participating application as per a developer s decisions as to what matters.

Kynetx benefits from the largest set of salient events possible to be defined and trackable. These events depend on what a participating application needs. Typical will events such as the occurrence of a web page view identification a location on a page conditions of the participating applications or hardware and so forth. For example a person user having a computer or phone turned on being online looking at a page of interest or the like may be a salient event significant to a participating application .

It is possible that the participating application is not actively passing data but is simply being monitored. For example the participating application may have or may be software but may instead simply be hardware with detectable conditions detectable and reportable by the endpoint . Even a mechanical device may be interfaced with a processor enabled endpoint device to monitor it.

A participating application may thus be a dumb device such as a mechanical linkage fitted with a cpu enabled endpoint monitoring conditions thereof or a lawn sprinkler relay having a voltage current or activity detectable by an endpoint associated therewith. Such a participating application is not only not Internet connectable or aware but may have no processing capability at all.

Nevertheless the system via the endpoint that is processor based and Internet connected may read or otherwise detect conditions and assert actions controlling that participating application. Thus the above characteristics and events may be detected controlled or both through the endpoint . Therefore such control may be asserted based on events such as weather data time periodicity humidity or anything else pertinent to operation of that participating application .

In another example a participating application may be a very sophisticated cell phone or personal digital assistant having Internet access. Salient events may include Internet page visits by the user who owns the participating application. Salient events may also be the user s physical location such as latitude and longitude along with data about the location of a brick and mortar business location who hosted the web pages previously accessed by that user. Such data may be read from computer data user volunteered data relating to user desires and from the mobile device active on and corresponding to the participating application associated with a user having some of the foregoing data applicable thereto.

In this latter example a store restaurant movie theater or like establishment may broadcast to a user a message email call or like communication upon the user coming within a certain proximity of that establishment. The communication may notify that user of the availability of something the user was recently searching for or reading about on a desktop laptop cell phone or other computing device on the Internet. The communication may provide coupons discounts sale information establishment name directions even an aisle number and price for the item of interest. All this may be with the permission or request of the user provided previously. Thus a commercial marketplace becomes even more fluid and a person may rely on the KRE computer system to watch for deals on goods and services at or below a desired price in or around a certain geography reported when they become available under the right conditions.

In general the end point knows what is salient for its participating application as told to it by the KRE . The participating application simply reports data to the endpoint or is monitored by the end point which collects whatever data the endpoint is programmed and connected to collect. The end point then passes on the salient data to the KRE as described above.

Conditions are more likely to be value related. These may be scientific data values geographic values commercial values proximity values any detectable state or condition values demographic values industrial or process values and so forth. A select statement salient T F may rely on a state machine used to track input of salience data. For example a rule may instruct to select when A x B y C w D v OR some condition Before a condition After a condition Between two conditions AND including another condition and so forth.

If the conditions exists then some response may be reported selected or the like. Conditions are typically true or false T F . An list of conditions may be relied upon like check data and operate as per values logic and so forth. Thus detection of facts data or the like related to external events like weather detection of personal conditions of a user such as location health status inputs etc. detection of conditions of a participating application such as on off hot dry up down moving stopped location etc. or any or all of the above may inform the decision by the KRE to trigger an instruction activating a functionality of the participating application e.g. car sprinkler linkage Iphone radio printer computer signal light etc. .

The way select statements deal with salience from endpoints communicating with participating applications is unique. The fact that one can define in a block of code the salience of events occurring at the participating application and detected by the endpoint provides unique capability to upgrade legacy devices participating applications virtually independently of any previous capacity or complete lack of capacity to communicate or process information. Likewise automated control based on virtually any parameter organic to the device the owner thereof the desires of the owner the weather or external factors etc. may be used to control the device .

Within a KRL file a block of code called the dispatch block is a filter above the select statement. Thus the KRE may know that a user cares about target.com. The KRL file application will operate on target.com. So within each layer the select statement gets more specific conditions are more specific. The parser is a syntax checker. The state of the state engine is set by the conditions required. Once the conditions achieve a completed state the KRE permits instructions to go to end point to control or otherwise communicate with the participating application .

In operation the rule engine may rely on select statements contained within each rule within a KRL file . These define the criteria that must be met in order for the contents of the rule to be evaluated further or selected. Criteria may be established by a developer to be anything cognizable by a computer such as a word a value a string a recognizable image or the like. However criteria may typically be set to be at the top of a decision hierarchy to determine whether to invoke evaluations rather than to contribute information to them. Note that Conditions explained below are typically lower and more detailed in the decision hierarchy of the system .

The rule engine may also use a prelude block a block of code that resides within an individual rule in a KRL file . This prelude block is used to define code elements that will be used in the rest of the rule.

Conditions are statements within the rule that are evaluated after the rule has been selected. Conditions may include evaluations of external data sources either native to the platform and to KRL or non native and accessed through the data access system. Conditions may be created from anything identifiable such as values of parameters text words images or other identifiable and communicable information. For example weather data such as moisture temperature and wind may be monitored and reported as may light and darkness to make a difference in some decision. Conditions of machines facts data locations people positions and so forth may be detectable and communicated as conditions.

Actions are taken after a rule is selected and all of the conditions evaluated are met or true. Then the rule engine encapsulates instructions in a directive e.g. instruction data or both sent back to the endpoint in the form actions. Actions may be communicated for example by data e.g. executable instructions parameters other data structures etc. corresponding to actions to be taken by the endpoint. These actions typically may involve asserting some type of control over the participating application corresponding to the endpoint .

Callbacks are data structures built into the actions to report information back to the rule engine based on the action by the end point participating application user operating or responsible for the participating application or the like. For example certain actions may be taken by a device or by a user after receiving resulting data or functionality reflecting operation of the participating application. Thus callbacks provide feedback from the rule engine and endpoint.

In a typical process an endpoint observes the occurrence of a salient event relating to a participating application . The endpoint generates a request to the rule engine comprised of the identifier for a corresponding KRL file needed as well as the salient data and any other information pertinent to that particular endpoint type.

The endpoint sends the request to the rule engine over the Internet. After the rule engine receives the request it pulls the KRL file either from a cached location or from the rule management application system . The rule engine sends the KRL file to the KRL parser to ensure that it is properly formed. The KRL parser parses the KRL file and returns a true or false result to the rule engine . True means the KRL file has proper syntax is properly formed and a false return means it is not.

The rule engine next sets up a state machine for each rule contained in the KRL file using the information contained in the KRL file in the select statement. The rule engine creates a server session with state storage for the particular participating application involved with the particular user associated therewith or both.

The rule engine evaluates the request from the endpoint and compares the steps defined in the state machine to the data sent from the endpoint . If a criterion or a plurality of criteria defined by the state machine are met by the data sent from the end point then the rule engine writes out the new state for the user and endpoint in the server session that was created as discussed above.

Once all criteria for a state machine for a particular rule are met the rule engine continues with the evaluation of the rest of the rule. The rule engine evaluates the conditions defined in the rule and accesses any data required. Once all of the conditions have evaluated to true then the rule engine generates a directive with the actions specified for the participating application .

The rule engine transmits the directive back to the endpoint which takes appropriate action in accordance therewith to pass the action instructions back to the participating application in the native protocol of the participating application whatever that may be. There need be no inherent limits on the protocol so long as an endpoint is configured physically to monitor and operate the participating application .

The participating application receives or otherwise consumes the instructions and effects the defined behavior or functionality corresponding thereto. A physical actuation of a component may occur information may pass a switch may be triggered or any other of a nearly endless varieties of action may occur. This is because the endpoint is configured to interact in the specific way protocol required by the participating application .

A user may react to the defined behavior. If a user takes an action that has an attached callback then the endpoint transmits the callback back to the rule engine .

Typically each time the rule engine transmits directives to the endpoint the rule engine records in a log file all pertinent information about those workings and transactions.

The application management system in the Kynetx system or platform provides a variety of unique functions. The application management system provides an abstract mechanism or a level of abstraction one could even call it a level of indirection for developers of systems that use the Kynetx platform to manage KRL files .

Initially the application management system through its components provides two mechanism for file management direct API access and a Ruby gem . A client application can invoke either of these methods to write out new KRL files or manage existing files . One result of this functionality is the capability for third parties to develop applications that use the Kynetx platform while maintaining a level of abstraction for their own users.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

