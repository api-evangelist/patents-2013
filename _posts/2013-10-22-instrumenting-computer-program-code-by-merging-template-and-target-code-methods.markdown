---

title: Instrumenting computer program code by merging template and target code methods
abstract: Embodiments provide systems, methods, and computer program products for instrumenting software application code. A target method and a template method may each be elevated to respective linked lists that maintain offsets in a relative relationship using pointers. The lists are merged and converted back to byte code as an instrumented method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09064042&OS=09064042&RS=09064042
owner: RIVERBED TECHNOLOGY, INC.
number: 09064042
owner_city: San Francisco
owner_country: US
publication_date: 20131022
---
The present application claims the benefit of U.S. Provisional Patent Application No. 61 726 067 filed on Nov. 14 2012 which is incorporated herein by reference in its entirety.

The present disclosure relates generally to the instrumentation of software code for software application performance and transaction monitoring.

Instrumentation of software application code is a process of inserting additional instructions into the code stream to enable measurement of one or more properties of the code while executing in an environment. These additional instructions do not change the intended behavior of the software application code. Instead the additional instructions can either make calls to an agent that records the callout time and other data points or record the information directly in line with the original code. Instrumentation of software application code referred to herein as target code may occur by wrapper methods or by in line instrumentation.

The wrapper methods generally replace the original code with a shell that performs recording and calls the original code. Wrapper methods generate an extra call level in the call tree hierarchy have difficulties interacting with the runtime environment e.g. .NET or Java Virtual Machine due to complexity and may create a security threat to the operating environment because of the changes the wrapper methods make to the call stack.

In line instrumentation addresses several of these issues in line instrumentation inserts a prolog which includes code to record a program state at the start of the target code before the target code and an epilog which includes code to record a program state at the completion of the target code after the target code. Although in line instrumentation is not subject to the same challenges as wrapper methods in line instrumentation is also beset with difficulties. Additional instructions must be inserted into key places in the target code which requires analysis and alteration of both the inserted code and the target code in order to address any possible changes in branch target offsets and to guarantee execution of the inserted epilog code. The analysis and alteration may require multiple passes through the code where branch target offsets may have to be recomputed several times.

The present disclosure will be described with reference to the accompanying drawings. Generally the drawing in which an element first appears is typically indicated by the leftmost digit s in the corresponding reference number.

Embodiments of the present disclosure may be implemented within the .NET Framework by Microsoft for example in the Common Language Runtime CLR . In these embodiments the software application code may be described with reference to modules. A module may be a compilation of byte code for example in the .NET environment Common Intermediate Language CIL code that is composed of one or more byte sequences. The compilation of byte code may have been organized into a hierarchy of classes where types in each class enumerate the methods and members of that class. In an example the byte code may be a series of opcodes and operands as will be understood by those skilled in the relevant art s . As an alternative example embodiments of the present disclosure may be implemented with the Java environment for example as part of a Java Virtual Machine JVM . Java does not implement modules in the same manner as the .NET Framework instead dealing directly with classes. These classes may be compiled into class files that together can be incorporated into a Java Archive JAR file. For the sake of simplicity the present disclosure will discuss exemplary embodiments with respect to the .NET Framework although other frameworks can also be used as will be recognized by those skilled in the relevant art s .

According to embodiments of the present disclosure multiple template methods may be maintained and used for instrumenting different methods and types of software application code. In an embodiment the present systems and methods may first determine which target method s should be instrumented select which template s should be used to instrument the target method s and perform the instrumentation for example just prior to just in time JIT compilation by a JIT compiler. In an embodiment different templates are pre created to fit within different general categories. Some examples of such categories include database applications web services socket connections and a general catch all category. The number of categories may range from just a few to hundreds or more as will be recognized by those skilled in the relevant art s . The template method s may be alternatively referred to as copy from methods but for the sake of simplicity will be referred to herein as template methods.

As shown in example network environment includes a plurality of user terminals . through . a network and a server . In an embodiment the plurality of user terminals . through .may be personal computing devices such as desktop computers laptop computers tablet computers mobile phones PDAs just to name a few examples or any combination of the above. A user terminal such as user terminal . may initiate a transaction request to server . The user of user terminal . may be a human. Alternatively the user may be any computer or application capable of requesting the use of computing resources on the server . For example the request may be based on the user s browsing of a particular website use of a cloud computing service or some other remote application as will be understood by a person skilled in the relevant art s .

The user terminal . may transmit the transaction request to the server via a network . The user terminal . may connect to the network via a connection and the server may connect to the network via a connection . In one example the network may be the Internet connecting the server e.g. a web server to the user terminal .. The network may alternatively be an intranet such as a local area network LAN . The user terminal . may communicate with the server using a variety of different communications protocols as will be recognized by those skilled in the relevant art s . The server generally may be any type of computing device configured to perform processing tasks on behalf of a user.

In an alternative example the server may house a database which receives queries from user terminals . through .. In such an example the user terminals . through .may be located within the same vicinity as the server for example behind a common firewall in an intranet or may be located remotely from the server and may connect to the server via a virtual private network VPN or via an unsecured connection as will be understood by those skilled in the relevant art s .

In an embodiment the server may include an application monitoring system for monitoring the performance of the software application s used for processing the transaction request from user terminal .. One exemplary embodiment of the server is depicted in . The server may include one or more processors . The one or more processors may each include one or more processing cores capable of performing parallel or sequential operations for example by use of threads. Server may also include a transceiver for example an Ethernet connection WiFi connection or other connection capable of enabling the server to transmit and receive data to from external sources such as user terminals . to .of . The server may include a data store for example a hard drive flash drive or other types of memory as will be understood by persons skilled in the relevant art s . The data store may store the application s used in completing the transaction request.

When the server starts the software application s necessary to complete the transaction request from user terminal . the server may load a first application module of the software application with an analysis module . The analysis module may analyze each module of the software application at different times to determine which methods within each module may be subject to subsequent instrumentation and monitoring. These methods are described herein as target methods as will be discussed in more detail below. For those methods selected for monitoring the instrumentation module may instrument the target method s according to the different embodiments below. As will be recognized by those skilled in the relevant art s the analysis module and or the instrumentation module may be implemented as hardware software or a combination of both to achieve their respective functions.

Data that is output from the instrumented methods may be in the form of trace files and can be stored in one example in the data store . Alternatively or in addition the trace files may be transmitted and stored in another data store at another server or mass storage device as will be recognized by those skilled in the relevant art s . The data in the trace files may be used to analyze performance metrics and trace transactions.

An exemplary embodiment of server will be discussed in further detail below with respect to . As will be recognized by those skilled in the relevant art s the different functions of server depicted in may be performed wholly within the server or alternatively may be performed by a plurality of different servers or other types of computing devices operating in cooperation within a geographic vicinity of each other or at geographically different locations.

At step the server loads and analyzes the first application module of the software application that will be used to process the received transaction request. In an embodiment the server for example by way of the analysis module determines whether the first application module has been analyzed and the results cached previously. If so the analysis module may load the cached analysis. Otherwise the analysis module may step through each class and method in the first application module to identify target method s of interest for possible instrumentation. The analysis which the server performs will be discussed in more detail with respect to below.

At step the server using the results of the analysis of step identifies which template method s should be used to instrument the target method s . In an embodiment the analysis module identifies the template method s and retrieves them from storage for example from data store . In an embodiment there may be a variety of templates available for different categories such as the database web services socket connections and catch all categories mentioned above. In addition new templates may at any time be created for additional categories or sub categories for example when a new Application Programming Interface API is introduced to the system.

At step the server instruments the target method s using the template method s retrieved from storage such as from data store . Instrumenting a target method will be discussed in more detail with respect to below. Generally the server by way of instrumentation module for example may convert the byte code of the target method to a list such as a linked list of pseudo instructions where any branch target offsets between instructions are replaced by pointers to those destination nodes. In this manner the original offset values become irrelevant during the instrumentation process and the computational cost and time is decreased. The same conversion to a list occurs with the template method. The target method in linked list form is then inserted between prolog and epilog of the template method in linked list form. All of the instructions may then receive newly computed offsets and the pointers may be replaced with new branch target offsets to the newly computed offsets. The instrumented method may then be converted back to byte code.

At step the instrumented method may be sent to a compiler for compilation for example JIT compilation in the CLR environment when the byte code is converted to machine code and executed. After compilation and during runtime the instrumented method may output data which is recorded to trace files. This data is used for monitoring transactions and or analyzing performance of the instrumented method s .

The steps through of process may be repeated for each subsequent module of the software application that may be loaded during operation of the software application at the server in response to the transaction request.

At step the analysis module receives a callback indicating that the application module has been loaded into memory for example provided by the CLR.

At decision step the analysis module determines whether the loaded application module has been previously analyzed by checking the cache. When the application module has been previously analyzed the analysis module stores an identifier of which template s to use when the application module is loaded again such as at step . The identifier could range from a single byte flag to a full string.

If the analysis module determines at step that the application module has not been previously analyzed the analysis module performs the analysis at step . In this step the analysis module may inspect an object derivation tree for the class or classes that are about to be JIT compiled. If the class inherits a particular interface or interfaces that are on a list of interfaces of interest e.g. which map to a particular category or categories of templates as described above the analysis module may determine that those interfaces should be instrumented. Additionally or alternatively the analysis module may analyze the body of one or more of the methods within the class or classes to identify certain instructions of interest. These instructions of interest may be instructions that when called call delegate methods which are a way to indirectly access another method. The analysis module may identify the target of a delegate call. The analysis module may then mark the target method of the delegate call to use a specific template method for instrumentation whenever that target method of the delegate call may be later called. In an embodiment the analysis module may enumerate all of the method types within the application module and identify whether each method should be instrumented.

Alternatively if at decision step the analysis module determines that the application module has been previously analyzed the analysis module may load the stored analysis results from the cache at step .

Under either alternative at step the analysis module identifies the template method s to use for instrumenting the target method s based on the analysis results whether cached or newly generated. For example the analysis module may review each identified method and determine which template method should be used for that identified method. The results of the analysis and identification of template methods may then be stored or re written to the cache for future use. In this manner the hierarchy of each module only has to be traversed once at load time which reduces the computational load during run time of the application code.

Process begins at step in which the instrumentation module identifies the target method identified in the analysis process of along with the template method determined to correspond with the target method for example by communicating with the analysis module . In an embodiment the analysis module may have identified a plurality of target methods for instrumentation in which case the instrumentation module identifies the plurality of template methods determined to correspond with the plurality of target methods. For the sake of simplicity discussion will focus on the single target method and single template method identified though it will be recognized that the same steps will apply to a plurality of methods.

At step the byte code of the target method is elevated to pseudo code or pseudo instructions as they will be referred to herein to form a target instruction list. illustrates the elevation of a target method byte code to a target instruction list . As shown in target instruction list is a linked list of objects that encapsulate opcodes and operands. The byte code of the template method is similarly elevated to pseudo instructions to form a template instruction list for example a linked list of opcodes and operands as shown in . According to embodiments of the present disclosure the byte code of the template method includes a prolog sequence a sentinel sequence and an epilog sequence . These sequences are retained after conversion from template method byte code to the template instruction list composed of sequences and . Before elevation the sentinel sequence includes a unique byte sequence of instructions that permits the instrumentation module to identify the sentinel sequence . The instrumentation module will use this unique sequence of instructions after elevation as the point to merge the target instruction list between the prolog and epilog sequences and of the template instruction list.

Where the target method and or template method included branch target offsets these branch target offsets are replaced by pointers. Each pointer points to the node of the linked list that corresponds to the original byte code before elevation for example as depicted in . provides a general illustration of the conversion of jump or branch target offsets referred to herein collectively as branch target offsets for simplicity of discussion in linked list to pointers in linked list . Linked list has two instructions and with branch target offsets. These offsets are converted to pointers in instructions and in linked list . In this manner the branch target offset value becomes irrelevant during the rest of the instrumentation process because the pointer maintains the interrelationship without requiring repeated re computations. In an embodiment the instrumentation module converts the branch target offsets to pointers during the same time as the elevation of the byte code to the linked list. As will be recognized by those skilled in the relevant art s this may also be performed after the elevation to the linked lists has been performed as a subsequent step on the new linked lists for both the target and template methods whenever either has branch target offsets.

Returning to at step the byte code of exception block s of the target method is elevated to an intermediate pseudo exception block representation referred to herein as pseudo blocks. In an embodiment the exception block may consist of try catch and try finally pairs although other exception handler ranges are possible as will be recognized by those skilled in the relevant art s . In the resulting pseudo block s the ranges of try handler and finally blocks may be replaced by pointers to corresponding nodes of instructions in each pseudo instruction list for the target and template methods. This is graphically illustrated in . In the target method exception handler ranges are elevated to a list of pseudo blocks where each pseudo block includes a handler and a start and end range. illustrates the replacement of the try handler and finally offsets of pseudo blocks with pointers in list to the corresponding nodes of instructions in the linked list . Linked list may represent the target instruction list . As a result if linked list is modified the pointers in the pseudo blocks would still point to the originally intended instructions.

The exception block s of the template method are similarly elevated to pseudo blocks where the ranges are replaced by pointers to the corresponding instructions in the template instruction list that includes sequences and as discussed with respect to above.

In embodiments that occur within the .NET environment which uses a token and table based system exception class tokens related to the exception blocks may have to be adjusted due to the new context. For example these tokens may reference classes and methods that are external or internal to the template method they are found in. These references are relative to the context of the template method they are found within. For example if there are any exceptions that catch in the template method there would be a corresponding exception class token specific to the context where the template method exists. That token may need to be updated once the methods are merged so the references are relative to the application module because the context changes from the template method to the application module containing the target method being instrumented.

Returning to process at step local variables of the target and template methods are merged into a single local variables list. In an embodiment the list of local variables for the template method is appended to the list of local variables for the target method. This is because local variables are addressed in the instruction stream by their relative position in their respective lists and there are typically more local variables associated with the target method than with the template method. This is depicted in where the template method local variables are appended to the target method local variables . In an embodiment new local variables may result from the process of instrumentation itself. Where this occurs the new local variables may be appended to the target method local variables followed by the template method local variables . This combination of local variables results in the instrumented local variable list in .

In this manner the instructions in the target instruction list which reference local variables require no adjustment while instructions in the template instruction list which includes sequences and that reference local variable indices will be offset by the number of local variables in the target instruction list . For example where the target instruction list includes n local variables the local variables for the template instruction list are appended by adding n to the index value of each local variable for the template instruction list. The local variable list of the target instruction list may alternatively be appended to the local variable list of the template instruction list that includes sequences and .

In embodiments that occur within the .NET environment a signature blob which represents all local variable types in the corresponding method may be updated. This may include updating all type field and method tokens referenced in the newly created signature blob resulting from the combined local variable list.

At step the pseudo instructions in the target instruction list are merged with the pseudo instructions in the template instruction list that includes sequences and . This is illustrated in more detail in which illustrates an exemplary flowchart of a process for merging target and template linked lists according to an embodiment. Discussion of is made with reference to which illustrates an exemplary merged linked list according to an embodiment.

At step the merged instruction list begins by inserting the prolog instruction list referenced above as prolog sequence .

After the prolog instruction list is inserted at step the sentinel sequence is detected. The sentinel sequence may include a unique instruction sequence that enables its identification as the location at which to insert the target method that is being instrumented.

After detecting the sentinel sequence at step the instrumentation module may insert target instruction list shown in as target instruction list at the end of the prolog instruction list .

At step any return pseudo instructions in the target instruction list are identified. Return pseudo instructions are identified for example by instrumentation module so they may be replaced by branch instructions with corresponding pointers to the first pseudo instruction of the epilog instruction list that follows the sentinel sequence . In an embodiment these return pseudo instructions may be instructions that cause the target method to end. These are replaced with the pointers to the epilog instruction list so the instrumented method that results from this process does not prematurely end.

At step the return pseudo instructions that were identified are replaced by the branch instructions to the epilog instruction list referenced above as epilog sequence with the corresponding pointers.

At step any pseudo instructions which have a short operand representation may be replaced by instructions that have a long operand representation. The use of short operand representation may occur for example in .NET environments where the compiler creates shorter instructions where possible.

Once the target instruction list has been appended to the prolog instruction list the sentinel sequence may be discarded at step . In an embodiment this may take the form of replacing the unique instruction sequence that formed sentinel sequence with no operation pseudo instructions.

Once the target instruction list is inserted the instrumentation module inserts the epilog instruction list after the target instruction list at step .

At step and as discussed above with respect to any tokens in any of the instruction sequences may be updated. This may be done as required to reflect the new context in which they are located.

In this manner a single merged instruction list results that contains the pseudo instructions from both the template and target methods.

Returning now to at step the pseudo blocks of the target instruction list are merged with the pseudo blocks of the template instruction list after completing the merge of the pseudo instruction linked lists in step . In an embodiment the template pseudo blocks are appended to target pseudo blocks . In the merge the pointers are retained to the branch targets in each exception block s lists. This results in proper nesting of the target pseudo blocks within the pseudo blocks of the template method reflecting the nesting of the pseudo instruction list within the instruction lists and of the template pseudo instructions. In an embodiment the nesting is in order of outermost to innermost instruction lists. This is depicted in which shows target method pseudo blocks preceding template method pseudo blocks in a merged context that results in a merged pseudo block .

Although illustrates the merging at step occurring before the merging at these may be done in any order as long as all of the merging is completed before conversion back to byte code as discussed below.

At step the instrumentation module may traverse the now merged linked list for example a combination of the merged instruction list and the merged pseudo block . In the traversal the instrumentation module assigns new program offsets to each pseudo instruction. In an embodiment the new program offsets begin with an offset of zero and increase with each pseudo instruction.

At step the instrumentation module may again traverse the merged lists to replace the original branch target offset pointers with modified or new branch target offsets that reflect the newly assigned program offsets resulting from step . After replacing the pointers with the new offsets the merged instruction list may be converted back to a merged instruction byte code sequence and written to a byte stream output buffer.

At step the instrumentation module may also calculate new branch and exception handler offsets from the relative offsets in the pointers depicted as relative offsets in . These pointers in the relative offsets may be replaced by new offsets shown in the exception blocks of . In step the starting and ending pseudo instructions for each region of each pseudo block may be replaced by the new offsets. Each pseudo block may then be converted back to original block form as a merged exception block byte code sequence.

At step the merged exception block byte code sequence may be appended to the merged instruction byte code sequence to form the instrumented byte code.

At step the instrumented local variable list may be associated with the instrumented byte code for example by summarizing the local variable list in a header of the instrumented byte code. In embodiments using the .NET environment a token or set of tokens representing the instrumented local variable list is added to a header of the instrumented byte code which associates the instrumented method with the updated local signature blob discussed above. Further the size of the instrumented method may be summarized and added to the header of the instrumented method.

Steps and may occur simultaneously to each other or in sequential order. Further the conversion back to byte code may separately occur for the merged instruction list and the merged pseudo block as described with respect to steps through . Alternatively the instrumentation module may calculate the new offsets and replace the pointers with the new branch target offsets for both the merged instruction list and the merged pseudo block before converted both back to byte code together with the instrumented local variable list in a single step. This is illustrated in where the full list including both the merged instruction list the merged pseudo block and the instrumented local variable list is converted back to instrumented byte code as the instrumented method.

The instrumented byte code depicted in may then be passed on to the JIT compiler for compilation and execution. In an embodiment target methods are re instrumented each time they are accessed for JIT compilation. Alternatively after a target method is instrumented the instrumented sequence may be cached for future re use. In any event the template method used for instrumenting any particular target method is not modified in memory during any instrumentation process so that the template method may be used again for other identified methods of interest in the same or different application modules.

In this manner embodiments of the present disclosure avoid the expensive repeated analysis re computation and alteration of branch target offsets while instrumenting application code in line with the code.

Embodiments of the present disclosure can be implemented in hardware software or as a combination of software and hardware. Consequently embodiments of the disclosure may be implemented in the environment of a computer system or other processing system. An example of such a computer system is shown in . Embodiments described in or B may execute on one or more computer systems . Furthermore each of the steps of the processes depicted in and can be implemented on one or more computer systems .

Computer system includes one or more processors such as processor . Processor can be a special purpose or a general purpose digital signal processor. Processor is connected to a communication infrastructure for example a bus or network . Various software implementations are described in terms of this exemplary computer system. After reading this description it will become apparent to a person skilled in the relevant art s how to implement the disclosure using other computer systems and or computer architectures.

Computer system also includes a main memory preferably random access memory RAM and may also include a secondary memory . Secondary memory may include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive or the like. Removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit represents a floppy disk magnetic tape optical disk or the like which is read by and written to by removable storage drive . As will be appreciated by persons skilled in the relevant art s removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In alternative implementations secondary memory may include other similar means for allowing computer programs or other instructions to be loaded into computer system . Such means may include for example a removable storage unit and an interface . Examples of such means may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket a thumb drive and USB port and other removable storage units and interfaces which allow software and data to be transferred from removable storage unit to computer system .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices. Examples of communications interface may include a modem a network interface such as an Ethernet card a communications port a PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a communications path . Communications path carries signals and may be implemented using wire or cable fiber optics a phone line a cellular phone link an RF link and other communications channels.

As used herein the terms computer program medium and computer readable medium are used to generally refer to tangible storage media such as removable storage units and or a hard disk installed in hard disk drive . These computer program products are means for providing software to computer system .

Computer programs also called computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable the computer system to implement the present disclosure as discussed herein. In particular the computer programs when executed enable processor to implement the processes of the present disclosure such as any of the methods described herein. Accordingly such computer programs represent controllers of the computer system . Where the disclosure is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive interface or communications interface .

In another embodiment features of the disclosure are implemented primarily in hardware using for example hardware components such as application specific integrated circuits ASICs and gate arrays. Implementation of a hardware state machine so as to perform the functions described herein will also be apparent to persons skilled in the relevant art s .

Embodiments have been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.

The foregoing description of the specific embodiments will so fully reveal the general nature of the disclosure that others can by applying knowledge within the skill of the art readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present disclosure. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.

The breadth and scope of embodiments of the present disclosure should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

