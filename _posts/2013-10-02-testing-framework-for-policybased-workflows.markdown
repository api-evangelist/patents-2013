---

title: Testing framework for policy-based workflows
abstract: A system comprehensively tests each feasible path in a policy-based Extensible Markup Language (XML) workflow. The system may receive an input workflow and parse workflow (or proxy code of the workflow) to construct a policy control flow graph. The system may identify paths in the policy control flow graph, such as each feasible path in the policy control flow graph. The system may determine path constraints for the identified paths, where the path constraints identify path conditions for traversing the identified path in the policy control flow graph. Then, the system may generate a set of test inputs for the workflow using the path constraints that, when input into the policy-based XML workflow, cause the workflow to traverse the identified paths.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09367434&OS=09367434&RS=09367434
owner: Accenture Global Services Limited
number: 09367434
owner_city: 
owner_country: IE
publication_date: 20131002
---
This disclosure relates to a framework for test generation. This disclosure also relates to generating a testing framework for policy based Extensible Markup Language XML workflows.

Rapid advances in technology have resulted in increasingly large applications that process increasingly large amounts of data. Applications can reach thousands to hundreds of thousands and even millions of lines of code. As one example a workflow application may include several thousands of lines of code and include millions to billions or more of possible paths to traverse through the workflow. Developers may produce code including workflow applications without a systematic testing framework to comprehensively or effectively test the code. Manually generating tests to comprehensively test the code may be laborious cost multiple days of effort or be completely infeasible in some cases.

The descriptions below include methods systems logic and devices for automated comprehensive testing of a policy based workflow.

In one aspect a method may be performed by a processor of a system. The method may include the steps of receiving a policy based Extensible Markup Language XML workflow comprising multiple policy nodes and multiple condition nodes the multiple policy nodes and multiple condition nodes accessible through a common input point in the policy based XML workflow parsing the policy based XML workflow to construct a policy control flow graph for the policy based XML workflow identifying paths in the policy control flow graph determining path constraints for the paths in the policy control flow graph the path constraints identifying one or more path conditions for traversing a respective path in the policy control flow graph generating a set of test inputs for the policy based XML workflow using the path constraints where the set of test inputs when input into the policy based XML workflow cause the policy based XML workflow to traverse the identified paths in the policy control flow graph and storing the generated set of test inputs into a memory of the system.

In another aspect a system may include code parsing logic path enumeration logic constraint collection logic and constraint solving logic. The code parsing logic may be configured to receive a policy based Extensible Markup Language XML workflow comprising multiple policy nodes and multiple condition nodes the multiple policy nodes and multiple condition nodes accessible through a common input point in the policy based XML workflow and parse the policy based XML workflow to construct a policy control flow graph for the policy based XML workflow. The path enumeration logic may be configured to identify paths in the policy control flow graph. The constraint collection logic may be configured to determine path constraints for the paths in the policy control flow graph the path constraints identifying one or more path conditions for traversing a respective path in the policy control flow graph. The constraint solving logic may be configured to generate a set of test inputs for the policy based XML workflow using the path constraints where the set of test inputs when input into the policy based XML workflow cause the policy based XML workflow to traverse the identified paths in the policy control flow graph.

In another aspect a non transitory computer readable medium may include processor executable instructions that when executed by a processor cause a system to receive a policy based workflow comprising multiple policy nodes and multiple condition nodes the multiple policy nodes and multiple condition nodes accessible through a common input point in the policy based XML workflow parse the policy based workflow to construct a policy control flow graph for the policy based workflow identify paths in the policy control flow graph filter the identified paths into a set of filtered paths determine path constraints for the set of filtered paths the path constraints identifying one or more path conditions for traversing a respective filtered path in the set of filtered paths and generate a set of test inputs for the policy based workflow using the path constraints where the set of test inputs when input into the policy based XML workflow cause the policy based workflow to traverse the set of filtered paths.

The system circuitry may implement any of the processing performed by the system in hardware firmware software or any combination thereof. The system circuitry includes test generation logic . As discussed in greater detail below the test generation logic may generate a set of tests that comprehensively test the policy based XML workflow. In that regard a system executing the set of tests e.g. test inputs may traverse each feasible path of the policy based XML workflow. A feasible path may refer to a path in the policy based XML workflow that an input can cause the workflow to traverse through. A path in the workflow may refer to an ordering of nodes in the policy based workflow that ends at an end point node and that an input to the workflow may traverse through.

In some implementations the system circuitry includes one or more processors and a memory . The memory may store test generation instructions test inputs and testing oracles . The processors may execute the test generation instructions to generate a set of test inputs for comprehensively testing a policy based XML workflow. The testing oracles may specify previous or expected outputs for the set of input tests . The testing oracles may be configured adapted or adjusted by a system administrator or code tester for example.

The policy based workflow may receive an input and implement a processing flow to produce an output . The type and format of the input may vary depending on the purpose of the policy based workflow . When the policy based workflow is implemented as part of an API management system or access control policy system the input may take the form of a HyperText Transfer Protocol HTTP request for instance. When the policy based workflow is implemented as part of an XSL transformation system the input may take the form of an XML document.

The policy based workflow may include multiple points e.g. nodes to process or direct an input . For example the exemplary policy based workflow includes policy nodes and condition nodes. Policy based workflows may be characterized in that they are only accessible from a limited number of input or entry points. In that regard the only point to control or perturb a path in the workflow may be at these input points. As shown in the workflow includes the policies labeled as Policy 1 Policy 2 Policy 3 Policy 4 Policy 5 and Policy N with the node labeled as Policy 1 acting as the only entry point to the workflow . In processing a particular input the policy based workflow may execute particular policies in the workflow depending on conditions of different variables e.g. depending on the value of input variables included as part of the input output variables included as part of the output system variables variables processed by previous policies in the workflow and others. Conditions in the policy based workflow may specify which of the policies in the workflow to execute e.g. by controlling the direction or path taken by the input in the workflow . As seen in the exemplary workflow includes the conditions labeled as C1 C2 C3 and CN. Variables and conditions included in a particular workflow may vary depending on the specific system implementing the workflow or purpose of the workflow .

A policy in the policy based workflow may include processing logic that manipulates an input output or control flow of the workflow . For example a Quota policy may affect the control flow of the policy based workflow by limiting how often a client app is permitted to invoke an API over a given time interval. A workflow policy may affect the state of the workflow by extracting or manipulating variables such as input output or system variables. Examples of such policies may include policies that assign a variable value or extract a variable value from an input output or system variable. Some policies in the workflow may manipulate the format of the input or output . For instance a JSON2XML policy in the workflow may convert an input implemented in a JavaScript Object Notation JSON format into an XML format. In that regard the JSON2XML policy may have a pre condition that the input be in a JSON format and a post condition that the processed input is in XML format.

The policy based workflow produces an output . As examples the output may take the form of an HTTP response in an API management system and accept deny message for an access control policy or an output XML or HTML document for an XSL transformation system.

The test generation logic generates a set of test inputs for the policy based workflow . The test generation logic may generate the test inputs as inputs into the policy based workflow that traverse for example each feasible path in the workflow . In that regard the test inputs when input into the policy based workflow may cover every feasible path in the workflow thus allowing comprehensive testing of the policy based workflow .

The test generation logic may quickly and efficiently generate the test inputs for the workflow in an automated fashion even with for workflows of increased size. A policy based XML workflow may include thousands of lines of code and multiple policies and conditions. As an illustrative example a policy based XML workflow with fifty 50 conditions may include as many as 2 50 number of possible paths. Even if not every one of the 2 50 possible number of paths are feasible the test generation logic may generate test inputs that cover each of the millions or billions or more of feasible paths in the illustrative policy based XML policy with 50 conditions.

The test generation logic may receive an input workflow and parse the input workflow using the code parsing logic . The test generation logic may in some instances adapt the input workflow into a format recognizable by the code parsing logic . For instance the system may implement the code parsing logic to specifically parse XML code. Upon receiving an input workflow in a format other than XML e.g. JSON the test generation logic or other logic in the system may transcode the input workflow into XML format e.g. as proxy code.

The code parsing logic may parse the input workflow or proxy code to construct a policy control flow graph PCFG . The policy control flow graph may refer to a representation of the policy based workflow in the form of a data structure identifying the relationships between nodes in a workflow. The code parsing logic may parse XML code to identify the policies and or conditions specified in the input workflow . In some variations the code parsing logic represents the identified policies or conditions of the input workflow as vertices in the policy control flow graph . The code parsing logic may also identify edges between policies or conditions in the input workflow and represent the identified edges in the policy control flow graph . A particular vertex or edge in the policy control flow graph may include one or more conditions for reaching the particular vertex or traversing the particular edge. The code parsing logic may represent the policy control flow graph as a collection of vertices and edges e.g. as a Java Graph object.

In some implementations the code parsing logic may represent all policies conditions and or edges of the input workflow in the policy control flow graph . In other implementations the code parsing logic may represent less than all of the policies conditions and or edges of the input workflow in the policy control flow graph .

Continuing discussion of the exemplary process the path enumeration logic may enumerate e.g. identify paths in the input workflow by processing the policy control flow graph . The path enumeration logic may identify paths in the policy control flow graph by for example identifying an end point vertex e.g. node and determining the vertices edges combination s in the policy control flow graph that reach the end point vertex. As another example the path enumeration logic may sequentially process vertices and edges in the policy control flow graph e.g. starting from the input point of the input workflow . Upon identifying an end point vertex the path enumeration logic may determine the vertices edges combination s for some or all of the paths that reach and end at the end point vertex. Accordingly the path enumeration logic may determine a set of policy control flow graph paths from the policy control flow graph .

The path enumeration logic may determine the set of policy control flow graph paths to include some or all of the possible paths in the input workflow . In various implementations the set of policy control flow graph paths may include all of the feasible paths in the input workflow and not include non feasible paths in the input workflow . A non feasible path may refer to a path in a policy based workflow that no input can cause the workflow to traverse through or that the workflow can never execute. One example of a non feasible path is a path that includes conflicting condition requirements. In this example the non feasible path may include a first vertex e.g. first policy that can only be reached when a particular input variable is greater than the threshold value as well as a second vertex e.g. second policy that can only be reached when the particular input variable is less than the threshold value. Accordingly the path enumeration logic may filter or exclude non feasible paths in the input workflow from the policy control flow graph paths .

In some variations the path enumeration logic may determine the set of policy control flow graph paths to include a particular subset of the feasible paths in input policy . For example the path enumeration logic may exclude some feasible paths from set of the path control flow graph paths according to any number of filtering criteria. One example of a filtering criterion discussed above may specify excluding non feasible paths from the path control flow graph paths . Another exemplary filtering criterion may specify excluding paths feasible and or non feasible that traverse a particular vertex or edge in the policy control flow graph . Yet another exemplary filtering criterion may specify including feasible paths that traverse a particular vertex or edge in the policy control graph and excluding non feasible paths as well as feasible paths that do not traverse the particular vertex or edge. The test generation logic may specify various additional or alternative filtering criteria such as path criteria for paths exceeding a path length threshold e.g. in number of vertices or edges paths manipulating or accessing a particular variable paths that trigger a particular condition or set of conditions and more.

Continuing the constraint collection logic may determine path constraints for the set of paths included in the policy control flow graph paths . Path constraints for a particular path may refer to the conditions variables format state or other characteristics that an input e.g. request to the input workflow would include to traverse the particular path. In doing so the constraint collection logic may examine a particular path to identify the system state and or path conditions to input workflow to traverse that particular path. The constraint collection logic may sequentially examine nodes in the particular path and update the path constraints for the particular path based a change in the system state caused by the current node particular path condition required to traverse from the current node to a subsequent node and more. In that regard the constraint collection logic may append e.g. add a path condition to traverse from the current node to a subsequent node to previously determined path condition s for traversing to the current node. The constraint collection logic may continue to examine nodes in the particular path until reaching an end point e.g. end node of the particular path.

In some variations the path constraints may include a set of constraints for each path in the policy control flow graphs . In other variations the constraint collection logic may generate path constraints for select paths in the PCFG paths that meet one or more path filtering criteria including any of criteria discussed above. In that regard the test generation logic may filter the number of paths for which test inputs are determined at various points in the exemplary process by excluding edges and or vertices when generating the policy control flow graph by excluding particular paths when determining the policy control flow graph paths by foregoing determining constraints for particular paths when determining the path constraints or any combination thereof.

Continuing the exemplary process the constraint solving logic may process e.g. solve the path constraints to produce one or more test inputs . Put another way the constraint solving logic may determine as the test inputs the inputs to the input workflow that satisfy the path constraints . Thus the test generation logic may determine a set of test inputs that traverse each feasible path in the input workflow . The test inputs allow comprehensive testing of the input workflow by testing each feasible path in the input workflow .

An illustrative example of determining path constraints for a path in an exemplary workflow and solving the path constraints to determine an output test for the exemplary workflow is presented next in .

The policy based XML workflow in includes nine 9 nodes including the policy nodes labeled as nodes and as well as the condition nodes labeled as nodes and . At the nodes the workflow operates as follows 

At policy node the workflow receives an input request e.g. for a particular book and extracts a content type of the input request into a variable CT. 

At condition node the workflow determines whether the content type of the input request as identified in the variable CT is neither JSON nor XML. If true i.e. the content type of the input request not JSON or XML the workflow proceeds to policy node . If false i.e. the content type of the input request is either JSON or XML the workflow proceeds to the condition node .

At policy node the FAULT policy sends an error message to a user. Policy node is an end point vertex and thus one path in the workflow can be identified as the path sequentially traversing the following nodes node node node .

At condition node the workflow determines whether the content type of input request is JSON for example by evaluating the condition Header.ContentType JSON . As another implementation the condition node may examine the variable CT which also stores the content type of the input request. When the content type of the input request is JSON the workflow proceeds to policy node . When the content type of the input request is not JSON as evaluated at condition node the workflow proceeds to policy node .

At policy node the workflow converts the input request from JSON to XML. The workflow may for example execute a ToJSON transcoding function on the input request that converts the payload of the input request from JSON format to XML format.

At policy node the workflow determines the category of book requested in the input request by extracting an XPATH expression of the input request into a variable Cat. For example the workflow may perform the following Cat Request.xpath Bookstore Book Category . 

At condition node the workflow determines whether the category of book requested in the input request is fiction by evaluating a condition on the Cat variable. The workflow may execute the following condition Cat Fiction. When the Cat variable indicates the input request is requesting a book of category fiction the workflow proceeds to policy node . When not the workflow proceeds to policy node .

The test generation logic may determine a set of test inputs that when executed traverse each feasible path in the policy based XML workflow . In doing so the test generation logic may construct a policy control flow graph of the workflow and determine a set of policy control flow graph paths for the workflow e.g. as described above. In particular the test generation logic may determine all five 5 feasible paths of the workflow as the set of policy control flow graph paths which are as follows 

The test generation logic may determine path constraints for each of the five feasible paths in the workflow . One example is presented next in .

The process in includes various points which specify the system state labeled as State and path conditions labeled as PC identified by the test generation logic after examining a particular node in the policy based workflow . As seen in the exemplary process includes the points labeled as point .

The test generation logic may examine an initial node in a path or workflow. In the example shown in the test generation logic examines node which is the initial node in the policy based workflow as well as the initial node in path D. After examining node the test generation logic identifies the system state and path conditions specified in the point . In particular the test generation logic may determine that after reaching node the system state of the workflow includes the variable CT with an extracted value of the content type of the header of an input request. The path condition to traverse from node to node is 1 as the workflow always proceeds from node to node .

After examining node the test generation logic identifies the system state and path conditions specified in the point . The test generation logic may identify node as a condition node and determine that no change is made to the system state. Also the test generation logic may determine that to traverse from node to node the condition specified in node must be evaluated to be false e.g. that the content type of the input request is either JSON or XML. Accordingly the test generation logic may update the path conditions to be Header.ContentType XML Header.ContentType JSON. At point the path conditions may specify the particular conditions that may be specified in an input request for the workflow to traverse a particular subpath in the workflow or path D i.e. node node node .

The test generation logic may similarly examine the remaining nodes in path D of workflow . After examining condition node the test generation logic identifies the system state and path conditions specified in the point . The test generation logic may determine that to traverse from node to node the condition Header.ContentType JSON as specified in condition node must be evaluated to be true. Accordingly the test generation logic may add the path condition from node node to the previously determined path conditions for node node node which results in the path condition Header.ContentType XML Header.ContentType JSON Header.ContentType JSON. The test generation logic may simplify the path condition expression to be Header.ContentType JSON as shown in point .

After examining node the test generation logic identifies the system state and path conditions specified in the point . As node always traverses to node in the workflow the test generation logic may determine no changes to the path conditions. The test generation logic may update the system state based on the JSON2XML function performed at node by updating the system state to reflect the conversion of payload content type from JSON to XML. As seen in point includes the added variable information Request.Payload ToXML Request.Payload . Similarly after examining node the test generation logic identifies the system state and path conditions specified in the point which updates the system state to further include the variable information for the variable Cat that identifies the category of book requested by the input request.

After examining node the test generation logic identifies the system state and path conditions specified in the point . The test generation logic may determine the condition for traversing from node to node in path D of the workflow . Specifically the test generation logic may determine the condition Cat Fiction must be evaluated to be TRUE and accordingly append the condition ToXML Request.Payload .xpath Bookstore Book Category Fiction e.g. the path condition to traverse from node to node to the previously determined path condition of Header.ContentType JSON e.g. the previously determined path conditions for reaching node along path D .

The test generation logic may cease examining nodes for collecting path constraints in response to identifying or examining an end point node in a path. In the example shown in the test generation logic identifies node as an end point node in the workflow thus ending path D. The test generation logic may determine that executing the policy specified in node does not impact the system state or path conditions and thus determines the path constraints of path D of the workflow as the system state specified in point the path conditions specified in point or both. In some variations the test generation logic determines the path constraints as the path conditions to reach a particular node in a workflow along a particular path in the workflow e.g. the path conditions determined by the test generation logic to reach node along path D in the workflow .

In some variations the test generation logic determines the path constraints for previously enumerated paths in a workflow. In other variations the test generation logic may examine nodes and determine path constraints for one or more subpaths in the workflow e.g. ordering of nodes in the workflow that does not include an end point node before identifying a path e.g. ordering of nodes in the workflow that includes an end point node . In these variations the test generation logic may collect constraints and determine paths simultaneously for instance.

As one exemplary illustration the test generation logic may process e.g. examine some or all of the nodes in a workflow the edges between nodes in the workflow or both. The test generation logic may determine whether a currently examined node is an end point node. For a current node that is not an end point node the test generation logic may determine the path conditions for some or all of the subpaths to reach the current node. Then for a subsequent node linked to the current node the test generation logic may determine append the path condition to traverse to the subsequent node from the current node to the determined path conditions for reaching the current node. In this regard the test generation logic may sequentially and systematically determine path conditions for traversing various nodes in the workflow through various subpaths. When the current node is an end point node the test generation logic may identify one or more paths in the workflow that conclude at the end point node and determine the respective path constraints for the one or more paths as the path conditions for traversing to the endpoint node across various subpaths in the workflow. The test generation logic may for example determine path constraints for the feasible paths in the workflow.

The test generation logic may generate a test input according to the path constraints of a particular path in a policy based workflow. The test input may be in the form of an input e.g. input request to the workflow that traverses the particular path of the policy based workflow. In that regard the test generation logic may test specific policies and or conditions in the workflow even when the only access to the policy based workflow to perturb a path to reach the specific policies and or conditions is at an initial input to the workflow or system front end.

The test generation logic may generate the test input according to the path constraints of a particular path in an input format supported by a workflow. Returning to the example shown in the test generation logic may process e.g. solve the following path constraint for path D in the exemplary policy based workflow of ToXML Request.Payload .xpath Bookstore Book Category Fiction Header.ContentType JSON. For example the test generation logic may solve the path constraint for path D by generating a test input as the following cURL request executable from a command line in a system executing cURL software 

The test generation logic may receive as an input a policy based workflow . In some variations the test generation logic may specifically process policy based XML workflows. Accordingly the test generation logic may determine whether the received policy based workflow is in an XML format . If not the test generation logic may transcode or convert the input policy based workflow into XML .

The test generation logic may parse the policy based XML workflow to construct a policy control flow graph . The test generation logic may represent the policy control flow graph a Java Graph object including a collection vertices and edges for example. The vertices may represent the policy nodes or condition nodes in the input policy based workflow. Then the test generation logic may identify one or more paths in the policy control flow graph in any of the ways described above. The test generation logic may identify some or all of the paths in the policy control flow graph e.g. by filtering identified paths according to one or more filtering criteria. As one example the test generation logic may identify all of the feasible paths in the input workflow. As another example the test generation logic may identify all of the feasible paths in the input workflow that traverse through a particular node or edge in the input workflow.

The test generation logic may determine path constraints for the paths in the policy control flow graph e.g. during or after the identification of paths in the policy control flow graph. In some implementations the test generation logic sequentially processes or examines nodes to collect constraints for subpaths in the policy control flow graph. Upon identifying an endpoint node in the workflow the test generation logic may identify the particular paths e.g. particular feasible paths in the workflow that conclude at the endpoint node and determine the path constraints for the particular paths using the collected path constraints for the subpaths to nodes that directly traverse to the endpoint node. The test generation logic may solve the determined path constraints to obtain a set of test inputs that tests the input workflow.

The test generation logic may generate a set of test inputs that comprehensively tests the input workflow. In that regard the test generation logic may identify each of the feasible paths in the input workflow determine path constraints for each of the feasible paths and generate a corresponding test input using the determined path constraints. The test generation logic may determine a test input for each feasible path in the input workflow and the test input when input into the input workflow may traverse the particular feasible path the test input corresponds to. Accordingly the test generation logic may efficiently generate the test inputs to systematically and comprehensively test the input workflow.

In some variations the test generation logic may access testing oracles for the input policy based workflow . The testing oracles may specify expected results for one or more of the input tests for example. As another example the testing oracles may indicate the results from inputting a set of test inputs into a previous version of the workflow. The test generation logic or other testing logic in the system may test the policy based workflow using the generated set of test inputs and the testing oracles . In that regard the test generation logic may compare the results of inputting the test inputs into the input workflow with the expected or previous results specified by the testing oracles.

The test generation logic may apply a set of test inputs to a current version and previous version of the input policy based workflow. By comparing the results the test generation logic may identify differences in the results caused by the version change in the policy based workflow. In that regard the test generation logic may identify expected differences in the results e.g. expected from modified policies and or condition and unexpected differences e.g. crashing errors that may have been inadvertently triggered based on the version difference . In this way the test generation logic may use testing results from the previous or current version of the input workflow as testing oracles to identify issues in the workflow that need resolution or debugging. In some variations a tester may inspect the result differences and update one or more values of the testing oracles .

As described above the test generation logic may provide a framework for efficiently and comprehensively testing a policy based workflow such as a policy based XML workflow. As the size and complexity of such workflows continue to increase the test generation logic provides an effective and flexible avenue for comprehensively testing the immensely large number of feasible paths in these workflows.

The methods devices systems circuitry and logic described above including the test generation logic may be implemented in many different ways in many different combinations of hardware software or both hardware and software. For example all or parts of the system may include circuitry in a controller a microprocessor or an application specific integrated circuit ASIC or may be implemented with discrete logic or components or a combination of other types of analog or digital circuitry combined on a single integrated circuit or distributed among multiple integrated circuits. All or part of the logic described above may be implemented as instructions for execution by a processor controller or other processing device and may be stored in a tangible or non transitory machine readable or computer readable medium such as flash memory volatile memory non volatile memory random access memory RAM or read only memory ROM erasable programmable read only memory EPROM or other machine readable medium such as a compact disc read only memory CDROM or magnetic or optical disk. Thus a product such as a computer program product may include a storage medium and computer readable instructions stored on the medium which when executed in an endpoint computer system or other device cause the device to perform operations according to any of the description above. The system may be implemented in many different ways. Each module such as the test generation logic code parsing logic the path enumeration logic the constraint collection logic and the constraint solving logic may be hardware or a combination of hardware and software. For example each module may include an application specific integrated circuit ASIC a Field Programmable Gate Array FPGA a circuit a digital logic circuit an analog circuit a combination of discrete circuits gates or any other type of hardware or combination thereof. Alternatively or in addition each module may include memory hardware such as a portion of the memory for example that comprises instructions executable with the processor or other processor to implement one or more of the features of the module. When any one of the module includes the portion of the memory that comprises instructions executable with the processor the module may or may not include the processor. In some examples each module may just be the portion of the memory or other physical memory that comprises instructions executable with the processor or other processor to implement the features of the corresponding module without the module including any other hardware. Because each module includes at least some hardware even when the included hardware comprises software each module may be interchangeably referred to as a hardware module such as the test generation hardware module the code parsing hardware module path enumeration hardware module constraint collection hardware module and the constraint solving hardware module.

The processing capability described above may be distributed among multiple system components such as among multiple processors and memories optionally including multiple distributed processing systems. Parameters databases and other data structures may be separately stored and managed may be incorporated into a single memory or database may be logically and physically organized in many different ways and may implemented in many ways including data structures such as linked lists hash tables or implicit storage mechanisms. Programs may be parts e.g. subroutines of a single program separate programs distributed across several memories and processors or implemented in many different ways such as in a library such as a shared library e.g. a dynamic link library DLL . The DLL for example may store code that performs any of the system processing described above. While various embodiments of the systems and methods have been described it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the systems and methods.

