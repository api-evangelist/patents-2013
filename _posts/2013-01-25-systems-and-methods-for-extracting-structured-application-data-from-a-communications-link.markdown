---

title: Systems and methods for extracting structured application data from a communications link
abstract: Systems and methods for generating a semantic description of operations between network agents. In an embodiment, packet-level traffic between two or more network agents is captured. The packet-level traffic is bundled into one or more messages, wherein each message comprises one or more elements. For each of the messages, the elements of the message are matched to one or more attributes, and the message is decoded into message data based on the matched attributes. The message data is then used to generate a semantic description of operations between the network agents.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09100291&OS=09100291&RS=09100291
owner: DB Networks, Inc.
number: 09100291
owner_city: Poway
owner_country: US
publication_date: 20130125
---
This application claims priority to U.S. Provisional Patent App. No. 61 593 075 filed on Jan. 31 2012 and titled System and Method for Extracting Structured Application Data from a Communications Link the entirety of which is hereby incorporated herein by reference.

The invention is generally directed to information technology with features of network switching routing proxy and database technologies and more particularly to the extraction of semantic data via a network tap that provides a possibly incomplete copy of traffic between two network agents with no substantial modifications to the existing network or application infrastructure.

Over the last few decades structured database technology has become a critical component in many corporate technology initiatives. With the success of the Internet the use of database technology has exploded in many consumer and business to business applications. With the popularity of database architectures new risks and challenges have arisen. Such risks and challenges include complex and difficult to identify performances issues and subtle gaps in security that can allow confidential data to be accessed by unauthorized users. Accordingly what is needed are new improved mechanisms for identifying these performance issues and closing these security gaps.

A large fraction of database applications use a database server which has structured data stored and indexed. Clients access the database server to store update and query the structured data. The clients may communicate with the database server using standard networking technology such as Transmission Control Protocol TCP Internet Protocol IP Ethernet and the like using various physical or virtual media. While standard protocols are generally used for the lower levels of communications with the database server higher level protocols are often specific to a vendor and or client server architecture and may not be fully specified. Vendors may not be technically able to publish these specifications or may choose not to publish these specifications for other reasons.

Below the application and or database layer a sequenced byte protocol such as TCP or Sequenced Packet Exchange SPX is generally used to ensure delivery of messages between client and server systems in the face of potentially unreliable lower level transport mechanisms. These protocols may exchange multiple packets to deliver a single byte of data. The transmission and or reception of such packets may be asynchronous such that the order of the packets is not necessarily the same as the order of the byte stream required by the application or database layer. These protocols are designed to work when packets are lost or corrupted between two network agents such as a client system and server system.

Many network sessions may be established between a server e.g. database server and one or more client systems. Generally each session operates asynchronously with respect to the other sessions and the data and control information from a plurality of sessions may overlap temporally. In addition multiple encapsulation technologies and physical layer technologies may be used between a server and its clients.

There are a number of network tapping technologies that can be used to extract a copy of the packet stream flowing between two or more network agents. However a network tap attempting to observe an exchange will not witness an exact copy of the traffic as seen by either network agent. Rather the network tap will receive a unique third party view of the packets which may comprise a subset or superset of the packets seen by the network agents.

While many uncertainties as to encapsulation session multiplexing order and validity of request data may be resolved using data embedded in underlying protocols and transports these mechanisms are designed to operate at either end of a network conversation i.e. at the network agent . Furthermore this embedded data is not able to fully resolve uncertainties in the actual content of a specific network conversation. In addition in commonly used network architectures the packet stream captured by a network tap is frequently damaged in some way. Moreover the application protocols e.g. Oracle s client server protocol are often not publicly specified. Thus conventionally it is impossible to derive full details of operations between a server and its clients using a network tap.

Accordingly systems and methods are disclosed which utilize the buffering from a network tap in conjunction with capture and analysis techniques to derive a detailed semantic description or model of operations between two network agents. This detailed model can then be used to detect and respond to performance issues and security gaps particularly in the context of database based applications.

In an embodiment a method for generating a semantic description of operations between network agents is disclosed. The method comprises using at least one hardware processor capturing packet level traffic between a first network agent and a second network agent bundling the packet level traffic into one or more messages wherein each of the one or more messages comprises one or more elements for each of the one or more messages matching one or more of the one or more elements of the message to one or more attributes and decoding the message into message data based on the matched one or more attributes and generating a semantic description of operations between the first network agent and the second network agent based on the message data.

In an additional embodiment a system for generating a semantic description of operations between network agents is disclosed. The system comprises at least one hardware processor and at least one executable software module that when executed by the at least one hardware processor captures packet level traffic between a first network agent and a second network agent bundles the packet level traffic into one or more messages wherein each of the one or more messages comprises one or more elements for each of the one or more messages matches one or more of the one or more elements of the message to one or more attributes and decodes the message into message data based on the matched one or more attributes and generates a semantic description of operations between the first network agent and the second network agent based on the message data.

Systems and methods are disclosed for generating a detailed semantic model or description of operations between two or more network agents. In an embodiment the disclosed systems and methods are applied to network sessions comprising device interactions that are synchronous at the application layer. This includes without limitation remote procedure calls RPCs or similar request and response interactions such as those utilizing Hypertext Transfer Protocol HTTP . In these interactions a first device transmits a request to a second device through one or more networks and the second device returns a response to the first device via the one or more networks. Both the request and the response may comprise one or more packets transmitted between the devices. The packet level flow between the request and response may overlap temporally from the perspective of either device or a network mirroring device and or may be collected from multiple points within the network architecture. In an embodiment multiple network sessions between communicating network agents may generate packets that interleave arbitrarily without affecting operation of the disclosed systems and methods.

According to an embodiment the systems and methods extract a model or description of semantic operations performed between two network agents from an imperfect copy of the network packet traffic exchanges between the network agents. This model may include without limitation raw performance data on each operation descriptive metadata e.g. query string data types data sizes etc. and or actual data. When traffic is missing out of order or the exact specification of the traffic is unknown a partial model of operations may still be generated and used at an application layer level and the framework of a session may be resynchronized based on a change in direction of data flow e.g. between request and response messages .

Database queries or operations that update the data in a database may be serviced quickly or slowly by a database server depending on the complexity of the data query or update operation the instantaneous load being experienced by the database server or by other factors which may be beyond the database server itself e.g. the storage system a varying virtual central processing unit CPU allotment etc. . In an embodiment by observing the time lag between a specific request and response using the descriptive metadata e.g. Structured Query Language SQL query string and by observing the content and format of the data itself the performance of many operational aspects of the database server can be determined in real time. In addition the nature of data and actual data being updated or retrieved is latent in the network data packets flowing bi directionally between a client system and server. By observing this traffic inappropriate attempts to extract or change parts of the database may be detected. In an embodiment semantics of the operations between a client system and server are extracted and analyzed using a copy of the existing traffic. Based on this analysis traffic may be modified to accelerate or otherwise improve performance and or mitigate against various forms of attacks.

In an embodiment a capture component is placed within a network topology such that it is exposed to traffic transmitted between the plurality of network agents to be analyzed. Observed packets may be copied and transmitted to a filter component via a series of network links and or buffer stages. The filter component may then discard packets that are not related to the network agents and or applications being analyzed. The remaining packets may be passed to a reassembly component which builds a representation of the byte stream for each network session using sequence data and other descriptive data in the packets and or the time of receipt of the packets.

Once the representation of the byte stream for a session is built by the reassembly component it may be passed to an application layer analysis component. The analysis component may unpack the contents of the byte stream into the request and response data and descriptions to generate a semantic operation model of the traffic. This semantic model may be used by an application specific component which uses the semantic model to detect security and performance issues and or mitigate detected breaches of a security policy.

It should be understood that the capture component filter component reassembly component application layer analysis component application specific component and any other components or modules discussed herein may be implemented in hardware software or both hardware and software and may be separate or integrated components. For instance the filter component reassembly component application layer analysis component and application specific components may be software modules executing on hardware of a capture device or on a separate device that is communicatively coupled to the capture device.

At the outset the layers of the Open System Interconnection OSI model will be described. The OSI model defines a networking framework to implement protocols in seven layers. A layer serves the layer above it and is served by the layer below it.

Layer 7 Application Layer. This layer supports applications and end user processes. The application layer interacts with software applications that implement a communication component. Functions of the application layer include identifying communication partners determining resource availability and synchronizing communications.

Layer 6 Presentation Layer or Syntax Layer . This layer translates between application formats and network formats in order to provide independence from differences in data representations e.g. encryption . The presentation layer transforms data from the network into a form that the application layer can understand and formats and encrypts data from an application to be sent across a network.

Layer 5 Session Layer. This layer controls the connections between computers. It establishes manages and terminates connections between applications. The session layer is commonly implemented explicitly in application environments that use RPCs.

Layer 4 Transport Layer. This layer provides transparent transfer of data between network agents and is responsible for end to end error recovery segmentation and de segmentation and flow control. Flow control involves determining whether data is coming from more than one application and integrating each application s data into a single stream for the physical network. The transport layer ensures complete data transfer.

Layer 3 Network Layer. This layer provides the functional and procedural means of transferring variable length data sequences from a source host on one network to a destination host on a different network while maintaining the quality of service requested by the transport layer. It creates logical paths for transmitting data from node to node. It provides switching routing forwarding addressing internetworking error handling congestion control and packet sequencing functions. The network layer determines the way that data will be sent to a recipient agent.

Layer 2 Data Link Layer. This layer provides the functional and procedural means to transfer data between network agents and to detect and possibly correct errors that may occur in the physical layer. The data link layer encodes and decodes data packets provides transmission protocol knowledge and management and handles errors in the physical later as well as flow control and frame synchronization. It assigns the appropriate physical protocol to data and defines the type of network and packet sequencing. The data link layer is subdivided into a Media Access Control MAC layer and a Logical Link Control LLC layer. The MAC layer controls how a network agent gains access to data and the permission to transmit data. The LLC layer controls frame synchronization flow control and error checking.

Layer 1 Physical Layer. This layer defines the electrical and physical specifications for devices. It conveys the bit stream e.g. via electrical light or radio signal through the network at the electrical and or mechanical level. The physical layer provides the hardware means of sending and receiving data on a carrier including defining cables cards voltage levels timing and other physical aspects.

In an embodiment capture and analysis device s may not be dedicated device s and may instead be cloud instances which utilize shared resources of one or more servers. It should be understood that network agents and and capture and analysis device s may comprise any type or types of computing devices capable of wired and or wireless communication including without limitation desktop computers laptop computers tablet computers smart phones or other mobile phones servers game consoles televisions set top boxes electronic kiosks Automated Teller Machines and the like. Network agent network agent and or device s may also comprise or be communicatively coupled with one or more databases such as a MySQL Oracle IBM Microsoft SQL Sybase Access or other types of databases including cloud based database instances. In addition while only two agents and one switch and one set of capture and analysis device s are illustrated it should be understood that the network may comprise any number of agents switches and capture and analysis devices.

Memory controller provides a path for CPU to read data from and write data to main memory via cache memory . CPU may execute a program comprising software instructions stored in main memory which implement the processes described herein.

Storage controller may be connected via bus to bus controller . Storage controller may read and write data e.g. a semantic model and program instructions to a persistent storage device via link . For example storage device may comprise a commercial one terabyte Serial Advanced Technology Attachment SATA hard drive and link may comprise a SATA II link. However it should be understood that any storage device and associated interface may be used.

Network interface controller driver controls NIC and marshals packets received on network link into packet buffers in main memory . Some packets may be discarded by a packet filter engine under the direction of capture and analysis modules . For example packet filter engine may discard packets that are not related to specific protocols of interest to the model building mechanism of modules such as administrative traffic e.g. Address Resolution Protocol ARP or other broadcasts or traffic between network agents other than those of interest. Raw packet capture module may then copy the retained packets into ingress packet buffer s used by capture and analysis modules .

Capture and analysis modules perform processing as described elsewhere herein on the ingress packet traffic placed in packet buffers to generate a semantic model of the operations taking place between network agents and . This model may be incrementally placed into model log buffers and then written by file system driver e.g. in the context of a Linux operation system an Ext4 file system driver and storage controller driver to persistent storage device .

Kernel may provide timing facilities to the capture and analysis modules so that they may interpret the packet traffic in buffers during processing . Timing facilities may include a mechanism to retrieve the current time of day at high resolution e.g. microseconds or greater . Modules may compare the time retrieved from timing facilities to timestamps written by network interface controller driver into the packets as they are received. These timestamps may be used for example to determine when expected packets are to be considered lost by the reassembly and protocol analysis code.

In an embodiment packet traffic between network agents and is copied by a network mirror or Switched Port Analyzer SPAN tap mechanism. For example a network switch may be placed in the path between network agents and such that all packets transmitted by network agent to network agent and vice versa are transmitted through switch via communication links and . In an embodiment network switch may be a Layer 2 i.e. the data link layer network switch. Switch may be configured to transmit a copy of all packets received from both network agents and via network links and respectively to capture and analysis device s via communication link . Each of the network links and or may conform to the Institute of Electrical and Electronics Engineers IEEE 802.3ab 1000BASE T Ethernet standards.

In addition one or more detectors which may be local e.g. executed on the same machine or remote to capture and analysis device e.g. executed on separate machine s communicatively connected to capture and analysis device via one or more networks may be provided. Detector s may process the output of capture and analysis device . For example detector s may utilize semantic descriptions of operations between network agents and generated by capture and analysis device to create one or more higher level models including multiple layers of higher level models and different types of higher level models e.g. models specific to a security application a performance application and or for other types of applications . Modules of capture and analysis device may interface with detector s via one or more application programming interfaces APIs .

Network agent may send an acknowledgement to network agent via link . Acknowledgement is received at switch which is on the communication path between network agents and . Switch sends a copy of acknowledgement on link to network agent and also transmits a copy of acknowledgement on link to capture and analysis device s . Acknowledgement may comprise one or more packets that indicate to network agent that request was received.

Network agent may send a response to network agent via link . Response is received at switch which sends a copy of response on link to network agent . Switch also transmits a copy of response on link to capture and analysis device s . Response comprises one or more packets that form a response to request .

Network agent may send an acknowledgement to network agent via link . Acknowledgement is received at switch which is on the communication path between network agents and . Switch sends a copy of acknowledgement on link to network agent . Switch also transmits a copy of acknowledgement on link to capture and analysis device s . Reception of acknowledgement copy by network agent completes a single application level request and response cycle that began with the transmission of request by network agent .

In an embodiment buffer engine in NIC assembles the data from MAC into representations of the packets and stores the representations in packet buffer s . Controller driver which may correspond to driver in passes the received packets stored in packet buffer through a packet filter engine . Packet filter engine may comprise or utilize instructions generated by a program which compiles an optimized packet filter from a high level network description. The resulting packet filter discards packets that are not of interest to model building process . What remains are TCP IP packets that are intended for reception by the network agents of interest e.g. network agents and and or for specific TCP ports. The filter e.g. the specific agents and or TCP ports of interest may be configured by a user of the system.

In an embodiment the filter may comprise a set of one or more specifications or criteria which may be specified via a user interface and or as text lines in a configuration file. For example a specification may include without limitation one or more IP addresses e.g. defined as singletons or ranges one or more TCP port numbers e.g. defined as singletons or ranges and or one or more Virtual Local Area Network VLAN tags. In addition each of the specifications may be positive or negative. A positive specification will keep or allow packets meeting the specification whereas a negative specification will discard or deny packets meeting the specification. Implicit specifications may also exist. For instance completely empty or non TCP packets may be discarded without an explicit specification being established. For each packet the set of specifications are processed in order until one of them matches the packet in question. Once a packet is matched to one of the specifications the action specified e.g. allow or deny is enacted. Denied packets are discarded while allowed packets are passed on to the next module in the analysis chain.

An operating system capture mechanism or facility e.g. in the case of a Linux operating system AF PACKET version 2 may copy the packets remaining after the first stage filter into raw packet buffers . Raw packet buffers may be shared with or accessible by the capture and analysis address space .

Packets placed in raw buffer by operating system capture mechanism are processed or analyzed by the programs or modules residing in the capture and analysis address space . In an embodiment the result of this analysis is a semantic model of the operations between two network agents at Layer 7 i.e. the application layer . For instance this model may describe the database operations between a database client and a database server in terms of events and their surrounding contexts.

In an embodiment illustrated in packets are processed by capture and analysis modules after they are placed in raw packet buffers by operating system capture mechanism . A second stage packet filter may be applied to discard non TCP packets that were not previously discarded by in kernel first stage filter . Filter may also discard TCP control packets e.g. packets with all flags set that are not used or are harmful to the reassembly process but can not be easily removed by first stage filter . Notably in an embodiment first stage filter is intended to run with very little state or configuration information whereas second stage filter has access to broad real time state provided by higher layers.

Examples of packets that may be harmful include those that indicate unusual or unexpected conditions in TCP state. For instance a christmas tree packet with all control bits set may cause the internal state machine of the TCP stack to misinterpret the packet and use the data in it. This data may potentially hide an attack in a properly formatted packet received around the same time. As another example harmful packets may include a packet that duplicates the TCP sequence space of a previous packet. Sending both sets of data for processing by a higher layer would cause the higher layer to see the invalid data. Another example of harmful packets are packets with invalid checksums or length fields. These may be misinterpreted by higher layers causing them to read un initialized storage space e.g. a buffer overrun type of attack . As yet another example packets deemed by a higher layer to not be of interest may be harmful. Such packets are identified by their source destination IP port and VLAN tuple and this identification changes dynamically. It is not practical to recompile a specific filter every time a higher layer identifies a TCP connection as uninteresting so the filtering is done in a place where dynamic state is available.

In an embodiment an Ethernet header interpreter determines the end of the Ethernet header. Ethernet header interpreter may then discard packets that are not tagged as IP unicast or VLAN e.g. according to IEEE 802.1Q . For instance multicast packets may not be of interest and can drain resources needed to handle a high load situation whereas VLAN tagged packets may need to be kept so that the underlying unicast header and other headers can be extracted from them in order to decide whether or not they should be kept. A VLAN header interpreter may extract the VLAN identifier as an identifier attribute on the final model for packets with a VLAN header. The extracted VLAN header may be used to associate a packet with a TCP connection. A TCP connection in this context may be identified by a tuple of source IP destination IP source TCP port destination TCP port VLAN identifier and or physical receive port. The use of the VLAN identifier and receive port allows the system to differentiate traffic seen on different virtual or real networks that may be using cloned identical IP configurations. VLAN header interpreter may also discard any VLAN tagged packets that are not IP.

In an embodiment an IP interpreter and reassembler which may be compliant with Request for Comments RFC extracts the source address and destination address from packets and reassembles sequences of fragmented IP packets into single IP packets in IP packet buffers . Fragments of IP packets may be held in reassembly buffers until either all other fragments for the IP packet are received or a timeout occurs. If a timeout occurs all fragments for the IP packet may be discarded or alternatively assembled as incomplete and optionally marked as incomplete. A short timeout on packets held for reassembly can ensure that memory usage is kept in check in a fragmented environment with high packet loss.

Completed IP packets in IP packet buffers may be processed by a TCP header interpreter and stream reassembler which may be compliant with RFC . TCP header interpreter and stream reassembler may sort IP packets into streams of data per TCP connection and data direction e.g. from agent to agent or from agent to agent and store the sorted IP packets in byte stream buffers . In other words TCP header interpreter and stream reassembler may maintain a byte stream buffer for each TCP stream direction. Out of sequence data may be held in pending data buffers . As in sequence data for a given TCP stream direction is identified it may be appended to the corresponding byte stream buffer . The data in byte steam buffers hold ordered contiguous and non duplicated payload data for each specific TCP session in each specific direction. As in order TCP data is added to a connection specific byte stream buffer a bundler may be notified. Bundler is also notified if a message boundary is detected e.g. from a control packet from a change in direction of traffic or from a timeout that indicates that no additional data has been received on a stream for a predetermined period of time .

Thus pre Layer 7 processing starts with raw Ethernet packets and ends with byte stream buffers and an event stream which describes notable events in a session. For example the notable events in a TCP session may comprise an indication that in order TCP data has been added to the byte stream buffer corresponding to the TCP session an indication that no additional data has been added after a timeout period or an indication that a TCP control message has been received which closes the session. The byte and event streams may be passed to bundler which commences the Layer 7 portion of the analysis process.

A bundle is a complete request message or a complete response message at the application layer. Bundler may use several strategies to determine the boundaries of a bundle e.g. using control packets data direction or timeouts and send a bundle of data on to the protocol analysis modules. For instance boundary determination methods may comprise one or more of the following 

Data Direction in sequence data received from the reassembler for a single session will change directions for example at the boundary between the request message and the response message. This change of direction may be used to indicate an end of message boundary. For example a change of direction may be used to indicate an end to request message and or the beginning of an acknowledgement message or response message . Thus the very nature of request and response interactions may be used to place markers in a data stream to indicate message boundaries or otherwise indicate message boundaries that could not have otherwise been deduced without perfect knowledge and capturing.

Reassembler Activity Timeout at the end of a message where no additional traffic is immediately forthcoming e.g. typically a response a time tick from the reassembler or an expiration of a timer may be used to indicate an end of message boundary. For example the occurrence of a timeout following receipt of a packet of response message may be used to indicate and end to response message .

Reassembler Missing Segment if a segment of a message is missing a timeout may be used to indicate a message boundary. A missing message segment may represent a TCP packet which should have been received with payload from the middle of a request or response stream. An incomplete message may be marked as incomplete. In many cases protocol handlers can still extract sufficient data from the incomplete message to build a model. For example an expiration of a timer or an occurrence of a timeout following receipt of a prior segment or other event which results in an expectation of the missing segment may be used to indicate an end to a request or response message. The incomplete request or response message may be marked as incomplete. An interpreter e.g. TNS protocol interpreter and or TTC protocol interpreter may use a detected gap resulting from packet loss to determine if it can extract data and how much data it can extract from the data that it has without having to receive all of the data.

In an embodiment bundler provides bundles of in sequence unidirectional application traffic and associated descriptive data to an application protocol interpreter e.g. interpreter . Bundler needs no knowledge of the application protocol specification and may pass incomplete traffic i.e. bundles with one or more regions of missing in sequence data to the application protocol interpreter if segments or packets were lost.

In an embodiment the TCP reassembly phase illustrated in comprises processing by second stage packet filter Ethernet header interpreter VLAN header interpreter IP header interpreter and reassembler and TCP header interpreter and reassembler . The arrows showing request and response data provided by the TCP reassembler to bundler represent the byte stream buffers . The full request and response data resulting from bundler comprise bundle descriptors and buffers . Bundle descriptors and buffers provide the output of bundler to the first stage of Layer 7 protocol interpretation e.g. TNS protocol interpreter in an Oracle specific context .

In the message flow illustrated in the first request segment of the request transmitted from network agent and the first segment of the acknowledgement ACK transmitted from network agent are received. Reassembly renders the payload of first segment as a stream of request data to bundler . This provision of the payload of first segment may be provided before reception of ACK or may be provided after reception of ACK which indicates that first request segment was successfully received by network agent . In addition the ACK messages may be used by the reassembler to shortcut the timeout process. For instance if an ACK message is seen for a payload packet that was not witnessed it is likely that the missing packet was lost in the capture path. In either case when bundler receives first request data there is no indication yet that the message is complete. Thus bundler queues first request data .

The second and final request segment of the request from network agent and the corresponding ACK from network agent are then received by the reassembler. The reassembler appends this second request segment in sequence to the current stream of request data to bundler and provides the payload data of second request segment to bundler . Since bundler still has no indication that the message is complete bundler queues second request data . In other words bundler appends second request data to first request data .

In the illustrated example network agent formulates a three segment response to the request from network agent . The first segment of the response from network agent and the corresponding ACK from network agent are received. The reassembler provides the payload data for first response segment to bundler . Bundler detects that the direction of traffic has changed and determines that the previous message bundle it was collating is now complete. Thus bundler sends this message bundle i.e. the full request from network agent to network agent comprising request data and to a Layer 7 protocol interpreter for further analysis.

The additional two segments and of the response from network agent to network agent and the corresponding ACK messages and are received. Second response segment and third response segment are processed into data streams and respectively and provided to bundler . Bundler collates first response data and second response data i.e. appends data and to data but does not yet pass them on to the Layer 7 protocol interpreter.

Next a first segment of a second new request from network agent to network agent and the corresponding ACK are received. The reassembler sends the request data from request segment to bundler . Bundler detects that the direction of data transmission has changed and issues the complete response i.e. comprising response data and corresponding to the first request to the Layer 7 protocol interpreter.

Bundles representing requests and responses are processed by higher level protocol processing to build a semantic model of the operations taking place between the two network agents and . While this higher level protocol processing may sometimes be described herein in the context of an Oracle client server connection it should be understood that this description is merely illustrative. The systems and methods disclosed herein may be applied to or generalized for other applications and contexts as well.

In an example embodiment specific to an Oracle client server connection a Transparent Network Substrate TNS protocol interpreter may be provided which unpacks the procedure call and response payloads and asynchronous messages from TNS wrapper structures found in bundles . TNS is a multiplexing and asynchronous message wrapper protocol used by the Oracle client server protocol. It should be understood that alternative or additional interpreters may be used for other protocols. For instance Microsoft SQL Server uses Tabular Data Stream TDS and Symmetric Multiprocessing SMP wrapper protocols which may be abstracted similarly to TNS. LDAP MySQL and Postgresq1 each use header wrapper protocols. In addition HTTP is a header wrapper protocol for eXtensible Markup Language XML traffic or HyperText Markup Language HTML traffic. An interpreter can be constructed for any one or more of these protocols and used as an alternative or in addition to interpreter .

In addition in an embodiment a Two Task Common TTC protocol decoder or interpreter may extract remote procedure verbs parameters and result payloads from each request bundle and response bundle. The TTC protocol provides character set and data type conversion between different characters sets or formats on a client and server.

Protocol template matching by a protocol interpreter e.g. TTC protocol template matching by TTC protocol interpreter will now be described with reference to . Messages processed by the protocol interpreter are made up of a sequence of elements e.g. RPC verbs RPC parameters RPC results etc. which are decoded by the interpreter into a data form that is useful for building a model. The transformation from elements to data is controlled by a set of attributes and or which may be specific to each element. Each message may contain a variable number of elements. For example illustrates four elements and .

A library of attribute templates may be created for each new protocol session by the protocol interpreter e.g. TNS protocol interpreter and or TTC protocol interpreter . Library may be created using pre coded knowledge of the protocol in question and may be selected as a subset of a larger library of attribute templates for example for one or more protocols available for all sessions. For a newly discovered or identified session the template library may be initially filled with a relatively small set of templates that match broad groups of protocol messages and refer to groups of more specific templates. Multiple templates in the library of attribute templates may match any given message. Thus in an embodiment templates may be ordered in the library such that more exact matches are checked by the protocol interpreter before less exact ones. A more exact match will more fully describe a message than a less exact match.

In an embodiment templates provide characterizations of negotiated data types RPC options and client server architectures. These characterizations may all be used to decode the individual fields of specific RPCs. This can be especially useful when the protocol is not fully specified or secret or when the initial negotiation for a session cannot be observed. Among other things template matching can be used to determine which side of a connection e.g. TCP connection is the client and which side of the connection is the server when the start of a communication cannot be observed.

Each template in library contains a list of one or more attributes that may be applied to elements of a message e.g. an RPC request or response message . For example a template that matches example message would apply to the elements and of message . The matching template can be used to decode message into data which is usable by model generator . Each template in library may also contain one or more references to additional templates or a reference to a list of additional templates.

In an embodiment a template may comprise a set of dynamic runtime classes e.g. written in C code . The templates or marshallers are configured to pull specific patterns of data out of the stream and compose valid data. One example is a string template which is configured to recognize a string represented by a one byte length field followed by one or more data blocks in which the last data block has a zero byte length field. Such a template can be tested by attempting to de marshal a string using the template. For example if while a reading a string the interpreter ends up attempting to read past the end of the available data in the bundle the template has failed to match. However it should be understood that this is simply one illustrative example. Other templates may fail to match for simpler reasons. For example if a high bit is never expected to be set in a specific byte location in a numeric format it may be determined that a template configured to detect a number in the numeric format has failed to match if a high bit is detected in the specific byte location.

One or more observable attributes e.g. RPC field types and common markers may be determined by direct examination of the elements. Template s may be chosen by matching one or more of their attributes to observable attributes . In other words observable attributes may be compared to the attributes of one or more templates in library to identify the best matching template s from library . Once matching template s have been identified based on attributes observed from elements other attributes may be inferred using template s .

Each template comprises a set of observable attributes. Observable attributes may be those attributes which are apparent or determinable from message e.g. from elements or already known about message . As each new template is selected for consideration in step each attribute of that template may be placed in the set of attributes to be checked or observed against message . These attributes may comprise inferred attributes i.e. attributes which may not have been determinable from message or what was previously known about message without having first identified the template comprising the inferred attributes. In step it is determined whether any attributes remain to be checked. If so an unchecked attribute is selected in step .

The template indicates to which element of the message each attribute within the template applies. In step the start of the element to which the attribute selected in step applies is located in message . The start of the element may be located by using previously validated observable or inferred attributes from the chosen template. For example the size of a previous element may be an inferred or observed attribute and this size may be used to locate the next element in the message.

In step the selected attribute e.g. attribute is checked against the located element e.g. element . If this check is successful e.g. the located element satisfies or corresponds to the selected attribute the next observable attribute in the selected template is selected and checked. The process of steps and may repeat until all observable attributes have been checked.

If in step an attribute fails to check against an element of message the process may return to step . This process may repeat until all templates in the session s library have been checked and or until it is otherwise determined that no more templates must be checked. A check may be unsuccessful for instance if the element is not present e.g. due to packet loss or due to the template not being an appropriate match for message or if the element does not fit the form of the attribute e.g. a data type or value range . Furthermore if no library template is found that successfully checks against message message may be marked as completely undecodable in step . On the other hand if all observable and or inferred attributes in a template successfully check against message the template is added to a set of matched templates or the attributes of the template are added to a set of attributes in step .

If a template is chosen for the set of matched templates in step based on matched attributes it is determined in step whether the chosen template contains an inferred attribute that references an additional set of one or more templates. For example this additional set of one or more templates may comprise more specific templates. The additional set of one or more templates is added to the template library for the session in step and the processing of message is continued in step based on the supplemented template library .

Once all templates in template library including any referenced templates added in step have been considered with respect to the elements of message message is decoded in step using one or more matched templates. Message may be decoded in step into data by applying all of the attributes e.g. observable attributes and inferred attributes from the chosen template s to the elements of message e.g. elements and . In this manner the pattern of observable attributes found in message results in the identification of a set of inferred attributes by matching the observable attributes to templates in template library that comprise both observable and inferred attributes.

All of these attributes i.e. both observable attributes and inferred attributes are applied together to message in step to generate a decoded message in step . For instance the process in step for decoding element of message comprises applying the combined observable attributes e.g. attributes and and inferred attributes e.g. attributes to element to produce data . The other elements of message i.e. elements and may be decoded in a similar manner.

Each type of attribute may imply or indicate its own form of transformation. As an illustrative non limiting example in the context of Oracle TTC protocol interpretation some examples of applicable attributes include the basic type of data e.g. string numeric date interval etc. the acceptable range of values a specific value or bit pattern e.g. an operation code the dynamic range of a value e.g. how many bits are required to represent the full range of the value how many padding bits may be included in a message and their possible values and locations the encoding of a value e.g. endianness character set bit width etc. and or the internal structure of a value e.g. simple array of characters with a single length groups of characters with a length field between each one etc. .

Some elements of a message may contain bulk data that is not of interest. Thus in an embodiment the transformation from element to data e.g. from element to data in step may involve eliding or omitting some or all of the actual data leaving only a description of the data e.g. the chosen attributes for use in building a model. The bundling mechanism described in more detail elsewhere herein ensures that the high level message boundaries are discernable even if part of a message is skipped or omitted in this fashion.

In an embodiment template library which is used to decode a message persists on a per session basis. This allows earlier messages in the session to inform the decoding of later messages in a session. This feature may be particularly critical for instance in decoding messages in a session in which the initial connection setup messages are missing.

While the embodiment illustrated in uses a TNS protocol interpreter and TTC protocol interpreter it should be understood that different interpreters e.g. for protocols other than TNS and or TTC may be used in addition to or instead of the illustrated interpreters and or a different number of interpreters may be used e.g. one two three four etc. depending on the particular protocol s being interpreted.

In an embodiment the data extracted from TNS protocol interpreter and or TTC protocol interpreter or in other contexts from one or more other interpreters may be passed to an operation filter . Operation filter may use application level semantic data to filter operations that are not of interest. Operations of interest or operations not of interest may be defined or configured by a user. As an illustrative example the application level semantic data may include a service name for a database. For instance two database instances named CRMPROD and CRMDEV may be present on or otherwise available from the same server and use the same TCP port e.g. port for RPC traffic. A user may specify that only operations involving CRMPROD are of interest or that the operations involving CRMDEV are not of interest. In either case operation filter may filter out operations involving CRMDEV from consideration prior to analysis by model generator .

At any of the interpreter or filter stages leading up to model generator e.g. stages and or processing of a bundle or group s of bundles in a session may be deferred leaving the bundle s queued until a new bundle or event is received for the session. This mechanism may be used when information from subsequent bundles may be needed by any of the stages or modules to interpret earlier bundles. For instance TTC protocol interpreter may use this queuing mechanism to defer processing of undecodable messages in a session until its template library is more refined or developed. In addition model generator may use this queuing mechanism to retain bundles while attempting to determine which side of a connection is the server and which side of the connection is the client.

Referring again to model generator uses the stream of data and events generated by one or more protocol interpreters e.g. TNS protocol interpreter and TTC protocol interpreter and in an embodiment filtered by operation filter to build an abstracted semantic traffic model of the operations taking place between network agent and network agent . Model may comprise a sequence of verbs and backing data that pertains to a single session e.g. database session . Model maintains a collection of states for each session and transaction and describes the sequence of operations applied to that state.

Additional models including multiple layers of models may be built from semantic traffic model for example by detector . The details of these higher level models may be specific to the analysis engine built to use the data of model and may vary based on the goals of the application which will utilize model . In other words different users may build different higher level models depending on the task at hand. For example for a security application a higher level model may comprise structural and parametric data that describe the normal behavior of an application and expose outlying operations that may represent attacks. As another example for a performance application the higher level model may comprise data describing the timing and size of verbs and their parameters. As a further example a database firewall may build a higher level model describing SQL statements and execution semantics surrounding them. A web application firewall WAF or WAF like system may build a higher level model from model that shows Uniform Resource Identifiers URIs and POST parameters.

Model may be built in main memory and or cache memory and written by file system driver and storage controller driver e.g. via memory controller bus controller and storage controller to persistent storage device . Specifically in an embodiment the data of model e.g. events and metadata may be queued to model log buffers which may be written to persistent storage device .

The data of model queued in model log buffers may comprise a feed that is inputted into one side of an API to be used by the specific higher level application e.g. detector providing the API to for example construct higher level models. For instance for a security application RPCs being used in monitored sessions and the parameters used in the RPCs and or SQL operations being used and the rows and columns being modified by the SQL operations may be provided from model via model log buffers to the security application via an API defined by the security application. For a performance application the types of operations being used in monitored sessions may be provided from model via model log buffers to the performance application via an API defined by the performance application. Alternatively it should be understood that the capture and analysis modules may define the API and one or more applications e.g. detector which may comprise security application s performance application s and or other types of applications may access the data of model e.g. stored in model log buffers via the API defined by capture and analysis modules .

The disclosed systems and methods may be applied to any application level protocol that is session synchronous. Such protocols include without limitation database client server protocols used by Oracle Microsoft SQL Sybase IBM DB2 PostgreSQL MySQL MongoDB and other databases. Such protocols also include non database server protocols such as HTTP HTTPS Network File System NFS Apple Filing Protocol AFP Server Message Block SMB Domain Name System DNS Simple Mail Transfer Protocol SMTP Internet Message Access Protocol IMAP Post Office Protocol POP and custom or proprietary application protocols. In addition the application protocols may be carried over transport mechanisms other than TCP over IP version 4 IPv4 including without limitation User Datagram Protocol UDP over IPv4 UDP over IP version 6 IPv6 TCP over IPv6 Remote Desktop Protocol RDP over IPv4 Internetwork Packet Exchange Sequenced Packet Exchange IPX SPX Internet Control Message Protocol ICMP over IPv4 and ICMP over IPv6. The protocols may be carried in any combination over Layer 2 bridges Network Address Translation NAT devices Virtual Private Network VPN tunnels VLAN technologies and in memory inter process communication IPC arrangements on Non Uniform Memory Access NUMA and Uniform Memory Access UMA architectures.

The disclosed systems and methods may also be applied to any packet based or stream based physical layers including arbitrary combinations of such layers within the same system. These include physical transports over any supported media including without limitation Fiber Distributed Data Interface FDDI Token Ring 100 megabit Ethernet 10 megabit Ethernet over coaxial cables 10 gigabit Ethernet and Digital Signal 1 DS1 Digital Signal 3 DS3 signaling.

The disclosed systems and methods may utilize any capture mechanism that can make copies of the traffic between network agents and provide these copies to the disclosed capture and analysis device or modules . Such capture mechanisms include without limitation electrical level taps MII proxy taps a NAT device which routes traffic between network agents and transparently captures the routed traffic a virtual SPAN or mirror facility that may be part of a Virtual Machine VM manager or hypervisor a TCP or IPC proxy running on any of the involved network agents and playback of previously captured traffic e.g. log from a storage device.

The disclosed systems and methods are not limited to analyzing traffic and building models for a single pair of network agents. Rather the systems and methods are able to simultaneously monitor many sessions between many pairs of network agents. Furthermore traffic may be captured simultaneously from a plurality of capture mechanisms in real time or from a play back. The systems and methods may differentiate between network agents based on transport addresses as well as other attributes such as MAC addresses IP addresses TCP port numbers VLAN tags application layer specific identifiers e.g. service name SID for Oracle protocols etc. and or physical ingress port tags.

It should be understood that the capture and analysis device and or mirror tap may be implemented entirely in software executing in a VM environment. The components of the system including without limitation the capture devices or mechanisms may run in a distributed fashion on a plurality of virtual or physical appliances and or operating system processes or drivers. Furthermore the systems and methods may be implemented on any operating system that supports basic networking and file system capabilities. Alternatively the systems and methods may be implemented on a physical or virtual device without an operating system e.g. incorporating required hardware drivers into an application which embodies the systems and methods itself .

Different hardware architectures may act as the base for the mirror tap or the capture and analysis device . These architectures include without limitation multiple CPU core systems and any supported network or storage peripherals and controllers which support the performance requirements of the system. Any stored program or CPU architecture e.g. Harvard CPU architecture may support the disclosed systems and methods.

The reassembly and protocol decoding or interpretation systems and methods described herein may be implemented with different layering than described. For example the Ethernet VLAN IP and or TCP reassembly modules may be a single module or entity and may not support items such as IP fragmentation or VLAN header parsing. The reassembler may use control flags e.g. ACK finish FIN reset RST etc. to help determine message boundaries and other exceptional conditions.

Semantic model may be stored on persistent storage on differing storage architectures. Such storage architectures include without limitation network file systems Storage Area Network SAN storage Redundant Array of Independent Disks RAID storage and or flash memory. Alternatively model may not be stored in persistent storage at all. Rather model may be consumed by the ultimate destination application e.g. via an API and discarded.

It should be understood that the destination application of semantic model may use model of traffic to perform other tasks than just those tasks discussed elsewhere herein. Such tasks may include without limitation informing a block proxy when to hold and when to release traffic flowing through the capture and analysis device so that it may act similarly to an Intrusion Prevention System IPS and acting as an application level proxy and modifying or locally satisfying operations for performance or security purposes e.g. to implement a database accelerator .

The disclosed systems and methods may handle extreme conditions. Such conditions may include without limitation a perfect plurality of traffic copies received due to the utilized capture architecture a perfect loss of traffic in one direction between a pair of network agents and new versions of application protocols that are completely unspecified.

In an embodiment there may be channels of communication which push data notifications indications or other information backwards down the analysis chain. Such channels may include without limitation notification from the TTC layer to the TNS layer regarding message boundaries or asynchronous signal notifications and or messages from TNS protocol interpreter to bundler and or reassemblers and or to eliminate the need for a timeout to determine the end of a message e.g. a message to bundler or reassemblers or comprising an indication that the end of the message has been determined . Such channels may be implemented to allow modules e.g. interpreters filters etc. further along the analysis chain to peek at the data and assist modules earlier in the analysis chain. For example this assistance provided by later modules to earlier modules in the analysis chain may comprise the determination of message boundaries.

In an embodiment during analysis bundler and or one or both of reassemblers and may elide blocks of data that are of no use to the application layers. The elided data may be significant in some instances and may include without limitation bulk row data and bind parameters. For example all data not required for an application at hand may be elided or redacted. The data to be elided may be predetermined e.g. by user defined parameters stored in a configuration file . For instance for a database firewall that is not processing the contents of return row data the application may elide result row payloads and or all parameter data.

In an embodiment bundler and or one or both of reassemblers and may implement a streaming protocol such that data is delivered to the protocol interpreters without the need to buffer the data or completely buffer the data.

Attributes for protocol message elements such as TTC protocol message elements may be inferred directly from clues which are intrinsic to the message or from other clues. These other clues may include without limitation known architectures and or version numbers of the network agents involved in the interaction. For example these architectures and or version numbers may be known via configuration or caching of data from a previous message or session.

In embodiments the search of attribute elements such as TTC attribute elements may be elided for a subset of one or more elements. For instance in an embodiment if clues provided from an earlier part of the connection establishment protocol indicate that certain templates are not needed they may be excluded from consideration for performance reasons. As an illustrative example certain RPC structures may never be used after a given version of an Oracle client library. Thus if the connection setup determines that a newer library version is in use the interpreters can refrain from attempting to match any templates that solely support older library versions. Additionally the results of a search for attribute elements may be cached to improve performance.

Generation of the per session template library may be informed by the results of related sessions. For example if a template library is selected for a first connection from client A to server B this previously selected library may be reused as a starting point for a second and subsequent connection from client A to server B since there may be a good chance that the second connection is from the same application as the first connection. Furthermore protocol attribute templates may be excluded or included in library based on attributes outside of the immediate protocol messages such as TNS protocol headers configuration inputs e.g. manually defined by a user IP header fields rows or bind payload data TCP header fields transport layer header fields etc.

In an embodiment additional or alternative heuristic methods than those described elsewhere herein may be used to determine at least some of the attributes of the data elements for a given message and or a set of templates that are in the scope of a particular session. For example information acquired from a session setup negotiation may be used to directly determine one or more attributes. For instance a book of templates for given server version numbers or client library versions and server types may be used to provide a starting point for the template library search. The time to search all possible combinations of templates can be significant. Thus reducing the search space can be valuable for example in terms of improving performance. In addition the disclosed bundling mechanism may be generalized and used for other purposes than those described elsewhere herein. For example the bundling mechanism may be used to determine semantics of TNS marker messages determine performance related statistics in the model builder decode row data characterize row data etc.

The system preferably includes one or more processors such as processor . Additional processors may be provided such as an auxiliary processor to manage input output an auxiliary processor to perform floating point mathematical operations a special purpose microprocessor having an architecture suitable for fast execution of signal processing algorithms e.g. digital signal processor a slave processor subordinate to the main processing system e.g. back end processor an additional microprocessor or controller for dual or multiple processor systems or a coprocessor. Such auxiliary processors may be discrete processors or may be integrated with the processor . Examples of processors which may be used with system include without limitation the Pentium processor Core i7 processor and Xeon processor all of which are available from Intel Corporation of Santa Clara Calif.

The processor is preferably connected to a communication bus . The communication bus may include a data channel for facilitating information transfer between storage and other peripheral components of the system . The communication bus further may provide a set of signals used for communication with the processor including a data bus address bus and control bus not shown . The communication bus may comprise any standard or non standard bus architecture such as for example bus architectures compliant with industry standard architecture ISA extended industry standard architecture EISA Micro Channel Architecture MCA peripheral component interconnect PCI local bus or standards promulgated by the Institute of Electrical and Electronics Engineers IEEE including IEEE 488 general purpose interface bus GPIB IEEE 696 S 100 and the like.

System preferably includes a main memory and may also include a secondary memory . The main memory provides storage of instructions and data for programs executing on the processor such as one or more of the functions and or modules discussed above. It should be understood that programs stored in the memory and executed by processor may be written and or compiled according to any suitable language including without limitation C C Java JavaScript Perl Visual Basic .NET and the like. The main memory is typically semiconductor based memory such as dynamic random access memory DRAM and or static random access memory SRAM . Other semiconductor based memory types include for example synchronous dynamic random access memory SDRAM Rambus dynamic random access memory RDRAM ferroelectric random access memory FRAM and the like including read only memory ROM .

The secondary memory may optionally include an internal memory and or a removable medium for example a floppy disk drive a magnetic tape drive a compact disc CD drive a digital versatile disc DVD drive other optical drive a flash memory drive etc. The removable medium is read from and or written to in a well known manner. Removable storage medium may be for example a floppy disk magnetic tape CD DVD SD card etc.

The removable storage medium is a non transitory computer readable medium having stored thereon computer executable code i.e. software and or data. The computer software or data stored on the removable storage medium is read into the system for execution by the processor .

In alternative embodiments secondary memory may include other similar means for allowing computer programs or other data or instructions to be loaded into the system . Such means may include for example an external storage medium and an interface . Examples of external storage medium may include an external hard disk drive or an external optical drive or and external magneto optical drive.

Other examples of secondary memory may include semiconductor based memory such as programmable read only memory PROM erasable programmable read only memory EPROM electrically erasable read only memory EEPROM or flash memory block oriented memory similar to EEPROM . Also included are any other removable storage media and communication interface which allow software and data to be transferred from an external medium to the system .

System may include a communication interface . The communication interface allows software and data to be transferred between system and external devices e.g. printers networks or information sources. For example computer software or executable code may be transferred to system from a network server via communication interface . Examples of communication interface include a built in network adapter network interface card NIC Personal Computer Memory Card International Association PCMCIA network card card bus network adapter wireless network adapter Universal Serial Bus USB network adapter modem a network interface card NIC a wireless data card a communications port an infrared interface an IEEE 1394 fire wire or any other device capable of interfacing system with a network or another computing device.

Communication interface preferably implements industry promulgated protocol standards such as Ethernet IEEE 802 standards Fiber Channel digital subscriber line DSL asynchronous digital subscriber line ADSL frame relay asynchronous transfer mode ATM integrated digital services network ISDN personal communications services PCS transmission control protocol Internet protocol TCP IP serial line Internet protocol point to point protocol SLIP PPP and so on but may also implement customized or non standard interface protocols as well.

Software and data transferred via communication interface are generally in the form of electrical communication signals . These signals are preferably provided to communication interface via a communication channel . In one embodiment the communication channel may be a wired or wireless network or any variety of other communication links. Communication channel carries signals and can be implemented using a variety of wired or wireless communication means including wire or cable fiber optics conventional phone line cellular phone link wireless data communication link radio frequency RF link or infrared link just to name a few.

Computer executable code i.e. computer programs or software is stored in the main memory and or the secondary memory . Computer programs can also be received via communication interface and stored in the main memory and or the secondary memory . Such computer programs when executed enable the system to perform the various functions of the present invention as previously described.

In this description the term computer readable medium is used to refer to any non transitory computer readable storage media used to provide computer executable code e.g. software and computer programs to the system . Examples of these media include main memory secondary memory including internal memory removable medium and external storage medium and any peripheral device communicatively coupled with communication interface including a network information server or other network device . These non transitory computer readable mediums are means for providing executable code programming instructions and software to the system .

In an embodiment that is implemented using software the software may be stored on a computer readable medium and loaded into the system by way of removable medium I O interface or communication interface . In such an embodiment the software is loaded into the system in the form of electrical communication signals . The software when executed by the processor preferably causes the processor to perform the inventive features and functions previously described herein.

In an embodiment I O interface provides an interface between one or more components of system and one or more input and or output devices. Example input devices include without limitation keyboards touch screens or other touch sensitive devices biometric sensing devices computer mice trackballs pen based pointing devices and the like. Examples of output devices include without limitation cathode ray tubes CRTs plasma displays light emitting diode LED displays liquid crystal displays LCDs printers vacuum florescent displays VFDs surface conduction electron emitter displays SEDs field emission displays FEDs and the like.

The system also includes optional wireless communication components that facilitate wireless communication over a voice and over a data network. The wireless communication components comprise an antenna system a radio system and a baseband system . In the system radio frequency RF signals are transmitted and received over the air by the antenna system under the management of the radio system .

In one embodiment the antenna system may comprise one or more antennae and one or more multiplexors not shown that perform a switching function to provide the antenna system with transmit and receive signal paths. In the receive path received RF signals can be coupled from a multiplexor to a low noise amplifier not shown that amplifies the received RF signal and sends the amplified signal to the radio system .

In alternative embodiments the radio system may comprise one or more radios that are configured to communicate over various frequencies. In one embodiment the radio system may combine a demodulator not shown and modulator not shown in one integrated circuit IC . The demodulator and modulator can also be separate components. In the incoming path the demodulator strips away the RF carrier signal leaving a baseband receive audio signal which is sent from the radio system to the baseband system .

If the received signal contains audio information then baseband system decodes the signal and converts it to an analog signal. Then the signal is amplified and sent to a speaker. The baseband system also receives analog audio signals from a microphone. These analog audio signals are converted to digital signals and encoded by the baseband system . The baseband system also codes the digital signals for transmission and generates a baseband transmit audio signal that is routed to the modulator portion of the radio system . The modulator mixes the baseband transmit audio signal with an RF carrier signal generating an RF transmit signal that is routed to the antenna system and may pass through a power amplifier not shown . The power amplifier amplifies the RF transmit signal and routes it to the antenna system where the signal is switched to the antenna port for transmission.

The baseband system is also communicatively coupled with the processor . The central processing unit has access to data storage areas and . The central processing unit is preferably configured to execute instructions i.e. computer programs or software that can be stored in the memory or the secondary memory . Computer programs can also be received from the baseband processor and stored in the data storage area or in secondary memory or executed upon receipt. Such computer programs when executed enable the system to perform the various functions of the present invention as previously described. For example data storage areas may include various software modules not shown .

Various embodiments may also be implemented primarily in hardware using for example components such as application specific integrated circuits ASICs or field programmable gate arrays FPGAs . Implementation of a hardware state machine capable of performing the functions described herein will also be apparent to those skilled in the relevant art. Various embodiments may also be implemented using a combination of both hardware and software.

Furthermore those of skill in the art will appreciate that the various illustrative logical blocks modules circuits and method steps described in connection with the above described figures and the embodiments disclosed herein can often be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules circuits and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled persons can implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the invention. In addition the grouping of functions within a module block circuit or step is for ease of description. Specific functions or steps can be moved from one module block or circuit to another without departing from the invention.

Moreover the various illustrative logical blocks modules functions and methods described in connection with the embodiments disclosed herein can be implemented or performed with a general purpose processor a digital signal processor DSP an ASIC FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor can be a microprocessor but in the alternative the processor can be any processor controller microcontroller or state machine. A processor can also be implemented as a combination of computing devices for example a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

Additionally the steps of a method or algorithm described in connection with the embodiments disclosed herein can be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module can reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of storage medium including a network storage medium. An exemplary storage medium can be coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium can be integral to the processor. The processor and the storage medium can also reside in an ASIC.

Any of the software components described herein may take a variety of forms. For example a component may be a stand alone software package or it may be a software package incorporated as a tool in a larger software product. It may be downloadable from a network for example a website as a stand alone product or as an add in package for installation in an existing software application. It may also be available as a client server software application as a web enabled software application and or as a mobile application.

The above description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the invention. Various modifications to these embodiments will be readily apparent to those skilled in the art and the general principles described herein can be applied to other embodiments without departing from the spirit or scope of the invention. Thus it is to be understood that the description and drawings presented herein represent a presently preferred embodiment of the invention and are therefore representative of the subject matter which is broadly contemplated by the present invention. It is further understood that the scope of the present invention fully encompasses other embodiments that may become obvious to those skilled in the art and that the scope of the present invention is accordingly not limited.

