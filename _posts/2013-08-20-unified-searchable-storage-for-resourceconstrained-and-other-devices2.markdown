---

title: Unified searchable storage for resource-constrained and other devices
abstract: The present disclosure describes a data indexing and search service that resides locally on a computing device (e.g., a mobile phone) and that can host data for multiple applications on the device. By centralizing the storage of data as well as the search and query functions, unified search queries can be performed by the service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09558248&OS=09558248&RS=09558248
owner: Google Inc.
number: 09558248
owner_city: Mountain View
owner_country: US
publication_date: 20130820
---
This application claims the benefit of U.S. Provisional Application Ser. No. 61 753 152 filed on Jan. 16 2013 which is incorporated by reference.

Search programs can allow a user to perform text searches for example of a user s e mail computer files music photos chats and Web pages viewed. When initially installed on a device e.g. a desktop personal computer the software program can index the files in the computer. After initial indexing is completed the software may continue to index files as needed. The indexed files then can be searched by a user and results can be returned for example in a web browser.

Some devices that store various types of files that a user may wish to search are resource constrained in the sense that the devices may have for example a relatively slow central processing unit CPU limited random access memory RAM and or limited disk storage. In such resource constrained environments updating the storage and index can be inefficient resulting in high background CPU usage and too much disk activity. As a result some solutions do not scale easily to the desirable amount of data to be stored and searched. The lack of scalability can make it difficult if not impossible to include features such as fast unified searching and unified keyword and entity suggestions that span across multiple applications and databases.

The present disclosure describes a data indexing and search service that resides locally on a device e.g. a mobile phone and that can host data for multiple applications on the device. By centralizing the storage of data as well as the search and query functions unified search queries can be performed by the service without the need in some cases to start up multiple applications and open multiple databases.

For example according to one aspect a computing device includes a user interface including a search box and applications residing in the computing device wherein each application includes a respective content provider. The computing device an index manager a data indexing and search service residing in the computing device and providing an entry point to the index manager and disk backed storage e.g. flash storage . The data indexing and search service is operable to obtain data from the content providers associated with respective ones of the applications. The index manager indexes the data from the content providers and stores the indexed data in the disk backed storage. The data index manager includes a query processor to handle execution of search queries received from the search box and received from any of the applications. The query processor handles execution of the search queries by searching the indexed data stored in the disk backed storage and returning results based on the searching.

Various implementations include one or more of the following features. For example in some implementations in response to receiving a search query from a particular one of the applications the data indexing and search service returns result only with respect to a corpus associated with the particular one of the applications. On the other hand in response to receiving a search query from the search box the data indexing and search service can return results with respect to all corpora associated with the applications or with respect to a subset of the corpora.

In some implementations the disk backed storage stores a first index having a lexicon that maps terms contained in documents from a particular application to term identifiers and a second index having a lexicon that maps terms to term identifiers and an offset into an index file. Indexing of the data can take place for example in the first index which periodically can be merged into the second index. The lexicons can be implemented for example as file backed tries.

In some cases the indexing and search service performs indexing of data from a particular one of the applications in response to a request from the particular application to register with the indexing and search service. The indexing and search service also may perform indexing of data from a particular one of the applications in response to a request for indexing by the particular application.

In another aspect a method of indexing and searching data on a computing device is described. For example in some implementations the method includes binding a first application residing on the computing device to an indexing and search service residing on the computing device and registering a corpus and a content provider associated with the first application with the indexing and search service. Data from files associated with the first application are indexed by the indexing and search service and the indexed data is stored in disk backed storage on the device. The indexing and search service then can be used to execute a search query from the first application. A similar process can be performed with respect to other applications residing on the computing device.

Some implementations include one or more of the following advantages. For example storing all application indices in one place i.e. in the same disk backed flash storage can facilitate faster universal searches. Furthermore the disk backed storage can be scalable and can provide for example statistics for predictive applications. The data indexing and search service can execute searches relatively quickly and can use compressed storage with a relatively small footprint. The service can reduce the number of flash writes required and can allow write operations to include a greater amount of data e.g. through the use of batching .

Other aspects features and advantages will be apparent from the following detailed description the accompanying drawings and the claims.

The present disclosure describes a data indexing and search service that resides locally on a device e.g. a mobile phone and that hosts the data for multiple applications on the device. The data indexing and service can provide an efficient centralized on device offline search and document store service and can provide an open application programming interface API to the other applications on the device. The techniques can facilitate searching all corpora or a subset of corpora in the device and can facilitate keyword suggestions across all corpora or a subset of corpora . In addition a privacy model is described to ensure that data e.g. suggestions and search results from one corpus does not appear in searches intended for another corpus.

The techniques described here can be implemented for example on various types of resource constrained devices including handheld computing devices such as mobile phones tablets and personal digital assistants PDAs . The techniques also can be implemented on other computing devices such as desktop personal computers laptop computers.

As illustrated in a computing device e.g. a mobile phone has a graphical user interface including a search box in which a user of the device can enter a search term. The device also stores one or more applications e.g. applications A B and C that may be executed on the device. An example of such an application is an e mail application residing on the device. A data indexing and search service pulls data e.g. documents from respective client content providers associated with each application A B C stores the data in a respective corpus and indexes it. Corpora can be stored for example in files in flash storage on the computing device.

Indexing and search service serves as an entry point to an index manager which implements a binder API handles content synchronizations from the client applications and encapsulates a thread where background processing takes place. Index manager includes a document storage manager that manages corpora and a query processor that handles the execution of search queries received from search box or from one of the client applications A B C. When an application needs to obtain results of a search query the application delegates the search to service rather than performing the search itself.

Flash storage also stores a lite index and a main index . Lite index can be updated on an ongoing basis and has a lexicon that maps terms contained in the documents to term identifiers. Main index serves as permanent index that stores the rest of the index. Lite index can be merged periodically into permanent index which has a lexicon that maps terms to term identifiers and an offset into an index file. The lexicons indices and corpora can be stored in separate files in disk backed storage . The lexicons can be implemented for example as file backed tries that are initialized by a disk read.

To interface with service an application A B C binds to and calls the service s Interface Definition Language Application Programming Interface IDL API . Service then uses the content provider in the application A B C to synchronize the application s data to its own store . A document can be referred to by a Uniform Resource Identifier URI which can be an arbitrary string determined by the client application. illustrates further details according to a particular implementation discussed in the following paragraphs.

Initially a client application A B C binds to service block . The client application then calls a Grant URI Permission function with respect to a corpus content provider and registers the corpus and content provider with service using a Registration function block . When a client application registers with service the client application provides an address for an API from which the service can pull the content. Service then synchronizes the client s data using the client s content provider block . Further details of the synchronization process are described below. When the client application has new data for service it calls a Request Indexing function block which causes service to pull more data from the client s content provider block . As described below a client application A B C can issue a keyword query or ask for suggestions based on a multi word prefix block . The queries and requests for suggestion are handled by service block .

Details of the synchronization process which is the mechanism by which service inserts documents from other applications A B C and makes them searchable is described next. In some implementations service synchronizes documents and tags which are properties of a document. A client application can dynamically change attributes of a document provided to service and as discussed below a user can limit a search query to documents having specified features. As mentioned above documents can be uniquely referred to by an opaque string URI and can contain sections which also can be indexed. For example for an e mail application a document may be a single message and its sections can include From To Subject and Body lines. Such a document can include for example the following tags Inbox Unread or Sent. In some implementations the total data in the document may not exceed a predetermined amount. For data that exceeds this length sections of the document may be truncated starting for example with the longest section in that document. Synchronization data is a table keyed by a monotonically increasing action sequence number. Service then applies those actions in that order. The respective content provider returns the sequence numbers e.g. arrival timestamps in monotonically increasing order.

A client application A B C can use a Get Corpus Status function to gain visibility into the processing of its data by service . For example for any data that is committed the client application can safely assume that service will not ask for that data again. However if the user deletes the service s data the client application would need to re register in which case service will request the data anew. A client application A B C can unregister a corpus which makes the data no longer accessible the data eventually is wiped from flash storage .

The following paragraphs explain how indexing and searching can be performed by service . Indexing can be triggered either by registering a corpus for example when an application A B or C first requests to use data indexing and searching service or by requesting indexing. The tasks of polling application content providers writing data to flash storage and indexing occurs in a background thread. When registering a new corpus indexing by service commences immediately. When service receives an indexing request with respect to an existing corpus service can delay indexing e.g. by one second in anticipation of receiving additional indexing requests.

In some implementations indexing takes place in batches of up to twenty documents or one hundred tags representing properties of documents. The application s content provider is requested to return at most this many documents for a given query. After this batch is indexed another indexing task can be rescheduled on the thread immediately. The goal is to reduce large queries to the application s content provider and to allow for fairness among corpora that need indexing. Indexing can be performed to completion i.e. until no documents from any of the corpora remain to be indexed .

As mentioned above document storage manager manages corpora . Each document from one of the applications A B C to be stored and indexed in a corresponding corpus is compressed and appended to the file. Deletions and tags i.e. document properties can be marked in bitmaps indexed by document identifiers. The file also maintains a mapping from the corpus and URI to the document identifier.

Term identifier document identifier pairs that indicate documents containing a particular term are appended into buffers in lite index and main index . Indices then can return all terms matching a specified prefix or can return a list of document identifiers indexed under a specified term in response to a suggest or search query.

Index files can store posting lists. For example in some implementations each block maintains a free list of byte arrays for posting lists which can be in blocks of flash page size e.g. 4K 8K . Posting lists can be strictly ordered for example from the most recent document down the default search result sort order and contain hits e.g. document identifiers indicating documents that contain a specified term. In some implementations posting list byte arrays are allocated in fixed sizes roughly in powers of two up to 1 000 hits with each hit containing four bytes. If a term has more than 1 000 hits the blocks are chained in a single linked list.

In some implementations a query is specified in free form and may have a maximum permissible length. Special operators supported by some implementations include the following 

Search and suggest queries arrive through binder API and are executed in line. As indicated by when service receives a query from search box block query processor parses the query block to determine corpus restrictions tag restrictions and section modifiers e.g. the To line or he Subject line in an e mail message . When a query is received in service a buffer in one of lite index or main index can be sorted by term identifier block . Then a binary search for the term of interest is performed block and a list of the document identifiers for the documents containing the search term is obtained block . For search queries from search box service can return results with respect to all corpora associated with the applications or with respect to a subset of the corpora block .

In some implementations query processor looks up the terms in both lite index and main index retrieves a certain portion of document identifiers up to a parameter num to score document identifiers from both indices and in the case of multiple term searches obtains the intersection or union of the posting lists. Query processor can look up a document score array i.e. a score dictated by each application such as the date of the document to map each document identifier to its score and computes the top document identifiers by score. These document identifiers are used to look up content corresponding to the document identifiers. A part of the document content is returned for each document based on query parameters. For subsequent queries if new documents are indexed then new terms that were added for example to the lite index can be sorted separately and then combined with a previously sorted list.

To manage the disk backed flash storage storage is accessed through index . New documents can be appended immediately to document store as they are added. The newly added documents then are indexed. Although the index and lexicon have two segments i.e. main and lite indexing takes place in lite index . During indexing all lexicon and index changes are written to lite index until a flush function is called. Index hits are accumulated in a file but no explicit disk sync occurs until the flush function is called which merges lite index into main index erases lite index and calls a fsync function for the main index to commit the buffered data. The flush function can be scheduled when lite index limits are reached or when a timer expires e.g. once a day .

As noted above when a search query is received query processor searches both lite index and main index . During a flush operation a lock prevents searches from traversing partially written data thus no searches can take place during the flush operation. In some implementations a flush operation takes 2 10 seconds and about six hundred e mail messages can be buffered in lite index before a flush operation is required.

Periodically e.g. once a week or when there is no available disk space a compaction process is performed to create new copies of the corpus files index files and lexicon files . All deleted document identifiers are erased the document identifier space is re compacted and a new index is written based on the new document identifiers. The document identifiers are re ordered by highest scoring first. A new lexicon points to the posting list locations in the new index. After the compaction is completed a fsync function is called with respect to all files. The new files are then used. No indexing occurs during compaction but searches can proceed using the old index.

Preferably data integrity is preserved without resorting to frequent costly calls to the disk sync function. To achieve this goal the following properties is used in some implementations. First the index is like a cache it contains no irrecoverable data and all data can be re created from corpus or if necessary re synced from the content source e.g. the content provider associated with application A B or C . Second a solution that has higher costs of recovery for unlikely scenarios but much lower average resource usage e.g. disk writes for the common cases is preferred. For this purpose data can be split conceptually into ground truth data and recoverable data. If ground truth data is lost it needs to be recovered from the content source i.e. the client application content provider which tends to be costly. On the other hand recoverable data can be reconstructed from ground truth data. Ground truth data can include for example document store document identifier mapper maps a document identifier to an offset in the document store and tag bitmaps. Recoverable data can include for example a URI map that maps a URI to a document identifier a document score table that maps a document identifier to a document store as well as index lexicon and term properties. Ground truth data is append only. Therefore flushed ground truth data cannot be corrupted by power loss.

The lite index and lexicon can use read write MAP SHARED file backed data structures that include updating cyclic redundancy checks CRCs . For example each random write array can be protected by a CRC. When the file backed data structure receives an onSleep callback it updates its CRC. Two strategies can be used to update the CRC. First a small number of random updates can be buffered and used to compute an incremental CRC whereas large numbers of updates can be clear the buffer and fall back on a complete CRC re computation. Upon startup consistency can be checked against the CRCs to ensure that inconsistent data is not loaded and used.

The main index and lexicon can use MAP PRIVATE read only file backed data that does not modify the file data between flushes. Therefore the main index and lexicon are immune to file corruption between flushes. During a flush an in flushing bit is synchronized to flash storage the flush is completed and then the bit is unset and main index is re synchronized to flash storage . Upon startup if the in flushing bit is set the system assumes that the files are corrupted and re constructs them from the ground truth data.

Consistency can be coordinated between index manager which synchronizes content with client applications A B and C and index implementation. For example upon initialization index manager passes down the last flush status to index . The flush status contains the last flushed i.e. committed document store size. Index responds with an indication of how much content it was able to successfully recover since the last flush point and responds with the per corpus last sequence number it has seen in the recovered region. Index manager resets its last sequence number for each corpus to the last flushed sequence number plus any recovered sequence numbers from index . After this document store initialization is complete the index is initialized. If lite index is corrupted documents seen since the last flush are re indexed. If main index is corrupted the entire index is rebuilt.

Any data structures touched both by searching time and indexing time can be protected by locks. For example in some implementations data indexing and search service remains active as long as a client application A B C is bound to it or the background thread has work to perform. When service is inactive index manager receives an onSleep event to cache service . In some situations the framework i.e. the device s operating system may decide that there is memory pressure and stop the process as well as the index manager at any time. However by caching service the data and code can be readily available in case the user wants to execute back to back queries.

The service also creates a periodic maintenance alarm that runs for example every day at 2 00 a.m. local time. If for example the device s battery is low ACTION BATTERY LOW the maintenance alarm is retried every hour until it succeeds. In some cases the maintenance executes the flush function i.e. disk commit every day and a compaction either every week or when the free space is less than a predetermined amount e.g. 10 of the allowed space.

By centralizing the storage of data as well as the search and query functions unified search queries can be performed by service without the need to start up multiple applications and open multiple databases. Storing all application indices in one place can facilitate faster universal searches. In some cases fast relevancy scored suggestions from the entire lexicon can be provided. Furthermore storage can be scalable and can serve for example statistics for predictive applications. Data indexing and search service can execute searches relatively quickly and uses compressed storage with a relatively small footprint. The service can reduces the number of flash writes required and can allow write operations to include a greater amount of data e.g. through the use of batching . Service can fetch a document by using the document s URI. Also in the illustrated implementation service does not have a durable write interface thus service decides when to commit data not client applications.

To ensure that data e.g. suggestions and search results from one corpus does not appear in searches intended for another corpus each application A B C is permitted to have a search performed only on its own corpus. In contrast a search query entered into search box can be executed with respect to all corpora or a specified sub set of corpora .

Various aspects of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them. The terms data processing apparatus and computer encompasses all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone or other computing device. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

While operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly other implementations are within the scope of the claims.

