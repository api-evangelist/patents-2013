---

title: System and method for file differencing with importance ranking
abstract: A system and method determines the differences between versions of an object, such as a file. The object versions are compared using a differencing tool to identify the differences between the versions. A scoring algorithm may be selected for the object based on one or more attributes of the object. The scoring algorithm is used to compute a difference score for the object. The difference score may be a function of the differences between the object versions and the characteristics or qualities of those differences. The difference score provides an indication of the relative importance of the changes made to the object. The difference scores from multiple objects may be presented in an interactive report, and sorted to identify those objects that underwent the most significant or noteworthy changes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104743&OS=09104743&RS=09104743
owner: The Mathworks, Inc.
number: 09104743
owner_city: Natick
owner_country: US
publication_date: 20130215
---
This application is a Continuation of application Ser. No. 12 830 844 filed Jul. 6 2010 for a System and Method for File Differencing with Importance Ranking by Malcolm A. Wood et al. which application is hereby incorporated by reference in its entirety.

The present invention relates generally to computer processing and more specifically to systems and methods for comparing electronic objects to identify differences.

In many fields of endeavor numerous electronic objects such as files are often created. During the course of designing and building a new product or system for example large numbers of objects are typically created revised edited and sometimes deleted thereby generating multiple versions of each object. In particular computer program files may be created and then updated as new features are added errors are corrected and old features are removed. Data files may be created and then modified as new data is acquired. In addition two files may start out as identical copies but diverge as they are updated and changed by different people or processes.

Oftentimes managers and others are interested in evaluating the changes that have been made to an object from one version to the next. To determine the differences between two files a differencing process is performed. A differencing process analyzes two or sometimes three files and produces a technical description of the differences between or among them. The UNIX operating system for example includes a utility known as diff that compares the contents of two files. To run the diff utility a user enters the diff command at a Command Line Interface CLI along with the names of the files. The Windows operating system from Microsoft Corp. of Redmond Wash. includes a similar utility called windiff that determines the differences between ASCII files.

Computer readable media may store instructions that when executed by processing logic identify the differences between versions of an electronic object. The instructions may store the versions of the object in a memory and the object may have one or more attributes. The instructions may compare the versions of the object to identify the differences between the versions of the object and may identify a characteristic of at least one identified difference. The instructions may select automatically from a plurality of available scoring algorithms a given scoring algorithm for the object. The selection of the given scoring algorithm may be based on the one or more attributes of the object. The instructions may compute a difference score for the object using the given scoring algorithm. The instructions may present the computed difference score to a user. The computed difference score may be a function of the differences identified between the versions of the object and the characteristic of the at least one identified difference.

In an embodiment a method may store a plurality of electronic objects in a memory analyze a pair of objects to find the differences between them assign a weight to each of the differences calculate a difference score for the objects and present the difference score on a display. The difference score may be a function of the assigned weights of the differences found between the pair of objects.

In an embodiment an apparatus may include a memory that stores a plurality of electronic objects. The apparatus may also include a display and a processor coupled to the memory and to the display. The processor moreover may be configured to compare a pair of matching electronic objects to identify the differences between the objects. The processor may also assign an importance level to each difference identified between the objects. The processor may compute a difference score for the objects. The difference score may be a function of the importance levels assigned to the differences between the pair of matching electronic objects. The processor may present the computed difference score on the display.

Briefly embodiments of the invention relate to a system and method for performing differencing between multiple versions of an object such as a file or between multiple objects. The system and method may be implemented through a differencing engine. The differencing engine may include a selector a comparator a scoring engine and a report generator. The differencing engine may also include or have access to one or more differencing tools and to a plurality of scoring algorithms. The object versions to be analyzed are received at the differencing engine and the selector retrieves or derives one or more attributes of the object.

Exemplary object attributes include file type such as a C programming file a text file an eXtensible Markup Language XML file etc. Furthermore for C programming files additional attributes may include whether the file is a source file a header file a make file etc. If multiple differencing tools are provided the selector may select one of the differencing tools. Using the selected differencing tool the comparator analyzes the versions of the object identifies the differences between the versions and identifies a characteristic or quality of at least one of the identified differences. The comparator may also identify an overall change type between the object versions. Exemplary change types include modification addition and deletion types.

The selector may select one of the scoring algorithms based on the one or more attributes of the object. The scoring engine uses the selected scoring algorithm to compute a difference score for the object. The difference score may be a function of the extent of differences i.e. the total number of differences identified by the comparator and at least some of the characteristics or qualities of those differences. More specifically the scoring algorithm is specially designed such that differences deemed to be more significant are given a higher weight than differences deemed to be less significant.

The overall change type and the difference score may be provided to the report generator. The report generator may be configured to organize the difference scores and the change types for a plurality of objects whose versions were evaluated into a high level summary report having a table or array format. The report may be presented on a display and may include an entry or row for each object whose versions were compared. Each entry may include an object name field an overall change type field and a difference score field among others. The entries of the array may be sorted in response to a selection of a given field by a user. For example upon selection of a difference column the entries of the array may be sorted e.g. from highest difference score to lowest difference score. The report generator may also link the identified differences for a given object to the high level summary report and may permit a user to navigate to these identified differences in order to obtain a greater level of detail regarding the differences identified among versions of the analyzed objects.

In an embodiment a user may manually select or designate the objects whose versions are to be evaluated by the differencing engine. For example the differencing engine may include a user interface component that generates a user interface such as a graphical user interface GUI for presentation to the user. The GUI may include one or more controls through which the user can select the objects whose versions are to be evaluated e.g. by file name.

In a further embodiment the selection of objects may be performed programmatically e.g. automatically by the differencing engine. Specifically the differencing engine may further include a mapper. The mapper may be configured to identify particular objects for comparison based on use cases. That is the mapper may be preconfigured with a plurality of use cases. Each use case may correspond to or specify one or more classes of objects. A user rather than manually identifying specific objects to the differencing engine may specify a given use case.

For example a first use case may be established for a system design phase of a product development program. This first use case moreover may only specify a design class of objects for comparison. A second use case may be established for a system testing phase of the product development program. This second use case may only specify those objects that fall within a test class. The mapper may search a project directory in order to identify all of the objects that match the class or classes corresponding to the use case specified by the user e.g. all design objects or all test objects. The identified objects may then be analyzed by the differencing engine as described above. A third use case may be established for Configuration Management. This third use case may specify files that were obtained from a software Configuration Management CM tool or system which may be located on one or more remote machines and modified on a user machine. The specified files may be compared to the respective files stored within the CM tool to identify the changes that have been made. Additional use cases may be established for systems that store files or objects in locations other than on the user s machine such as Product Lifecycle Management PLM tools relational databases DVDs etc.

In yet a further embodiment the use cases may also specify the differencing tool and or the scoring algorithm to apply to the class of objects corresponding to the use case.

The main memory may store among other things a plurality of programs libraries or modules such as an operating system and one or more applications configured to run on top of the operating system including a program development environment a code generator and a differencing engine . Also stored on the workstation may be one or more projects such as projects . Projects may be stored on the main memory as illustrated on the disk drive and or on other storage. Each project moreover may include a plurality of objects such as files or other electronic data containers. Exemplary objects include computer source code files text files spreadsheets binary files databases data files graphical model files etc.

The removable media drive is configured to accept and read a computer readable media such as a CD DVD floppy disk solid state drive tape flash memory or other media. The removable media drive may further be configured to write to the computer readable media . The user I O may include a keyboard a pointing device such as a mouse and a display . It should be understood that other or additional user I O may be provided such as a touch screen a touch pad a camera a microphone a printer etc.

Suitable processors for implementing the CPU can include single or multicore processors such as the Core Pentium or Celeron families of processors from Intel Corp. of Santa Clara Calif. or the Phenom AMD Athlon or AMD Opteron families of processors from Advanced Micro Devices Inc. of Sunnyvale Calif. among others.

Suitable operating systems include the Windows series of operating systems from Microsoft Corp. of Redmond Wash. the Linux operating system the MAC OS series of operating systems from Apple Inc. of Cupertino Calif. the UNIX series of operating system and the Android operating system from Google Inc. of Mountain View Calif. among others.

It should be understood that the program development environment may be a text based programming system a visual programming system a graphical programming system or some combination thereof. Suitable program development environments include the MATLAB and Simulink technical computing environments as well as the Stateflow and SimEvents modeling systems from The MathWorks Inc. of Natick Mass. the .NET programming system from Microsoft Corp. the LabVIEW programming environment from National Instruments Corp. of Austin Tex. the Visual Engineering Environment VEE from Agilent Technologies Inc. of Santa Clara Calif. the Khoros development system from AccuS oft Corp. of Northborough Mass. a C programming environment a C programming environment or various combinations thereof among others. Suitable code generators include the Real Time Workshop code generator and the HDL Coder code generator both from The MathWorks Inc.

Suitable workstations include Dell Precision series of workstations from Dell Inc. of Round Rock Tex. and the HP Z400 Z600 and Z800 series of workstations from Hewlett Packard Co. of Palo Alto Calif. among others.

Nonetheless those skilled in the art will understand that the workstation of is meant for illustrative purposes only and that the present invention may be used with other data processing devices computer systems processing systems or computational devices such as personal computers PCs laptops palm computers tablet computers and other portable computing devices smart phones electronic readers e readers client terminals of client server systems grid or cloud computing systems etc.

It should also be understood that the workstation need not include the program development environment or the code generator .

It should be understood that one or more of the components of the differencing engine may be located or stored remotely relative to other components. For example one or more of the scoring algorithms may be accessed by the differencing engine across a network such as the Internet. The remote scoring algorithm moreover may be accessed through a service oriented protocol.

The differencing engine may receive user input as indicated by arrow . As described herein a user may input a designation of one or more objects such as files to be compared. In a further embodiment the user also may indicate or select one or more use cases . The differencing engine also may receive the designated objects and or object versions to be analyzed as indicated by arrow . In addition the differencing engine may have access to one or more project directories as indicated by arrow . As described above the project directory may include a plurality of objects and versions of objects. The differencing engine generates results or output which may be in the form of a report as indicated by arrow . The output may be presented to the user e.g. via display or by printing a hard e.g. paper copy. The results or output also may be in a form suitable for receipt and further processing by another computer program or application. For example an Application Programming Interface API may be created for the differencing engine so that other applications or processes may obtain all or portions of the results e.g. through one or more Get commands. Another form of the results or output may be an electronic representation such as a file.

The selector comparator scoring engine and report generator among other components of the differencing engine may comprise registers and combinational logic configured and arranged to produce sequential logic circuits. In an embodiment the selector comparator scoring engine and report generator are or include software modules or libraries. The software modules or libraries can contain program instructions pertaining to the methods described herein that may be stored on computer readable media such as main memory disk drive and or computer readable media and executed by one or more processing elements such as CPU . Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments various combinations of software and hardware including firmware may be utilized.

In an embodiment the differencing engine may be implemented as an add on tool to the program development environment . Accordingly the differencing engine may analyze objects from within environment and at least some of these objects may have been created and or revised from within the program development environment .

Suitable differencing tools for use with the present invention include the UNIX diff utility the Microsoft Windows windiff utility the File and Directory Comparison

Tool from The MathWorks Inc. the WinMerge open source differencing and merging tool for Microsoft Windows and the Araxis Merge file comparison software product from Araxis Ltd. of Isle of Man UK among others. For objects representing graphical models or block diagrams a differencing tool as described in U.S. Pat. No. 5 974 254 issued Oct. 26 1999 for a Method for Detecting Differences Between Graphical Programs and S. Chawathe A. Rajaraman and J. Widom SIGMOD Conference Montreal Canada June 1996 pp. 493 504 may be used both of which are hereby incorporated by reference in their entireties.

It should be understood that the differencing tools may be included within the operating system or may be stand alone applications or utilities.

The objects moreover may be modified or revised e.g. by adding new data to the objects by deleting or modifying existing data within the objects etc. thereby creating multiple versions of the objects as also indicated at block . Thus a given object may have a current version and one or more prior versions. In addition a given object may have branched versions in which case more than one current version may exist.

One or more objects whose versions are to be compared are received e.g. at the workstation as indicated at block . In an embodiment the differencing engine may provide a user interface not shown such as a graphical user interface GUI for presentation on the workstation s display . A user may interface with the GUI to designate the one or more objects to be analyzed. For example the GUI may present one or more controls such as a Directory or Open dialog box that allow a user to navigate a file system e.g. with the keyboard and or mouse in order to locate and select objects and object versions for comparison. For example the user may designate a current version which represents the most up to date version of an object and an earlier version or the user may designate two different current versions of a branched object.

It should be understood that the user may alternatively designate one or more directories folders or other data containers that contain or reference a plurality of objects and or object versions that are to be compared. It should be further understood that a user may designate two objects to be compared instead of designating two versions of an object. It should also be understood that a user may designate more than two objects e.g. three objects for comparison.

The selector examines the one or more designated objects to identify respective attributes of the one or more objects as indicated at block . Exemplary attributes include an object s file type and root element for XML files or objects. For example suppose the user designated a file folder containing a plurality of C programming files. The selector may determine that a first attribute of these objects is a C programming file attribute. Suppose further that the folder includes source files header files make files and documentation files such as HTML documentation files. For the source files the selector may further determine that an additional attribute of these files is a source file attribute. For the header files the selector may further determine that an additional attribute of these files is a header file attribute and so on.

In an embodiment the selector may be configured to examine the file extension of the object to identify the one or more attributes for that object. For example the selector may be configured to assign the C programming file and source file attributes to objects having a .c extension. Similarly the selector may be configured to assign the C programming and header file attributes to objects having a .h extension.

The selector may be configured to examine additional features of a designated object in addition to its file extension to determine the object s one or more attributes. For example as indicated above for XML objects or files the selector may examine the root element. For the Microsoft Word XML file format the root element has the form . For the Simulink Manifest file format the root element has the form .

The selector may choose a particular differencing tool from the differencing tool library for each object based on the one or more attributes of the object as indicated at block . For example for an ASCII text file the selector may choose the windiff utility. For an XML file the selector may choose the above referenced Chawathe algorithm. For a binary executable object the selector may choose the Reflector Diff AddIn.

The selector also chooses a scoring algorithm from the scoring algorithm library for each object based on the one or more attributes of the object as indicated at block . In particular the selector may maintain or have access to a database not shown that associates object attributes with scoring algorithms. The association of object attributes to scoring algorithms may be predefined. The selector may perform a lookup on the database using the one or more attributes derived for an object to identify the corresponding scoring algorithm for that object.

For example the selector may identify the following scoring algorithm for an object determined to have the C programming and source file attributes difference score 2 

C is a total number of the differences detected in the comment lines of the source file versions plus a number of the differences detected in the non comment lines that are solely whitespace differences and

For an object determined to have the C programming and header file attributes the selector may identify the following scoring algorithm difference score 2 where

C is a total number of the differences detected in the comment lines of the header file versions plus a number of the differences detected in the non comment lines that are solely whitespace differences and

In an embodiment each scoring algorithm is designed so that those differences deemed to have greater significance such as differences in the main programming lines of a C programming source file are assigned a higher weight than those differences deemed to have less significance such as differences to the comment lines of a C programming file differences to a copyright notice differences to a date of modification and differences that are simply the addition or removal of whitespaces. Accordingly the difference score computed by each scoring algorithm provides a measure of the significance or importance ranking of the changes that have been made to the object. For example difference scores may be numeric values and a high difference score may indicate a large number of significant i.e. relatively important changes to the object. On the other hand a low difference score indicates that the changes even though there may be many are relatively insignificant. The difference score thus provides an indication as to the noteworthiness of the changes made to an object as opposed to simply being an indication of a total number of differences that have been made to the object. It also provides a way to rank the changes made to a plurality of objects by importance as described herein.

The ranking of changes may also be a partial order. For example differences in a first set of attributes may be ranked independently from differences in a second set of attributes. The ranking may then be a higher dimensional value which may be represented in a multidimensional space a graph etc.

For an object determined to have a .mat file attribute e.g. a file having a .mat extension the selector may identify the following scoring algorithm difference score added or removed modified

modified is the number of variables that appear in both versions or objects but have different values.

It should be understood that this scoring algorithm may be refined to give a greater weighting to variables such as numeric matrices that contain more elements or to give a lower weighting to variables in which only a few elements are different.

For an object determined to have an .xml file attribute e.g. a file having an .xml extension the selector may identify the following scoring engine difference score added or removed modified moved total number of nodes

moved is the total number of nodes that are themselves unchanged but that have moved within the hierarchical structure of the .xml versions or objects and

total number of nodes is the number of nodes in the first .xml object or version added to the number of nodes in the second .xml object or version.

It should be further understood that in other embodiments the selection of the differencing tool and the scoring algorithm to be used for a given object may be performed by the comparator and the scoring engine themselves or by other components. For example the functionality of the selector may be distributed among the comparator and the scoring engine .

The selector may provide or pass the identity of the selected differencing tool and the scoring algorithm to the comparator and the scoring engine respectively. The comparator compares the received versions of the object by applying the selected or chosen differencing tool from the differencing tools library as indicated at block . Application of the differencing tool by the comparator may produce a technical description of the differences between the versions of the object. That is the differencing tool may identify each difference between the two versions. It may also identify the kind or characteristic of the difference e.g. addition of white space modification of main text line etc.

The differencing tool may additionally be designed or configured to derive an overall or main characterization of the changes between the versions of the object being compared as indicated at block . For example when comparing two folders of objects an object that appears only in the current version may have an overall characterization of Added. An object that appears only in the prior version may have an overall characterization of Deleted.

In addition meta information regarding the changes that have been made to an object project etc. may be stored. Exemplary meta information includes undo information. The meta information may be used to establish relationships between different versions of objects.

To the extent a user selects two directories or folders of objects for comparison the selector may identify the particular objects within each directory that are to be compared against each other. The selector may match objects having the same file name from the two directories for comparison. That is the selector may use file names to designate the object pairs for comparison. It should be understood that this functionality may be implemented in the comparator .

The scoring engine applies the selected scoring algorithm to compute a difference score for the object versions being analyzed as indicated at block . The scoring engine may obtain the actual technical differences in the object versions from the comparator such as the extent i.e. the total number of differences the number of differences to comment lines etc. for use in computing the difference score. That is the scoring engine may obtain at least some of the input values needed to compute the difference score based on the analysis performed by the comparator .

It should be understood that the scoring engine may be configured to compute a difference score for folders as well as for objects or files. The score computed for a pair of folders being analyzed may be determined by summing the difference scores computed for the objects or files within the folders which may apply weight factors to the respective scores. The computation of difference scores for folders may be performed in response to a request from the user. In an alternative embodiment for performance purposes the scoring engine may be configured to compute the difference score for selected folders as a background process or on another core of a multi core processor among other alternatives.

The technical differences identified by the comparator the overall characterization of the changes and the computed difference score for the objects may be provided by the comparator and the scoring engine to the report generator . The report generator may organize the received information in the form of a report as indicated at block . The report moreover may be presented to the user by the report generator as indicated at block . For example the report may be presented on the display of the workstation . Alternatively or additionally the report may be printed.

The report generator may generate the summary report such that the entries may be sorted based on the information or data in the cells. That is in response to a user selecting a column e.g. with the mouse the sorting engine of the report generator may re sort the entries of the report based on the data or information in the selected column as indicated at block . A symbol such as caret symbol may be presented by the report generator in the report to designate the particular column e.g. the Type column on which the report is currently sorted. The caret symbol moreover may point up to indicate that the selected column is sorted in ascending order or the caret may point down to indicate that the selected column is sorted in descending order.

In response to the user selecting the Difference Score column the sorting engine may sort the report so that the objects with the highest difference scores are at the top of the report . That is the sorting engine ranks the objects by the importance or significance of the changes that have been made to the objects. Accordingly the user can quickly determine which objects have undergone the most significant change between the current version and the prior version as determined by the one or more scoring algorithms . In response to the user selecting the Change Summary column the sorting engine may sort the report in terms of the types of differences. The user can thus quickly determine e.g. which new objects have been added or which old objects have been removed.

In an embodiment the report generator may link or hierarchically organize information regarding the objects and the differences that were determined into multiple views as indicated at block . Furthermore the report generator may configure the report to be interactive so that the user may navigate among the various views or levels to obtain the desired degree of information. The report moreover may represent a top level view of the hierarchy providing high level summary information for all of the objects of the selected directories or folders. A user moreover may navigate among the various levels of the hierarchy to obtain a greater level of detail regarding the differences between the versions of an object. For example a user may select a given object in the report . In response to user selection of an object displayed in the report the viewing engine of the report generator may be configured to switch to another e.g. more detailed view as indicated at block .

More specifically within an entry such as entry that corresponds to an object in both the prior and current versions a command button such as compare button may be provided. In response to the user selecting the compare button the viewing engine may generate a more detailed view of the differences identified in the two versions of the respective object i.e. the lengthoffline.m file. That is the more detailed view may be linked to the summary report through the compare button .

To return to the top level report the user may close the more detailed view . Alternatively or additionally the detailed view may include a return command button not shown .

In an embodiment one or more of the scoring algorithms may be configurable e.g. by the user. For example a scoring algorithm may include settable parameters as weights for one or more detected differences such as additional spaces capitalizations block positions within graphical models block names within graphical models etc. A user may then assign values including a value of zero to one or more of the settable parameters thereby customizing the difference algorithm to the user s needs. Furthermore one or more of the scoring algorithms may consider meta information changes or differences such as who made the changes to the object in what time interval were the changes made from what geographic location were the changes made from what machine or terminal or from what type of machine or terminal were the changes made etc. This meta information moreover may be assigned weights that are configurable.

A user interested in the functional changes to the source code file may choose a high Wf value and a low Wc value. Another user interested in the documentation changes to the source code file may choose a low Wf value and a high Wc value.

In an embodiment the scoring engine may be configured to provide presets for the weights Wf and Wc. The scoring engine also may provide multiple sets of different weightings and the user may select the most suitable set for his or her purposes. In addition the scoring engine may allow the user to set one or more of the weights e.g. Wf and Wc manually. Those skilled in the art will understand that user settable weights may be implemented with other possibly far more complex scoring algorithms.

In an embodiment numerous people may be involved in the creation of a software hardware or combination software hardware system or product. The product for example may be a mobile phone an engine control unit ECU an aircraft flight control system etc. The development of such a complex system or product may follow a formal or informal development cycle having several stages during which numerous objects are created revised and possibly deleted. A well known product development model or cycle is the V model. The V model consists of a number of phases including a Requirements Phase a Design Phase a Development Phase a Testing Phase a Documentation Phase and a Deployment Phase represented in a V shaped diagram.

During the Requirements Phase the requirements of the system are defined e.g. by analyzing the needs of users and or customers. One or more user requirements files may be created and revised during this phase. The user requirements files may be text or diagram files that describe or illustrate the functional performance security and other requirements of the proposed system. Suitable user requirements file formats include text Hyper Text Markup Language HTML spreadsheet files word processing files drawing or diagram files and Portable Document Format PDF files among others. The user requirements files may be created with a system requirements tool such as the IBM Rational DOORS software product from IBM Corp. of Armonk N.Y.

During the Design Phase system engineers may study the user requirements files and develop a design of the system. Numerous objects may be created revised and deleted during this phase. For example the system engineers may create one or high level design files such as System Functional Architectural Software and or Hardware Specifications which may serve as blueprints for the proposed system. These files may provide a list of the various components or modules of the system a description of the functionality of each component or module and a description of their interfaces. These files may also describe databases data structures and other details of the system. In addition system testing files may also created during the Design Phase. Exemplary design file formats include text HTML and spreadsheet files among others.

During the Development Phase programmers hardware engineers and other developers create software firmware hardware elements and other components based on the design files. For example the system design described in the design documents may be coded. Numerous objects may be created revised and deleted during this phase. These objects may include computer source code files header files makefiles documentation files etc. At least some of the files may be compatible with one or more programming languages such as C C the MATLAB development environment the Simulink modeling environment the .NET framework VHDL Verilog etc. There may also be one or more derived files such as C or C source or object code files that were derived from other typically higher level source files. For example C C VHDL or Verilog code may be generated from one or more files created in the MATLAB development and or the Simulink modeling environment by the code generator .

In a Model Based Design or Model Based Engineering approach to system development one or more graphical models of the entire system may be created and revised. The graphical models may be or may include one or more block diagrams and or state charts. The models moreover may be executable and thus may be simulated to test their performance and operation. As indicated above production quality code may be automatically generated from one or more of the block diagrams or state charts of the models. Exemplary modeling systems include the Simulink modeling environment from The MathWorks Inc.

During the Testing Phase a prototype system may be built and tested. The prototype system may be tested against the requirements developed during the Requirements Phase. In addition to testing a prototype of the entire system testing may be performed on one or more components or modules. Numerous objects may be created revised and possibly deleted during this phase. For example a test specification file that describes the tests to be performed and the manner in which they are to be carried out may be created. Test vectors may be created for use during the Testing Phase. Test data may be generated and stored in data objects such as databases. In addition one or more Test Reports that describe the results of the testing may be created.

During the Documentation Phase materials containing information regarding the use and operation of the system are created. As with the other phases numerous objects may be created revised and deleted during this phase. For example technical writers may produce User s Guides Reference Manuals Repair and Troubleshooting Guides Help programs etc. These objects may be in the form of text files HTML files help files etc.

In addition objects that document or memorialize the internal design of software the algorithms developed or used Application Programming Interfaces APIs or other interfaces for the purpose of future maintenance and enhancement may also be created during the Documentation or other phases. The MATLAB Report Generator and the Simulink Report Generator documentation tools from The MathWorks Inc. for example may be used to automatically create documentation from Simulink and Stateflow models. These tools allow users to document software requirements and design specifications and produce reports.

During the Deployment Phase objects created during the Development Phase may be modified to support the commercial distribution of the system or product. For example objects may be optimized to support large scale production. In addition object files created during the Development Phase may be grouped together with objects created during the Documentation Phase such as a User s Manual and compressed e.g. with a zip utility to produce an archive such as a zip file.

It should be understood that there could be other phases such as a Training and Support Phase a Maintenance Phase a Marketing Phase etc. It should also be understood that other product or system development models besides the V model may be used.

The objects created during the development of the system or product may be logically organized into one or more project directories. Each project directory may have a plurality folders and subfolders providing further logical organization of the objects. The project directory folder and subfolders moreover may be organized in a hierarchical tree structure.

It should be understood that requirements or other files may be identified automatically with a tool such as the Simulink Manifest tool which may be used to identify requirements files for Simulink models.

The mapper traverses the designated project directories and extracts certain objects based on the one or more uses cases that it received as indicated at block . For example a project manager may select a User Requirements use case. The User Requirements use case includes a predefined listing of object classes and or object metrics or characteristics. For example a first class of the User Requirements use case may be objects within the User Requirements folder of the project directory . A second class of the User Requirements use case may be objects anywhere in the directory that have a certain file name or term within their file names such as the terms survey or feedback .

More specifically objects are associated with one or more metrics or characteristics. Each use case moreover may include a predefined list of one or more metrics or characteristics. Objects having the one or more metrics or characteristics listed in a use case match that use case. Exemplary object metrics or characteristics include 

In another example a model design engineer may select a Design use case. is a schematic illustration of a Design use case . The Design use may include a list of metrics or characteristics such as Design phase objects and .mdl file type objects located anywhere in the project directory . The .mdl objects correspond to graphical models created with the Simulink technical computing environment.

By employing use cases a user need not specify each object or folder of interest. Instead the appropriate objects are mapped by the use case and the mapper may search the project directory to identify the objects that match the criteria of the use case .

The identified objects may then be provided to the selector so that differencing tools and scoring algorithms may be identified and applied as described above.

In an embodiment a use case may alternatively or additional identify the differencing tool and or the scoring algorithm to be used for a given object whose versions are to be analyzed as indicated at block . That is the mapper may choose a particular differencing tool and scoring algorithm to apply to an object based on the use case indicated by the user.

It is the use cases moreover that determine which particular scoring algorithm is to be used for a given object during a given differencing run. For example with use case object is mapped to scoring algorithm object is mapped to scoring algorithm and objects and are mapped to scoring algorithm . As object does not meet any of the metrics or characteristics of use case there is no mapping of object . With use case objects and are mapped to scoring algorithm and objects and are mapped to scoring algorithm . As object does not meet any of the metrics or characteristics of use case there is no mapping of object .

It should be understood that is meant for illustrative purposes only and that the mapper may map a large number objects to a large number of scoring algorithms based on the use cases . It should also be understood that the mapper may be implemented in software or hardware and may utilize a plurality of data structures. It should be further understood that the use cases may map matching objects to differencing tools in a similar manner.

The foregoing description has been directed to specific embodiments of the present invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. For example a user may select the differencing tool and or the scoring algorithm to be used. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

