---

title: Method and apparatus for programming software components
abstract: Methods and systems are disclosed for programming software components that treats software components as the basic unit of abstraction and computation. A software component is encapsulated and classes and other program entities, such as data fields and methods, within a given component do not exist beyond a component boundary. A component interacts with other components only by means of a defined set of input and output ports. A component can inherit and implement ports declared in a template and can declare and implement new ports. A component can only access the external environment through its output ports. An output port of one component can only be connected to a conforming input port of another component. A connect statement is an explicit plumbing operation for connecting components together. Interactions between components are loosely coupled. A related set of templates can be grouped to form a group.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08966444&OS=08966444&RS=08966444
owner: Intenational Business Machines Corporation
number: 08966444
owner_city: Armonk
owner_country: US
publication_date: 20130723
---
This application is a divisional application of U.S. patent application Ser. No. 13 407 097 filed on Feb. 28 2012 which is a continuation of U.S. patent application Ser. No. 09 925 580 filed on Aug. 9 2001 which claims the benefit of U.S. Provisional Application No. 60 276 237 filed Mar. 15 2001.

The present invention relates generally to the fields of software programming and more particularly to methods and apparatus for programming software components.

The cost and complexity of developing large scale software systems has increased dramatically in recent years. Software reuse and software maintenance are two of the biggest challenges in software engineering. Software reusability is a performance metric indicating the degree to which a software module or other software product can be used in more than one computer program or system. Software maintenance includes any modifications to a software product after the product is initially delivered e.g. to correct faults improve performance or to adapt the product to another environment.

Object oriented OO software development techniques have been said to offer significant advantages in the context of software reuse and maintenance. Generally object oriented techniques represent real world and abstract objects using programmed objects. The concept of abstraction allows object oriented programmers to focus only on relevant characteristics of the real world domain. While object oriented programming techniques have offered significant advances in the area of software reuse and maintenance such object oriented techniques suffer from a number of limitations which if overcome could greatly improve the ability to reuse and maintain software products.

Most current component technologies are based on a set of standards such as Component Object Model COM Enterprise JavaBeans EJB and Common Object Request Broker Architecture CORBA . For a more detailed discussion of the current state of component software technology see for example Clemens Szyperski. Component Software Beyond Object Oriented Programming. Addison Wesley 1999 incorporated by reference herein.

Generally these component models define a set of interfaces or services that can be invoked by clients. Existing component models have strived to ensure that components are reusable modules that can be inserted into any compatible system without knowing the internal details of the component. For example a component that is developed using the WebSpere platform from International Business Machines Corporation of Armonk N.Y. should seamlessly be portable to a WebLogic platform. In practice however this generally does not happen since components are artifacts of Application Programming Interfaces APIs and there is no clear semantic definition of a component. Currently very little research has been done in promoting components as first class citizens in a main stream programming language.

A need therefore exists for a method for programming software components that enhances the maintainability and reusability of components.

Generally a method and apparatus are disclosed for programming software components that treat software components as the basic unit of abstraction and computation. Thus a software component is encapsulated and classes and other program entities such as data fields and methods within a given component do not exist beyond a component boundary. One component cannot inherit another component s internal structure and behavior.

A component interacts with other components only by means of a defined set of input and output ports. A component can inherit and implement ports declared in a template and can declare and implement new ports. A component must attach each of its input ports to a concrete class within it. Thus when a message arrives at an input port of a component the messages should be processed by some logic i.e. classes in the component.

A component can only access the external environment through its output ports. Thus a component can only invoke services of other components via its own output ports. An output port of one component can only be connected to a conforming input port of another component. Port typing restricts the kinds of messages i.e. operations that can be passed from one component to another component. A connect statement is an explicit plumbing operation for connecting components together. The connect statement creates dependencies among components and ensures that the corresponding types and protocols of each connected component match.

According to a further feature of the invention interactions between components are loosely coupled. A looser coupling between components helps improve reusability and maintenance of components. Generally one component is not aware of the identity of other components in a system. Among other benefits loose coupling enhances maintainability and reusability of components. Implicit invocation is an architectural style for achieving such loose coupling among components. A related set of templates can be grouped together to form a group. Groups are useful for implementing implicit invocation and multicasting.

A more complete understanding of the present invention as well as further features and advantages of the present invention will be obtained by reference to the following detailed description and drawings.

According to one aspect of the present invention a software programming environment is disclosed for programming software components. In the software programming environment of the present invention software components are first class citizens that have precisely defined sets of input and output typed ports. illustrates the structure of two exemplary components collectively referred to as components in accordance with the present invention. According to another aspect of the present invention a component is the basic unit of abstraction and computation. Thus classes and other program entities within a given component do not exist beyond a component boundary.

As shown in a component has a number of input ports through N collectively input ports and a number of output ports through N collectively output ports . A component interacts or communicates with another component such as the component only via these ports . Thus these ports are interfaces or plumbing mechanisms that connect components together.

A component is required to specify certain external contracts so that other components can connect to it. Contracts of a component may consist of both input contracts and output contracts. One should be able to specify these contracts at an abstract level without worrying about the implementation details. The software programming environment of the present invention provides a template to specify a part of the abstract contract of a component . As discussed further below in a section entitled Defining and Creating Components template consists of declarations for input ports and output ports. A port in a template consists of three parts 1 a keyword indicating the direction of the port either in or out 2 a type such as Bool indicating the type of the port and 3 a name for the port such as xin. The type of the port can only be of interface types since we use interface to plumb components together .

A component in the software programming environment of the present invention implements the abstract contract defined by a template. As shown in a component in the present software programming environment consists of two portions 1 an external portion that other components can see and 2 an internal portion that is private to the component . Thus a client cannot access the implementation of a component directly but only through the input ports of the component .

A component can inherit and implement ports declared in a template additionally a component itself can declare and implement new ports . The internal portion of a component is made of a set of data fields methods and classes. When messages i.e. interface operations arrive at an input port of a component the messages should be processed i.e. implemented by some logic i.e. classes in the component .

A component must attach each of its input ports to a concrete class within it. This class acts as a proxy to the messages that arrive at the input port . The proxy class should be able to handle all operations that arrive at the input port i.e. implement the interface of the input port . A connect statement is an explicit plumbing operation for connecting components together. The connect statement creates dependencies among components and ensures that the corresponding types and protocols of each connected component match. A component can only invoke services of other components via its own output ports. This feature allows a looser coupling between components. Looser coupling helps improve reusability and maintenance of components. Thus a component can only access the environment through its output ports .

The basic properties of software components are discussed further below in a section entitled Basic Properties of Software Components. 

Consider a simple example where a client wants to interact with a boolean component that implements standard Boolean operations such as not and nand . The first step is to define an interface i.e. the set of operations that the Boolean component is expected to provide. The following code segment defines an interface Bool that defines two standard operations not and nand on the primitive boolean type.

The following code segment is a template for a boolean component that consists of only one input port . In general a template may consist of multiple input ports and multiple output ports.

The following code segment defines a component referred to as BooleanComp implementing the template BooleanTempl defined above 

Thus the input port xin is attached to the class BoolClass. This completes our implementation of BooleanComp components. Thus the class BoolClass should be able to handle all operations that arrive at the input port xin.

The client component ClientC has one output port . The main method can only be called by the virtual machine VM or the runtime system and is the entry point to the application. In ClientC an instance of ClientC and BooleanComp components are created. Next the output port CC.xout of the ClientC instance is connected to the input port BC.xin of the BooleanComp instance. The connect statement is an explicit plumbing operation for connecting components together. Once the connection is established the services of BooleanComp component can be used.

As previously indicated a component can only invoke services of other components via its own output ports . In the present example tt is important to remember that the not service is available at the output port only if the output port was previously connected to a component that provides the not service.

A component in accordance with the present invention is a pluggable unit. Generally a component is comprised of a collection of classes. A key concept in building a software system from off the shelf software components is the notion of abstraction. To use a component a programmer should know what it is expected to do when assembled as part of a system. To assemble a component in a system the component must have input and output connections. Thus a component is a unit of abstraction with connection ports .

A component in accordance with the present invention employs typed ports for plumbing. Components interact with other components only via their input and output ports . Types are used as a plumbing mechanism to connect components together. An output port of one component can only be connected to a conforming input port of another component . Typing essentially restricts the kinds of messages i.e. operations that can be passed from one component to another component 

The software programming environment of the present invention provides templates that allow the various contracts of components in the system and how components interact with one another to be specified at a very high level. Templates give signatures to components .

Components in accordance with the present invention and interactions between components are loosely coupled. Ideally one component should not be aware of the identity of other components in the system. Loose coupling enhances maintainability and reusability of components. Implicit invocation is an architectural style for achieving such loose coupling among components.

There is no inheritance mechanism between components . Components are individual off the shelf units. One component cannot inherit another component s internal structure and behavior. A component itself is made of some internal structures that are not observable beyond the component . These internal structures can have inheritance relations among themselves. One can think of a component to be made of a set of related classes that implement the logic of the component in a similar manner to Design Patterns.

Components in the software programming environment of the present invention do not have global states such as global variables public classes and public methods that are visible throughout the system. Global states inhibit reuse and maintenance of software components.

The only interaction that a component has with the external world is through its input output ports . The specification or the contract of a component such as the input and output behavior invariance and dependencies to other components should be clearly specified. For example for a File Transfer Protocol FTP component it is important that a client first connects to a file server before issuing a get file command.

Interfaces are a set of named operations and defined constants. In the present programming environment interfaces are used to type ports in a template and also to type method parameters and return values. The present programming environment supports multiple inheritances among interfaces. Interface inheritance establishes a subtype relation among interfaces. If a first interface I extends a second interface J then I is called the subtype of J and is denoted as I

A template is a signature to components . A template consists of a set of declarations for constructors input ports and output ports . A template may be implemented by one or more components . Both the input ports and the output ports are typed. These ports act as connectors when component instances are connected or plumbed together. The port names within a template should be distinct and multiple ports can have the same type.

In the present environment one template can extend other templates forming a template inheritance hierarchy. Once again the template inheritance hierarchy forms a directed acyclic graph dag structure. Let T and S be two templates such that T extends S. Then T is called a sub template of S and is denoted as T

A sub template can redefine the type of a port . Let a template T extend another template S and let Ti and To be the types of an input port and an output port of T respectively. Also let Si and So be the types of the corresponding input port and the output port in S respectively i.e. the port names are the same in both templates . Then for the override to be safe Ti

In the present environment template constructors are used for supporting implicit invocation and multicasting as discussed below in a section entitled Implicit Invocation and Multitasking. A signature of a constructor consists of the number of parameters and the type of each parameter. Constructors do not have a return type. A template can inherit a constructor declaration from its ancestor template. The inherited constructor in a template T gets the same name as T. Let a template T extend another template S and Ct and Cs be constructors declared in the two templates respectively. Ct and Cs are said to be equivalent if and only if they have the same number of parameters and the type of each parameter is also the same. Also Ct is said to override Cs. The name of a constructor does not affect the equivalence relation.

A component is a unit of computation. A component definition consists of two portions an external portion and an internal portion. The external portion consists of a set of input ports output ports and constructors. A component may implement a template structure in which case it should implement all the input ports and constructors defined in the template. A port constructor in a component can override a port constructor declared in a template and the overriding rule is exactly the same as for the template override defined above. There is no inheritance relation among components . Each input port in a component should be attached using the attach command to some concrete class with in the component . This class should implement the type of the input port . The attached class acts as a proxy to the information arriving at that input port . An input port can be attached to more than one class. In this case when information arrives at the input port the information is forwarded to all the attached classes in a similar manner to multicasting.

In the programming environment of the present invention new instances of a component are created using the new command. For example the statement MyComponent myComp new MyComponent creates an instance of the component by invoking the constructor MyComponent . The keyword This is used as the reference to the current component instance. As used herein the term one component interacts with another component generally means component instances. In other words a component instance must first be created before methods at the output port can be connected and invoked. But sometimes we need the ability to invoke certain operations even prior to creating component instances such as the ability to initialize a component . A component can have a special initialization function init that that can be directly called by the client component without instantiating a component instance. An init function can take a set of typed parameters and can return a typed value.

Members in a component may be declared as static in which case the members are common to all instances of a component . The method main is a special static method that only a virtual machine VM or a runtime system can use as an entry point to the application. Each component instance may have its own instance fields. A component can define private interfaces that the classes within the component can implement. A class may implement only interfaces that are defined at the input port or the interfaces that are private to the component . Private interfaces are useful when components perform complicated tasks within it.

Classes and methods in a component implement the logic of the component . One can create instances of a class using the new operator. We use the keyword this as the reference to the current class instance. Classes in a component can have only instance members and static declarations are not allowed within a class definition. Members of a class can be declared as private. A private member is visible only within the class. Once again there are no public and protected modifiers in a class.

Classes can use component fields and methods to pass information between classes. The class hierarchy forms a tree like structure in a similar manner to single implementation inheritance. The present invention does not allow extension of a class beyond the component boundary. A class or a method in a class can also be declared abstract. An abstract method in a class is implemented by an heir class of the abstract class. An input port cannot be attached to an abstract class since one cannot create instances of abstract classes and ports connect component instances .

It is noted that while this is used to reference the current class instance This is used for component instances.

The type system of the present invention consists of primitive types interface types component types template types class types and group types. Currently only port types are restricted to be of interface types. Other entities like component fields class fields method parameters return values and variables can be of any type.

Integration is a process by which multiple components are made to cooperate. The term integration is often variably referred to as composition plumbing interaction or communication. An integration can be either loosely coupled where components have little knowledge about the existence of other components or tightly coupled where a component knows of the existence of other components that the component is interacting with. Loose coupling helps to reduce the impact on the system when components are added removed or changed. Also loose coupling allows much better reuse of components. On the other hand tight coupling helps in improving the overall performance of the system. The present invention supports both loose coupling and tightly coupling of components.

A component that wants to interact with another component should first create an instance of that component . Consider the component ClientC discussed in the illustrative example above. In the main program we first created an instance of the BooleanComp component and then we connected the output port of an instance of the ClientC component to the input port of the BooleanComp component . In this case the client is aware of the existence of the BooleanComp component. The connect statement establishes an explicit connection between the two components. When we invoke CC.xout.not the client component ClientC knows the component with which it is interacting. Notice that ClientC is still not aware of which implementation within BooleanComp will satisfy the call request.

According to another feature of the invention an output port of one component can be connected to an input port of another component only if they have compatible types. Let CC.xout be an output port of a component CC and BC.xin be the input port of another component BC. For the statement connect CC.xout to BC.xin to be safe the interface type S of BC.xin must be a subtype of the interface type T of CC.xout. This is because any operation that the component CC requests via its xout port should be supported by the component BC at its xin port . An output port of a component can be connected to an input port of more than one component . This multiple simultaneous connection can be used to implement multicasting and design patterns like the Observer pattern as discussed in the following section.

Ideally one component should not be aware of the identity of other components in a software system. The interaction between components should be completely decoupled. Decoupling component interactions significantly improves maintainability adaptability and reusability of components. The interaction between decoupled components is referred to as implicit invocation. Observer pattern event driven mechanism selective broadcasting publish subscribe model and multicasting are some of the designs that support some form of implicit invocation.

Implicit invocation is a software architecture style that allows software components to announce interesting events which in turn cause the actual invocation to happen on all those components that have registered interests in the events. In implicit invocation an event announcer is decoupled from the event recipients. Usually a central mechanism manages the dependencies between the announcer and the recipients. Possible applications of implicit invocation include real time data distribution such as weather report stock reports and sports score report file distributions for software updates and email groups.

For example an Observer pattern implements a way to capture one to many dependencies between objects so that when one object changes state all its dependent objects are notified and updated automatically. An Observer pattern consists of two kinds of players 1 the subject that publishes the change and 2 a set of observers that wants to observe the change. Assume that you subscribe to a stock tip mailing group and within this group certain members i.e. the observers are interested only in certain kind of stock sectors. A stock tip publisher publishes stock tips on different sectors to the group. The system will selectively send only those stock tips to the sectors that the members selected. To implement the Observer pattern a group is initially created using the group construct. A group consists of a set of templates and these templates act as filters to messages sent to the group. A group acts as a mediator between the publisher and the subscribers. The interface hierarchy for stock tips is defined as follows 

In the above template hierarchy FinStockT and TechStockT are sub templates of StockT. The constructors FinStockT and TechStockT both override the constructor StockT for reasons described above in the sub section entitled Templates. 

Groups are needed for achieving multicasting e.g. where a message can be posted for a group and the message is automatically distributed to each member of the group . Components can register to a group to receive messages that are posted to the group. Templates in the group act as filters to messages sent to the group.

Stock components are then implemented using the templates defined above. These components act as observers for the stock tips.

To receive information from the group StockGroup the recipients should first register with the group in the following exemplary manner that uses a property file written in XML format 

The constructor declarations FinStockT and StockT are equivalent and the component FinStockC implements one constructor FinStockC that is a representative for both the template constructors similarly for the tech stock constructors .

The group StockGroup consists of three templates. These templates act as filters when messages are posted to StockGroup. Notice that both the observer components FinStockC and TechStockC are registered with the group StockGroup.

The statement connect SP.finout to FT.sin connects the component instance of StackPublisher to component instances pointed to FT which here is the component FinStockC.

The two method invocations SC.finout.generalTip Market is good and SC.finout.finTip Buy once again invoke only methods defined in the FinStockC component.

It is noted that a single call statement such as SC.finout.finTip Buy may invoke methods in more than one component. It is further noted that the subject component is not even aware of the observer components that participate. Typically in object oriented implementations of the Observer pattern the subject gets a handle to instances of the observer this is because the observer has to first register with the subject that it is interested in the finTip event .

Generic types allow one to define a general type that can be instantiated to more a specific type. Generic types are useful to define collection components. Generic components consist of a port whose type is a generic type. Genericity is based on F bounded parametric genericity. A generic stack component is constructed as follows. First StackInterface is defined as follows 

The above client code creates one instance of StackComponent and connects the two output ports of ClientComponent to the same input port of StackComponent. It is noted that the actual type of the port is passed only when the two components are connected together.

In the world of component based software a set of components interact with each other in a container. The container essentially provides services such as security transaction coordination and life cycle management. A client that wants to access the services of a component has to go through the container. The present invention can model a container as a component except that some of the ports are typed using contracts. The following example illustrates higher order component programming 

It may be useful to export a component instance method rather than a class instance method . As previously indicated however one of the features of the present invention is that clients can only communicate with a component by means of its input output ports. One possible solution is to encapsulate a component instance method in a class and then provide an interface that hooks up a class that implements the interface to an input port. Another solution is to use delegates to type ports. Delegates are like function pointers except that it is secure type safe and encapsulated. A delegate is a type which can be attached to a concrete method just as an interface is a type that can be attached to a concrete class . In other words a delegate is a type for defining a method signature so that delegate instances can hold and invoke a method that matches its signature. The following example illustrates the use of delegates 

The data storage device includes operating system program code such as an exemplary Linux Unix or Windows operating system. The data storage device also includes the software component programming language incorporating features of the present invention that may be used to generate application code . The communications port optionally connects the software component programming system to a network environment not shown .

It is to be understood that the embodiments and variations shown and described herein are merely illustrative of the principles of this invention and that various modifications may be implemented by those skilled in the art without departing from the scope and spirit of the invention.

