---

title: Transparent high availability for stateful services
abstract: One embodiment of the present invention provides a system. The system includes a high availability module and a data transformation module. During operation, the high availability module identifies a modified object belonging to an application in a second system. A modification to the modified object is associated with a transaction identifier. The high availability module also identifies a local object corresponding to the modified object associated with a standby application corresponding to the application in the second system. The data transformation module automatically transforms the value of the modified object to a value assignable to the local object, including pointer conversion to point to equivalent object of the second system. The high availability module updates the current value of the local object with the transformed value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342348&OS=09342348&RS=09342348
owner: BROCADE COMMUNICATIONS SYSTEMS, INC.
number: 09342348
owner_city: San Jose
owner_country: US
publication_date: 20130122
---
This application claims the benefit of U.S. Provisional Application No. 61 589 780 titled Transparent High Availability for Stateful Services by inventor Girish Kumar Goyal filed 23 Jan. 2012 the disclosure of which is incorporated by reference herein.

The present disclosure relates to service availability. More specifically the present disclosure relates to a method and system for transparently providing high availability to services.

High availability enables a system to provide continuous services with minimum or no disruption in a failure scenario. However supporting high availability in an existing or new system can be complex error prone and costly. Consequently deployment of critical high availability features to systems often face delays and causes unwanted disruption to services. Technology vendors usually provide fault resilient services using an active standby model. In this model all services also referred to as applications run in an active system and all services requiring high availability can be referred to as fault resilient services or applications replicate and synchronize their critical states in a standby system. The active or standby system can be a physical or virtual device. If the active system suffers a hardware or software failure the replicated fault resilient services in the standby system take over and resume the operations without disruption.

Fault resilient applications running on an active system usually use the synchronization infrastructure provided in an operating system OS to replicate state changes to the corresponding standby system. However in this approach a respective application is responsible for managing and synchronizing the application states. These states are known only to the application and the application is required to serialize and de serialize the states. The application is also responsible for sending the states via the operating system synchronization services to the standby system.

Different applications running on a system can have states which have interdependencies. For example some operations can cause state updates for a plurality of applications. The operating system synchronization service usually does not provide any coordinated state synchronization across these multiple related applications. A respective fault resilient application synchronizes its states with the standby system independent of any other application in the system. As a result an application needs to explicitly inform other related applications regarding the state updates.

While high availability brings many desirable features to applications some issues remain unsolved in providing transparency and coordination to the high availability synchronization process.

One embodiment of the present invention provides a system. The system includes a high availability module and a data transformation module. During operation the high availability module identifies a modified object belonging to an application in a second system. A modification to the modified object is associated with a transaction identifier. The high availability module also identifies a local object corresponding to the modified object associated with a standby application corresponding to the application in the second system. The data transformation module transforms the value of the modified object to a value assignable to the local object. The high availability module updates the current value of the local object with the transformed value.

In a variation on this embodiment the local object and the modified object have the same identifier. This identifier is unique in the standby application and the application in the second system.

In a variation on this embodiment the high availability module identifies a plurality of modified objects associated with the transaction identifier and determines whether updates to the plurality of modified objects have been completed. If completed the high availability module commits the update of the local object.

In a further variation the high availability module stores an intent associated with the transaction identifier. The intent specifies the modifications to the modified object. The high availability module discards the intent in response to committing the update and provide the intent to the standby application in response to detecting a failure to the second system before committing the update thereby allowing the standby application to re execute the modification to the object

In a variation on this embodiment the system also includes a kernel interface module which determines whether a memory page containing one or more objects associated with an application has been modified.

In a variation on this embodiment while identifying the modified object the high availability module receives a modified memory page associated with the application in the second system and identifies a modified object from the modified memory page. This modified object includes a value different from a previously stored value of the modified object.

In a variation on this embodiment the high availability module receives a registration request for one or more of an application an object associated with the application and an object group. This object group comprises of one or more objects associated with the application. The high availability module then tracks memory activity of the system based on the registration request.

In a variation on this embodiment the modified object represents dynamically allocated memory in the second system. The high availability module then determines an amount of the dynamically allocated memory in the second system determines a data layout of the modified object and dynamically allocates memory to the standby application based on the amount of the dynamically allocated memory and the data layout.

In a variation on this embodiment the data transformation module transforms a value of an unmodified opaque object to a value assignable to a local object associated with a standby application. This opaque object is incompletely defined. The high availability module also deposits the transformed value into the local object.

One embodiment of the present invention provides a system. The system includes a high availability module and a coordinated transaction manager module. During operation the high availability module stores a plurality of updates identified by a transaction identifier. These updates are associated with a plurality of related applications in a second system. The coordinated transaction manager module assigns the transaction identifier to the updates and maintains a dependency map representing dependency of the plurality of applications on updates identified by a second transaction identifier. The high availability module commits the updates in response to the dependency map indicating no further dependency.

In a variation on this embodiment the high availability module discards the updates in response to detecting a failure to the second system before committing the updates.

In a variation on this embodiment the high availability module receives a request for committing the updates identified by the transaction identifier from one of the plurality of the applications.

In a variation on this embodiment the high availability module maintains a counter value indicating the number of the plurality of applications associated with the identifier and commits the updates when the counter value indicates all of the plurality of applications has completed updates.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the claims.

In embodiments of the present invention the problem of providing high availability to applications running on a system is solved by incorporating an infrastructure to the system which provides transparency and coordination to high availability. An active system can provide high availability by having at least one additional system as a standby. The active or the standby system can be any physical or virtual device. A respective application requiring high availability can be referred to as a fault resilient application running in the active system replicates its critical state on the standby system. An application state includes any data in memory allocated statically at compile time or dynamically at run time along with the layout of that data. This data layout can correspond to a predefined or application specific data structure. If the active system becomes unavailable e.g. suffers a hardware or software failure the standby system performs a failover by resuming the operations of the active system without disruption.

However a respective fault resilient application in the active system is usually responsible for managing and synchronizing the states requiring high availability can be referred to as fault resilient states with the corresponding application in the standby system. As a result the application requires separate serialization i.e. the process of converting a state into a format that can be reconstructed in the same or another system and de serialization codes for synchronizing all fault resilient states and subsequent incremental changes. If the fault resilient states for the application changes both codes have to be updated. An example of such change can include addition or deletion of new fields to or from a data structure. Moreover the application is required to validate serialization and de serialization of a respective required field. The system discovers any field missed by the application only after an unsuccessful failover attempt.

Furthermore if a particular operation in the active system causes state updates for a plurality of applications these affected applications become related to each other and need to ensure consistency for each other. Under such a scenario the state updates in the standby system remain inconsistent until the standby system receives all related state updates. If the active system fails before sending all related updates the standby system can have inconsistent data. During the failover process the related applications in the standby system need to communicate among each other to ensure a respective related application has consistent data. As a result the applications become more complex and the failover duration is increased.

To solve this problem in embodiments of the present invention both active and standby systems are equipped with a transparent high availability THA infrastructure which automates synchronization for fault resilient applications. The infrastructure facilitates automatic transformation of states and provides incremental state updates by automatically detecting state changes. The infrastructure also supports coordinated state synchronization for multiple applications. The infrastructure thus reduces substantial development and testing time of the applications and ensures predictability and reliability in a failover scenario.

During operation a respective fault resilient application registers its fault resilient states with the infrastructure. The infrastructure creates corresponding metadata for data transformation e.g. from one software version to another and automatically detects any change to the states. The infrastructure ensures that the standby system commits state updates i.e. makes the updates permanent only when all associated updates are received. As a result the state updates remain transparent and robust without any inconsistency in state updates. Furthermore the infrastructure allows coordinated synchronization among a plurality of applications with state dependency ensuring the committed states in the standby system are always consistent. Such coordinated synchronization thus avoids state reconciliation i.e. comparing committed state with other applications to ensure state consistency in a failover scenario. In some embodiments the infrastructure stores the logs of uncommitted state updates for a respective fault resilient application and allows reconciliation for the application after a failover using the logs.

Although the present disclosure is presented using examples based on the active standby high availability model embodiments of the present invention are not limited only to the active standby model. Embodiments of the present invention are relevant to any mechanism which requires synchronization among multiple systems. The active standby model can be based on any number of active or standby systems providing high availability to each other. In this disclosure the terms active system and standby system are used in a generic sense and can refer to any software system virtual device or physical device. Examples of a physical device include and but are not limited to a computing device a network switch and a portable electronic device.

The term frame refers to a group of bits that can be transported together across a network. Frame should not be interpreted as limiting embodiments of the present invention to layer 2 networks. Frame can be replaced by other terminologies referring to a group of bits such as packet cell or datagram. 

The term switch is used in a generic sense and can refer to any standalone or fabric switch operating in any network layer. Switch should not be interpreted as limiting embodiments of the present invention to layer 2 networks. Any physical or virtual device that can forward traffic in a network can be referred to as a switch. Examples of a switch include but are not limited to a layer 2 switch a layer 3 router a Transparent Interconnection of Lots of Links TRILL routing bridge RBridge or a virtual machine with frame forwarding capability.

The term synchronization is used in a generic sense and can refer to any process which shares or replicates information among systems. Examples of such process include but are not limited to memory sharing data bus sharing message passing and data frame exchanges. The term update is used also in a generic sense and can refer to any process which changes information in a system.

The term application is used in a generic sense and can refer to any software or hardware entity which executes instructions to perform certain operations. An application can reside in a system and provide specific services. In this disclosure the terms application and service are used interchangeably. An application can have one or more states. The term state can represent the current operation and memory condition of the corresponding application. Examples of a state include but are not limited to one or more global local static or dynamic variable or pointer values memory allocation and function call stack. A state can be represented by one or more objects. An object can represent a contiguous chunk of memory containing application state which needs to be synchronized. In this disclosure the terms state and object are used interchangeably.

Without transparent high availability infrastructure and applications and in virtual machine are responsible for synchronizing states with corresponding applications in virtual machine . These states include any data in memory allocated statically at compile time or dynamically at run time along with the layout of that data. Applications and individually maintain the code for synchronization. If application or misses any data associated with the fault resilient states virtual machine discovers the missing data only after an unsuccessful failover attempt. Such data can be represented by one or more objects. An object represents a contiguous segment of memory containing data associated with application states. Furthermore if an operation in virtual machine causes state updates for both applications and corresponding state updates in virtual machine remain inconsistent until both applications and individually synchronize their respective updated states. If virtual machine fails after only one of applications and has synchronized the updates virtual machine can have inconsistent data.

Transparent high availability infrastructure and solve these problems by providing transparency and coordination to the synchronization process of applications and . During operation applications and in virtual machine register their fault resilient states i.e. the objects representing the states with infrastructure . The burden of serialization and de serialization shifts from applications and to infrastructures and . If a fault resilient state changes in application application simply asks infrastructure to synchronize changed state with the standby instance in virtual machine . Infrastructure in turn shares the updated information with infrastructure .

During the registration process applications and provide infrastructure with metadata such as size length location and data layout associated with the objects. When virtual machine becomes operational infrastructure sends the metadata to infrastructure . Infrastructure identifies the fault resilient states in the local version of applications and based on the metadata. In some embodiments the software version of one of or both applications and in virtual machine can be different from the corresponding applications in virtual machine . Infrastructure then creates transformation map for the objects based on the corresponding metadata of the software version in virtual machine and the software version in virtual machine . For example an object of application can be a 16 bit integer in virtual machine while a 32 bit integer in virtual machine . Infrastructure creates a map to transparently transform the 16 bit integer to a 32 bit integer.

When application instructs infrastructure to synchronize infrastructure determines which registered objects have changed serializes the changed objects and sends the serialized objects to infrastructure . Infrastructure then de serializes the objects and updates the corresponding local objects based on the transformation map. For any subsequent synchronization instruction from application infrastructure transparently detects the updates in the objects of application and sends the memory pages comprising the objects to infrastructure . Infrastructure commits the changes only when all modified objects associated with the synchronization instruction are received thereby ensuring data consistency. As a result the synchronization process between infrastructures and remains robust without any inconsistent data.

Furthermore infrastructures and allow coordinated synchronization among applications and . If an operation in virtual machine causes state updates for applications and infrastructure allocates a global identifier to the update and keeps track of the update for applications and using the identifier. Only when the update is completed by both applications and infrastructure commits the updates. In some embodiments before committing the infrastructure also ensures that no other updates are ongoing for applications and . In this way infrastructures and provide consistency to the committed states in virtual machine . In some embodiments infrastructure sends the updates to infrastructure as soon as the operation is done in a respective application. However infrastructure simply logs the received updates in local memory without committing the updates. When all updates are completed infrastructure instructs infrastructure to commit the state of applications and atomically on the standby instance in virtual machine . If a failover happens during the coordinated synchronization process infrastructure discards any uncommitted state updates thereby ensuring that either all or none of the state updates are applied and a respective application state is always consistent. Applications and can optionally associate an intent with a specific update such that if the corresponding update is discarded the application can retrieve the associated intent and re execute the operations after the failover.

Note that virtual machines and can communicate with each other via a shared memory. In some embodiments hypervisor manages the shared memory. Virtual machines and have shared access to a portion of the memory. Virtual machine keeps the committed states in the shared memory. If virtual machine fails the shared memory is still preserved and virtual machine assumes control of the shared memory. Infrastructure can log the uncommitted updates in the shared memory. If the failure occurs during the synchronization process infrastructure can reconcile the logged updates.

In some embodiments an active or a standby system can be a physical device. illustrates exemplary systems providing high availability between multiple devices in accordance with an embodiment of the present invention. In the example in transparent high availability infrastructure operates in active device and transparent high availability infrastructure operates in standby device . Devices and are coupled to each other via a network switch and communicate with each other via their respective network interfaces. One of or both infrastructures and can run in a virtual device running on a physical device. For example infrastructure can run on an operating system i.e. a kernel directly operating device while infrastructure can run on an operating system operating a virtual machine running on device . Infrastructures and operate the same way as infrastructures and do respectively as described in conjunction with .

In some embodiments an active or a standby system can be a network switch. illustrates exemplary systems providing high availability between multiple switches in accordance with an embodiment of the present invention. Transparent high availability infrastructure operates in active network switch and transparent high availability infrastructure operates in standby network switch . Switches and are coupled to each other via a network and communicate with each other via their respective network interfaces. Switches and can be coupled to each other via one or more links in network . One of or both switches and can be a layer 2 switch a layer 3 router a TRILL RBridge a virtual switch or any other networking device. In this example infrastructures sends data e.g. objects to infrastructures using data frames. One of or both infrastructures and can run in a virtual device running in a physical device. For example switch can be a physical switch while switch can be a virtual switch running on a physical device. Infrastructures and operate the same way as infrastructures and do respectively as described in conjunction with .

In some embodiments a transparent high availability infrastructure operates in conjunction with the synchronization service provided by an operating system. Hence the architecture of the infrastructure relies on the libraries provided by the operating system. illustrates an exemplary architecture of a transparent high availability infrastructure in accordance with an embodiment of the present invention. This example illustrates the architecture of transparent high availability infrastructure or infrastructure in . Infrastructure includes transparent high availability libraries and which facilitates high availability to fault resilient states. Libraries and provide a new application programming interface API to applications and respectively. Applications and use the API to register and synchronize their corresponding fault resilient states.

In some embodiments libraries and operate based on the operating system synchronization service SS libraries and respectively and use the corresponding synchronization service API to send and receive updates. Applications and can also use application libraries and respectively to access libraries and respectively. Because application is not fault resilient application may not be associated with a transparent high availability library. Applications can use application library to access the standard features of API via synchronization service library .

Libraries and rely on coordinated transaction manager CTM kernel module for coordinating state synchronization among a group of related application. Kernel module is responsible for managing global identifiers for coordinated synchronization. Kernel module also creates and maintains dependency map to support coordinated state update among a plurality of related applications. Infrastructure uses this dependency map to ensure that all state updates of the related applications are completed before committing the updates thereby avoiding reconciliation after failover. Kernel provides an API to libraries and for automatically detecting changes to the fault resilient states associated with applications and . In this way libraries and transparently detect the state changes without requiring applications and to track the changes.

A fault resilient state of an application can be represented by one or more objects. An object represents a contiguous segment of memory containing application state which needs to be synchronized. The object can include a single or a group of compile time static or global variables or dynamically allocated memory. In some embodiments a respective object is identified by a unique name. To establish a correlation between an object in the active system and the corresponding object in the standby system the name should be the same for both the objects. A plurality of objects can be grouped together to facilitate a subset of the state to be synchronized at group level. In some embodiments an object can belong to only one object group. The infrastructure allows the application to independently synchronize a respective object or an object group.

To avoid memory modifications to the same page from both fault resilient and non fault resilient applications and efficiently manage memory usage the infrastructure maintains a memory pool for dynamic memory allocation. When an application requires dynamic memory for a dynamic object the application requests the transparent high availability infrastructure the required quantity of memory along with an optional prefix to be used to identify the allocated memory. The infrastructure provides the dynamic memory to the application from the memory pool. The infrastructure also assigns an implicit name which uniquely identifies the dynamic object in the active system and provides the name and layout of the object to the corresponding standby system. The infrastructure in the standby system automatically creates the corresponding dynamic object when the corresponding application state is synchronized.

The infrastructure supports primitive data types. Examples of such data type can include but are not limited to integer floating point character and pointer. Furthermore the infrastructure allows the application to construct data structures using these primitive data types. The application can use these data structures for constructing more complex data structures. During operation the application registers a respective data structure which comprises of one or more primitive or constructed data structures with the infrastructure. The application provides the name offset type and size of a respective field in the data structure to the infrastructure for registering the data structure. In some embodiments the application can specify only those fields which need to be replicated as part of the registration process. After the registration an application can register and or create objects of the registered data structure.

In the example in application registers itself and its fault resilient states with infrastructure . Infrastructure in turn starts tracking the registered states in memory. During the initialization process infrastructure shares metadata for objects representing the states with infrastructure . presents a flowchart illustrating the registration process of a transparent high availability infrastructure in accordance with an embodiment of the present invention. The infrastructure first receives registration from fault resilient applications operation and registers the applications with the infrastructure operation .

The infrastructure receives state registrations from the applications operation and registers the corresponding states with the infrastructure operation . The state registration includes metadata associated with the objects representing the states. The metadata can include a unique name local memory address length of a respective object and a data layout for the object. Data layout is specified by associating a predefined or application specific data structures with the object.

If the state synchronization has been initiated the infrastructure detects any state changes e.g. new deleted states operation and sends the new deleted states e.g. the associated metadata to the infrastructure in the standby system operation . These states can be represented by one or more objects. After sending the states the infrastructure sends any modified data associated with the objects operation and associated commit notification operation to the infrastructure in the standby system. The infrastructure sends the commit notification after sending all modified data to the infrastructure in the standby system. After sending the commit notification the infrastructure continues to process incoming requests operation .

The infrastructure checks whether the received data has been modified based on the comparison operation . If so the infrastructure stores the received data and the transaction identifier in the active snapshot operation . If the received data has not been modified operation or upon receiving all modifications that requires an atomic update the infrastructure receives a commit notification from the active system operation and initiates a commit phase operation of the synchronization process. The infrastructure performs a data and pointer conversion based on the data transformation map operation . The conversion process is described in further details in conjunction with . Upon completing the modifications and conversions the infrastructure commits the modified data to the standby instance operation .

During the initialization process a transparent high availability infrastructure builds a map of the memory containing the fault resilient states of the fault resilient applications. In some embodiments the memory map is at a page granularity. Using this memory map the infrastructure automatically detects changes to the applications. illustrates an exemplary transparent synchronization using automatic state change detection in accordance with an embodiment of the present invention. Memory map in active system includes pages and containing the states of an application. In this example page includes objects and page includes objects and and page includes objects and .

During operation the application requests the infrastructure to synchronize the states. The infrastructure passes a list of pages and to the enhanced operating system kernel of the active system and obtains a notification indicating the modified pages and . The notification can be a bitmap corresponding to the list of pages. The infrastructure performs a reverse lookup to identify objects in modified pages and and sends the identified objects to standby system . In some embodiments the infrastructure sends pages and to standby system and the infrastructure in standby system performs the reverse lookup to identify the objects in pages and . The infrastructure in the standby system compares the current data of the identified objects with the corresponding objects in active state snapshot . An active snapshot can also be stored in the active system. Under such a scenario the infrastructure in the active system can perform the comparison. In some embodiments the infrastructure operates without a copy of snapshot wherein the infrastructure considers all objects in a modified page e.g. objects in page as modified objects. In some further embodiments the active system can detect the changes using cache without maintaining a snapshot of the states.

Based on the comparison the infrastructure identifies the modified objects and denoted with dotted lines and updates snapshot with the updated data. If there is no other update associated with the current synchronization the infrastructure commits the updates to the corresponding objects in standby states . In some embodiments the updates are associated with a transaction identifier which is stored with the updates. Note that objects can belong to different object groups or contexts.

In some embodiments a respective application in the active system tracks the changes in its objects. illustrates an exemplary synchronization using automatic state change detection with application tracking in accordance with an embodiment of the present invention. The application which stores its states in pages and can track the changes in the objects in these pages. During operation the application detects changes in objects and and sends only objects and to standby system . In this way the data transfer between systems and can be reduced and no additional data comparison is needed on the standby system.

Synchronization between an active and a standby system can include changes to one or more objects of one or more applications. A transparent high availability infrastructure maintains consistency to the changed objects between the active and standby systems. In some embodiments to ensure consistency the transparent high availability infrastructure performs the synchronization process in two phases update and commit. illustrates an exemplary transparent synchronization using state transformation and commit in accordance with an embodiment of the present invention.

During state update phase the transparent high availability infrastructure in active system automatically detects modified states which includes static objects and and dynamic object as described in conjunction with . A respective update in modified states is associated with a transaction identifier. For example updates to objects and can have two corresponding transaction identifiers. The infrastructure tracks the uncommitted updates with these transaction identifiers. When instructed the infrastructure sends modified states and the associated transaction identifiers to the transparent high availability infrastructure in standby system . The infrastructure in standby system receives modifies states and stores a copy in local memory updated states .

When the infrastructure in standby system commits the changes associated with a transaction identifier the infrastructure ensures all changes associated with the identifier are committed atomically. For example if a modified state updates two objects and the infrastructure ensures both changes are committed to committed states . In this commit phase the infrastructure tracks a respective object and performs necessary data transformation. During this data transformation the infrastructure creates and deletes the local dynamic objects e.g. dynamic object in updated states and later in committed states corresponding to the modified dynamic object in active system . When a dynamic object is deleted the infrastructure reuses the freed memory by allocating the memory to another dynamic object. In some embodiments the infrastructure uses mmap system call which maps files or devices into memory to allocate dynamic memory from a pre assigned memory pool.

In the example in when the application associated with objects registers with the infrastructure the application provides the data layout of object to the infrastructure. The infrastructure in system sends the layout to the infrastructure of system . The infrastructure in system uses the data layout to prepare a data transformation map the object. The transformation map allows the location type and size of a respective field in object to be different in systems and . As a result systems and can run different software versions of the application. This automatic data transformation between the software versions enables transparent state update between two different software versions of the application.

During operation application modifies object and instructs library to synchronize the state of application . Object includes 32 bit floating point and 16 bit integer . Library obtains from enhanced kernel a bitmap indicating the modified pages and sends object data update to infrastructure operation . Upon receiving the data update library uses the object identifier e.g. object name or address to locate the corresponding object associated with corresponding application in standby system .

Library identifies 32 bit floating point and 32 bit integer as the matching fields in object . In some embodiments the matching fields are identified based on identical names. Based on the data layout of object library recognizes that floating point has the same offset and bit size that floating point has in object . Hence library updates the value of floating point with the value of floating point . However library recognizes that integer has a different offset than integer has in object because a 16 bit character resides between floating point and integer in object . Library also recognizes that integer is 32 bits long whereas corresponding integer is 16 bits long. Based on the data layout of object library automatically locate the new offset and bit size of integer and performs necessary conversion e.g. bit stuffing for additional bits to update integer with the value of integer operation .

Because corresponding objects in active and standby systems e.g. objects and can reside on different memory locations respective transparent high availability libraries convert pointer values to point to an equivalent object field in standby system . illustrates an exemplary data update using pointer conversion in accordance with an embodiment of the present invention. During operation application instructs library to synchronize an object which points to integer object . Library sends object data to infrastructure operation . Upon receiving the data library uses the object identifier e.g. object name or address to locate the corresponding integer pointer which points to corresponding integer in standby system and checks whether object has been changed.

Library looks up the active snapshot to find the object corresponding to the pointer value in object which is object and maps it to equivalent object in standby system operation . Library also stores the address of object in integer pointer object operation . In some embodiments library also supports mapping of nested pointers including arrays and nested structures. For example if pointer points to an element in an integer array library first identifies the beginning of the array. Library uses the data layout of the array to locate the corresponding array element pointed by the pointer. Library then applies the same nested traversal on pointer to locate the corresponding location in system . In this way if elements in the array in system are 16 bit integers and the elements in the array in system are 32 bit integers library can still identify the location and size of the array element.

Similarly if object and object are structures with two fields respectively and object points to the second field of object library transforms that pointer value to point to the second field of object . Furthermore library stores the address of the second field of object in object in standby system . As a result any modification indicated by the pointer value of object can readily be transformed to the corresponding modification indicated by the pointer value of object . In some embodiments this automatic data transformation feature allows an application to use just the serialization de serialization aspect of infrastructures and . Application can send an opaque message data from active system to standby system . During operation application can specify the layout of the opaque message data to infrastructure and instruct infrastructure to transform the opaque message data. Consequently upon receiving the message data infrastructure transforms the message data and deposits the transformed data directly in the data buffer of application .

In some embodiments the infrastructure can also preserve the intents associated with the uncommitted updates operation . An intent is an abstract representation of an operation to be performed by an application in the active system. The application performing the operation can register its intents which can be of an opaque data type with a transaction. An active system sends these intents to the standby system immediately. The standby system preserves these intents for the uncommitted transactions. Once committed the standby system discards these intents. If the intents associated with uncommitted transactions are preserved the application can retrieve the intents after the failover and re execute the operations specified by the intent. After preserving the intents the infrastructure notifies the applications in the standby system operation and starts operating as the active system operation .

Coordinated synchronization across multiple related applications avoids state reconciliation. illustrates an exemplary coordinated synchronization in accordance with an embodiment of the present invention. During operation application can be referred to as the initiating application initiates the coordinated synchronization for related applications and . Application obtains a unique transaction identifier for the coordinated synchronization and informs applications and about identifier . In some embodiments application constructs a message which can be a multicast message to inform applications and about identifier . Applications and update their respective state using the same transaction identifier without committing. In some embodiments coordinated transaction manager kernel module e.g. module in is responsible for managing transaction identifier and tracking of the transaction dependencies.

In some embodiments the developers of applications and predefine their execution sequence. When a respective application has completed the update one of the applications notifies can be referred to as the notifying application the transparent high availability infrastructure to commit all changes associated with transaction identifier . In some embodiments initiating application can be the notifying application. Upon finishing the respective updates applications and notify application . Application then notifies the infrastructure to commit all changes associated with transaction identifier . Alternatively the last application in the execution order application instructs the infrastructure to commit.

In some embodiments the infrastructure of the standby system maintains a counter value indicating the number of related applications associated with an identifier. For example for identifier the number of applications is 3. During operation when application completes the update application notifies the infrastructure. The infrastructure in turn decrements the counter value to 2. Similarly upon completion applications and notify the infrastructure which in turn decrements the value of the counter for a respective application. When the value reaches zero the infrastructure considers the updates associated with identifier to be ready to commit. In some further embodiments application notifies the infrastructure about applications and as the participant in the coordinated synchronization associated with identifier . Applications and independently commit their respective updates. Once the infrastructure detects that all participants have committed the updates the infrastructure commits all updates.

When the infrastructure in a standby system receives state update requests from applications and the transparent high availability library of the infrastructure notifies the corresponding kernel module about the request and queues the requests in memory. The kernel module tracks the state updates based on transaction identifier as uncommitted transactions. The kernel module maintains a queue of uncommitted updates for applications and and builds a corresponding dependency map for applications and . When application or requests the library to commit the updates the library consults the dependency map to determine whether the updates can be committed. When the dependency map indicates no further dependency the library notifies corresponding applications to commit the queued states.

In the example in application initiates the coordinated synchronization for related applications and using transaction identifier . Similarly application initiates the coordinated synchronization for related applications and using transaction identifier . Because state updates are committed in temporal order when a second update depends on a first update the second update is committed only when the first update is committed. The kernel module enforces the dependency among updates executing in different order in different applications. For example at time the kernel module determines that updates associated with identifier are completed by all related applications. The kernel module then notifies applications and to commit the updates.

On the other hand application or requests the library to commit updates associated with identifier at time . However applications and perform updates associated with both identifiers and and updates associated with identifier have not been completed at time . As a result the library does not commit the updates associated with identifier at time . Only when application or requests the library to commit updates associated with identifier at time the kernel module notifies applications and to commit updates associated with both identifiers and .

Suppose that the active system fails at time . By time the updates associated with identifier have been committed. However because of the dependency the updates associated with identifiers and have not been committed. As a result the infrastructure of the standby system discards the updates associated with identifiers and . In some embodiments an application can register its intents using identifiers and . During the failover process if a respective transaction is not committed in the standby system the application retrieves the intents associated with identifiers and and re executes the operations specified by the intents.

If the infrastructure has received a commit request associated with the identifier the infrastructure checks dependency associated with the identifier from coordinated transaction manager kernel module operation . In some embodiments the infrastructure uses a dependency map to check the dependency. The infrastructure determines whether the updates associated with the identifier are committable operation . In the example in the infrastructure determines that the updates associated with identifier are not committable at time . If the updates are not committable the infrastructure continues to check for dependency operation . Otherwise if the updates are committable the infrastructure commits the updates associated with the identifier operation . In some embodiments the infrastructure notifies the applications to commit the updates.

During operation an application in system registers its fault resilient states with high availability module . High availability module obtains a modified memory page from a second system associated with a fault resilient application. High availability module identifies the objects in the received modified page and identifies a modified object. High availability module then identifies an object in memory which has the same name as the modified object and is associated with a standby application in system corresponding to the fault resilient application.

Transformation module transforms the value of the modified object to a value assignable to the local object as described in conjunction with . After the data transformation high availability module updates the current value of the local object with the transformed value. If high availability module receives updates for multiple objects associated with a transaction identifier high availability module commits the updates only after receiving and determining all changes associated with the transaction identifier. High availability module also allocates dynamic memory a from a memory pool residing in memory and available to high availability module .

In some embodiments high availability module stores a plurality of updates identified by a transaction identifier in memory . Coordinated transaction manager module assigns the transaction identifier to the updates and maintains a dependency map for the plurality of applications causing the updates. High availability module commits the updates upon receiving a commit request and when the dependency map indicates that the applications have no further dependency. In some embodiments coordinated transaction manager module can maintain the dependency using a counter value. If high availability module detects a failure to the second system before committing the updates high availability module discards the updates.

Note that the above mentioned modules can be implemented in hardware as well as in software. In one embodiment these modules can be embodied in computer executable instructions stored in a memory which is coupled to one or more processors in system . When executed these instructions cause the processor s to perform the aforementioned functions.

In summary embodiments of the present invention provide a system and a method for transparently providing high availability. In one embodiment the system includes a high availability module and a data transformation module. During operation the high availability module identifies a modified object belonging to an application in a second system. A modification to the modified object is associated with a transaction identifier. The high availability module also identifies a local object corresponding to the modified object associated with a standby application corresponding to the application in the second system. The data transformation module transforms the value of the modified object to a value assignable to the local object. The high availability module updates the current value of the local object with the transformed value.

The methods and processes described herein can be embodied as code and or data which can be stored in a computer readable non transitory storage medium. When a computer system reads and executes the code and or data stored on the computer readable non transitory storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the medium.

The methods and processes described herein can be executed by and or included in hardware modules or apparatus. These modules or apparatus may include but are not limited to an application specific integrated circuit ASIC chip a field programmable gate array FPGA a dedicated or shared processor that executes a particular software module or a piece of code at a particular time and or other programmable logic devices now known or later developed. When the hardware modules or apparatus are activated they perform the methods and processes included within them.

The foregoing descriptions of embodiments of the present invention have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit this disclosure. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. The scope of the present invention is defined by the appended claims.

