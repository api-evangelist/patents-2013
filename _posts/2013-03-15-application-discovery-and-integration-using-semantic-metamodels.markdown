---

title: Application discovery and integration using semantic metamodels
abstract: A metamodel selector may determine a semantic metamodel for at least two software applications, the semantic metamodel including a description of semantics, processes, and data that are applicable to the at least two software applications. A metadata manager may determine application metadata describing an application of the at least two applications. A transformation engine may transform the application metadata into an application-specific metamodel instance of the semantic metamodel, and an integration engine may integrate the at least two software applications, based on the application-specific metamodel instance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09400647&OS=09400647&RS=09400647
owner: SAP SE
number: 09400647
owner_city: Walldorf
owner_country: DE
publication_date: 20130315
---
Software applications such as business applications are often composed of multiple applications and related services all working together. In some situations application users may adopt a standard set of such applications and related services from a single supplier in an attempt to ensure that the various components will work well together. However in many scenarios the best solutions to meet specific user needs are often made up of heterogeneous technologies in a hybrid landscape combining best in class applications. Moreover even in cases in which all components are obtained from a single supplier there is no guarantee that the components will fit perfectly together. Consequently integration of multiple software applications is often required and typically represents a time consuming manually intensive error prone expensive and generally inefficient process for obtaining the desired result.

According to one general aspect a system may include recorded on a non transitory computer readable storage medium and executable by at least one processor. The system may include a metamodel selector configured to cause the at least one processor to determine a semantic metamodel for at least two software applications the semantic metamodel including a description of semantics processes and data that are applicable to the at least two software applications. The system may include a metadata manager configured to cause the at least one processor to determine application metadata describing an application of the at least two applications. The system may include a transformation engine configured to cause the at least one processor to transform the application metadata into an application specific metamodel instance of the semantic metamodel. The system may include an integration engine configured to cause the at least one processor to integrate the at least two software applications based on the application specific metamodel instance.

According to another general aspect a computer implemented method for causing at least one processor to execute instructions recorded on a computer readable storage medium may include determining a semantic metamodel for at least two software applications the semantic metamodel including a description of semantics processes and data that are applicable to the at least two software applications. The method may include determining application metadata describing an application of the at least two applications transforming the application metadata into an application specific metamodel instance of the semantic metamodel and integrating the at least two software applications based on the application specific metamodel instance.

A computer program product may be tangibly embodied on a non transitory computer readable medium and may comprise instructions that when executed are configured to cause at least one processor to determine a semantic metamodel for at least two software applications the semantic metamodel including a description of semantics processes and data that are applicable to the at least two software applications. The instructions when executed may be further configured to determine application metadata describing an application of the at least two applications transform the application metadata into an application specific metamodel instance of the semantic metamodel and integrate the at least two software applications based on the application specific metamodel instance.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features will be apparent from the description and drawings and from the claims.

Thus in the system one or more of the semantic metamodels provide the application with an ability to describe itself in a generic common high level language where the resulting description is represented in as the application specific metamodel instance . In other words rather than focusing on specific details of an individual integration between two specified applications and explicitly mapping semantics and data from one such application to the other the semantic metamodel enables the application to generate its self describing application specific metamodel instance independently of any specific integration with any other software application. For example as described in more detail below it may occur that the application may not even exist at a time that the application specific metamodel instance is created.

Nonetheless once the application is created discovered or otherwise identified or determined for integration with the application the semantic metamodels i.e. an appropriate semantic metamodel selected therefrom as described below provide for a generic high level language for describing systems data structures and functionalities of each of the applications without affecting the underlying actual low level implementations of these things in each application which may themselves therefore continue to function in system specific e.g. proprietary ways.

In the example of the application and the application should be understood to conceptually represent virtually any software application. As such either or both of the applications should be understood to execute e.g. locally or in a secure environment behind a firewall over a public network or in any other suitable execution environment. In many of the examples that follow the applications are described as business applications such as may be operated by a company enterprise or other business entity. However again it may be appreciated that such examples are non limiting and that the applications also may represent many other types of software applications such as e.g. educational applications government applications charitable or other non profit applications or applications designed for personal use by a user.

Whatever a nature of type of the application illustrates that a metadata manager may be utilized to manage associated application metadata which describes aspects features and functions of the application . For example the metadata may describe a type and location of associated data e.g. master data or configuration data used by the application . The metadata also may describe various processes executed by the application e.g. processes for manipulating the above referenced data and or external data. In some cases the metadata may relate such processes to relevant use cases and descriptions thereof. For example in the case of business applications the metadata may describe the application in the context of various relevant business processes and associated use cases.

In some cases the metadata may simply be provided in conjunction with the application e.g. by a creator or publisher thereof in which case the metadata manager may be responsible simply for storing accessing the metadata . In other scenarios the metadata manager may be responsible for generating the metadata automatically e.g. based on an analysis of underlying application code of the application . In still other examples the metadata manager may be configured to interact with a user of the application to create the metadata even long after an original creation or publication of the application .

As referenced above it may occur that one or more semantic metamodels are available for use with or by the application . Accordingly the application is illustrated as including a metamodel selector which may be configured to select a particular semantic metamodel from the one or more semantic metamodels for creation of the application specific metamodel instance . Consequently as described in more detail below it may be appreciated that the application should be understood to utilize some or all of the same semantic metamodel in creating its associated application specific metamodel instance .

Thus in some examples it may occur that of the available semantic metamodels only one i.e. the semantic metamodel is available or compatible for use with the application . In other scenarios it may occur that two or more of the semantic metamodels could be used with the application but that the application may choose from among the available subset of the semantic metamodels based on a desired nature and type of integration e.g. based on a type of integration and associated semantic metamodel relevant to a type or class of application or to the application itself if known at the time .

In practice the metamodel selector may operate by selecting or otherwise identifying one or more features or use cases contained within the metadata for comparison thereof against the semantic metamodels . For example such features may be pre determined by the user of the application or may be dynamically selected by the metamodel selector based e.g. on other aspects of the application . Then by comparing the thus identified features of the application from the metadata to corresponding aspects of the semantic metamodels the metamodel selector may identify the semantic metamodel to be used in obtaining the application specific metamodel instance .

In the example of the semantic metamodels are illustrated as being stored within a metamodel and model repository . As described in detail below the repository provides a central available searchable location which thus facilitates e.g. operations of the metamodel selector in selecting the semantic metamodel . For example in scenarios in which the system is implemented in the context of a specific business or other enterprise the repository may be implemented within an associated on premises IT environment. In other example implementations however as described in detail below the repository may be implemented in Cloud based scenarios in which the repository is publicly available to all users of the application .

In specific examples the semantic metamodels including the semantic metamodel may be implemented as XML extensible markup language schemas. In general as is known such a schema describes allowable structures and contents of XML documents that are compatible therewith. Accordingly a transformation engine may be configured to utilize the semantic metamodel together with the metadata to thereby provide the application specific metamodel instance as an XML document. As such and in example implementations the application specific metamodel instance as well as the application specific metamodel instance may be created stored and utilized using well known techniques for searching for and manipulating XML documents. Nonetheless it may appreciated that various other types of current or future schemas may be utilized to implement the semantic metamodels .

In the example of the transformation engine executes several different types of mappings in order to instantiate the semantic metamodel using the metadata to thereby obtain the application specific metamodel instance . For example the transformation engine is illustrated as including a semantic mapper which may be operable to transform individual or combinations of terms and or concepts within the metadata into corresponding terms concepts using language consistent with the semantic metamodel .

Detailed examples of such semantic mappings are provided in detail below but for the sake of illustration it may occur that the application is a business application related to obtaining a request for proposal RFP which uses the term winning bid obtained from a vendor. At the same time the semantic metamodel may include a portion that relates to such RFPs in which the semantic mapper determines that a supplier is equivalent to a vendor and a winning bid contains final price information for a line item of an outline agreement defined in the semantic metamodel . As may be appreciated with respect to the simplified example the application may utilize a term such as seller or provider yet the application specific metamodel instance associated therewith may similarly refer to such entities as supplier thereby providing the above referenced common framework for referring to a given concept during a subsequent integration of the applications .

Somewhat similarly a process mapper may map processes described in the metadata to processes specified within the semantic metamodel . In this regard it may be appreciated that a single process of the metadata may correspond to two or more processes of the semantic metamodel or conversely multiple processes of the metadata may refer to a single process of the semantic metamodel . In still other example scenarios a given number of a plurality of processes of the metadata may correspond to a same or different number of processes specified in the context of the semantic metamodel . For example it may occur that the metadata describes a series of process steps but that the semantic metamodel only needs to specify a first and last step of the series of process steps in order to facilitate desired integrations of the application with other applications such as the application . For example in a pricing process the metadata may specify various rounds of negotiations e.g. auctions for lowering an initially offered price. Meanwhile the semantic metamodel may only require the fact that a price was requested and ultimately obtained for purposes of specifying the application specific metamodel instance .

Finally with respect to the transformation engine of the example of the data mapper may be configured to relate data types and specific data instances of the metadata to the semantic metamodel . For example as referenced above the data mapper may seek to relate master data or configuration data of the application to corresponding types of data within the semantic metamodel .

The data mapper may also be responsible for mapping individual data fields of data of the application to corresponding data fields within the application specific metamodel instance . In this regard it may be appreciated that although examples of mapping data from one field to another are by themselves well known the data mapper of provides for specific functionalities which enable these and other types of data mapping in the context of the semantic metamodel to thereby facilitate a desired integration of the application in a manner that is partially or completely automated and therefore generally more efficient and cost effective than existing techniques which require varying extents of manual identification of data fields to be mapped.

As referenced above the repository may serve as a central point of discovery identification and selection of one or more of the semantic metamodels by the metamodel selector . Similarly an application matcher may be utilized to discover select and utilize the application and or other applications for integration with the application . In other words the repository may be used to register a plurality of applications such as the application providing various features and functions which may be desirable to use in conjunction with operations of the application . In practice all such applications may be stored or referenced in conjunction with corresponding application specific metamodel instances so that upon discovery identification and selection thereof any such application may be immediately available for integration with the application utilizing the various techniques described above and in conjunction with operations of an integration engine described in more detail below.

For example in a highly simplified example it may occur that a user of the application has specific knowledge of the individual application and may desire integration of the application therewith. In such scenarios the user of the application may utilize the application matcher simply to identify the application within a repository perhaps simply by identifying the application using an appropriate unique identifier or name. Thereafter integration of the applications may proceed as described herein.

In other example implementations however the user of the application may not have such specific knowledge. Rather the user may simply have an idea of a desired type of functionality to be implemented by or in conjunction with operations of the application . In such cases the application matcher may be utilized to perform a search of applications stored in association with the repository in order to match available applications and their associated functionalities with the desired functionalities to be included in an integration with the application .

For example the application matcher may be configured to search the applications of the repository based on their corresponding names or other descriptions or metadata associated therewith in order to ascertain a likelihood of desired functionality being provided thereby. Further the application matcher may restrict such searches to those applications which are associated with application specific metamodel instances derived from the same semantic metamodel utilized by the application to generate the application specific metamodel instance in order to ensure compatibility between applications identified by the application matcher and the application .

In more specific example implementations the application specific metamodel instance may be provided with what is referred to herein as a bill of needs which is designed to specify one or more functionalities that may be associated with the application i.e. that may be provided one of the applications for access thereto by integration of the application with the application .

As referenced above and described in more detail below the application specific metamodel instance may include various requirements of the application as translated from the metadata by the transformation engine which specify functionalities and points of integration. Therefore similarly and as also explained in detail below the bill of needs may be expressed using the same or substantially the same techniques as used in expressing such application features. In other words the application features specify what the application does while the bill of needs specifies what the application would like to have done by another application which would presumably express its abilities in this regard in the context of its own application features included within its own application specific metamodel instance.

Thus the application matcher may proceed by matching some or all of a bill of needs of the application specific metamodel instance with matching application features of the application specific metamodel instance and thereafter executing integration of the applications using the relevant portions of the application features and bill of needs of the application specific metamodel instance on the one hand and the application features of the application specific metamodel instance on the other hand.

By way of more specific examples with reference to a discovery process that may be executed by the application matcher is illustrated in which the application is illustrated as a requisition application which accesses the metamodel and model repository to discover the application as a sourcing application for integration therewith. In the example as referenced above the application specific metamodel instance may include both application features and bill of needs associated with the requisition application .

As described the format and structure of the application features and may be identical or substantially identical although the application features specify capabilities and characteristics of the requisition application while the bill of needs express one or more desired capabilities and characteristics which are sought in the context of a sourcing application such as the sourcing application . Meanwhile the sourcing application is illustrated as being associated with application features of its own application specific metamodel instance . As may be appreciated the application features may include a format and structure that matches both the application features and bill of needs of the application specific metamodel instance all of which are in accordance with the common semantic metamodel .

By way of specific non limiting example it may occur that the requisition application corresponds to a Cloud based human resources system which may wish to make use of a Cloud survey tool to support employee performance reviews. Meanwhile the sourcing application may represent one of perhaps a plurality of such survey tools. In operation an owner or other provider of the survey tool may wish to make such a survey tool publicly available for use in conjunction with the repository . In this regard such a provider may publish or otherwise register the survey tool in the repository . For example rather than storing the survey tool itself in conjunction with the repository the provider may simply register a reference to the survey tool in conjunction with registration of the corresponding application specific metamodel instance which itself may be made available for search and discovery within the repository .

It may be further appreciated that the applications may be developed completely independently of one another and at different times. For example the requisition application e.g. the human resources application referenced above may be developed before the sourcing application e.g. the survey tool even exists. Nonetheless a developer or other provider of the human resources application may recognize a potential need for such a survey tool and may provide specifics of such a need within the bill of needs .

Thus at some later time an administrator or other user of the human resources application may in fact wish to utilize the functionality of such a survey tool and may be provided with an administrative dashboard or other user interface in the context of the human resources application in which each general feature specified by the bill of needs including the referenced survey tool may be paired with a list of available services of the repository and may be used to support the specified feature.

Then the administrator may simply need to select a subscribe button or other appropriate interface element in order to initiate integration of the applications and thereby activate the desired functionality. Thereafter for example new buttons or other UI artifacts may be provided or enabled within the human resources application in order to provide for launching an operation of the survey tool . In this way the administrator of the human resources application may identify and select the survey tool as providing desired functionality even if the survey tool did not exist and or was developed wholly independently of the human resources application . Moreover it may be appreciated that the administrator may similarly update the desired survey functionality using a different survey tool than the survey tool if desired and if when such a preferred survey tool becomes available within the repository .

For example the integration engine may implement a mediated integration in which the integration engine or other suitable component serves as a central point of interaction between inputs and outputs of the applications . In other example implementations the integration may be direct so that the outputs of each application are suitably provided as direct inputs to the other of the applications as inputs thereof. In these and other examples it may be appreciated that the various inputs outputs of the applications are commonly specified and described through the use of the corresponding application specific metamodel instances .

With reference back to application is illustrated as being executed using at least one computing device which itself includes at least one processor A and computer readable storage medium B. That is for example instructions for execution of the application may be stored using the computer readable storage medium B and may be executed by the at least one processor A in order to obtain various features and functions described herein.

For example the at least one processor A may represent multiple processors executed in parallel. Meanwhile the computer readable storage medium B may be utilized to store data of the application such as master data or configuration data or the metadata as well as the actual instructions for execution of the application . Of course the at least once computing device may include or be associated with various peripheral components e.g. human interface devices for displays various power components and various network or other communication interfaces none of which are specifically illustrated in the example of for the sake of simplicity and clarity.

Similarly the at least one computing device is represented generically in for the sake of simplicity but may be understood to represent any appropriate computing device such as e.g. a desktop computer a computer of a computing cluster or any appropriate mobile computing device e.g. a laptop notebook netbook tablet or Smartphone . Further in as much as the at least one computing device may represent two or more computing devices in communication with one another it may be appreciated that some or all of the functionalities described with respect to the application may be implemented on a first such computing device while remaining operations may be executed on the one or more computing devices and communications therewith.

For example in particular it may be appreciated that any of the various components illustrated as executing in conjunction with the application may be in fact executed separately from the application e.g. using a separate computing device and or a separate application or other hardware software platform. In particular for example it may occur that the metamodel selector the transformation engine the application matcher and or the integration engine may individually or collectively be executed outside of and in communication with the application . For example these components may be operated as a middleware between the application and the repository . Similarly it may occur that these components are provided in conjunction with the repository itself using an appropriate Cloud based hardware software platform. Similarly the metadata manager may also be implemented separately from the application such as in scenarios in which the application is not initially provided with appropriate metadata .

Thus from the above description it should be apparent that in various example scenarios the application may simply be an otherwise conventional application which may be registered with the repository by an owner or other provider thereof. Thereafter a provider of the repository may utilize the various components to generate the application specific metamodel instance for association with the application within the repository to thereby make the application publicly available for integration with other applications utilizing the same semantic metamodel e.g. of the semantic metamodels . Such examples may be suitable for scenarios in which providers of the application are unwilling or unable to generate the corresponding application specific metamodel instance .

In other example scenarios however it may occur that the semantic metamodels including the semantic metamodel represent a known standard for commonly expressing features and needs of applications. In such scenarios providers of such applications as the application may desire to obtain the benefits of such a standard representation and may adopt use of a corresponding appropriate semantic metamodel in order to generate the application specific metamodel instance for registration in conjunction with the application within the repository . Of course similar comments and scenarios may apply to the application and its corresponding application specific metamodel instance and to all such applications and associated metamodel instances registered in the context of the repository .

Thus an aggregate and over time the repository may come to represent a large store of available applications which may be easily e.g. automatically integrated with one another in desired fashions to thereby provide developers and other application users with desired functionalities in a cost effective and efficient manner. Moreover such advantages may be obtained even though the various application specific metamodel instances are developed independently in conjunction with their underlying applications and without requiring knowledge of or even existence of the other applications which may be integrated therewith at some future point in time. Thus the developers and other users of the various applications may each be provided with a large number and variety of potentially desirable applications and associated features as well as with the ability to utilize such applications and associated features in a convenient manner.

In the example of a semantic metamodel may be determined for at least two software applications the semantic metamodel including a description of semantics processes and data that are applicable to the at least two software applications . For example the metamodel selector of may select the semantic metamodel from the available semantic metamodels of the metamodel and model repository . In some examples only a single semantic metamodel may be applicable or compatible with a given software application such as the application so that metamodel selection per se need not be performed in every scenario. Further as referenced above it is not necessary to know of an existence much less a particular identity of both of the at least two software applications in order to utilize the selected semantic model with respect to a software application. Rather the operation merely requires that the referenced semantic metamodel provides the referenced description in a manner that is applicable to the at least two software applications and as described in detail herein provides each of the at least two software applications with an ability to describe itself for current or future integration with the other application.

Application metadata describing an application of the at least two applications may be determined . For example the metadata manager of may determine the metadata of the application . As described the metadata may be currently available and stored in association with the application and or may be partially or completely generated for the application by the metadata manager . As described the metadata may generally describe various features aspects or requirements of the application in a manner that is generally application or assistant specific so that such applications may be provided with corresponding metadata in a manner that is suitable for e.g. proprietary to the given application and or underlying platform.

The application metadata may be transformed into an application specific metamodel instance of the semantic metamodel . For example the transformation engine may transform the metadata using the semantic metamodel to obtain the application specific metamodel instance . In this way the application in question e.g. the application may describe itself for current or future integrations.

Thus the at least two software applications may be integrated based on the application specific metamodel instance . For example the integration engine may be configured to utilize integration points e.g. input output interfaces identified by the application specific metamodel instance with respect to the application in order to integrate the application with the application .

Thus may be understood to represent a high level operational flow of example basic operations of the system of . As referenced above with respect to various additional or alternative operations may be included many of which may be understood or appreciated from the above description of .

For example although not specifically recited in the second of the at least two software applications may generally also be associated with a corresponding application specific metamodel instance e.g. the application specific metamodel instance associated with the application so that the integration engine may utilize both such instances to implement the integration of the applications .

Similarly does not explicitly mention the use of the bill of needs referenced above e.g. with respect to and associated matchings thereof between the bill of needs of the requisition application and corresponding application features of the sourcing application . Nonetheless again it may be appreciated that any and all such additional or alternative operations may be included in an appropriate or desired manner in the context of the overall operational flow of the flowchart of . Many such additional or alternative features and associated operations are described below with respect to the specific examples of .

Further within the attributes a company that is responsible for the application in question may be identified. Similarly a uniform resource locator URL may be included which identifies the responsible company through the use of a URL link e.g. to the company website or relevant portion thereof.

Further in a semantic ID is included which generally represents information relating to a description purpose and context of the application . More detailed examples of the semantic ID are provided below e.g. with respect to .

Also in features refer to a set of requirements filled by the application and exposed for external use. In other words the features corresponds generally to the application features of . Similarly needs refer to a set of requirements that the application desires or needs to be filled by some other application or service in order to provide a corresponding functionality. Thus the needs responds generally to the bill of needs described above with respect to .

As shown the purpose may include a standard purpose referring to a set of predefined purposes for all compatible business applications. As further shown with respect to the standard purposes such purposes may include integration associated process step associated analytics and or associated monitoring . The purpose also may include an extended purpose which may refer for example to extensions added by a customer or other consumer or purchaser of a relevant application. Thus the extended purpose identifies application specific purpose or semantic usages associated with such customizations.

With regard to the features a plurality of associated requirements may be enumerated where each requirement may include for example usage semantics one or more process lists data list and service list . As may be appreciated from the above description of such lists and related information may correspond with the semantic mapper the process mapper and the data mapper of the transformation engine of .

As shown the usage may relate generally to define usage semantics for the application and its associated requirements . The process list may refer generally to a set of processes for the requirement . The data list provides a relevant set of data for the defined requirement . Finally similarly the service list defines the subset of services for the defined requirement.

As also described above the needs correspond generally to the type of bill of needs described above e.g. the bill of needs of . Consequently in contrast to the features and the requirements which specify set of requirements filled by the application and exposed for external use the needs and associated requirements provide a set of requirements that the application needs or desires to be filled by some other application or service e.g. the application .

As may be observed the corresponding requirement structure may correspond substantially or completely identical to the requirement structure associated with the requirement of the features . In this way for example it may be a straightforward extension for a provider or user of the metamodel of to add the needs to the metamodel due to familiarity with the features and associated data requirements . Moreover due to such identity between the requirements and the needs including requirements and requirement structure it may be straightforward to determine integration points at which the application provides integration points for integration with a second application which itself as described with respect to may utilize requirements which are identical in form and structure to the requirement structures .

Thus in the example of further detail regarding usage semantics are provided. As already described the usage semantics may include the semantic ID which is shown in expanded form as being identical to the semantic ID of as referenced above. Meanwhile the direction is expanded to illustrate an example direction and which input and output directions are identified for corresponding data flows.

Further in a relationship structure illustrates an example form and format for relationship of the set of valid relationships and associations described above. That is as shown the relationship may identify related processes in a corresponding list which identify the referenced related processes themselves along with semantic ID that associates a current related process reference to the actual defined process. Again the semantic ID may correspond in form and format to the semantic ID .

Similarly a list of related data may reference corresponding related data which is associated by virtue of the semantic ID . Finally in and similarly a list of related services may be associated with a corresponding related service by semantic ID .

With reference back to e.g. the requirement of the process list may be associated with a process of which as illustrated provides a definition and associated semantics of a particular business process. Specifically as shown usage semantics may be provided along with a status list that enumerates various phases in the process life cycle of the process .

Then corresponding status information may be provided utilizing associated usage semantics in conjunction with a process name and ID as well as a service definition providing a definition and semantics of related services. It may be noted that the usage semantics and as well as described below may correspond to the usage data structures described above with respect to in the appropriate context illustrated in . Similarly the service definition and semantics may correspond to related data structures described below with respect to similar comments apply to the service described below .

Further in an action list associated with the process enumerate the set of available process actions shown in of actions . As referenced each action may be associated with corresponding defined usage semantics name ID and associated definition semantic of related services.

Further data elements may be used to represent a set of fields of a business object s data model. Corresponding data elements may thus represent an individual field within a business object. Then the data element as shown may be associated with a data element type that identifies whether a field is a standard field or an extension . The data element may also be associated with a data element ID a data element name a data element content type and a data element content value . Finally with respect to the data element may be further associated with a data collection of child business objects.

Further with respect to a service interface may be included which identifies a manner in which a related service may be connected and consumed. Consequently the service interface may specify an end point URI uniform resource identifier associated with the service. Further a service schema URI may be provided as a URI pointing a schema that defines input and output parameters for the service in question.

Further the example of provides specific instances of needs corresponding to the needs of as well as features corresponding to the features of . Then in the specific example the needs may include a first requirement related to a purchase requisition. As shown the requirement structure includes usage semantics again corresponding to the related structures of . Specifically as shown a direction specifies an input direction and a semantic ID provides an ID for a purchase requisition and associated description. Again the semantic ID is linked to a purpose e.g. a purpose of aggregating demand.

Then relationships may specify related processes such as may be associated with a semantic ID for strategic sourcing. Similarly a related service may be associated with a semantic ID for creating a request for proposal RFP . Further related data may be associated with a semantic ID for for the RFP itself.

Similar and supply to a second need requirement for a purchase order specifically as shown the requirement includes usage semantics including a direction specifying an output direction. A semantic ID again specifies an ID i.e. purchase order and associated description and is associated with a purpose of providing a purchase order.

Relationships specify a related process having a semantic ID for an order to be issued. A related service is associated with a semantic ID describing creation of a purchase order PO . Further related data is associated with a semantic ID for the PO itself.

Similar comments apply to the example RFP requirement and associated data structure . Specifically as shown a usage semantics specifies a direction as an input direction. A semantic ID provides a corresponding RFP identifier and description along with a purpose specifying the purpose of request for a proposal.

Relationships include a related process having a semantic for contract management and a semantic ID for auction management. A related service is associated with a semantic ID for creation of a contract as well as a semantic ID for creation of an auction. Related data is associated with a semantic ID for the resulting contract itself while similarly a semantic provides the created managed auction.

Further a process corresponding to the description of includes usage semantics describing a demand to source a usage net related to supplier discovery usage semantics relating source to award and usage semantics relating award to contract. As further shown the usage semantics may include a status new a status bid and status award . As also shown the status may include a specified service for submitting a bid as well as a service for starting a related auction.

A service corresponding conceptually to the service of includes a structure that specifies usage semantics related to RFP creation which has a semantic ID associated therewith. Then a service is specified as having a service type SOAP along with a relevant URI and service schema URI. Then data corresponding to provides data structure which specifies usage semantics related to an RFP along with a corresponding semantic ID . A data type specifies an RFx with element related to a proposal due date and element related to an intent to respond. Then structure includes usage semantics for a vendor having a semantic ID shown as supplier. A data type for the vendor will be shown as master data where in the example one element is a DUNS number and a second element identifies the vendor as a small business. Finally with respect to a relationship is also illustrated between the data structures .

Thus with respect to the above description of the application specific metamodel instance of may be understood to illustrate such an instance for an underlying sourcing application. In the example the various features illustrate that the application in question has the capabilities to provide an RFP. Further the needs specify that in order to provide the RFP the application may desire or require a second application to generate a purchase requisition and or a purchase order .

As described in detail the application in the example of may thus represent for example the requisition application of in which the needs correspond to the bill of needs described with respect thereto and the features correspond to the application features . Then some second application and corresponding application specific metamodel instance not specifically illustrated with respect to and corresponding to the sourcing application of may be discovered within the repository . Thereupon the application of may easily be integrated with one or more such applications in order to fulfill the needs in an automatic cost effective and efficient manner.

For the sake of further illustration example a developed XML schema for representing one of the semantic metamodels of is provided below. Of course it may be appreciated that the provided XML schema is intended merely for the sake of further illustration example with respect to a particular implementation of such a semantic metamodel in conjunction with the examples provided above with respect to . Thus in this regard the provided XML schema should not be understood to be limiting of the types of current and future techniques that may be utilized to represent the semantic metamodels .

Implementations of the various techniques described herein may be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Implementations may implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program such as the computer program s described above can be written in any form of programming language including compiled or interpreted languages and can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method steps also may be performed by and an apparatus may be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer also may include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory may be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations may be implemented on a computer having a display device e.g. a cathode ray tube CRT or liquid crystal display LCD monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Implementations may be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation or any combination of such back end middleware or front end components. Components may be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

While certain features of the described implementations have been illustrated as described herein many modifications substitutions changes and equivalents will now occur to those skilled in the art. It is therefore to be understood that the appended claims are intended to cover all such modifications and changes as fall within the scope of the embodiments.

