---

title: System and methods for generating and managing a virtual device
abstract: Embodiments of the present disclosure may be configured to permit development and validation of a device driver or a device application program by using improved virtual devices. Such improved virtual devices may facilitate driver development without use of physical devices or hardware prototypes. In various embodiments, advanced validation of a device-driver combination may be permitted that would be difficult to achieve even with a physical device. Certain embodiments also may detect inconsistencies between virtual and physical devices, which may be used to improve drivers and device application programs and increase compatibility of such drivers and device application programs with physical devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09152540&OS=09152540&RS=09152540
owner: Oregon State Board of Higher Education on Behalf of Portland State University
number: 09152540
owner_city: Portland
owner_country: US
publication_date: 20130111
---
The invention was made with government support under grants 0720546 and 0916968 awarded by the National Science Foundation. The United States Government has certain rights in the invention.

This application claims the benefit of U.S. patent application Ser. No. 13 601 425 filed Aug. 31 2012.

The present invention generally relates to computer systems. More specifically the present invention relates to development and testing of computer programs such as virtual devices that simulate or emulate hardware devices and device drivers that facilitate communication between virtual or hardware devices and other hardware or software entities.

Computer systems such as smartphones personal digital assistants tablets netbooks laptops and desktops typically include a processor communication unit such as a bus power supply and optionally a housing unit. Often computer systems are configured to function with peripheral devices which are termed devices for purposes of this application.

Devices may be categorized by the position of each relative to a housing unit. For example internal devices called also integrated devices generally are stored inside or integrated with the housing unit. Such integrated devices may include an internal hard drive CD R drive CD ROM drive DVD ROM drive sound card network card video adapter or an internal modem. External devices on the other hand generally are stored outside of the housing unit and may include a printer scanner monitor touchscreen keyboard or pointing devices such as a mouse gaming controller or joystick.

Devices may be categorized also by function. For example storage devices may include an external hard drive flash drive disk drive or any other device configured to permit information storage. Input devices may include keyboard pointing devices such as a mouse gaming controller or joystick digital camera webcam barcode reader microphone fingerprint scanner or any other device configured to permit input of information into the computer. Output devices may include display devices such as a monitor segment display such as a digital clock display television set or tactile electronic display audio output devices such as speakers or headphones printers or any other device configured to permit information output from the computer.

Many devices are configured to provide an output that is perceivable by a user. For purposes of this application a perceivable output may include any perceptible output from the device including for example that which is viewable on a display a touchable button a light or stored information. Other perceivable outputs may be input from one device e.g. a keyboard or a mouse and perceived as an output on a display device such as a monitor or a touchscreen.

Computer systems may use hardware software or both to manage the resources of the computer system. Software used to manage a computer system s resources is termed an operating system. When a user seeks to use a device with a computer system the operating system may not have the information necessary to communicate with that device. Because of the plethora of devices available to connect with computer systems it would be impractical to include the information necessary for communicating with every device in every operating system. Accordingly a software program called a device driver or driver allows the device and operating system to communicate with each other. Generally at least one driver is available for every type of device. At times a driver may be developed for each of multiple operating systems e.g. Microsoft Windows Mac OS X Android Linux BSD etc. . When the driver permits communication between the operating system and a physical device the device can perform its function to generate a perceivable input output.

Drivers also may be used to facilitate communication between the operating system and an application program. An application program also referred to herein as an app may be configured to permit the user to perform a specific task. Popular apps may include word processing programs image editing programs game programs database management programs and document management programs. Certain apps may be configured for use specifically with a device. Such an app is termed a device application program for purposes of this application.

Conventionally a driver or an app utilizing a device through the driver could not be developed until the physical device or at least a stable prototype of the physical device was completed. Clearly such a delay in the development and validation of the driver further delays offering of the product for sale. At times developers begin designing drivers based on predictions of the physical device. When the physical device becomes available draft versions of the driver often require substantial revisions which results in a largely inefficient process.

To shorten the development cycle systems have been built to enable earlier development of a driver. One such approach includes using an early prototype such as a Field Programmable Gate Array FPGA prototype for driver development. However such prototypes can delay the start of driver development until the register transfer level RTL design of the device is generally finished. Also an FPGA prototype may differ significantly from the physical device. As a result the driver developed to work with that prototype may need significant revision in order that it can function with the physical device.

In addition known approaches for testing an FPGA prototype or even the physical device during driver development permit only limited observation of the internal conditions of the prototype or device. Also prototypes and physical devices generally do not permit recording events that occurred for example before an error and are difficult to control without a time consuming and labor intensive bootstrapping process.

Another approach to enable the development of a driver involves the utilization of virtual machines and virtual devices. A virtual machine is a software program configured to simulate the operation of certain hardware or operating system with minimal access to the actual hardware or operating system in the host computer system. In certain embodiments a virtual machine is a simulated computer system operating within but generally isolated from a physical computer system.

A virtual device is a software program configured to simulate the operation of or function as a physical device without access to the physical device or a prototype of the physical device. In various embodiments a virtual device may be configured to have the same functional restrictions and other restrictions as physical devices. In various embodiments a virtual device may be presented as a virtualized replacement of a physical device.

Virtual devices may operate within an environmental infrastructure such as a virtual machine or an operating system. When functioning in a virtual machine a guest operating system may interact with a virtual device as if it is a physical device. This requires no change to the driver stack of the guest operating system. In contrast when functioning in a non virtual operating system an operating system may be extended to allow loading of a virtual device as if it is a physical device. This involves changing the driver stack of the operating system. An example of this approach is the Device Simulation Framework DSF which allows introduction of virtual devices that model and simulate Universal Serial Bus USB devices in an operating system.

While certain virtual devices are known such virtual devices have not been optimized for device simulation and driver development. Specifically certain known virtual devices are too simple to permit development of a driver that consistently functions with the physical device. Other known virtual devices are too complex to create an efficient simulation. For example certain virtual devices permit observation tracking and control of the device but often result in excess performance overhead and cause the simulation to operate slowly.

In addition known virtual devices use concrete execution of software code. In other words to achieve a certain task a program may execute instructions that include one or more if then statements e.g. if A then B if not A then C . In concrete execution the developer must predetermine which choice the program will make at each decision point. Accordingly to simulate each physical device behavior a developer must explicitly specify concrete values and choices or supply run time scripts for each device behavior. Such virtual devices render it difficult to conduct comprehensive exploration of possible device behaviors and simulation of the possible concurrency in device driver interaction.

Other known device simulations are not configured to operate in virtualization environments such as DSF and a Quick EMUlator QEMU virtual machine. Such simulations include those generated from device designs at different stages within the development process for example transaction level TL designs in SystemC or SystemVerilog register transfer level RTL designs in Verilog or VHDL and gate level GL designs as net lists.

In addition methods for preparing testing protocols for known virtual devices and the co developed drivers typically must be generated manually and or on a case by case basis which is time intensive and cost prohibitive.

Clearly there is a demand for a system and methods for constructing virtual devices that incorporate various levels of detail from a device design developing a driver or application program with improved performance preparing automated testing protocols for validating a driver driver device combination or application program and verifying conformance between virtual devices and their real counterparts where such system and methods are configured to maximize the smooth integration of the resulting driver or application program with a physical device.

Embodiments of the present invention may be configured to use characteristics of virtual devices to improve symbolic execution effectiveness generate test cases characterizing paths through virtual devices and drivers provide facilities to replay those paths with the generated test cases and to assess conformance of virtual devices used for testing during development of physical devices with the physical devices themselves.

Referring to a device driver may facilitate communication between a hardware device and various other software or hardware logic such as an application program or an operating system . Additionally or alternatively and as illustrated in device driver may facilitate indirect communication between hardware device and application program e.g. through operating system . In other embodiments hardware device may communicate directly with application program or operating system .

In various embodiments device driver may be configured to act as translator between hardware device and other entities such as application program or operating system . For example device driver may communicate with hardware device through a computer bus or communications link and with application program or operating system through system calls. When application program or operating system invokes a routine in device driver device driver may issue commands to hardware device . Once hardware device sends data back to device driver device driver may invoke routines in application program or operating system . Device driver is illustrated with broken lines in various Figures since various drafts of the driver may be developed throughout the implementation of the system and methods.

Certain components of the system of the present invention may form modules as illustrated in B and . An infrastructure module may be configured to provide computer infrastructure to the other modules. A virtual device module may be configured to simulate a hardware device. A support module may be configured to provide support functions such as generating test cases and reports and providing management options to the other modules.

In various embodiments infrastructure module may include a program environment such as operating system and or virtual machine . Virtual machine may come in various forms including but not limited to Quick EMUlator QEMU VMWare VirtualBox or Xen. In various embodiments infrastructure module may also include application program . Operating system may include or may be configured to communicate with device driver developed through certain methods of the present invention or other methods. Virtual machine may include a virtual device stub component which may be configured to appear to virtual machine as if it is virtual device . Virtual device stub component also may be configured to facilitate communication with the actual virtual device such as by sending and receiving information such as input output requests to and from a virtual machine interface in virtual device module .

In various embodiments virtual device module may include a virtual device virtual machine interface and a symbolic execution engine . Virtual machine interface may be a program configured to facilitate communication with other components such as by sending and receiving information to and from virtual device stub component in infrastructure module .

Symbolic execution engine may be configured to facilitate symbolic execution of a computer code such as virtual device computer code or device driver computer code. Tools that may be used to implement all or aspects of symbolic execution engine may include but are not limited to SAGE KLEE and S2E Cute jCute CREST BitBlaze DART and Java Pathfinder. In various embodiments symbolic execution engine may be configured to explore execution paths through a computer program and to generate a set of constraints called a path condition that describes the set of values possible on each explored path. During symbolic execution variables may be represented as symbolic expressions instead of concrete values. Accordingly the outputs computed by the computer program may be expressed as a function of input symbolic values. In various embodiments a symbolic state of a program may include symbolic values of program variables a path condition and a program counter. In various embodiments the path condition may be a Boolean formula comprising constraints accumulated as the path is explored. In order to follow a particular path through a computer program inputs to the computer program must satisfy the corresponding path condition determined during symbolic execution of the computer program. In various embodiments the program counter may point to the next statement to be executed.

Embodiments of the support module may include components such as a management component test case generator bug report generator and a coverage report generator . Management component may be configured to test control and communicate with application program virtual device and device driver . Test case generator may generate test cases for use with virtual device device driver and application program to achieve various test criteria. If during testing a bug or error is detected bug report generator may prepare a report describing the bug or error. Coverage report generator may be configured to prepare a report describing the functions and status of virtual device device driver or application program . Based on the coverage report test case generator may generate additional test cases that may improve the coverage.

In various embodiments virtual device may include a symbolic virtual device SVD or a hardware device design based virtual device. Embodiments of a symbolic virtual device may be configured to permit non deterministic device behaviors. For example instructions for implementing the device may include code with decision points for two or more choices. When the execution reaches that decision point the decision may be made according to certain guidelines. Advantageously such instructions may be easier and faster to develop since the developer can provide general guidelines instead of mapping every choice at every decision point.

Program instructions for an SVD may be non deterministic in terms of both concurrency and environment inputs. Concurrency is a property of a system in which several programs are executing simultaneously and potentially interacting with each other by for example sharing certain resources. Environmental inputs may include information received from other system components e.g. an operating system application program or device and in various embodiments may be symbolic values and or concrete values.

In various embodiments symbolic execution engine may be configured to execute an SVD. As noted above instead of running program code on manually generated or randomly generated inputs engines run the SVD code using a symbolic input initially allowed to be anything. In various embodiments symbolic execution engine may replace program inputs with symbolic values and concrete operations with symbolic operations. When execution of the program reaches a decision point based on a symbolic value symbolic execution engine may follow both options conceptually.

In various embodiments symbolic execution engine and or test case generator may be configured to generate test inputs. In various embodiments test case generator may be part of symbolic execution engine or vice versa. During execution of an SVD when a path reaches a result a test case may be generated by solving the current path condition for concrete values. When the concrete values are used as the input the same path may be followed which may facilitate identification and or repair of bugs.

A simple example of analysis of every possible path through one or more decision points in a computer program is illustrated in and . A symbolic execution tree illustrates the possible paths explored by the symbolic execution of the following computer code 

In decision point nodes may represent the symbolic program states and arcs may represent the state transitions. At the input the variable X has a symbolic value e.g. any value allowed by its type in this case an integer . At each decision point node the constraint is accumulated and the set of accumulated constraints up to that point may be a current path condition.

The example code above is a simple example. Real life code implementing a virtual device or device driver may be dramatically more complex. The number of paths through a program may be roughly exponential in program size. Thus attempting to traverse all paths of a complex computer program may result in so called path explosion. Path explosion may strain computing resources e.g. processing cycles memory and development schedules limiting the ability to utilize symbolic execution to thoroughly test computer programs such as device drivers or virtual devices.

Accordingly embodiments of an engine may be configured to minimize or eliminate the challenges with exponential path possibilities e.g. by managing use of computing resources such as processing cycles and memory. One or more restraints may be applied when executing the virtual device. One type of restraint is a loop bound which may be added to bound loops with loop conditions that are symbolic expressions. In this manner it may be possible to control or limit the depth to which each loop is explored. In various embodiments loop bounds may be added manually e.g. for embodiments having only a few loops or automatically e.g. for embodiments having many loops .

Another type of restraint that may be utilized to minimize or eliminate path explosion may be a time bound. A time bound may be configured to require termination of symbolic execution of a computer program e.g. virtual device device driver in a particular amount of time. If the symbolic execution does not completely finish within the given time bound there may be unfinished paths. For such paths test cases for the incomplete path conditions may still be generated. In various embodiments both loop and time bounds may be utilized concurrently.

Embodiments of an engine may be configured to generate reports describing information about traces through a computer program. However certain reporting methods may result in reports of traces covering the same instruction or sequence of instructions. For example assume the following simple computer program 

Symbolic execution similar to that described above with regard to of this computer program may yield two paths and two corresponding path conditions. 12 Path 1 1 2 Path 2 

However a computer program executed using symbolic execution engine may be compiled to an intermediate representation in which the compiler may decompose the if conditional expression into two separate branches. For example KLEE may operate on Low Level Virtual Machine LLVM bitcode to find three paths and corresponding path conditions 1 Path 1 2 Path 2 1 2. Path 3 

Paths and may cover the same sequence of computer program instructions. To provide the ability to output a trace report without duplicative traces in various embodiments symbolic execution engine or other another component may be configured to detect and eliminate duplicative traces.

In various embodiments multiple types of reports may be created e.g. at various levels of complexity. For example in various embodiments a virtual device may be executed e.g. by symbolic execution engine with symbolic value. Test cases may be generated e.g. by symbolic execution engine that include concrete values for all explored paths. For each generated test case the virtual device may be executed with the concrete value or values. A path trace may be obtained. If a path trace covers a sequence of code already covered path information may be output to an extended analysis report. If a path trace covers a sequence of code yet to be covered then path information may be output in both the extended analysis report and a simplified analysis report that does not include duplicative traces.

In various embodiments generation of effective test cases may be facilitated by enabling specification of various types of initial states of a virtual device. One example type of initial state is a concrete state. A concrete state may be a predefined state in which all state variables are assigned specific values. In various embodiments these values may be captured from a physical device that is the same as or similar to the virtual device. Another type of initial state is a symbolic state in which all state variables are made symbolic. As described above the symbolic state may be used to identify paths of a computer program such as a virtual device or device driver. Another type of initial state is a concolic state in which some state variables may be assigned concrete values and other state variables are made symbolic.

Certain embodiments of a virtual device may invoke outside functions from its environment. Such outside functions may be implemented using a function call for a subroutine. In various embodiments if a function call does not affect a state variable of a virtual device symbolic execution engine may be configured to display a warning message and refrain from taking further action regarding the function call. If the function call may affect the value of state variable of the virtual devices on the other hand the function may be implemented in a stub which is invoked by the virtual device in symbolic execution.

In various embodiments once concrete test cases are generated the virtual device or driver may be executed e.g. by symbolic execution engine independently or by another component using the concrete test cases. In some embodiments the computer program may be executed with generated concrete test cases in a debugging environment that facilitates real time examination of variables and states e.g. using breakpoints. In various embodiments such execution may operate in accordance with the following pseudocode 

In various embodiments a developer may interrupt or change the path while running the concrete test cases e.g. to permit further exploration of what inputs and initial states are used to trigger the path and inspect values of variables at any step. This method can be easily applied to many types of device models of virtual devices minimizes overhead and provides a user friendly interface.

In various embodiments symbolic execution engine may be capable of executing one programming language or multiple programming languages. In various embodiments an SVD specification may be compatible with a specific symbolic execution engine or multiple symbolic execution engines. In various embodiments an SVD specification may include one programming language certain language features or multiple programming languages. Symbolic execution engine may symbolically execute the SVD wherein the environmental inputs are provided as symbolic values rather than concrete values. Additionally the engine symbolically executes the SVD at decision points wherein the decision is selected non deterministically from all the possible choices.

Embodiments of an SVD may operate in a number of modes. In a debugging mode an SVD may be executed symbolically e.g. by symbolic execution engine . As the SVD responds to an input output request symbolic execution engine may compute the feasible SVD execution paths at the current device state. The feasible paths may be provided directly to the user to make a choice or the choice is made by a pre set strategies. This mode may provide for step by step debugging by facilitating complete control over the SVD. The debugging mode also may be configured to permit in situ path prediction and randomized execution of the SVD.

In a profiling mode an SVD may be executed concretely by the virtual machine and symbolically by the symbolic execution engine sometimes simultaneously. Symbolic execution may exhaustively explore all possible execution paths through the SVD. The concrete execution paths of the SVD resulting from a test case may be compared e.g. by coverage report generator against the symbolic paths to calculate the coverage report for the test case. In this mode the symbolic paths can be pre generated by the symbolic engine to improve the run time profiling efficiency.

Upon executing test cases the symbolic execution engine may provide the coverage statistics such as statement coverage branch coverage path coverage and transaction coverage information. Transaction coverage information may include identification of some or all possible transactions of an SVD resulting from an environmental input or a driver command. Transaction coverage information also may include an assessment of the impact of a test case or test suite in terms of which transactions or paths have been hit and how often each was hit. Additional metrics specific to devices may also be utilized that considers one or more driver commands and environmental inputs. After the execution statistics such as percentiles for the coverage metrics are collected they may be visualized graphically as bar charts pie charts or other diagrams.

If symbolic execution engine is not compatible with an SVD or symbolic execution engine is configured for use with a number of SVDs an adapter may be created for each SVD or a group of SVDs. Such an adapter is termed a harness for purposes of this application. In certain embodiments a harness and an SVD pair may form a stand alone program. Embodiments of a harness may include a virtual machine with a guest operating system. However other simpler embodiments are contemplated as well. In various embodiments a harness may be configured to handle non deterministic entry function calls symbolic inputs to device models and function calls to the environment.

A harness may be generated using manual harness generation or automatic harness generation. Manual generation of a harness may involve examination of how a virtual machine invokes the virtual device which virtual machine APIs are invoked by a virtual device and what these APIs invoke recursively. The implementation of the invoked functions is included in the harness. At times it may be necessary to make a function produce non deterministic outputs by throwing away its implementation.

Manual harness generation may be useful to generate a harness configured to function with a category of devices. Certain devices are categorized based on functionality such as network adapters and massive storage devices or based on a type of interface standard such as Peripheral Component Interconnect PCI and Universal Serial Bus USB .

A harness may be generated automatically by implementing an algorithm that includes a number of steps. First a call graph that is a graph displaying the invocation relationships between various subroutines originating from a virtual device is analyzed to determine which functions were invoked by the virtual device and how often those functions were invoked. Then based on the frequency of use certain functions are selected for incorporation into the harness code. It is often sufficient to include the implementations of the first level functions invoked. This algorithm also includes a refinement loop which adjusts based on the symbolic execution for instance if making a function non deterministic leads to a large number of paths the implementation of this function may need to be included.

Embodiments of a harness which may be generated manually or automatically may include a number of components including declarations of state variables and parameters of entry functions code for making state variables and inputs of entry functions symbolic non deterministic calls to virtual device entry functions and stub functions for virtual machine API functions invoked by virtual devices.

Regarding the declarations of state variables and parameters of entry functions in various embodiments a virtual device may not be a stand alone program. Accordingly the state variables and function parameters may be defined. If a virtual device is running in a virtual machine it may register its entry functions with the virtual machine. Moreover the virtual machine may help the virtual device manage its state variables. When an entry function is invoked the state variables and necessary parameters of the function may be transferred to the function from the virtual machine. Other declarations define necessary parameters for the entry functions.

Regarding code for making state variables and inputs of entry functions symbolic this permits covering as many paths as possible. The inputs of an entry function should contain state variables and necessary parameters. Certain embodiments implement a specific function svd make symbolic in the engine to initialize the inputs symbolically. All state variables and parameters of entry functions may be made symbolic before they are used.

Regarding non deterministic calls to virtual device entry functions virtual devices provide all kinds of entry functions for communicating with the operating system or virtual machine. To analyze a virtual device all entry functions are executed with symbolic inputs. A symbolic variable is defined in the harness to make nondeterministic calls to all entry functions. Certain functions may be invoked by a driver to write to or read from the device registers. Additional functions may be invoked by the operating system or virtual machine to notify the device about events from outside environments such as whether there is a physical link to the device and whether there is a new packet to receive.

Regarding stub functions for virtual machine API functions invoked by virtual devices certain stub functions for selected functionalities are known in the art. Such stub functions may be included in a harness according to desired or necessary functionalities.

The above described techniques were applied to five existing virtual devices that are distributed with the QEMU virtual machine and which are described in the Table I below 

To execute these virtual devices symbolically a simple harness was manually created for each virtual device. A common library of stub functions was also created for all five virtual devices. The size of this stub library was 481 lines. The respective source code files for these virtual devices ranged from 2099 lines to 4648 lines. The respective harnesses were relatively simple with about 100 lines. Creation of the harnesses and stub libraries only required several hours a piece. Details about the device models and their harnesses are given in Table II below.

To evaluate the performance overhead of our approach these virtual devices were executed under five configurations which are shown in Table III below. The experiments were performed on a laptop with an 8 core Intel Core 2 i7 CPU 8 GB of RAM 320 GB and 7200 RPM IDE disk drive and running the Ubuntu Linux OS with 64 bit kernel version 2.6.38. The five configurations are divided into two groups based on different loop bound LB and time bound TB . The first group contains configurations and for which the same loop bound and different time bounds were selected. The second group contains configurations and for which different loop bounds and different time bounds were selected. Table III includes the number of different paths followed in simplified results and memory usages in megabytes for running the five virtual devices under the five configurations.

With the given loop bounds and time bounds the above described techniques achieved exploration of numerous paths with modest memory usage. With the same loop bound more paths may be explored with a larger time bound. With a larger loop bound new paths may be followed with multiple loop iterations. However each path may take different amount time to explore. A path containing multiple loop iterations often takes more time to explore. Therefore in some test runs for instance PCNet it may be possible to follow relatively few paths with the same time bound but a larger loop bound.

In certain embodiments the SVD may be loaded into an operating system or may be included in a virtual machine in the same manner as a conventional virtual device. In such embodiments the interface of the SVD to the operating system or virtual machine may mimic a conventional virtual device interface. However the internal mechanism for loading an SVD is executed by a symbolic execution engine. The execution of SVD may include two parts the symbolic execution of its device model and the virtual device interface that connects its device model to the operating system or virtual machine. As the SVD is loaded both the symbolic device model and the virtual device interface are executed. When the SVD is initialized for each variable in the device model a concrete value is assigned if such a value is known otherwise a symbolic value is assigned.

With SVD loaded in the environment the developer may execute the device driver in the operating system the host operating system or a guest operating system on the virtual machine to interact with the SVD as if it was a physical device. As the SVD receives a command from the driver it executes the device model symbolically in response to the command. The engine may introduce environment inputs non deterministically to permit exploration of concurrent execution of device model and device driver. Inputs may be assigned symbolic values so that many concrete input scenarios are explored by the execution. When multiple execution paths are feasible one path is selected non deterministically. Instead of a specific device behavior the SVD exhibits a permissible device behavior non deterministically selected.

Certain embodiments of the present invention permit a developer to control the behavior of the SVD so that its execution is not completely non deterministic. The developer may control the SVD behavior by instructing the engine to yield control to the developer at certain decision points rather than making non deterministic choices. The developer may also control the SVD behavior by assigning different weights to different choices at certain decision point so that the symbolic engine makes its choice according to the weights.

Certain embodiments of the present invention include a hardware device design based virtual device as illustrated in . The simulation of a hardware design such as an RTL model may incorporated into a virtual machine as a virtual device. A device design may be simulated by a design simulator such as a stand alone hardware simulator or a design specific simulation library. The simulation may be configured to communicate with the virtual machine through a virtual device stub component . Inputs outputs may be converted through the virtual device stub interface to the inputs outputs of the simulated design. The virtual device stub component may be defined to follow the requirements of the virtual machine and the interface protocols of the anticipated device such as PCI and USB. Virtual device inputs outputs are often defined as software function calls while inputs outputs to hardware designs vary depending on the hardware design languages used. For example for RTL designs the inputs outputs are defined as signals coming in and going out of a hardware module and for SystemC design the inputs outputs are defined as function calls but in different formats from the virtual device function calls. Accordingly the convertor specification includes inputs outputs to the virtual device inputs outputs to the hardware design and rules for converting between them.

The hardware design is compiled into a design specific virtual device such as a C C module and the module is packaged as a virtual device and loaded into the virtual machine module as illustrated in .

Once the HD VD is specified the necessary software programs are automatically generated that implement the convertor connect the virtual device stub interface to the convertor and connect the convertor to the interface of the hardware design through the facilities of the design simulators . For a design simulator such as Mentor Graphics ModelSim which operates as a stand alone system the convertor is split into two parts the virtual device side and the simulator side. Each side of the convertor is implemented as a dynamically linked library loaded by the virtual device environment and the hardware simulator respectively. The two libraries communicate with each other at run time to realize the input output conversion.

The virtual device side library may capture the input function calls to the virtual device and communicates the type of calls and the parameters to the simulator side library which then generates the input signals function calls to the hardware design accordingly. The simulator side library captures the output signals function calls from the hardware design and communicates the types of signals and their values or the types of function calls and their parameters to the virtual device side library which then invokes the corresponding virtual device output function calls with the properly formulated parameters. For a hardware simulator such as Verilator which compiles the hardware design into a software program that may be utilized as a library the convertor is combined with the simulation program to create a dynamically linked library. This library is loaded by the virtual device environment. As the stub virtual device receives a virtual device input a corresponding function of the convertor is called and the parameters of the virtual device input are passed onto the convertor. In this convertor function those parameters are analyzed and the proper sequence of functions in the simulator program is called with the properly formulated parameters. When the simulator program is ready to output it invokes a function in the convertor which transforms the output from the simulated design into the invocation to the corresponding virtual device output functions.

The HD VD may be loaded into an operating system or a virtual machine. For a stand alone simulator such as ModelSim the simulator is first started and the hardware design loaded. As it starts the simulator side library is loaded. Then the virtual device stub is loaded by the virtual device environment. As the virtual device stub is loaded the virtual device side library may also be loaded. As this library is loaded it synchronizes with the simulator side library. Once these libraries are synchronized and the virtual device stub recognized by the operating system or the virtual machine the loading of HD VD is complete and ready to be utilized by the device driver. In this setup the virtual device environment and the simulator are two separate processes and they communicate through inter process communication. For a simulator generated as a library as the virtual device stub is loaded by the virtual device environment the dynamically linked library is also loaded with the virtual device stub. Once the virtual device stub is recognized by the operating system the loading of HD VD is complete and ready to be utilized by the device driver. In the setup the simulator is part of the virtual device environment and often executed in a thread.

Once the HD VD is recognized by the operating system or virtual machine it is treated as if it was a physical device. The development and validation of device driver may be conducted on top of the HD VD the same way as the physical device. Since the HD VD is the simulated hardware design as the device driver interacts with it all functionalities of the simulator may be utilized to monitor its status such as internal states control its behaviors and log its execution traces.

Embodiments of the present invention include an integrated development environment configured to provide automation through the lifecycle of SVDs including creation analysis deployment run time control and testing. Such an integrated development environment is configured to provide a number of functions automatically. For example it may permit 1 creation compilation and debugging of SVDs 2 SVD transaction analysis enumerating possible types of transactions through SVDs 3 push a button deployment of SVDs into virtual machines 4 run time control of SVDs breakpoint step through in situ path prediction and randomized execution 5 incorporation of HD VD into SVD and 6 SVD test coverage report and automatic test generation.

An embodiment of an integrated development environment including three workflows e.g. SVD workflow HD VD workflow and SVD HD VD workflow is illustrated in . All the three workflows can be initiated from a user interface such as a VD Studio graphical user interface. A user interface may be viewed on an input output display interface . In certain embodiments a user interface is used to invoke a visual editor for each corresponding workflow namely SVD visual editor A and or HD VD visual editor B. The user may create and configure SVD and HD VD through the visual editor to create an SVD specification A or an HD VD specification B. Once the SVD specification A and or HD VD specification B is completed it is compiled into a SVD A and or HD VD B automatically using a compiler A B. The SVD A and HD VD B are then deployed into an environment such as a virtual machine or operating system or an embodiment of a virtual device module that may include a symbolic engine and or a design simulator . As the simulators execute the SVD A and HD VD B traces are captured and send to the bug report and coverage report generator in the support module . Test cases can also be generated and provided to the simulators to apply.

As noted above in various embodiments virtual devices may be used to develop a device driver for future use with a later developed physical device. However virtual devices may behave differently from physical devices due to design and implementation errors misunderstanding of design specifications and even the different level of details. It therefore may be beneficial to assess the conformance of a physical device with its virtual device and discover the inconsistencies.

Accordingly in various embodiments conformance assessment of a hardware device with its corresponding virtual device may be facilitated e.g. to localize any inconsistencies as illustrated in . This may permit symbolic execution of a virtual device with the same driver request sequence to a corresponding physical device and assessment of whether the physical device and its virtual device counterpart behave consistently. For example in various embodiments the driver requests sent to the physical device may be recorded the virtual device may be symbolically executed using the recorded request sequence and the observable states of the virtual device and physical device may be analyzed for inconsistencies.

Conformance assessment may address the limited observability of physical devices. A physical device may have internal states which are difficult to observe. Moreover the outside environment inputs of the physical device may also be difficult to capture. However using disclosed techniques physical device state transitions on the virtual device may be replayed to model the internal states and outside environment inputs using variables with symbolic values. In this way symbolic execution covers their possible values.

Conformance assessment may not suffer from the complexity of symbolic execution. As noted above the complexity of symbolic execution may be high due to path explosion. As will be explained further below to reduce resulting time and resource overheads a technique referred to herein as adaptive concretization may be employed to eliminate unnecessary symbolic variables a major factor contributing to the symbolic execution complexity.

In various embodiments conformance assessment may be implemented by a trace recorder and a conformance checker as illustrated in . Trace recorder may be configured to capture a driver request sequence to physical device and the physical device state before each driver request is issued. A sequence of such request state pairs may be referred to as a device trace. Trace recorder may produce a trace file that includes the captured device traces.

In some embodiments trace recorder may record every driver request. In other embodiments trace recorder may selectively record certain driver requests. In some embodiments trade recorder may only be capable of capturing a subset of all possible variables that together form a physical device state. For example in various embodiments some registers of physical device such as interface registers may be accessible to trace recorder . Other registers such as internal registers may not be accessible to trace recorder. In some such embodiments conformance checker may assign symbolic values to the inaccessible registers or more generally variables . The resulting physical device state may be referred to as a partial state. 

In various embodiments conformance checker may be configured to execute virtual device with the recorded driver request sequence from trace file determine whether physical device and virtual device are consistent and output an inconsistency record if inconsistencies are found.

In various embodiments conformance assessment may include initializing a state of virtual device by assigning the observable state of physical device before virtual device takes a first driver request. Then virtual device may be symbolically executed upon a driver request from the device trace. After virtual device consumes the driver request a consistency between virtual device and physical device may assessed. If an inconsistency is found it may be recorded and virtual device and physical device may be synchronized by setting the physical device state as the virtual device state. Otherwise virtual device may be synchronized by further constraining the virtual device states with the corresponding register values in the physical device state. Then conformance checker may receive the next driver request and repeat the executing checking and recording steps. The conformance checking process may terminate when it completes a trace file e.g. by finishing the last driver request in the sequence.

In various embodiments conformance checker may include a state checker component not shown which may receive a partial state of physical device and a set of symbolic states of virtual device as inputs. As noted above the partial state may be a symbolic state that may contain concrete values e.g. for accessible registers and symbolic values e.g. for inaccessible registers that together form all possible states of physical device . Each symbolic state of virtual device may contain a set of possible virtual device states. An inconsistency may be discovered if there is no intersection between the partial state and any symbolic state of the virtual device.

An algorithm that may be implemented in the state checker component may in various embodiments operate on a partial state P and the set of symbolic states of the virtual device G. G may contain several symbolic states S S . . . S. For each S G 

In order to compute P S expressions of P and Smay be constructed. Assume that the device state has the following variables var var . . . var. The values of the state variables of P may be defined as Val var Val var . . . Val var . In various embodiments the expression of P may be constructed as Expr P van Val var var Val var . . . var Val var . Similarly assuming that the constraints of Sis expressed as Cont S the expression of S Expr S may be constructed as follows var Val var var Val var . . . van Val var Cont S . By constructing the expressions of P and S testing whether P Sis non empty may be transformed to testing whether Expr P Expr S may be satisfied. An example algorithm for implementing this process is below 

Suppose a device state contains two variables a and b. In the partial state P there may be only one variable a which has the concrete value of 3. The symbolic value may represent the variable b. In the set of symbolic states of the virtual device there may be a symbolic state S a b 

After conformance checking synchronization steps may be employed. In various embodiments if an inconsistency was found during conformance testing the physical device state may be set as the virtual device state. Otherwise the new virtual device state may be a union of all non empty intersection of P and S since this union contains the possible virtual states consistent with the physical device state.

As described above certain embodiments of the present invention include a harness. A harness may be used in association with the conformance checking process as well. Non deterministic choices are used to enable non determinism in virtual devices such as QEMU virtual devices. Some input variables of the virtual device have unknown values. For example outside environment inputs of the virtual device are unknown as they are not captured from the physical device. These variables are initialized with symbolic values so that symbolic execution can cover the possible inputs from the outside environment. Capturing the hardware concurrency requires non deterministic executions of a loop where the module functions are invoked non deterministically. Such a loop is defined as the main loop of an execution harness. Theoretically symbolic execution needs to execute the loop until all states are explored. However this is not realistic for some embodiments as fix point computation in symbolic execution is expensive.

In various embodiments symbolically executing a module function of a virtual device often may have the same effect or a similar effect on the device state as executing it only once. For example receiving a packet and receiving multiple packets usually lead to the same effect on the device registers an interrupt is fired by setting one bit in the interrupt register. Therefore to efficiently capture the concurrency of module functions the loop bound may be set equal to the number of the module functions in the execution harness. This implementation of non deterministic interleaving may cover most of the device concurrency. Nevertheless it is possible to have false negatives as a boundary for the main loop may be set instead of non deterministic many executions.

False negatives may result in certain embodiments because the non deterministic interleaving by executing the main loop of the execution harness is bounded to a fixed number of times or because symbolic execution executes a loop in the virtual device that is not statically bounded a fixed number of times. However such false negatives are typically low because the loops in the virtual device and the main loop in the execution harness are bound to reflect physical device usage and accordingly cover most of the virtual device behaviors.

In various embodiments a conformance checking embodiment may be implemented as a kernel library such as a Linux kernel library. Linux device drivers may call kernel API functions to manipulate devices. For example a driver may call a function writel to write a long integer to a device register. The source code of these kernel functions may be instrumented so that the trace recorder is invoked to record the driver requests once the driver calls these functions to manipulate the device.

A conformance checking embodiment also may include a symbolic execution engine to symbolically execute the virtual device. Before execution a compiler such as an llvm gcc compiler may be used to translate the virtual device into an intermediate representation such as LLVM bitcode. A symbolic execution engine such as KLEE may be modified for state checking. The symbolic execution engine also may be modified to remove certain functions not used in certain embodiments for example generating test cases.

As was the case with test case generation symbolic execution during conformance checking may be vulnerable to path explosion. To reduce symbolic execution overhead in various embodiments a technique known as adaptive concretization may be used to eliminate unnecessary symbolic variables. When conformance checking reveals that a virtual device state is consistent with a corresponding physical device that may suggest that during execution of the virtual device few if any of the symbolic variables of the virtual device were accessed. In fact the values of the symbolic variables may not affect the conformance checking results most of the time. Therefore in various embodiments symbolic symbols may be adaptively concretized while introducing relatively few false negatives.

An example adaptive concretization process is illustrated in . In various embodiments a first round of the adaptive concretization may be referred to as a concretizing mode. In this mode virtual device may be concretized at block e.g. by directly assigning concrete random values to its symbolic variables. Conformance assessment similar to that illustrated in may then be conducted e.g. by a first conformance checker A. As input first conformance checker A may use a concretized virtual device A rather than general virtual device as well as trace file . In various embodiments first conformance checker A may be configured to output driver requests that reveal inconsistencies between concretized virtual device A and its counterpart physical device .

In various embodiments a second round of adaptive concretization may be referred to as a symbolic mode. In such a mode a second conformance checker B may be configured to perform a second round of conformance assessment using the original virtual device e.g. with symbolic variables . In various embodiments second conformance checker B may be configured to output inconsistency records . Because second conformance checker B may only perform conformance assessment using the driver requests output by first conformance checker A in the first round of conformance checking which as noted above are only those request that lead to inconsistencies complexity and resource usage of symbolic execution may be reduced. Inconsistencies discovered by second conformance checker B may be output in an inconsistency record as inconsistencies between the virtual device and the physical device. In various embodiments inconsistencies in inconsistency record may include virtual device bugs and or physical device bugs. By using adaptive concretization enumerating unnecessary states is avoided. This can reduce symbolic execution overheads significantly.

In embodiments in which the virtual device is concretized using adaptive concretization a state checking algorithm of the concretizing mode may be simplified. The state checker in the concretizing mode may check concrete states that do not have any variables with symbolic values and any symbolic constraints. Accordingly the state checker may not need to construct symbolic expressions for each state or invoke the solver to solve constraints. Instead the state checker may be configured to implement an algorithm an example of which is shown below to determine whether the observable states of the physical device are equal to the corresponding states of the virtual device. In the example below InterfaceRegisters may represent a set of interface registers variables located in the range of selective capturing 

Three real world network adaptors and their corresponding virtual devices provided with QEMU were assessed for conformance using techniques described herein.

Conformance assessment was performed using the physical devices and corresponding virtual devices described in TABLE IV above. As shown in the charts of fourteen inconsistencies were found between the three network adapters and their virtual device counterparts seven in the e1000 six in the bcm5751 and one in the eepro100. By analyzing the inconsistency reports generated by conformance checker ten bugs were discovered in the virtual devices and two bugs were discovered in the silicon devices. As the results in demonstrate most of these inconsistencies are caused by the bugs of the virtual devices. This may be attributable to the facts that these network adaptor devices are stable products which have gone through extensive testing and bug fixing procedures and that their virtual devices may not have been as rigorously tested. However such virtual device bugs may nonetheless appear in physical device prototypes particular during earlier stages of hardware development since these bugs are common violations of hardware designs. Accordingly the conformance assessment described herein may be implemented during various hardware development stages which may lead to the discovery of many inconsistencies caused by bugs in physical device prototypes.

We evaluate the time usages in the two rounds of conformance checking respectively. Table V below shows the results. Conc. and Symb. denote the concretizing mode and the symbolic mode respectively. Values in the Time Usage column are the average time usages for the conformance checker processing every one hundred driver requests of the device trace collected under the different test cases. The time usages of both concretizing mode and symbolic mode are not so great as to render the technique useless. However if adaptive concretization is not used while processing the driver requests the time usages may be quite large. For example take e1000 and Reset NIC test case. Using a native non adaptive concretized approach the time usage is 2363.41 seconds. In contrast the time usages achieved using adaptive concretization described herein shown in Table V are lower e.g. 8.22 seconds under the concretized mode and 119.6 seconds under the symbolic mode. These results demonstrate that adaptive concretization can significantly reduce the time usage of symbolic execution. Memory utilizations may be evaluated in a similar way time usages.

Computer system includes an input output display interface connected to communication unit such as a bus which forwards data such as graphics text and information from the communication unit or from a frame buffer not shown to other components of the computer system . The input output display interface may be for example a keyboard touch screen joystick trackball mouse monitor speaker printer any other computer peripheral device or any combination thereof capable of entering and or viewing data.

A computer system includes one or more processors which may be a special purpose or a general purpose digital signal processor that processes certain information. Computer system also may include a main memory for example random access memory RAM read only memory ROM mass storage device or any combination thereof. Embodiments of a computer system may also include a secondary memory such as a hard disk unit a removable storage unit or any combination thereof. Computer system may also include a communication interface for example a modem a network interface such as an Ethernet card or Ethernet cable a communication port a PCMCIA slot and card wired or wireless systems such as Wi Fi Bluetooth Infrared local area networks wide area networks intranets etc.

It is contemplated that the main memory secondary memory communication interface or a combination thereof function as a computer usable storage medium otherwise referred to as a computer readable storage medium to store and or access computer software including computer instructions. For example computer programs or other instructions may be loaded into the computer system such as through a removable storage device for example a floppy disk ZIP disks magnetic tape portable flash drive optical disk such as a CD or DVD or Blu ray Micro Electro Mechanical Systems MEMS nanotechnological apparatus. Specifically computer software including computer instructions may be transferred from the removable storage unit or hard disc unit to the secondary memory or through the communication unit to the main memory of the computer system .

Communication interface allows software instructions and data to be transferred between the computer system and external devices or external networks. Software instructions and or data transferred by the communication interface are typically in the form of signals that may be electronic electromagnetic optical or other signals capable of being sent and received by the communication interface . Signals may be sent and received using wire or cable fiber optics a phone line a cellular phone link a Radio Frequency RF link wireless link or other communication channels.

Computer programs when executed enable the computer system particularly the processor to implement the methods of the invention according to computer software including instructions.

The computer system described herein may perform any one of or any combination of the steps of any of the methods presented herein. It is also contemplated that the methods according to the invention may be performed automatically or may be invoked by some form of manual intervention.

The computer system of is provided only for purposes of illustration such that the invention is not limited to this specific embodiment. It is appreciated that a person skilled in the relevant art knows how to program and implement the invention using any computer system.

The computer system may be a handheld device and include any small sized computer device including for example a personal digital assistant PDA smart hand held computing device cellular telephone or a laptop or netbook computer hand held console or MP3 player tablet or similar hand held computer device such as an iPad iPad Touch or iPhone .

While the foregoing written description of the invention enables one of ordinary skill to make and use what is considered presently to be the best mode thereof those of ordinary skill will understand and appreciate the existence of variations combinations and equivalents of the specific embodiments and examples herein. The invention should therefore not be limited by the above described embodiments and examples but by all embodiments within the scope and spirit of the invention.

