---

title: Massive multi-player online (MMO) games server and methods for executing the same
abstract: Video server systems and methods for providing video streams to a plurality of remote clients are described. In one implementation, the video streams are based on game states received from a remote game server. The game states are dependent on game commands received by the video server system from the remote clients and forwarded to the remote game server. The video server system is configured to appear, from the point of view of the game server, as more than one client. For example, the video server system may receive game states from the remote game server at more than one different Internet Protocol address and each of these Internet Protocol addresses may be associated with a different game session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09656160&OS=09656160&RS=09656160
owner: Sony Interactive Entertainment America LLC
number: 09656160
owner_city: San Mateo
owner_country: US
publication_date: 20130607
---
This application claims priority and benefit of provisional patent application 61 656 787 entitled MMO Server and filed on Jun. 7 2012 which is herein incorporated by reference.

This application is related to U.S. non provisional patent application Ser. No. 12 790 955 entitled Game Execution Environment and filed May 31 2010 which claims benefit and priority to 

The invention is in the field of computer programming and specifically in the field of server side execution of computer programs.

Execution of computer programs can generally occur using one of two approaches. In one model the computer program is executed on a single device where input is received from a user such as a game player and program output is presented to the user. In the other model program execution occurs on a remote server under the control of one or more clients. A user provides inputs at the client and receives program output for display at the client. Communication between the client and the server takes place over a communication network such as the internet. As used herein the terms remote server remote client etc. are meant to indicate devices that are geographically remote e.g. in a different building different town or different state. The term remote is intended to exclude devices in the same room or building.

A dual mode model of program execution is used to provide both immediate execution play of a game and also client side rendering of video. Essentially immediate execution is achieved by initially rendering video on a server and providing the rendered video to the client over a communication network such as the internet. Client side game logic and related content are downloaded to the client in parallel with or following the rendered video. When all or a sufficient fraction of the client side software is received by the client the mode of program execution is changed such that rendering of video occurs on the client rather than or in addition to the server.

Essentially immediate execution is achieved because server side game logic and related components can be provisioned quickly or before a request is received to play a game. The output of the server side game logic includes a video stream rendered on the server in response to received game commands a game state and a point of view of one or more game player. This video stream is communicated to the client where it is presented to the game player in real time. To accomplish this the only logic required on the client is that needed to receive decode and display the video stream.

Various embodiments of the invention include a game system comprising a video source configured to provide a streaming video to a first client geographically remote from the video source the streaming video being generated at the video source and being based on a state of a computer program e.g. computer game state and a download manager configured to download executable code and other components of the computer program from a code source to the first client via a network while the streaming video is being provided to the first client from the video source. These embodiments optionally further comprise a state source configured to provide the state of the computer program to the first client.

Various embodiments of the invention include a game server comprising an input a game engine transition logic state storage and an output. The input is configured to receive game commands from a plurality of geographically remote clients and the game engine is configured to maintain a global state of a video game based on the received game commands and to provide different subsets of the global state of the video game to different members of the plurality of clients each of the subsets being assigned to a particular member of the plurality of clients respectively. The transition logic is configured to reassign one of the subsets of the global state from a first member of the plurality of clients to a second member of the plurality of clients the state storage is configured to store the global state and the output is configured to provide the subsets of the global states to the plurality of clients over the internet.

Various embodiments of the invention include a method of providing a computer game the method comprising executing game logic on a video server where the execution of the game logic results in rendering of a video stream based on a game state. The method further comprises providing the video stream from the video server to a client over a communication network and providing executable game content to the client in parallel with the video stream the executable game content being configured to generate video based on the game state.

Additionally the game logic and related content e.g. content used by the game logic can be divided into parts and these parts can be downloaded in essentially any order from the game system to the client. In various embodiments the parts are downloaded in an order that is based on the probabilities that the ongoing game play may require those parts. For example if in view of the current state of the game a particular part of the client side game logic and other content is likely to be required to support further game play then that part will be given high priority in a download sequence. The download sequence is optionally updated dynamically responsive to the game play and parts of the game logic and related content are downloaded to the client in parallel with streaming video until the amount of the game logic and related content downloaded to the client is deemed to be sufficiently to support game play on the client side in the client side mode. At that point game play can be transitioned to the client streaming video ceases and downloading of the game code can completed. After streaming video to the client ends the remaining parts of the game code can continue to be dynamically ordered and downloaded to the client according to that order responsive to the game state. Optionally if the complete game code has not been downloaded and the game state unexpectedly requires a part of the game code that has not yet been downloaded the game play can transition back to the server side mode.

Various embodiments of the invention include a game system comprising a video source and a download manager. The video source is configured to provide a streaming video to a client geographically remote from the video source the streaming video being generated at the video source responsive to a present state of a computer program. The download manager is configured to dynamically determine responsive to the present state of the computer program a download sequence of a plurality of parts of an executable code and other components jointly executable content or executable game content of the computer program. The download manager is further configured to download parts of the executable content according to the download sequence from a code source to the client via a network while the streaming video is being provided to the client from the video source. In various embodiments the video source includes the download manager. In various embodiments the download manager is configured to dynamically determine the download sequence by determining the probabilities of other states of the computer program based on the current state of the computer program. In some of these embodiments the game system further comprises a computer readable medium that stores a probability tree database and the computer readable medium is in communication with the download manager. In these embodiments the download manager is further configured to determine the probabilities of other states of the computer program based on the current state of the computer program by querying the probability tree database. In various embodiments the game system further comprises a statistics engine configured to maintain the probability tree database.

Various embodiments of the invention include a method of providing a computer game. In these embodiments the method comprises executing game logic on a video server in a server side mode of game execution to render a video stream based on a game state and providing the video stream from the video server to a client over a communication network. The method further comprises dynamically determining responsive to the game state a download sequence of a plurality of parts of an executable game content the executable game content being configured to generate video based on the game state and providing the parts of the executable game content to the client in parallel with the video stream according to the download sequence. In various embodiments dynamically determining the download sequence includes querying a probability tree database. In various embodiments the method further comprises determining a download rate for providing the parts of the executable game content to the client and in some of these embodiments determining the download rate includes monitoring a bandwidth of a communication channel to the client. In various embodiments the method further comprises initiating a transition from the server side mode of game execution to a client side mode of game execution in which game logic is executed on the client to render the video stream based on the game state. In some of these embodiments the method further comprises providing the parts of the executable game content to the client after initiating the transition and in still further embodiments providing the parts of the executable game content to the client after initiating the transition can be performed according to the download sequence. In still further embodiments after initiating the transition the method further comprises dynamically determining the download sequence responsive to the game state.

Various embodiments of the invention include a video server system comprising a video source configured to render game video based on a game state and a point of view using a game engine the game state received from a remote game server and including the positions of objects in a game environment the point of view being received from a first client using an internet protocol the game server and the first client being disposed at different locations the first client being remote relative to the video source an I O device configured to provide the rendered game video over a network to the first client in data packets storage configured to store video frames of the rendered game video and a processor configured to execute logic of the video source.

Various embodiments of the invention include a video server system comprising a video source configured to render game video using a game engine the rendering being based on graphics and a point of view the graphics being received from a remote game server the point of view being received using an internet protocol from a remote client an I O device configured to provide the rendered game video over a network to the remote client in data packets storage configured to store the graphics and a processor configured to execute the game engine.

Various embodiments of the invention include a video server system comprising a video source configured to receive game commands from at least a first client of the video source and a second client of the video source configured to forward the received game commands to a remote game server configured to render game video based on a game state using a game engine the game state being based on the game commands the game state being received from the remote game server and including the positions of objects in a game environment the video source the game server the first client and the second client each being remote relative to one another an I O device configured to provide the rendered game video over a network to the first client in data packets storage configured to store video frames of the rendered game video and a processor configured to execute logic of the video source.

Various embodiments of the invention include a method of executing a video game the method comprising receiving at a video server a game command from a first remote client forwarding the received game command to a first remote game server receiving a first game state from the first game server the first game state being based on game commands received by the first game server from a plurality of clients of the first game server the plurality of clients of the first game server including the video server generating a first 3D environment based on the first game state using a first game engine rendering the first 3D environment to a first video stream using a graphics processing unit and providing the first video stream to the first remote client.

Various embodiments of the invention include a method of executing a video game the method comprising receiving at a video server a first game command from a first client of the video server the first client being remote from the video server receiving at the video server a second game command from a second client of the video server the second client being remote from the video server and the first client forwarding the first game command to a remote game server forwarding the second game command to the remote game server receiving a first game state from the remote game server the first game state being based on the first game command receiving a second game state from the remote game server the second game state being based on the second game command generating a first 3D environment based on the first game state using a first game engine generating a second 3D environment based on the second game state using the first game engine or a second game engine rendering the first 3D environment to a first video stream using a graphics processing unit rendering the second 3D environment to a second video stream using a graphics processing unit providing the first video stream to the first client and providing the second video stream to the second client.

Various embodiments of the invention include simultaneously downloading executable game logic and streaming game video to the same client and or transitioning from a server side mode of game execution to a client side mode of game execution. These processes potentially involve several parties and systems. A video server system is configured to provide streaming video to a client via a network in response to game rules and received game commands. A download manager is configured to provide executable game logic and related content to the client in parallel with the provision of the streaming video. The client is configured to receive the executable game logic and content while displaying the streaming game video to a game player. Optionally a game server is configured to maintain a global game state of a multiplayer video game and to provide subsets of this game state to the video server system as well as other clients of the game server. The executable game logic can be provided by the game server the video server system or a third party system.

The server side mode is characterized by rendering of game video on a video server and provision of the rendered video to a geographically remote client. In this mode the game video is responsive to game commands received at the video server from the client via a communication network. The client side mode is characterized by rendering of game video on the client responsive to game commands entered locally to the client. The server side mode and the client side mode are not necessarily mutually exclusive. Game video is optionally rendered at both the video server and the client and displayed on the client in parallel or sequentially. Game commands are commands that are related to control or otherwise participate in a game.

Transition logic configured for managing the transition between server side mode and client side mode is optionally distributed among the above devices. For example on the client the transition logic can be configured to terminate display of the streaming game video receive a copy of a local game state and or initiate execution of the received executable game logic. On the video server system the transition logic can be configured to terminate delivery of the streaming game video provide the copy of the local game state to the client determine when sufficient executable game logic has been provided to the client to initiate the transition and or determine an order in which the executable game logic should be provided to the client. On the game server transition logic can be configured to redirect the communications including game commands and game state between the video server system and the game server such that these communications occur between the game server and the client. Further features of the transition logic are discussed elsewhere herein.

The Video Server System may be configured to provide the video stream in a wide variety of alternative video formats including formats yet to be defined. Further the video stream may include video frames configured for presentation to a game player at a wide variety of frame rates. Typical frame rates are 30 frames per second 60 frames per second and 120 frames per second although higher or lower frame rates are included in alternative embodiments of the invention. In some embodiments Video Server System is configured to provide three dimensional video data e.g. matched video streams rendered from points of view separated by the distance between a person s eyes.

In some embodiments Video Server System is configured to render video based on two points of view. These points of view can be stereoscopic viewpoints of a single player different viewpoints of a single player or viewpoints of different players. For example when Video Server System includes a server side emulation of a multi player game console the resulting video may be split into two or more parts each including content based on a different player s point of view.

Clients referred to herein individually as A B etc. may include terminals personal computers game consoles tablet computers telephones televisions set top boxes kiosks wireless devices digital pads stand alone devices handheld game playing devices and or the like. Typically Clients are configured to receive encoded video streams decode the video streams and present the resulting video to a game player e.g. a player of a game. The processes of receiving encoded video streams and or decoding the video streams optionally includes storing individual video frames in a receive buffer of the client. The video streams may be presented to the game player on a display integral to Client or on a separate device such as a monitor or television. Clients are optionally configured to support more than one game player. For example a game console may be configured to support two three four or more simultaneous players. Each of these players may receive a separate video stream or a single video stream may include regions of an image portion generated specifically for each player e.g. generated based on each player s point of view. Clients are optionally geographically dispersed. The number of clients included in Game System may vary widely from one or two to thousands tens of thousands or more. As used herein the term game player is used to refer to a person that plays a game and the term game playing device is used to refer to a device used to play a game.

Clients are configured to receive video streams via Network . Network may be any type of communication network between computing devices including a telephone network the Internet wireless networks power line networks local area networks wide area networks private networks and or the like. Network explicitly does not include communication channels completely within a computing device such as a motherboard bus. In typical embodiments the video streams are communicated via standard protocols such as TCP IP or UDP IP. Alternatively the video streams are communicated via proprietary protocols.

A typical example of Clients is a personal computer comprising a processor non volatile memory a display decoding logic network communication capabilities and input devices. The decoding logic may include hardware firmware and or software stored on a computer readable medium. Systems for decoding and encoding video streams are well known in the art and vary depending on the particular encoding scheme used.

Clients may but are not required to further include systems configured for modifying received video. For example a client may be configured to perform further rendering to overlay one video image on another video image to crop a video image and or the like. Clients may be configured to receive various types of video frames such as I frames P frames and B frames and to process these frames into images for display to a game player. In some embodiments one or more members of Clients are configured to perform further rendering shading conversion to 3 D or like operations on the video stream. A member of Clients is optionally configured to receive more than one audio or video stream. Input devices of Clients may include for example a keyboard a joystick a pointing device a force feedback device a motion and or location sensing device a mouse a touch screen a neural interface a camera input devices yet to be developed and or the like.

The video stream and optionally audio stream received by Clients is generated and provided by Video Server System . As is described further elsewhere herein this video stream includes video frames and the audio stream includes audio frames . The video frames are configured e.g. they include pixel information in an appropriate data structure to contribute meaningfully to the images displayed to the game player. A meaningful contribution is a contribution that is readily observable by a game player. As used herein the term video frames is used to refer to frames including predominantly information that is configured to contribute to e.g. to effect the images shown to the game player. Most of the teachings herein with regard to video frames can also be applied to audio frames. Clients may be configured to receive more than one video stream at the same time. For example Client B may be configured to receive a matched pair of video streams configured to form a three dimensional image when one of the streams is presented to one eye and the other stream is presented to the other eye. Client B is optionally configured to receive a first video stream from a first source a second video stream from a second source and to overlay these two video streams for presentation to a game player.

Clients are typically configured to receive inputs from one or more game player. These inputs may include game commands configured to change the state of the video game or otherwise affect game play. The game commands can be received using input devices and or may be automatically generated by computing instructions executing on Clients . The received game commands are communicated from Clients via Network to Video Server System and or Game Server . For example in some embodiments the game commands are communicated to Game Server via Video Server System . In some embodiments separate copies of the game commands are communicated from Clients to Game Server and Video Server System . The communication of game commands is optionally dependent on the identity of the command. Game commands are optionally communicated from Client B through a different route or communication channel that that used to provide audio or video streams to Client B. For example a game command can be received from a wireless device such as a cellular telephone and the audio and or video streams can be provided to a display such as a television set. The wireless device and the display do not need to communicate directly. In this example Client B comprises two separate devices. The commands from the cellular telephone may pass through a cellular telephone network or a wireless router. In some embodiments game commands communicated from members of Clients to Video Server System are forwarded to Game Server . The game commands are optionally mapped to different representations e.g. converted to a different form prior to being forwarded. For example a move right command may be converted from one to another digital representation. Clients are optionally remote from each other.

In various embodiments Clients are configured to communicate add on data between each of Client and Video Server System or between different members of Clients . For example an add on that enables voice communication directly between clients can include the communication of audio data between clients. Add on data that augments the functionality of a server side computer program may be stored on one of Clients for use by a server side add on or for use by a client side add on. Add on data may also be stored on Video Server System or a separate add on server and be used by add ons located on one of Clients Video Server System or the add on server.

Game Server is optionally operated by a different entity than Video Server System . For example Game Server may be operated by the publisher of a multiplayer game. In this example Video Server System is optionally viewed as a client by Game Server and optionally configured to appear from the point of view of Game Server to be a prior art client executing a prior art game engine. Video Server System is optionally configured to appear as two or more different clients of Game Server . Communication between Video Server System and Game Server can occur via Network . As such Game Server can be a prior art multiplayer game server that sends game state information to multiple clients one or more of which is Video Server System . The game state is thus optionally based on game commands and or game state information received by Game Server from multiple game players using clients of Game Server that are remote from each other. Video Server System may be one two or more of these clients of Game Server . As such Video Source may be configured to receive a plurality of game states from one or more Game Server and to generate a separate video stream based on each of the plurality of game states respectively. These game states may be dependent on game commands forwarded to Game Server from Video Server System . For example a game state received from Game Server and used to generate game video provided to Client A may be based on game commands received from Client A and optionally also on game commands received from Client B Likewise a game state received from Game Server and used to generate game video provided to Client B may be based on game commands received from Client B and optionally also game commands received from Client A.

Video Server System may be configured to communicate with multiple instances of Game Server at the same time. For example Video Server System can be configured to provide a plurality of different video games to different game players. Each of these different video games may be supported by a different Game Server and or published by different entities. As such Video Server System is optionally concurrently a client to two different Game Servers . In some embodiments several geographically distributed instances of Video Server System are configured to provide game video to a plurality of different game players. Each of these instances of Video Server System may be in communication with the same instance of Game Server . Communication between Video Server System and one or more Game Server optionally occurs via a dedicated communication channel. For example Video Server System may be connected to Game Server via a high bandwidth channel that is dedicated to communication between these two systems. Multiple game states or subsets of a global game state may be provided to Video Source from Game Server . Each of these game states may be used to render a separate game video stream respectively. The received subsets are typically the result of game commands received from multiple game players and or multiple Clients . Video Server System is optionally configured to appear as two or more different clients of Game Server . As discussed elsewhere herein this can be accomplished by using different internet protocol IP addresses for different game sessions.

Video Server System comprises at least a Video Source an I O Device a Processor and non transitory Storage . Video Server System may consist of one computing device or be distributed among a plurality of computing devices. These computing devices are optionally connected via a communications system such as a local area network.

Video Source is configured to provide a video stream e.g. streaming video or a series of video frames that form a moving picture. In some embodiments Video Source is also configured to provide an audio stream. In some embodiments Video Source includes a video game engine and rendering logic. The video game engine is configured to receive game commands from a player and to maintain a copy of the state of the video game based on the received commands. This game state includes the position of objects in a game environment as well as typically a point of view. The game state may also include properties images colors and or textures of objects. The game state is typically maintained based on game rules as well as game commands such as move turn attack set focus to interact use and or the like. The game state optionally includes information regarding the geographical positions of objects in the real world. These may include the positions of Client A Client B or other clients of Video Source . As such the rendering environment used for the rendering and or resulting video can be dependent on the positions or orientations of one or more of Clients . In one example Client A is a tablet computing device and the rendering is dependent on the orientation of the tablet as held by a game player. Changes in this orientation can result in changes in the resulting video. In another example the 3D environment used in rendering includes a different set of objects if Client A is located in San Francisco instead of Palo Alto. In another example the 3D environment textures advertisements and or other inputs to the rendered video may be different if Client A is in the stands of a San Francisco Giants baseball game as compared to being in the stands at a San Jose Sharks hockey game. The state information received by Video Source and used to generate game video optionally includes the geographic locations of multiple members of Clients .

Part of the game engine is optionally disposed within Game Server . Game Server may maintain a copy of the state of the game based on game commands or game state subsets received from multiple players using geographically disperse clients. In these cases the game state is provided by Game Server to Video Source wherein a copy of the game state is stored and rendering is performed. Game Server may receive game commands directly from one or more Clients via Network and or may receive game commands via Video Server System .

In some embodiments Game Server is configured to provide other information to Video Source as further discussed in U.S. Pat. No. 8 147 339. This other information is optionally used for generating rendered video and can include graphics time shifted video live video audio the locations of objects in the real world the occurrence of events in the real world still images shadows bitmaps lighting patterns texture and or other graphics. For example live video may be included as part of video streams generated by Video Source and communicated to one or more of Clients . In another example texture image data may be provided by Game Server to Video Source wherein the texture image data is included in rendered video.

Multiple game states or subsets of a global game state may be provided to Video Source from Game Server . Each of these game states may be used to render a separate game video stream respectively. The received subsets are typically the result of game commands received from multiple game players and or multiple Clients .

In some embodiments Video Source receives game commands from multiple Clients . These game commands are forwarded to Game Server in association with different game sessions. The forwarded game commands may appear to come from different clients of Game Server . At Game Server the game commands are used to update a global game state. Subsets of this global game state are then provided to Video Source optionally using different IP addresses. Thus the plurality of game states used to render a plurality of separate game video streams are based on game commands received from different Clients respectively and forwarded to Game Server .

In other embodiments Video Source is configured to execute a multiplayer console game. A multiplayer console game is a game that can be played on a game console by several players each player using a game controller local to the game console. For example a console game may include a version of Mario Kart configured to be played by two or more players in the same room on a Nintendo console and Wii game controllers. In these embodiments game commands are received from two or more remote Clients and provided to a game engine e.g. game logic for the multiplayer console game. The game engine can be configured to receive game commands from a plurality of local game controllers. Video Source is optionally configured to convert the received commands to a form that would be expected from a local game controller before providing the received game commands to the game engine. These game commands are optionally also forwarded to Game Server in association with one or different game sessions. The forwarded game commands from the two or more clients may appear to come from different Internet Protocol addresses or from one Internet Protocol address. Likewise the forwarded game commands from the two or more clients may be associated with one or different game sessions. They may even be forwarded in together in a single data packet. In these embodiments Video Source is optionally configured to appear as a multi player game console from the point of view of Game Server . As such the communications and format of these communications that Game Server receives from Video Source are configured to be compatible with what Game Server would expect to receive from an actual game console. The game commands are optionally forwarded as an update to a game state. At Game Server the game commands are used to update a global game state. Subsets of this global game state are optionally provided from Gamer Server to Video Source optionally using either one or different IP addresses.

Video Source typically includes rendering logic e.g. hardware firmware and or software stored on a computer readable medium such as Storage . This rendering logic is configured to create video frames of the video stream based on the game state. All or part of the rendering logic is optionally disposed within a graphics processing unit GPU . Rendering logic typically includes processing stages configured for determining the three dimensional spatial relationships between objects and or for applying appropriate textures etc. based on the game state and viewpoint. The rendering logic produces raw video that is then usually encoded prior to communication to Clients . For example the raw video may be encoded according to an Adobe Flash standard .wav H.264 H.263 On2 VP6 VC 1 WMA Huffyuv Lagarith MPG x. Xvid. FFmpeg x264 VP6 8 realvideo mp3 or the like. The encoding process produces a video stream that is optionally packaged for delivery to a decoder on a remote device. The video stream is characterized by a frame size and a frame rate. Typical frame sizes include 800 600 1280 720 e.g. 720p 1024 768 although any other frame sizes may be used. The frame rate is the number of video frames per second. A video stream may include different types of video frames. For example the H.264 standard includes a P frame and an I frame. I frames include information to refresh all macro blocks pixels on a display device while P frames include information to refresh a subset thereof. P frames are typically smaller in data size than are I frames. As used herein the term frame size is meant to refer to a number of pixels within a frame. The term frame data size is used to refer to a number of bytes required to store the frame.

In alternative embodiments Video Source includes a video recording device such as a camera. This camera may be used to generate delayed or live video that can be included in the video stream of a computer game. The resulting video stream optionally includes both rendered images and images recorded using a still or video camera. Video Source may also include storage devices configured to store previously recorded video to be included in a video stream. Video Source may also include motion or positioning sensing devices configured to detect motion or position of an object e.g. person and logic configured to determine a game state or produce video based on the detected motion and or position.

Video Source is optionally configured to provide overlays configured to be placed on other video. For example these overlays may include a command interface login instructions video frames rendered from another game player s point of view messages to a game player images of other game players video feeds of other game players e.g. webcam video . In embodiments of Client B that include a touch screen interface the overlay may include a virtual keyboard joystick touch pad and or the like. In one example of an overlay a player s voice is overlaid on an audio stream. Video Source optionally further includes one or more audio sources.

In embodiments wherein Video Server System is configured to maintain the game state based on input from more than one player each player may have a different point of view comprising a position and direction of view. Video Source is optionally configured to provide a separate video stream for each player based on their point of view. Further Video Source may be configured to provide a different frame size frame data size and or encoding to each of Client . Video Source is optionally configured to provide 3 D video.

I O Device is configured for Video Server System to send and or receive information such as video commands add ons add on data requests for information a game state client identities player identities game commands security information audio data and or the like. I O Device typically includes communication hardware such as a network card or modem. I O Device is configured to communicate with Game Server Network and or Clients . I O Device is configured to receive the information from more than one of Clients . I O Device is optionally configured to receive the information as packets using a standard such as TCP or UDP. I O Device optionally includes a plurality of communication hardware. For example I O Device may include two or more network cards.

I O Device is optionally configured to have more than one IP address. As such I O Device can send game commands game states or other information listed in the paragraph above to Game Server in a manner such that Game Server sees the information as coming from two or more different IP addresses or two or more different clients of Game Server . Likewise I O device can receive the information listed above in data packets addressed to two or more different IP addresses. As such Video Server System can appear to be two or more different clients of Gamer Server . Each of these clients or IP addresses may be associated with a different game session and thus received different game state subsets from Game Server . In some embodiments I O Device is configured to forward game commands received from different Clients to Game Server using different IP address such that the commands are seen by Game Server as coming from different clients of Game Server as part of different game sessions.

Video Server System optionally further comprises a Client Qualifier . Client Qualifier is configured for remotely determining the capabilities of a client such as Clients A or B. These capabilities can include both the capabilities of Client B itself as well as the capabilities of one or more communication channels between Client B and Video Server System . For example Client Qualifier may be configured to test a communication channel through Network .

Client Qualifier can determine e.g. discover the capabilities of Client B manually or automatically. Manual determination includes communicating with a game player of Client B and asking the game player to provide capabilities. For example in some embodiments Client Qualifier is configured to display images text and or the like within a browser of Client B. The displayed objects represent request that the game player enter information such as operating system processor video decoder type type of network connection display resolution etc. of Client B. The information entered by the game player is communicated back to Client Qualifier .

Automatic determination may occur for example by execution of an agent on Client B and or by sending test video to Client B. The agent may comprise computing instructions such as java script embedded in a web page or installed as an add on. The agent is optionally provided by Client Qualifier . In various embodiments the agent can find out processing power of Client B decoding and display capabilities of Client B lag time reliability and bandwidth of communication channels between Client B and Video Server System a display type of Client B firewalls present on Client B hardware of Client B software executing on Client B registry entries within Client B whether Client B is connected via a wireless router and or the like.

Client Qualifier includes hardware firmware and or software stored on a computer readable medium. Client Qualifier is optionally disposed on a computing device separate from one or more other elements of Video Server System . For example in some embodiments Client Qualifier is configured to determine the characteristics of communication channels between Clients and more than one instance of Video Server System . In these embodiments the information discovered by Client Qualifier can be used to determine which instance of Video Server System is best suited for delivery of streaming video to one of Clients .

Download Manager is configured to manage the downloading of executable game content to Client B. This downloading occurs in parallel with the display to a game player of game video provided by Video Source to Client B. More than one of Clients may each simultaneously receive both streaming game video and executable game content. Downloading code parallel to streaming video means that packets of executable game content are communicated to Client B at the same time as or between packets of the streaming game video. Download Manager includes hardware firmware and or software stored on a computer readable medium and Download Manager can be distributed among one or more devices. The executable game content is configured for execution on Client B and when executed to generate video based on a game environment for display to a game player.

In some embodiments both game video and executable game content are provided to Client B in a same data packet. For example a packet may include a video frame of one of the various possible types and data that is part of the executable game content. The executable game content is optionally inserted into the packet by Encoder A or Post Processor prior to delivery to I O Device . In some embodiments Encoder A or Post Processor is configured to examine packets including a video frame calculate how much more data can be placed in the packet and insert executable game content to fill remaining space in the packet. A preferred packet size is optionally used to make this calculation. At Client B the packet is parsed and the video frame is decoded separately from the executable game content.

Download Manager manages the downloading of executable game content in part by controlling the rate e.g. Mbits second at which the executable game content is downloaded. This rate is dependent on the size of the data packets including the game code and the frequency at which these data packets are sent. Either of these factors can be varied to select a rate. The rate is selected based on 1 the available bandwidth of the communication channel between Video Server System and Client B and 2 the fraction of this bandwidth used to provide the streaming game video. For example if the bandwidth of the communication channel is 15 Mb sec and 10 Mb sec is required to provide the streaming game video at a desired quality then the rate at which the executable game content is downloaded will be limited to 5 Mb sec. Generally if X Mb sec bandwidth is available and Y Mb sec is used for the streaming video Download Manager will limit the rate at which the executable content is downloaded to be less than X Y Mb sec. Download Manager will reduce the rate at which the executable game content is downloaded relative to a maximum possible rate so that the streaming game video is received by client B with the desired level of quality e.g. a desired reliability at a given resolution color depth and frame size etc. Communicating the streaming video is given priority over downloading the executable game content.

Because the bandwidth of the communication channels between Video Server System and different members of Clients can have different bandwidths the rate at which the same executable game content is downloaded to these different members of Clients can be different. Further even if communication channels have the same bandwidths the rates at which executable game content is downloaded may be different if the rates at which streaming game video is downloaded to each of the Clients are different. For example if Client A receives streaming video of a first frame size and Client B receives streaming video of a second frame size the rate at which they received executable game content can be different even if their respective communication channels have the same bandwidth.

The rate at which executable game content is downloaded from Video Server System to Client B can be dynamically varied over time. For example if the bandwidth of the communication channel drops Download Manager may reduce the rate at which executable game content is downloaded to Client B in response to this drop. The drop in bandwidth is sometimes detected by monitoring for lost packets. In some embodiments Download Manager is configured to automatically reduce the rate at which the executable game content is downloaded if executable game content packets and or streaming video packets are lost. The rate at which the streaming game video is communicated can be held constant while the rate at which executable game content is downloaded is reduced. For example if reducing the rate at which streaming game video is communicated would cause the quality of the video presented to a game player to drop below a minimum quality then the rate at which executable game content is downloaded will be reduced before reducing the rate at which the streaming game video is communicated. The ratio of executable game content to streaming game video communication rates is thus reduced.

The rate at which executable game content is downloaded can be increased as well as decreased during the download process. For example after a temporary reduction in communication channel bandwidth the rate can be incrementally increased to test whether a higher download rate is possible. If packets are lost then the download rate is again lowered a bit. Using this approach optimum download rates can be found even when the bandwidth of the communication channel varies with time. In some embodiments the downloading of executable game content begins by starting at a relatively slow download rate and increasing the download rate until packets are lost. At this point the rate at which the executable game content is downloaded is reduced until packet loss reaches an acceptable level.

In some embodiments Download Manager is configured to receive an estimate of the available bandwidth between Video Server System and Client B. This available bandwidth can be determined using testing discussed elsewhere herein and may include more than one communication channel. For example an estimate of the available bandwidth can be received from Client Qualifier . Packets of the executable game content are optionally downloaded via a different communication channel than the streaming game video. These different communication channels may have some segments in common. For example the executable game content may be downloaded from a Code Source while the streaming game video is communicated from Video Source . Code Source is optionally disposed at a location geographically remote from Video Source . Thus the executable game content may pass through different segments of Network relative to the streaming game video. Even if some segments are different the executable game content and streaming game video may both pass through other segment s of Network e.g. the final segment connecting Network and Client B.

Depending on which segments of Network limit the bandwidth of the communication channels through which the executable game content and streaming game video are communicated it is sometimes possible to communicate and download more total bytes than would be possible through just one channel. For example if a first communication channel through which the streaming game video is communicated is limited to a bandwidth of X Mbits sec by a segment that is not used to download the executable game content then the total amount of bytes of both the streaming game video and the executable game content that can be downloaded will be greater than X Mbits sec. It is sometimes possible to increase the rate at which the executable game content is downloaded until either the bandwidth of a second communication channel used to download the executable game content is reached or the capacity of a segment of Network shared by both the first and second communication channel is reached. The rate at which the executable game content is downloaded can be increased until either packets of the executable game content or packets of the streaming game video are dropped too frequently. This rate is then reduced to an optimum value at which no or an acceptable amount of packets are dropped. The determination of optimum communication and download rates can be managed using Download Manager and or Client Qualifier .

Code Source includes a storage device such as a hard drive and or solid state memory configured to store the executable game logic and optionally related content. Code Source is optionally disposed in a location geographically distant from other parts of Video Server System . For example a single instance of Code Source in a first location can be shared by more than one Video Server System located in more than one different location. In these embodiments Code Source is configured to provide multiple copies of executable game content game logic and related content to different members of Clients in parallel each copy sometimes being provided in parallel with streaming game video provided to the same members of Clients . Code Source is optionally included in and or managed by the same party as Game Server . Code Source is optionally configured to provide executable game content for more than one video game title. The executable game content optionally includes add ons and or add on data.

In some embodiments all or parts of Code Source is distributed among some multiple devices optionally including members of Clients . In these embodiments all or parts of the executable game content can be provided from one of Clients to another of Clients on a peer to peer basis. For this purpose the testing and monitoring of communication channels described in relation to communication between Code Source and Video Source as part of Video Server System can also be applied to communication channels between members of Clients . For example parts of the executable game content received by Client B can be received from Video Server System Client A and or a Client C not shown . In some instances the relative proximity e.g. network distance of Client A and Client B may be much closer than the proximity of Client B and Video Server System . The peer to peer communication channels may therefore be preferred. The selection of which parts of the executable game content are received from which source is optionally made to optimize the delivery to Client B. When delivering from peer to peer the burden on each peer may be reduced by using more than 3 5 or 10 more peers as sources. Download Manager is optionally configured to manage the peer to peer communication. Video may also be generated and or delivered on a peer to peer basis.

Download Manager is optionally configured to manage the order in which the executable game content is downloaded. For example the order in which the executable game content is downloaded can be changed in response to a state of the video game stored on Video Server System or Client B. Download Manager is optionally configured to monitor this state while the game is executed in either streaming and or client side modes.

Download Manager is further configured to manage downloading of a game state to Client B. This game state is the game state used by Video Source to generate the streaming game video. The game state can be downloaded from an optional State Source or from Game Server . In some embodiments once an initial state is downloaded Download Manager is further configured to download updates such that two copies of the game state are maintained. For example one copy of the game state can be stored at State Source and used by Video Source while a second copy of the game state is maintained on Client B.

State Source includes storage such as a hard drive and or solid state memory configured to store a state of a video game. The stored state is optionally a subset of a global game state stored at Game Server and is typically updated based on commands received from members of Clients and or state updates received from Game Server .

Download Manager is optionally further configured to monitor the progress of the download of the executable game content and to initiate execution of the downloaded code on Client B using a Transition Logic . The initiation can occur when an executable subset of the executable game content is downloaded or when all of the executable game content is downloaded. Download Manager is typically configured to detect when one or both of these conditions are met.

The initiation can be automatic or manual. Automatic initiation is performed by Transition Logic and without requiring any action by a game player of Client B while manual initiation requires some action by the game player. In automatic initiation commands are sent from Transition Logic A to Transition Logic C on Client B that cause the executable game content to install and or start. Not all types of Client necessarily allow remote automatic initiation of program execution for security reasons.

In manual initiation a game player takes some action to start or permit the execution of the downloaded executable game content. For example the game player may click on a button that allows execution of an installation program that installs the executable game content sets configuration and data files and or starts execution of the game code once installed. This is a minimal interaction case in which the game player merely needs to make a single click. In other embodiments a game player must first initiate an installation of a game client from the downloaded executable game content answer configuration questions during the installation enter a license key manually initiate execution of the installed game client and or the like. In various embodiments any combination of these tasks may or may not be required of the game player.

In some embodiments manual initiation of the execution of the downloaded executable game content is facilitated by controls presented to the game player through the same browser window as the streaming game video is displayed. For example an initiation button can be presented to the game player as part of an overlay placed on the game video or an initiation button can be displayed in another part of the same browser window as the streaming game video is shown. The streaming game video and the initiation control are optionally in different frames of the browser window.

In some embodiments a game player is given control over when execution of the downloaded code is initiated. For example a message may be displayed to a game player stating that game play must be transitioned from server side mode to client side mode within a predetermined time e.g. 5 minutes. This message may be displayed as an overlay or may be displayed elsewhere in the browser window in which the streaming video is displayed or may be displayed in a separate window. The message can include a button allowing the game player to initiate the transition at a time of their choosing within the predetermined time. The message optionally counts down the predetermined time. At the end of this time the streaming game video is no longer provided to the client although alternative content not including a real time game play may be provided. In some embodiments initiation of execution of the downloaded executable game content on Client B requires that a game player manually terminate receipt of the streaming game video manually perform an installation of a game client based on the executable game content and then manually initiate execution of the game client. The game player is optionally given the predefined period of time in which to manually perform all or part of this transition.

In some embodiments permission to begin downloading is received from the game player and this permission is also used to initiate execution of both installation routines and the video game client. For example a message can be presented to the game player requesting permission to download the executable game content and also execute the downloaded code when ready. This control can be presented through the control presentation approaches discussed elsewhere herein. The control can be presented once a game player requests the game once the communication of streaming game video starts or sometime after the streaming game video is presented to the game player. For example in various embodiments downloading of executable game content only occurs after a predetermined time delay after a specific game state is reached after a player advances to a certain stage in the game after a player saves a game state and or the like. A request for permission to begin downloading and or to initiate execution of the executable game content is optionally accompanied by an option to purchase the game. For example initiation of downloading and or initiation of execution may require a payment.

In some embodiments downloading of the executable game content does not begin until delivery of the streaming game video has been terminated by a game player. For example Download Manager may be configured to offer a game player to download the executable game content once the game player stops playing the game. Thus in one embodiment the game player may play the game in server side mode for 30 minutes or some other time period and then exit the game. Upon exiting the game the game player is offered an opportunity to purchase the game. If the game player accepts the executable game content is downloaded. The order of the download is optionally dependent on what the game player has done in the game while in the server side mode. For example executable game content needed to support a current location of a game player s avatar may be downloaded first.

The game player may or may not decide to resume the game while this download is in progress. If the game player decides to resume the game then Download Manager is configured to first determine if an executable subset or all of the executable game content has already been downloaded. If the executable subset or all of the executable game content has been downloaded then the downloaded game code is executed. If the executable subset or all of the executable game content has not been downloaded then the game is again executed in the streaming mode. Further executable game content may or may not be downloaded while the game is again played in server side mode. Periods of server side mode play can be interspersed with periods of downloading as the game player engages in multiple game sessions over time.

In some embodiments it may be found that what was thought to be an executable subset of the game code is not sufficient for a game player to play the game. For example if the game player directs an avatar into a higher level region of the game before support for that region has been downloaded the client side mode of the game may be interrupted. Download Manager is optionally configured to revert to server side mode execution of the game if this occurs. In this case the various transition steps described herein can be performed in reverse.

While the receipt of streaming game video does not typically initially require that the game player have an account registered before controlling an avatar receiving the streaming game video receiving the game code saving a game state resulting from the game player s actions in the game and or transitioning from server side mode to local execution mode typically do require an account. The account can be established automatically or by the game player. In some embodiments Game Server sometimes requires an account in order to play a multiplayer game. In these embodiments an instance of Account Manager within Video Server System or elsewhere within Game System may establish a temporary account meeting the requirements of Game Server . For example Account Manager may be configured to automatically generate a user name password geographic location and or the like. This account information is then used to establish a game session between Video Server System and Game Server . This game session is used to communicate game commands and game state information between Video Server System and Game Server . Because of Account Manager a game player can start playing a server based video game before any account information is provided by the game player. Account information may be gathered from the game player over time at a particular point in the game when the player tries to save the status of a game or when local execution of the game is initiated. For example a game player may be asked to establish a user name and password after the game player has played for 5 10 or 15 minutes when a game player reaches a predetermined game level or game state when a game player attempts to save a game state and or the like. The game player may also be asked to pay for the game when establishing account information. A request to establish an account is optionally presented as an overlay on the streaming video or optionally elsewhere on the same browser window as the streaming game video is presented.

In some embodiments when switching between server side rendering of game video server side mode and client side rendering of game video client side mode of the game Transition Logic A is configured to provide account information received by Video Server System from Client B to Game Server . Transition Logic B uses this account information to replace account information that was automatically generated by Account Manager . For example when a game player first initiates a streaming video game Account Manager may provide Game Server with a randomly generated user name SLE4IF45FFK1 and password kalLI28Iup . Prior to transition between server and client execution modes a user name EmmaP and password 4mybutterfly selected by the game player is received by Video Server System . Around the time of transition the game player selected account information is sent from Transition Logic A to Transition Logic B and these values are used by Transition Logic B to replace the automatically generated account data in the memory of Game Server . Thus game player selected account information replaces the temporary account information automatically generated by Video Server System .

In some embodiments the account information automatically generated by Video Server System further includes a server selection player referral information a geographical location and or the like. Player referral information is information regarding how a player was introduced to a game. A player may be introduced by a website an advertisement a marketing program another game player etc. In these cases the referral information typically includes an identity of the referrer. For example a link configured to allow a first game player to play a streaming video game may be displayed on a page of a second game player on a social networking website. An identifier of the second player or avatar thereof can be included within the link and Video Server System is configured to use this identifier to identify the second player. The identity of the second player can be used by Account Manager or Game Server to give the second player credit for referring the first player. Further the identity of the second player can be used by Game Server to place the first player on a same game server avatar faction location in a game environment etc. as the second player. These are further examples of account information that is optionally generated by Video Server System .

In a more specific example a copy of the streaming game video or a frame thereof from the game World of Warcraft is provided by Video Source to the first player at Client B is provided to the FaceBook page of the first player. This copy of the streaming game video is associated on the page with a link configured to allow the second player to join the first player in playing World of Warcraft. When the link is clicked by the second player an identifier is sent to an instance of Video Server System . Account Manager uses this identifier to look up the World of Warcraft server player faction Horde or Alliance and optionally location within the World of Warcraft game space of the first player. Account Manager uses this information to automatically generate or suggest account information for the second player that places the second player on the same World of Warcraft server and player faction as the first player. Account Manager may also provide information to Game Server identifying the first player as having referred the second player. Thus the first player can get credit for bringing the second player into the game.

Some of the account information communicated from Video Server System to Game Server by Account Manager is generated during game play. For example during game play a game player may associate add ons with an account or establish avatars. This information can be communicated to where it is needed for client side execution mode as it is generated when the game is next saved as part of a periodic communication event and or the like.

Transition Logic is optionally configured to communicate other information between elements of Game System . For example installed add on code and generated add on data may be transferred to Client B from Video Server System or elsewhere in Game System . This transfer may occur at the time of transition or prior to transition. In some embodiments generated add on data and or add on code is copied to Client B in parallel with the communication of streaming game video from Video Source to Client B.

A game player s account information optionally includes an IP Internet Protocol address to which Game Server provides game state information. This IP address may be different for different login sessions. For example each time a game player logs into play the video game provided by Game Server Video Source may be provided a different IP address. Likewise Client B may have a different IP address for each session in which it receives streaming game video from Video Source . In the prior art the IP address to which Game Server sends game state information does not change within an individual game session. If the IP address changes the game player must login again or start from some initial state to start a new game session. In this way the IP address is associated with a game player authenticated by the login. Likewise when game commands are received by Game Server the IP address from which the commands are sent is used to assign the commands to a specific game session game player.

In some embodiments of the invention the IP address to which Game Server sends game state information and from which game commands are received are changed within a single game session. For example when the transition between streaming game mode and local game mode is performed Game Server switches from sending game state information to and receiving game commands from Video Source to sending the game state information and receiving the game commands from Client B. This is optionally accomplished without requiring that the game player login again.

To change the IP address Transition Logic A sends the client IP address that Video Source uses to communicate with Client B to Game Server . The client IP address is accompanied by a request that Game Server send game state information to Client B and or to accept game commands from Client B. At Game Server Transition Logic B receives this client IP address and associates it with a particular game session. Future game states are then sent to this client IP address in addition to or instead of the IP address of Video Source . Likewise if game commands are received at Game Server from the client IP address they are associated with the game session of the game player. This association is made even when the game session and optional login were initially established via Video Source . Further the game server IP address used by Video Source to communicate with Game Server is optionally provided to Client B so that Client B can send game commands directly to this game server IP address. Providing this game server IP address to Client B is optional in embodiments wherein the IP address of Game Server is included within the executable game content downloaded to Client B.

In some embodiments by associating the client IP address with the game session the game session is associated with more than one client. In this case the subset of the game state may be sent to both clients. For example the subset of the game state can be sent from Game Server to both Client B and Video Source . Game Server views Video Source as a client and may or may not differentiate Video Source and Client B as different types of clients. After some time the association between the game session and the IP address of Video Source may be dropped. In some embodiments associating the client IP address with the game session automatically results in dissociating the IP address of Video Source with the game session. Whether or not the dissociation occurs immediately or two IP address are associated with the game session for some time the end result is that Transition Logic causes the game session to be reassigned from a first client to a second client. This reassignment optionally occurs during a single game session without starting a new game session.

Download Manager and or Transition Logic are optionally configured to maintain two copies of the subset of the game state used by Video Source to render streaming game video. One of these copies is located at Video Source and the other at Client B. These copies are maintained by sending state updates to Client B from either Video Source or Game Server . The two copies of the state allow the execution mode transition to take place without inconsistency in the state experienced by the game player. Specifically the same state is available to both the game logic executing on Video Source and game logic executing on Client B. The two copies of the state are maintained for a period of time prior to during and or after the transition. This period of time can be short. In some embodiments the game logic on Video Source and the game logic on Client B are executed in parallel for a time such that two copies of video frames configured for presentation to the game player are generated in different places. Execution of the downloaded executable game content one Client B is optionally initiated while the streaming game video is still being communicated to and or displayed on Client B.

In some embodiments Transition Logic and or the downloaded executable game content is configured to terminate presentation of the streaming game video received by Client B from Video Source upon execution of the downloaded executable game content. For example the executable game content may when executed close a browser window in which the streaming game video is being presented. Alternatively the executable game content may be configured to redirect the browser window from Video Source to a video output of the executable game content. For example Transition Logic C may provide a URL of a local output of the executed game code to the browser window such that the video stream received from Video Source is replaced by the video output of the downloaded executable game content. The next time the executable game content is executed it is optionally configured to present game video in its own program window rather than a browser.

As discussed elsewhere herein in some embodiments Download Manager and or Transition Logic are configured to begin execution of the downloaded executable game content after only a subset of this game code is downloaded. Typically Download Manager is configured to increase the rate at which the executable game content is downloaded after transition because the download rate need no longer be limited in order to assure a minimal quality of the streaming game video.

Processor is configured to execute logic e.g. software included within the various components of Video Server System discussed herein. For example Processor may be programmed with software instructions in order to perform the functions of Video Source Game Server Client Qualifier Download Manager Code Source State Source and or Transition Logic A. Video Server System optionally includes more than one instance of Processor . Processor may also be programmed with software instructions in order to execute commands received by Video Server System or to coordinate the operation of the various elements of Game System discussed herein. Processor may include one or more hardware devices. Processor is optionally an electronic processor.

Storage includes non transitory analog and or digital storage devices. For example Storage may include an analog storage device configured to store video frames. Storage may include a computer readable digital storage e.g. a hard drive an optical drive or solid state storage. Storage is configured e.g. by way of an appropriate data structure or file system to store video frames artificial frames a video stream including both video frames and artificial frames audio frame an audio stream add ons add on data executable game content and or the like. Storage is optionally distributed among a plurality of devices. In some embodiments Storage is configured to store the software components of Video Source discussed elsewhere herein. These components may be stored in a format ready to be provisioned when needed.

The video games are executed using different instances of Game Logic individually labeled A B C etc. Game Logic is an example of a game engine and is configured to use a game state to determine a game environment that can be rendered to a video stream configured to be presented to a game player. The game environment is a two or three dimensional virtual environment including in game objects avatars locations of objects their shapes textures and spatial relationships there between and the like. A game environment can include vertex data transformation data and texture data and or the like.

Game Logic is configured to provide a video game as part of a game session. A game session is optionally a time period between a game player logging on to play a video game and logging off or being otherwise disconnected from the game. In embodiments where a game player plays a game without an established account to login to a game session is a continuous time period during which a game player s progress and or state is trackable and maintained by the game program. If the player is not associated with an account to which game progress and or state is saved then the game progress and state are lost when the game session terminates. Game sessions may exist between Client B and Video Source between Client B and Game Server and between Video Source and Game Server . In some embodiments a game session is transferred from being between Game Server and Video Source to being between Client B and Game Server and or vice versa without termination of the game session.

The rendering of the game environment is typically based on one or more points of view associated with a specific game player. These points of view can be drastically different such as an overhead view and a forward view. Or the points of view can be from positions differing by approximately the distance between a person s pupils and configured to create a 3D image. Video Source may include more than 1 2 3 5 7 15 or 31 instances of Game Logic . Game Logic is optionally a client of Game Server and may be configured to communicate with Game Server via Network . In some embodiments a plurality of points of view received by Video Source from a plurality of Clients is used to render a plurality of separate video streams that are then provided to the respective members of the plurality of Clients . Video Server System and or Video Source are optionally configured to provide this plurality of points of view to Game Server .

Game Logic is configured to receive game commands from one or more of Clients and to process the received commands according to a set of game rules. These rules cover for example how avatars interact with other avatars or in game objects avatar movement game instance management and or the like. Game Logic is optionally also configured to generate audio data based on events within the game. This audio data may represent a gunshot a splash an engine voice flying rain music or any other sound that could occur in a game. For example an event such as one object hitting another may result in audio data representing a related sound. Game Logic includes hardware firmware and or software stored on a computer readable medium. Game Logic is typically associated with related game content.

Each instance of Game Logic can be disposed on a separate computing device or several instances of Game Logic could be disposed on the same computing device or a single instance of Game Logic could be disposed across multiple computing devices. Instances of Game Logic can dynamically change the number and or identify of computing devices used depending on the requirements of the game environment the game player is currently experiencing. Instances of Game Logic disposed on the same computing device are optionally executed within separate virtual machines or virtual I O shells. In some embodiments different instances of Game Logic are configured to communicate game commands and or game state information directly to each other e.g. without necessarily communication through Game Server .

Game Logic typically executes on top of an Operating System OS . Operating System may include Windows Linux UNIX Mac OS Solaris and or the like. A virtual machine platform may operate between Operating System and Game Logics . The virtual machine platform can include commercial systems such as ESX Hyper V and or the like. In these embodiments one or more of Game Logic can be executed within a virtual machine. Multiple instances of Game Logic may execute on the same instance of Operating System . For example illustrates Game Logic A and Game Logic B both executing on the same Operating System . Instances of Game Logic executing on the same Operation System may or may not be configured for playing the same video game. For example Game Logic A B and C may all be World of Warcraft clients or may be clients of World of Warcraft Eve and Call to Arms respectively.

In some embodiments the game environments determined by Game Logic are passed to an optional Virtual 3D Video Driver . Virtual 3D Video Driver is configured to appear from the point of view of Game Logic as a non virtual 3D video driver controlling a graphics processing unit. Each instance of Game Logic may be associated with its own instance of Virtual 3D Video Driver or Virtual 3D Video Driver may be shared by two or more instances of Game Logic . In some embodiments game audio determined by each Game Logic is passed to an optional Virtual Audio Driver . Game audio includes sound data configured to be presented to a game player as part of an audio stream. The game audio can result from rules of the game e.g. shooting a gun should result in a popping sound or may be received from other sources such as music tracks members of Clients a microphone and or the like.

In alternative embodiments Game Logic is configured to include the functionality as discussed herein of Virtual 3D Video Driver and or Virtual Audio Driver . In these embodiments Virtual 3D Video Driver and or Virtual Audio Driver are not required.

Virtual 3D Video Driver is further configured to pass the received game environments to a non virtual 3D Driver . Optionally the delivery of game environments to 3D Driver is coordinated by the various instances of Virtual 3D Video Driver . For example delivery can be coordinated such that 3D Driver receives game environments from only one or a minimum number of Virtual 3D Video Driver at a time. In typical embodiments each of Virtual 3D Video Driver is configured such that they appear to be a separate process and a separate source of video data to 3D Driver . As such 3D Driver is configured to keep track of which video data results in which video frames after rendering.

The video data received by 3D Driver are passed to Graphics Processing Unit GPU for rendering into raw video frames. Graphics Processing Unit is optionally used to render more than one video stream in parallel. For example Graphics Processing Unit may generate a first video stream based on video data received from Game Logic A generate a second video stream based on video data received from Game Logic B generate a third video stream based on video data received from Game Logic C etc. in parallel. The parallel production of video streams includes the generation of these streams at the same time. However parallel production of video streams may but does not necessarily include the processing of individual frames at the same time within Graphics Processing Unit . For example in some embodiments 3D Driver alternatively passes the video data generated by the various members Game Logic to Graphics Processing Unit . Data generated by Game Logic A is used to make a video frame and subsequently data generated by Game Logic B is used to make a video frame etc. In this case the video streams are produced in parallel while individual frames are produced in series. Alternatively more than one video frame may be generated within Graphics Processing Unit at the same time. In this case a first part of Graphics Processing Unit is used to generate one frame while a second part of Graphics Processing Unit is used to generate a second frame the first and second frames arising from video data produced by different Game Logic . In some embodiments one set of graphical computation cores is used to generate the first frame while a second set of graphical computation cores is used to generate the second frame at the same time. The resulting video frames are passed back to the control of 3D Driver .

Virtual 3D Video Drivers are optionally configured to manage the transfer of raw rendered video frames from 3D Driver . For example Virtual 3D Drivers may be used to coordinate the transfer of video frames from the control of 3D Driver to a Shared Memory . Following rendering the video frames are in a memory of Graphics Processing Unit or a memory managed by 3D Driver . In either case they are under the control of 3D Driver . As Virtual 3D Video Drivers manages the communication of video data and frames to and from 3D Driver in some embodiments they are capable of placing the video frames within parts of Shared Memory associated with specific Video Dynamic Encoding Pipelines DEPs . The Video DEPs are individually identified as Video DEP A Video DEP B Video DEP C etc. In these embodiments each Video DEP is assigned specific memory locations within Shared Memory and is configured to retrieve video data from those locations.

In other embodiments Virtual 3D Drivers are configured to manage the transfer of video data to Shared Memory based on timing. In these embodiments the transfers managed by each of Virtual 3D Drivers are synchronized and the Virtual 3D Drivers notify each Video DEP when data for them is in Shared Memory . Once this data is retrieved by the notified member of Video DEPs data for another member of DEPs is transferred from 3D Driver to Shared Memory under the control of Virtual 3D Video Drivers . In these cases pixels read back from the local GPU memory to Shared Memory can be based on a schedule. As used herein the terms in sync and synchronized are meant to mean that the two events are related in time by a schedule by a timing signal by a time delay or that one event does not start until the other event has satisfied a condition e.g. has completed. For example Virtual 3D Drivers may operate in sync such that a game environment is provided to 3D Driver from a first of Virtual 3D Drivers once Graphics Processing Unit has completed rendering of a game environment from a second of Virtual 3D Drivers . The timing of this synchronization is optionally selected to make optimum use of Graphics Processing Unit .

As a result of the management by Virtual 3D Video Drivers the multiple video streams can be stored in Shared Memory without confusing which frames belong to which video stream. Shared Memory is optionally configured to store audio as well as video data. This audio data may be stored and or managed in ways similar to that discussed with respect to video data.

Virtual Audio Drivers are optionally part of a virtual I O shell between Game Logic and OS . They are configured to appear from the point of view of Game Logic as an audio driver and to pass any audio data they receive from Game Logic to one of Audio DEP . For example in some embodiments the Virtual Audio Driver associated with Game Logic A is configured to send audio data to Audio DEP A and the Virtual Audio Driver associated with Game Logic B is configured to send audio data to Audio DEP B etc.

Shared Memory includes random access memory RAM or a similar memory configured for efficient reading and writing of video data. Shared Memory is configured to store video data for a plurality of different Video DEP . Video data for different Video DEPs is optionally stored at the same time in Shared Memory . Shared Memory may consist of a single hardware device or may include multiple devices.

Video DEPs are dynamically allocated encoding pipelines that are each configured to encode video data rendered using Graphics Processing Unit . Each member of Video DEPs is configured to encode to video formats specified at the time the Video DEP is provisioned. This format specification is typically based on the needs of one of Clients and or the capabilities of the communication path between Video Server System and the Client . Video DEPs are optionally provisioned dynamically in response to a request from one of Clients . For example when Client B connects to Video Server System and sends a request for a video stream Video DEP can be provisioned to include elements such as an encoder selected specifically to meet needs of Client B. As is discussed elsewhere herein a member of Video DEPs is optionally configured to use more than one encoding scheme.

Video DEPs each include a Grabber configured to grab video data from Shared Memory and transfer this video data to a memory of the Video DEP . The Grabber is optionally under the control of a member of Virtual 3D Video Drivers . For example in various embodiments Grabber is controlled by a member of Virtual 3D Drivers to grab the video data from a specific location within Shared Memory and or at a specific time in synchronization with the transfer of video data to other members of Video DEPs .

Video DEP each optionally includes an Overlay Logic configured to overlay one or more video images on the video data e.g. frames generated by Graphics Processing Unit . An overlay is a first image to be placed on a second image or a sound added to another sound. Overlays may be applied with varying levels of transparency. For example the first image can be opaque and thus completely hide covered parts of the second image or the first image can be partially transparent in which case the second image can still be somewhat visible under the first image. An overlay may cover all or part s of the underlying image. For example an overlay may be configured to cover certain pixels within a larger area. In this case the overlay is mapped to pixels on a display of one of Clients or mapped to pixels within an image generated by Graphic Processing Unit . The mapping can be accomplished in various ways. For example a lower left pixel of the overlay may be assigned to a specific pixel on a video frame generated by Graphics Processing Unit . In some embodiments Overlay Logic is configured to resize an overlay prior to applying the overlay. Overlay Logic is optionally located in other positions within Video DEP A. For example after Preprocessor .

The overlays can include a wide variety of pixel video images. For example an overlay can include a real time or static image of a game player received via the internet a real time or static image of a sporting or other event an image of a input control e.g. a b TAB Return Space Bar Function Key Arrow and or other keys or input devices a map text and or the like. Overlays can vary widely in size and shape. In some cases the overlay is the result of rendering a 3D game environment. More than one overlay can be placed on an image. These overlays can be overlapping or separate. Overlays are optionally received in an encoded format and decoded prior to being applied.

The presence and content of overlays are optionally responsive to received game commands identity of one or more game players an account type identity of a game being played video captured from a prior or real time sporting event or real world game game rules and or the content of video generated by Game Logic . For example an overlay may include a menu resulting from receipt of a game command. An overlay may include content responsive to a pixel pattern e.g. image included within video generated by Game Logic . Overlay Logic is optionally configured to apply multiple overlays to a single video frame and these overlays may be from different sources.

Overlay Logic is optionally configured to apply an overlay after a video frame has been preprocessed using Preprocessor and or after encoding using one of Encoders . In some embodiments the overlay includes an image received at an input of Video Source e.g. I O device via the internet and Overlay Logic includes video processing logic configured to generate the overlay from the image. The received image is optionally received from an image source such as a camera or a file storage.

Video DEPs each optionally also include a Preprocessor PRE . Preprocessor is configured to perform a color space conversion such as RGB to YUV and or a scaling operation to increase or decrease the resolution of the video frame. Preprocessor is optional in embodiments wherein the output of Graphics Processing Unit is in the YUV color space or some other desired color space. Multiple Preprocessor may be included in a Video DEP configured to produce multiple video streams having video frames of different sizes.

Video DEPs each include at least one Encoder ENC . Encoders are individually identified as Encoder A Encoder B etc. Each of Encoders is configured to encode the video data according to a specific codec and optionally a specific color depth and or frame size. For example Encoders may be configured to encode video data to Adobe Flash standard .flv .wav .avi .mpg H.264 H.263 On2 VP6 VC 1 WMA and or other codecs discussed herein.

A member of Video DEPs may include one two or more Encoders . These encoders may be configured to encode to different codecs and or the different formats of the same codec. For example. Encoder A may be configured to encode according to a Flash standard at a first frame size and color depth while Encoder is configured to encode to the same Flash standard at a second frame size and color depth. The identity of Encoders within each member of Video DEPs is typically determined at the time the Video DEP is provisioned. For example a single command or command set may be used to create provision Video DEP A and specify which components the created Video DEP A should include. The creation of Video DEP A is discussed further elsewhere herein. A member of Video DEPs including two or more Encoders is alternatively viewed as two or more separate Video DEPs having some but not all components in common. For example Video DEP A and Video DEP B may have the same Preprocessor but different Encoders .

In one example Encoder A is configured to use a codec for H.264 while Encoder B is configured to use a codec for H.263. Having two or more different encoders available enables Video DEP A to change encoding during delivery of a video stream. The change in encoding can be from one type of encoding to another or merely a change in characteristics of a specific type of coding. For example the characteristics may change in terms of color depth number of frames per second encoding options number of pixels and or the like. In some embodiments Video DEP A is optionally configured to switch between Encoder A and B in response to a change in the characteristics of Client B or the communication channel between Client B and Video Source .

In practice when a different codec other than that being used is required a new Video DEP is spawned and executed in parallel with the current Video DEP for a short period of time. The new Video DEP is optionally a branch of the original Video DEP . For example some components of the original Video DEP may be used in the new Video DEP . These two Video DEP may have components logically arranged in a tree structure.

In some embodiments Video DEP are configured to use two or more different encoders to generate two or more different video streams at the same time. These video streams are based on the same game environment rendered by Graphics Processing Unit and thus include essentially the same materials with the possible exception of overlays and can be sent to different places. For example one of the video streams can be sent to Client A while the other is sent to Client B. Alternatively one of the video streams can be sent to Client B and the other to a website where third parties can watch the video. This website is optionally part of a social networking site or a game player s site. The two different video streams may be different in the frame rate encoding type frame size color depth etc. For example a video stream delivered to a social networking website can be of much lower quality than the video stream delivered to a game player who is playing a game using Client B. The second video stream may be directed to a game player who is playing the game or to people who are merely observing the game play. A video stream is optionally directed to more than one place.

Video DEP A optionally includes one or more Post Processors Post . Individual examples of Post Processors are labeled A and B. Post Processors are configured to package an encoded video frame in a container in a format appropriate for communication over a network according to a public or proprietary network protocol. For example some protocols such as Adobe RTMP require post processing while other video standards such as H.264 Annex B do not require post processing. Each of Post Processors may be associated with a specific member of Encoders or several Post Processors may be configured to receive encoded video frames from one member of Encoders .

The output of Post Processors is directed to I O Device for delivery to one or more of Clients . The Elements of Video DEPs discussed herein include hardware firmware and or software stored on a computer readable medium. For example each of Video DEPs may represent a set of software loaded into memory and executing using an electronic processor.

Audio DEPs are configured to receive audio data generated by members of Game Logic and encode this audio data to audio packets. The encoded data packets are then sent to Clients using I O Device and Network . Audio DEPs are also optionally configured to place an audio overlay on the audio data received from Game Logic . Different Audio DEPs are individually labeled A B C etc.

As with Video DEPs Audio DEPs are typically allocated as needed and assigned to process audio data from a specific member of Game Logic . This audio data may be based on events within a video game. For example actions taken by one or more players of the video game may result in audio data according to game rules e.g. falling in water makes a splashing sound . Allocation of Audio DEP A is typically responsive to the same factors and performed in the same manner as allocation of Video DEP A. For example the elements included in Audio DEP A may be responsive to needs of one of Clients . Audio DEP may receive audio data from Shared Memory and or directly from one of Virtual Audio Drivers .

Audio DEP A optionally includes a Grabber configured to receive audio data from one of Virtual Audio Drivers to receive audio data from one or more sources external to Video Server System and or to get audio data from Shared Memory . For example in some embodiments Grabber is configured to retrieve data received from sources external to Video Source such as one or more of Clients over the internet. The audio received from any of these sources can include voice audio music sound effects sound tracks alerts and or the like. For example the voice of a game player using Client A may be received from Client A or the game player may provide music to be heard by a game player using another of Clients . Audio data may be received as audio streams from more than one game player in parallel.

Audio DEP A optionally further includes Overlay Logic . Overlay Logic is configured to place one or more audio overlays on audio data generated by a member of Game Logic . The audio overlays can include audio music sound effects sound tracks alerts and or the like. For example in some embodiments an audio overlay includes voice data received as data packets from one or more game players over the internet. These data packets are optionally decoded by Overlay Logic prior to being included in the overlay. Placement of overlays on the audio data generated by a member of Game Logic optionally includes addition of this data to the generated audio data. All or part of an audio overlay can be received from a source external to Video Source . For example in some embodiments the overlay includes audio data received at I O Device via the internet and Overlay Logic includes audio processing logic configured to generate an audio overlay from this audio data. When referring to audio overlays the identities of which data is the overlay and which is the data on which the overlay is being applied may be arbitrary as in some embodiments audio data does not have a sense of layering order that can be possible in video data.

Audio DEP A further includes an Audio Encoder A. Audio Encoder A is configured to encode the audio data generated by a member of Game Logic and the audio overlay into an audio packet according to an audio codec. The encoding is typically performed after the audio overlay s have been applied to the audio data.

Grabber Audio Encoder A and Overlay Logic include hardware firmware and or software stored on a computer readable medium. Audio DEP B and Audio DEP C are alternative embodiments of Audio DEP A.

The operation of Video Source is typically managed by a Controller . Controller includes hardware firmware and or software stored on a computer readable medium. For example Controller may include software stored in memory and executed using a microprocessor.

In some embodiments Controller is configured to provision instances of Game Logic A Virtual Audio Driver and Virtual 3D Video Driver in response to a request to play a game. For example if a request for a specific video game is received from Client B Controller may retrieve Game Logic A Virtual Audio Driver and Virtual 3D Video Driver from Storage and place these in working memory. Game Logic A may be placed in communication with both Client B and Game Server . Game Logic A is then executed using Processor in order to play the video game.

In some embodiments Controller is configured to allocate instances of Video DEP and or Virtual Audio Driver in response to a request to play a game. For example Controller may be configured to first determine or receive the requirements for Video DEP A and Audio DEP A and then provision computing instructions that satisfy those requirements. Video DEP A and Audio DEP are then associated with one of Game Logic and one of Virtual 3D Driver . The provisioned Video DEP A is optionally configured to retrieve raw video data from a specific area within Shared Memory .

In some embodiments the requirements for Video DEP A and or Audio DEP A are determined by querying a game player using Client B. For example Controller may be configured to cause text messages to appear on Client B the messages requesting that a game player using Client B enter characteristics of a video stream desired by a game player. These characteristics can include a connection type a frame size an encoding scheme a frame rate a color depth and or the like. The entered characteristics are conveyed back to Controller which then used these characteristics to select elements to include in Video DEP A and or Audio DEP A when they are provisioned. For example if the game player requests a specific encoding scheme then an Encoder configured to use the requested encoding scheme is selected and included in Video DEP A.

In some embodiments the requirements for Video DEP A and or Audio DEP A are determined automatically. For example information gathered using a client qualifier can be used to determine the requirements for Video DEP A. In this example if Client B includes only a Microsoft Silverlight decoder and an Adobe Flash decoder then at least one of the corresponding encoder configurations or variants thereof is required in Video DEP A. Characteristics of the video stream to be generated using Video DEP A such as frame size color depth and frame rate can also be determined by Controller in this way.

The determination of requirements for Video DEP A and or Audio DEP may include both the use of characteristics provided by a game player and characteristics automatically determined. In some embodiments the possible characteristics are limited by a game player s account type payment and or subscription. For example a game player may pay to receive a higher quality video stream.

Controller may also manage sharing of Shared Memory . For example Controller may configure Video DEP A and or Audio DEP A to use specific memory locations within Shared Memory and or Controller may be configured to configured Video DEP A and or Audio DEP A to access Shared Memory in response to certain timing signals. The timing signals being timed for synchronization of access to Shared Memory by different Video DEPs .

Game Server includes an Input Output I O configured to receive game commands from a plurality of geographically remote clients via Network . The received commands may be in the form of game state updates. Input Output typically includes network connections such as Ethernet ports routers gateways and or the like. These network connections are optionally configured to communicate using TCP IP UDP IP and or other standards. Input Output is also configured to send game state information to the plurality of clients. This game state information typically includes subsets of a global game state maintained by Game Server . The subset provided to each client is normally dependent on a location of an avatar and a particular game session associated with the client. For example a subset of the global game state typically includes the state of the game representative of the area around the avatar. The subset is configured to be sufficient to define the game environment around the avatar and thus enable the rendering of streaming video based on a point of view of the avatar. The global game state is representative of an entire game or a significant part of a game and is based on game rules and game commands received from the geographically remote clients.

Game Server further includes a Game Engine configured to maintain the global state of a video game based on the received game commands and a set of game rules. Game Engine also keeps track of individual game sessions and is configured to select and generate a subset of the global game state for each game session. These subsets are provided to different members of the plurality of clients. Typically each generated subset of the global game state is assigned to a particular member of the plurality of clients respectively. This assignment is based on a game session established between Game Engine and the particular client.

Game Server optionally further includes Transition Logic B configured to transition game play from the server side mode to the client side mode and optionally vice versa. Specifically Transition Logic B is configured to transition within a single game session communications with Game Server from a first client to a second client. Typically the first client will be an instance of Video Source and the second client will be one of Clients . These roles will be reversed when transitioning back from client side mode to server side mode. The transition includes reassigning one of the subsets of the global state from a first member of the plurality of clients to a second member of the plurality of clients. As such the subset will be sent to the second member instead of or in addition to the first member of the plurality of clients. In addition Transition Logic B is configured to change the assignment of received communications to game sessions such that communications from the second member of the plurality of clients are assigned to the same game session as communications from the first member of the plurality of clients were assigned to. In some embodiments a single game session and or game state subset can be assigned to more than one client at the same time. In these cases game commands received from both clients are assigned to the same game session and the same subset of the global game state is sent to both clients. Game commands received from both clients are treated as if they were received from the same client.

As is described elsewhere herein the transition can involve receiving a request to reassign a game session from Video Server System . This request typically includes an IP address or some other address of one of Clients to which the reassignment is to be made. In some embodiments Transition Logic B is configured to accept reassignment requests only from specific predetermined clients. For example Transition Logic B may be configured to accept reassignment requests from instances of Video Server System but not instances of Client . The reassignment requests are optionally encrypted and or may include an authorization code.

Game Server further includes a State Storage configured to store the global state and subsets thereof. State Storage includes one or more static storage devices such as a hard drive static memory random access memory and or the like. The global state is optionally divided into several parts each representing a different region within a game.

Menu Area can include a wide variety of controls a few of which are shown for illustrative purposes. The controls shown in are optionally overlaid on part of the streaming game video. Clicking cursor over or otherwise selecting a control can result in a command being communicated to Transition Logic C Transition Logic B Transition Logic A Download Manager Account Manager and or the like.

In the illustrated example Menu Area includes a Buy Button configured for a game player to purchase a video game. In some embodiments this purchase can be made without interrupting game play. For example streaming game video can continue to be presented to the game player in Display Area while the purchase entry of name and credit card information and or the like is accomplished in Menu Area . Purchasing the game can result in the initiation of the transition between server side mode and client side mode can result in activation of downloaded executable game content can cause the downloading of executable game content to be initiated etc. Purchasing a game typically requires that a game player provide account information.

In the illustrated example Menu Area also includes an Account Button . Account Button can be used to access features of Account Manager . In various embodiments Account Button is used to set an account name create avatars choose servers make payments set passwords switch between games and or the like. The information provided by a game player using Account Button or Buy Button can be stored at Video Server System Game Server or elsewhere within Game System .

In a typical embodiment selecting Account Button or Buy Button will result in a command being sent to Video Server System which in turn will change the contents of Menu Area to give the game player further options and or data entry fields.

In the illustrated example Menu Area also includes a Brag Button . Brag Button is configured for a game player to automatically post game video to an external website such as a social networking site. The location that video is posted and the length of the posted video are examples of parameters that are optionally set using the Account Button . The posted video can be live or recorded. For example the Brag Button can be configured to post the last 60 seconds of play 2 minutes of play before killing a boss or real time video of a game. The video selected for posting is optionally dependent on the output of an Add on configured to monitor game play e.g. to detect a boss encounter an achievement a change in level etc.

In the illustrated example Menu Area further includes a New Game Button . New Game Button is configured to present to a game player a list of other video games available through Game System . Typically if the game player selects a new game delivery of video from the current game is terminated and replaced by video from the new game. Video from the current game and the new game are optionally displayed sequentially in the same browser window. Account Manager is optionally configured to copy game player account information from one video game to another. New Game Button is optionally configured for a game player to move without substantial delay from one video game to another. When a new game is started the game session is optionally assigned to a different instance of Game Logic or a different instance of Video Source . This assignment can involve passing the IP address of the client from the assignor to the assignee.

As noted previously Download Manager is configured to perform various functions related to downloading executable game content to the Client B. Further details of Download Manager and its operation can be found in co pending U.S. patent application Ser. No. 13 231 850 filed Sep. 13 2011.

In Receive Command Step a first game command is received at Video Server System from remote Client A. Optionally a second game command is also received at Video Server System from remote Client B. As discussed elsewhere herein Client A and Client B are typically remote relative to each other and to Video Server System . Optionally the first game command is associated with a first game session and the second game session is associated with a second game session. The different game sessions can be identified by for example receiving the commands at different IP addresses of Video Server System by different IP address of Clients A and B by identification information received in the same packet as one of the game commands and or the like.

In some embodiments a game engine within Video Server System e.g. Game Logic A is configured to receive game commands from a plurality of local game controllers. Such game logic is found in prior art game consoles. In these embodiments game commands received from Clients may be converted by Video Server System to a format that would be expected from a local game controller such as a Nintendo Wii .

In a Forward Command Step the received first game command and optionally the received second game command are forwarded from Video Server System to one or more remote game servers such as Game Server . In some embodiments both the first and second game commands are forwarded to Game Server . They may be forwarded together in the same data packet. In other embodiments the first game command is forwarded to Game Server and the second game command is forwarded to a different second remote game server having characteristics similar to those of Game Server . The two game servers to which the first and second game commands are forwarded may be configured for playing the same video game or different video games.

The first game command is optionally forwarded to Game Server using an IP address that identified the first game command as being associated with a first game session. Likewise the second game command is optionally forwarded using a different IP address such that it can be identified as being associated with a different game session. As such Game Server can see the first and second game commands as being received from different IP addresses and or different e.g. separate clients of Game Server . Each of these different IP addresses and or different clients may be associated with different game sessions. The IP address es used for identification can be either the to IP address to which data packets are addressed or the from IP address of the sender.

In Forward Command Step the game command is optionally converted from a first representation to a second representation before being forwarded. The second representation is optionally part of a game state.

In a Receive State Step a first game state is received by Video Server System from Game Server the received game state is based on game commands received by Game Server from a plurality of clients remote to Game Server . One or more of this plurality of clients includes Video Server System . The game commands on which the game state is based include the first and or second game commands forwarded in Forward Command Step .

Receive State Step optionally further includes receiving a second game state from the second game server. The second game state is based on game commands received by the second game server from a plurality of clients of the second game server. This plurality of clients of the second game server includes Video Server System and the game commands on which the second game state is based includes one or more game commands forwarded to the second game server in Forward Command Step . For example the second game state received in Receive State Step may be based on the second game command forwarded in Forward Command Step and may or may not be based on the first game command forwarded in Forward Command Step . Optionally the first game state is received at a first IP address of Video Server System while the second game state is received at a second IP address of Video Server System the first and second IP addresses being different and possibly associated with different game sessions. Video Server System is optionally concurrently a client to two different Game Servers .

The game states received in Receive State Step are optionally received at I O Device using an API Application Programming Interface that is configured to appear as one or more personal computers and or one or more game consoles from the point of view of Game Server . The game states are optionally received using Internet protocols such as TCP or UDP. The game states are optionally subsets of a global game state maintained by Game Server .

In an optional Update State Step the game state s received in Receive State Step are used to update one or more game states stored in Storage on Video Server System .

In a Generate Step a three dimensional 3D environment is generated based on the first game state received in Receive State Step using a first game engine e.g. using Game Logic A . Generate Step optionally further includes generating a second 3D environment based on the second game state received in Receive State Step . The second 3D environment can be generated using the same game engine or a different game engine such as Game Logic B. Game Logic A and Game Logic B may be configured for playing the same or different video games.

In a Render Step the first and or second 3D environments are rendered to produce first and or second video streams respectively. These video streams each include a sequence of video frames. In some embodiments the rendering includes the application of images or textures received from Game Server to objects within the 3D environment.

Generate Step and Render Step are optionally performed using GPU using the various techniques described elsewhere herein. For example in some embodiments the same instance of GPU is used to render both 3D environments while in other embodiments different instances of GPU are used.

In an Optional Encode Step the first and or second video streams are encoded using one or more encoders such as Encoder A and B. As discussed elsewhere herein the encoding is typically to a standard video protocol.

In an optional Package Step frames of the first and or second video streams are placed in data packets configured for communication over Network . In a Provide Step the packaged video is communicated to members of Clients using Network . In an example embodiment the first video stream rendered from the first 3D environment is communicated to Client A and the second video stream rendered from the second 3D environment is communicated to Client B.

The steps illustrated in can be performed in a wide variety of orders. For example both the first game command and the second game command may or may not be used to update a game state stored on Video Server System before the first and second game state are received from Game Server . Likewise the steps of forwarding the first game command and forwarding the second game command may or may not both be performed before the steps of receiving the first game state and receiving the second game state.

Several embodiments are specifically illustrated and or described herein. However it will be appreciated that modifications and variations are covered by the above teachings and within the scope of the appended claims without departing from the spirit and intended scope thereof. For example the systems and methods discussed herein can be applied to computer programs other than games. These other types of computer programs can include graphics programs spreadsheets word processors database programs accounting programs project management programs video editing programs image editing programs website development programs inventory programs e mail programs file management programs document management viewing programs drawing computer aided design programs presentation programs and or the like. While the server side mode and the client side mode are discussed herein as separate modes of game delivery in some embodiments these modes can be combined. For example part of the video presented to the game player can be streamed from Video Server System while another part of the video can be generated on Client B. In different modes of game play the parts and or ratio of the streamed verses locally generated video can change. For example some game events may include more streamed video than other game events.

The embodiments discussed herein are illustrative of the present invention. As these embodiments of the present invention are described with reference to illustrations various modifications or adaptations of the methods and or specific structures described may become apparent to those skilled in the art. All such modifications adaptations or variations that rely upon the teachings of the present invention and through which these teachings have advanced the art are considered to be within the spirit and scope of the present invention. Hence these descriptions and drawings should not be considered in a limiting sense as it is understood that the present invention is in no way limited to only the embodiments illustrated.

Computing systems referred to herein can comprise an integrated circuit a microprocessor a personal computer a server a distributed computing system a communication device a network device or the like and various combinations of the same. A computing system may also comprise one or more computer readable media including volatile and or non volatile memory such as random access memory RAM dynamic random access memory DRAM static random access memory SRAM magnetic media optical media nano media a hard drive a compact disk a digital versatile disc DVD and or other devices configured for storing analog or digital information such as in a database. The various examples of logic noted above can comprise hardware firmware or software stored in a non transient manner on a computer readable medium or combinations thereof. A computer readable medium as used herein expressly excludes paper and carrier waves. Computer implemented steps of the methods noted herein can comprise a set of instructions stored on a computer readable medium that when executed cause the computing system to perform the steps. A computing system programmed to perform particular functions pursuant to instructions from program software is a special purpose computing system for performing those particular functions. Data that is manipulated by a special purpose computing system while performing those particular functions is at least electronically saved in buffers of the computing system physically changing the special purpose computing system from one state to the next with each change to the stored data.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications can be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

