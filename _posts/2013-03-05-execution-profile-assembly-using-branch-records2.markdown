---

title: Execution profile assembly using branch records
abstract: Technologies for assembling an execution profile of an event are disclosed. The system and method may include recording a plurality of branch records, generating a first test event substantially identical to the event, verifying legitimacy of an owner of a code segment associated with the event, establishing an initial point of an execution chain associated with the event, establishing a final point of the execution chain associated with the event, analyzing branch records for an address associated with the code segment, installing a plurality of primary monitors within the execution chain associated with the event, and triggering the plurality of primary monitors.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09613212&OS=09613212&RS=09613212
owner: McAfee, Inc.
number: 09613212
owner_city: Santa Clara
owner_country: US
publication_date: 20130305
---
This invention relates generally to the field of electronic security and more specifically to creating a full execution profile using branch records.

In the realm of electronic security electronic security products often find themselves one step behind the proprietor and distributors of harmful software. Many traditional approaches to electronic security take as their starting point the identification of threats and reaction to these threats. This reactive approach may protect electronic devices against known threats but leaves them vulnerable to unknown threats. Further this reactive approach requires constant vigilance and updating of the electronic device in order to keep up with the latest advancements in harmful software.

In modern electronic systems one major issue remains electronic security. A constant threat to the security of an electronic system is the threat of assimilation of system resources through means other than those intended by the user of the system. These means may take the form of software hardware firmware or some combination thereof and may include computer viruses worms spyware adware or other means that may gather information from an infected electronic device corrupt the device or have some other deleterious effect. These means may be generally referred to as malware. 

One particularly nefarious breed of malware may insert itself into electronic device s event processing routines in order to subvert monitor and or alter these processes. For example a key stroke logging software may be inserted into the handling of keystrokes in order to capture these keystrokes.

Malware may be generally characterized by a need to be inserted into the handling of an event of some sort even if only to be scheduled for execution by the system. Detecting malware s presence in an event processing is valuable but often difficult. For example malware may be included in an event s processing by indirect methods such as taking advantage of a vulnerability of the electronic device itself an exploit . Some prior electronic security software has been able to discover which insertion methods may be used and monitoring these insertion methods e.g. the known vulnerabilities . For example in the case of a key stroke logger the method of insertion may be an exploit of an application programming interface API . One historic method of dealing with this vulnerability has been to monitor the API in order to detect subversion of the normal operation.

Reactive approaches to detection such as this may make it difficult to keep pace with changes to malware insertion techniques. An improved approach may be one that allows for detection of the presence of malware in an event s processing regardless of the insertion method. Additionally it may be beneficial to also support using assembled execution profiles to validate the invoker of an API such as a privileged API .

In some embodiments system may take advantage of what are known as branch records to assemble execution profiles. For example branch records may be lists of execution branches that have occurred e.g. jumps calls etc. . Branch records may typically be provided by processor . However one of ordinary skill in the art will appreciate that the branch record could also be provided by other components of system such as a virtualization or emulation environment.

Historically a challenge facing the use of branch records has been that their depth is limited. For example on Intel i7 CPUs the depth of the record is 16 entries. On older Intel CPUs the depth is even less. One approach to addressing the depth of the records has been to extend the recording of the branch records by offloading the branch records to memory . However given other operating constraints of system this may still limit the depth of branch records that may be recorded as well as incurring a performance penalty for the other operations required of system .

In some embodiments system may include branch recording mechanism . For example system may include the Last Branch Record LBR mechanism supported by Intel CPUs. Other branch recording mechanisms may be used without departing from the scope of the present disclosure.

In some embodiments system may also include inline hook engine . In order to effectively monitor the execution of code that is of interest system may implement hooks. Inline hook engine may be configured to place these hooks in line with code to be monitored. For example in line hooks may comprise replacement instructions placed within the monitored code where the in line hook may transfer control of the monitored code to a callback function when the hooked code is executed. These hooks may be placed and executed in any appropriate operating mode of system including kernel and user modes. In some configurations of system inline hook engine may be further configured to place the in line hooks in a manner that may avoid anti hook mechanisms resident on system . For example in a configuration of system in which system has implement Patch Guard for Windows it may be necessary to avoid the anti hook mechanisms when placing kernel mode hooks.

In the same or alternative embodiments inline hook engine may be configured to allow monitoring of execution and or access of an address through the use of a technique other than inline hooks. For example virtualization based monitoring of access and or execution of an address CPU based monitoring of access and or execution of an address and or other hardware based monitoring of access and or execution of an address.

In some embodiments system may also include test event generator Test event generator may be configured to generate test events in order to assemble an execution profile of the code involved in handling a normal event of the same type. For example test event generator may generate test events such as keystroke events. Test event generator may be configured to generate a test event through a variety of methods including 1 invoking an API to queue up an input output I O operation 2 generating a hardware or software interrupt and or 3 retrieving the address of the registered handler of an interrupt and invoking that code as it would be during the handling of the interrupt.

In some embodiments system may also include code owner locator . Code owner locator may be configured to identify the owner of code found at a particular address. In some configurations the code address may be retrieved through execution profiling as described in more detail above. Code owner locator may be configured to first check an address range for code originating from loaded modules such as executables libraries e.g. DLLs in Windows and device drivers. This may assist code owner locator in distinguishing static code from code in runtime allocated memory.

Code owner locator may also be configured to check an address range for memory allocated at runtime by running process and device drivers. For example code owner locator may be configured to monitor memory allocations and assemble a list of the location s and range s of the allocations. In some configurations of system code owner locator may perform this check through the implementation of monitoring callbacks supplied by the operating system of system and or a more direct monitoring via in line hooking.

In some embodiments code owner locator may be further configured to validate the owner previously identified and that the owner s participation in the handling of a test event is legitimate. For example code owner locator may be configured to determine whether the executable for the identified owner is signed and signed by a trusted source whether the executable is normally expected to be part of handling of the test event s particular type whether the origins of the executable are suspicious and or whether the running executable process device driver has been tampered with.

In operation system may be configured to assemble execution profiles for various types of events. For example system may be configured to assemble execution profiles for events such as a keystroke event an API call e.g. the API to enumerate running processes on a system and or any key event malware may need for operation e.g. thread execution being resumed by the operating system s scheduler .

To aid in understanding the following example is provided. Although this example provides certain details it will be understood by one of ordinary skill in the art that system may be configured in different ways without departing from the scope of the present disclosure. APIs have increasingly become useful in allowing different types of applications to communicate with one another. It may therefore be beneficial to validate that the invoker of an API is a legitimate user of the API. Some prior method such as return oriented programming ROP may make simply checking the code code origin of the invoker insufficient as legitimate code may be hijacked using ROP to invoke the API on behalf of malware.

By assembling an execution profile of the invocation of the API system may establish a much greater confidence that the invoker is legitimate. In operation in order to assemble an execution profile test event generator may substitute a test event for the exit of the API. This exit may be re issued as needed to expose more of the invocation s execution profile as described in more detail below.

For example inline hook engine may be configured to determine the hook entry point s for an API whose invocation is to be validated. In the same or alternative configurations the entry point may invoke inline hook engine . Similarly inline hook engine may be configured to determine the hook exit point s for the API. In the same or alternative configurations the exist point may invoke inline hook engine .

Upon the invocation of any hook point inline hook engine may be further configured to identify the process and or thread invoking the API. If the hook is for the entry point of API inline hook engine may save the process and or thread information for matching against other hook point invocations. If the hook is for an API exit point or a secondary hooks inline hook engine may compare the process and or thread information to that saved from entry point hook invocation.

Inline hook engine may then be configured to extract code addresses from the call stack at the point of API invocation. In some configurations inline hook engine may extract code address from branch recording mechanism . Inline hook engine may exclude any from other threads execution as well as any addresses already seen and monitored as described in more detail below with reference to .

Next inline hook engine may place secondary hooks at the extracted code address as described in more detail below with reference to . If the hook invoked is for exit from API inline hook engine may save the execution state stack registers etc. for later restoration. In some embodiments inline hook engine may also be configured to place secondary hooks at addresses discovered through examination of branch records at the point of invocation of a previously placed hooks as described in more detail below with reference to .

As the API execution continues further hooks may be triggered. If the exit point for API has already been reached by the process and or thread being tracked inline hook engine may queue a re issuing of the exit. In such a circumstance inline hook engine may be configured to restore the execution state e.g. stack registers etc. and restart execution from the API exit point. This may allow more identified hook points identified to be reached.

Execution from the exit point may be triggered for a predetermined number of iterations. As execution continues secondary hook points may be hit exposing more code addresses via the stack walk and branch record analysis allowing a deeper walk back into the invocation of the API with each iteration.

Code owner locator may be configured to determine the owners of the analyzed code and validate that these are legitimate users of the API as described in more detail below with reference to . Code owner locator may be further configured to create a security violation if the owners of the code are not validated.

By examining the branch records and installing hooks in this iterative fashion system may address the depth limitations of branch records allowing for application to assembly of execution profiles. Further system may not require as much updating as prior solutions e.g. to monitor newly discovered APIs to be exploited by malware . Still further system may be used to check for malware bypassing of API monitoring and operating system supported filtering e.g. file system filters Registry filters etc. . With the ability to create execution profiles for APIs system may be used to harden privileged APIs against unauthorized use by malware.

According to one embodiment method preferably begins at step . Teachings of the present disclosure may be implemented in a variety of configurations. As such the preferred initialization point for method and the order of steps comprising method may depend on the implementation chosen.

In some embodiments the steps of method may be performed by some or all of the components of system as described in more detail above with reference to . For example in some configurations inline hook engine may be responsible for installing hooks at key points in the event processing chain. In other configurations these steps may be performed by different components of system with departing from the scope of the present disclosure.

At step method may install inline hooks at certain points in an event s processing. As described in more detail above with reference to the hooks may be installed at points determined by inline hook engine to be important in the event processing. For example method may install inline hooks at the following locations 1 APIs used to queue up the event e.g. the APIs used by a keyboard driver to insert keystroke codes into a queue for processing 2 APIs used by consuming code to retrieve the event e.g. APIs used by application level software to retrieve the queued keystrokes and 2 APIs used to invoke registered callbacks during the course of processing the event e.g. operating system supported callbacks invoked during course of processing keystrokes that may allow for keystroke filter drivers etc. . After installing the inline hooks method may proceed to step .

At step method may use the installed inline hooks to track the start and end of processing for a particular event. Once this monitoring has begun method may proceed to step . At step method may use the data gathered during monitoring to establish initial points of monitoring and branch record retrieval which may be built upon while assembling the execution profile for the handling of the event. After establishing these initial points method may proceed to step .

At step method may install inline hooks at key points in the operating system s scheduling of threads. For example method may install inline hooks at the following locations 1 APIs used by threads to yield execution back to system e.g. when waiting for I O and 2 code used by system to schedule a thread for execution e.g. task switching and launching of new threads . After installing the inline hooks method may proceed to step .

At step method may use the installed inline hooks to monitor when execution switches between threads. Once this monitoring has begun method may proceed to step . At step method may use the data gathered during monitoring to interpret the data present in the branch record which may cover branches for all threads running on processor . After interpreting the data in the branch record method may proceed to step .

At step method may generate a trace event sending the trace event to the initial step of the event handling chain. For example in the case of keystroke events method would send the trace event to the lowest portion of the keystroke event processing stack. After generating the trace event method may proceed to step .

At step method may trigger the hooks at the initial step of an event handling chain. For example as described in more detail above with reference to step hooks may be placed within APIs used to queue up an event. In the case of keystroke events these hooks may trigger therefore picking up the keystroke event being submitted to the stack. After triggering these initial hooks method may proceed to step .

At step method may note the process and thread in effect for the monitored event as well as note that a trace event is being processed for this process thread. This may allow recognition of which subsequent event processing interceptions relate to the trace event as opposed to other related real events happening. After noting the process in effect method may proceed to step .

At step method may examine the recorded branch records. In some embodiments each branch record entry points to code. In some configurations the branch record may point to a transfer address. In the same or alternative configurations the branch record may point to a source address. For example in the case of the Intel i7 LBR each branch record entry may contain the address of execution before and after the taking of the branch. These code addresses may be saved for further processing. After examining the recorded branch records method may proceed to step .

At step method may trigger inline hooks at a final portion of an event s processing chain. For example as described in more detail above with reference to step method may install hooks at APIs used by consuming code to retrieve an event. In the case of a keystroke event for example method may trigger an inline hook at retrieval of a queued keystroke by a user mode application. The triggering of inline hooks at the final portion of an event s processing chain is described in more detail below with reference to . After triggering these hooks method may proceed to step .

At step method may include installing secondary hooks. As described in more detail above with reference to and below with reference to secondary hooks may be installed at addresses based on for example addresses discovered through examination ofbranch records examination of a callback stack at a point of invocation of hooks etc. After installing the secondary hooks method may proceed to step .

At step method may include handling secondary hooks as described in more detail below with reference to . After handling secondary hooks method may proceed to step .

At step method may determine the owners of the code from the code addresses retrieved from the branch records as described in more detail above with reference to steps and as described in more detail above with reference to . After determining the owners of the code method may proceed to step .

At step method may determine the legitimacy of the code and its owner in the handling of the test event as described in more detail above with reference to . If the code is determined to be incorrectly present in the handling of a test event method may proceed to step where a security violation may be generated. After generating the security violation method may proceed to step . If the code is not determined to be incorrectly present in the handling of a test event method may proceed to step .

At step method may determine whether a complete history of the execution flow of handling the trace event has been assembled. By repeating the trace event as described in more detail above with reference to steps and below with reference to limitations on the depth of branch records may be avoided while still assembling the execution profile of a trace event. If a complete history has not been assembled method may return to step . If a complete history has been assembled method may proceed to step .

At step secondary hooks may be removed. After removing the secondary hooks method may proceed to step . At step method may send information to the primary hook handlers that a trace event is no longer in process. After sending this information method may return to step .

Although discloses a particular number of steps to be taken with respect to method method may be executed with more or fewer steps than those depicted in . In addition although discloses a certain order of steps comprising method the steps comprising method may be completed in any suitable order. For example in the embodiment of method shown inline hooks are inserted in a serial manner. However in some configurations it may be necessary or desirable to insert these hooks in a parallel manner for more efficient processing.

According to one embodiment method preferably begins at step . Teachings of the present disclosure may be implemented in a variety of configurations. As such the preferred initialization point for method and the order of steps comprising method may depend on the implementation chosen.

In some embodiments the steps of method may be performed by some or all of the components of system as described in more detail above with reference to . For example in some configurations inline hook engine may be responsible for examining branch records. In other configurations these steps may be performed by branch recoding mechanism and or different components of system with departing from the scope of the present disclosure.

At step method may retrieve the identities of the current process and thread. After retrieving the identities method may proceed to step . At step method may determine whether the retrieved identities match the process and thread identified at the beginning of the trace event as described in more detail above with reference to steps of method of . If the identities match method may proceed to step . If the identities do not match method may proceed to step . At step an error code is generated whereupon method may terminate as described in more detail below with reference to step .

At step method may examine the branch records and note the code addresses. After noting the addresses method may proceed to step . At step method may examine a log of task switches to see whether a task switch occurred since start of trace event or since the last hook handler was invoked and the branch record retrieved. If a task switch was noted method may proceed to step . It a task switch was not noted method may proceed to step .

At step method may examine a branch record address to determine whether it points to code associated with switching tasks. If the branch record does not point to code associated with switching tasks method may proceed to step . At step method may save the branch record address for further processing before proceeding to step .

At step the branch record address may be examined for suitability for placing of secondary hooks. In some embodiments this may include determining whether the code address is already monitored by a hook. If deemed suitable method may proceed to step where an inline hook may placed at the identified code addresses before method proceeds to step . If the code address is not deemed suitable method may proceed to step .

Referring again to step if the branch record does point to code associated with switching tasks method may proceed to step where method may discard the location as well as any subsequent entries in the branch records and then proceed to step .

At step method may determine whether another branch record address should be analyzed. If another exists method may select another branch record and return to step . If all branch record addresses have been analyzed method may terminate. In some embodiments the termination of method may include proceeding to other method steps. For example method may return to step of method as described in more detail above with reference to .

Although discloses a particular number of steps to be taken with respect to method method may be executed with more or fewer steps than those depicted in . In addition although discloses a certain order of steps comprising method the steps comprising method may be completed in any suitable order. For example in the embodiment of method shown one branch record address at a time is examined. However in some configurations it may be necessary or desirable to examine a plurality of branch record addresses simultaneously.

According to one embodiment method preferably begins at step . Teachings of the present disclosure may be implemented in a variety of configurations. As such the preferred initialization point for method and the order of steps comprising method may depend on the implementation chosen.

In some embodiments the steps of method may be performed by some or all of the components of system as described in more detail above with reference to . For example in some configurations inline hook engine may be responsible for the handling of secondary hooks. In other configurations these steps may be performed by branch recoding mechanism and or different components of system with departing from the scope of the present disclosure.

At step method may retrieve the identities of the current process and thread. After retrieving the identities method may proceed to step . At step method may determine whether the retrieved identities match the process and thread identified at the beginning of the trace event as described in more detail above with reference to steps of method of . If the identities match method may proceed to step . If the identities do not match method may proceed to step . At step an error code is generated whereupon method may terminate as described in more detail below with reference to step .

At step method may examine the branch records and note the code addresses. After noting the addresses method may proceed to step . At step method may examine a log of task switches to see whether a task switch occurred since start of trace event or since the last hook handler was invoked and the branch record retrieved. If a task switch was noted method may proceed to step . It a task switch was not noted method may proceed to step .

At step method may examine a branch record address to determine whether it points to code associated with switching tasks. If the branch record does not point to code associated with switching tasks method may proceed to step . At step method may save the branch record address for further processing before proceeding to step .

At step the branch record address may be examined for suitability for placing of secondary hooks. In some embodiments this may include determining whether the code address is already monitored by a hook. If deemed suitable method may proceed to step where an inline hook may placed at the identified code addresses before method proceeds to step . If the code address is not deemed suitable method may proceed to step .

Referring again to step if the branch record does point to code associated with switching tasks method may proceed to step where method may discard the location as well as any subsequent entries in the branch records and then proceed to step .

At step method may determine whether another branch record address should be analyzed. If another exists method may select another branch record and return to step . If all branch record addresses have been analyzed method may proceed to step .

At step method may trigger the generation of a new trace event. In some embodiments this may include queuing for later triggering after the current trace event has completed to limit recursion. In the same or alternative embodiments recursive handling may be supported. After triggering the generation of a new trace event method may terminate. In some embodiments the termination of method may include proceeding to other method steps. For example method may return to step of method as described in more detail above with reference to .

Although discloses a particular number of steps to be taken with respect to method method may be executed with more or fewer steps than those depicted in . In addition although discloses a certain order of steps comprising method the steps comprising method may be completed in any suitable order. For example in the embodiment of method shown one branch record address at a time is examined. However in some configurations it may be necessary or desirable to examine a plurality of branch record addresses simultaneously.

A system for assembling an execution profile of an event is disclosed. The system may include a processor a branch recording mechanism communicatively coupled to the processor the branch recording mechanism configured to record a plurality of branch records a test event generator communicatively coupled to the processor the test event generator configured to generate a first test event substantially identical to the event a code owner locator communicatively coupled to the processor the code owner locator configured to verify legitimacy of an owner of a code segment associated with the event and an inline hook engine communicatively coupled to the processor. The inline hook engine may be configured to establish an initial point of an execution chain associated with the event establish a final point of the execution chain associated with the event analyze branch records for an address associated with the code segment install a plurality of primary monitors within the execution chain associated with the event and trigger the plurality of primary monitors.

The inline hook engine may be further configured to install a plurality of primary monitors by being configured to determine whether the address is suitable for a primary monitor the primary monitor being one of the plurality of primary monitors. The inline hook engine may be further configured to install a plurality of primary monitors by being configured to discard the address if it is associated with a switching task. The inline hook engine may be further configured to install a plurality of primary monitors by being configured to verify an identity of a process associated with the execution chain. The inline hook engine may be configured to determine whether the execution profile is complete and if the execution profile is not complete signal the test event generator to generate a second test event substantially identical to the event. The inline hook engine may be further configured to install a plurality of primary monitors by being configured to verify an identity of a thread associated with the execution chain.

The inline hook engine may be further configured to install a plurality of secondary monitors within the execution chain associated with the event and trigger the plurality of secondary monitors. The inline hook engine may be further configured to install a plurality of secondary monitors by being configured to determine whether the address is suitable for a secondary monitor the secondary monitor being one of the plurality of secondary monitors. The inline hook engine may be further configured to install a plurality of secondary monitors by being configured to discard the address if it is associated with a switching task. The inline hook engine may be further configured to install a plurality of secondary monitors by being configured to verify an identity of a process associated with the execution chain. The inline hook engine may be configured to determine whether the execution profile is complete and if the execution profile is not complete signal the test event generator to generate a second test event substantially identical to the event.

The plurality of primary monitors may include a plurality of inline hooks a plurality of virtualization based monitors and or a plurality of hardware based monitors.

Addresses used for placing a plurality of secondary monitors may be discovered through meanins including an examination of a call stack at a point of invocation of an earlier placed primary monitor or an earlier placed secondary monitor examination of a branch record available at a point of invocation of an earlier placed primary monitor or an earlier placed secondary monitor.

At least one machine readable storage medium comprising computer executable instructions carried on the computer readable medium the instructions readable by a processor is disclosed. The instructions when read and executed for causing the processor to record a plurality of branch records generate a first test event substantially identical to the event verify legitimacy of an owner of a code segment associated with the event establish an initial point of an execution chain associated with the event establish a final point of the execution chain associated with the event analyze branch records for an address associated with the code segment install a plurality of primary monitors within the execution chain associated with the event and trigger the plurality of primary monitors.

The medium may also include instructions to install a plurality of secondary monitors within the execution chain associated with the event and trigger the plurality of secondary monitors.

Installing a plurality of primary monitors may include determining whether the address is suitable for a primary monitor the primary monitor being one of the plurality of primary monitors. Installing a plurality of primary monitors may include discarding the address if it is associated with a switching task. Installing a plurality of primary monitors may include verifying an identity of a process associated with the execution chain. Installing a plurality of primary monitors may include verifying an identity of a thread associated with the execution chain.

The medium may also include instructions to determine whether the execution profile is complete and if the execution profile is not complete signal the test event generator to generate a second test event substantially identical to the event.

Installing a plurality of secondary monitors may include determining whether the address is suitable for a secondary monitor the secondary monitor being one of the plurality of secondary monitors. Installing a plurality of secondary monitors may include discarding the address if it is associated with a switching task. Installing a plurality of secondary monitors may include verifying an identity of a process associated with the execution chain.

The medium may also include instructions to determine whether the execution profile is complete and if the execution profile is not complete signal the test event generator to generate a second test event substantially identical to the event.

The plurality of primary monitors may include a plurality of inline hooks a plurality of virtualization based monitors and or a plurality of hardware based monitors.

Addresses used for placing a plurality of secondary monitors may be discovered through means including an examination of a call stack at a point of invocation of an earlier placed primary monitor or an earlier placed secondary monitor examination of a branch record available at a point of invocation of an earlier placed primary monitor or an earlier placed secondary monitor.

A method for assembling an execution profile of an event is disclosed. The method may include recording a plurality of branch records generating a first test event substantially identical to the event verifying legitimacy of an owner of a code segment associated with the event establishing an initial point of an execution chain associated with the event establishing a final point of the execution chain associated with the event analyzing branch records for an address associated with the code segment installing a plurality of primary monitors within the execution chain associated with the event and triggering the plurality of primary monitors.

The method may also include installing a plurality of secondary monitors within the execution chain associated with the event and triggering the plurality of secondary monitors.

Installing a plurality of primary monitors may include determining whether the address is suitable for a primary monitor the primary monitor being one of the plurality of primary monitors. Installing a plurality of primary monitors may include discarding the address if it is associated with a switching task. Installing a plurality of primary monitors may include verifying an identity of a process associated with the execution chain. Installing a plurality of primary monitors may include verifying an identity of a thread associated with the execution chain.

The method may also include determining whether the execution profile is complete and if the execution profile is not complete signaling the test event generator to generate a second test event substantially identical to the event.

Installing a plurality of secondary monitors may include determining whether the address is suitable for a secondary monitor the secondary monitor being one of the plurality of secondary monitors. Installing a plurality of secondary monitors may include discarding the address if it is associated with a switching task. Installing a plurality of secondary monitors may include verifying an identity of a process associated with the execution chain.

The method may also include determining whether the execution profile is complete and if the execution profile is not complete signaling the test event generator to generate a second test event substantially identical to the event.

The plurality of primary monitors may include a plurality of inline hooks a plurality of virtualization based monitors and or a plurality of hardware based monitors.

Addresses used for placing a plurality of secondary monitors may be discovered through means including an examination of a call stack at a point of invocation of an earlier placed primary monitor or an earlier placed secondary monitor examination of a branch record available at a point of invocation of an earlier placed primary monitor or an earlier placed secondary monitor.

