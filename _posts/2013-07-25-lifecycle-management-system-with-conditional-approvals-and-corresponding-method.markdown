---

title: Lifecycle management system with conditional approvals and corresponding method
abstract: Certain example embodiments concern a lifecycle management system for at least one computing component. A lifecycle model, including lifecycle states assignable to the at least one computing component, is defined. The lifecycle states include a production state. The lifecycle management system ensures the at least one computing component can be productively used only if it is assigned the production state. A lifecycle transition request assigning a requested target lifecycle state of the lifecycle model to the at least one computing component is received. A conditional lifecycle state, different from the requested target lifecycle state, is assigned to the at least one computing component. At least one condition to be fulfilled for the at least one computing component to be assigned the requested target lifecycle state is assigned. The requested target lifecycle state is automatically assigned to the at least one computing component when the at least one condition is fulfilled.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09286060&OS=09286060&RS=09286060
owner: Software AG
number: 09286060
owner_city: Darmstadt
owner_country: DE
publication_date: 20130725
---
This application claims priority to EP Application No. 13 173 358.6 filed 24 Jun. 2013 the entire contents of which is hereby incorporated by reference.

Certain example embodiments relate to the lifecycle management of computing components and more particularly to a lifecycle management system and a corresponding method for managing the lifecycle of at least one computing component with conditional approvals.

Service oriented architecture SOA is a software design and software architecture design pattern based on structured collections of discrete computing components or software modules known as services that collectively provide the functionality of a large software application. The purpose of SOA is to allow an easy cooperation of a large number of computers that are connected over a network such as the Internet. Every computer can run an arbitrary number of programs called services in this context that are built in a way that they can exchange information with one another without the need to make changes to the underlying program itself. In a SOA resources are made available to participants in the network as independent services that the participants can access in a standardized way. Whereas most definitions of a SOA use SOAP requests conveyed via HTTP or HTTPS over TCP IP a SOA may use any web service based technology. The web services interoperate based on formal definitions which are independent from the underlying platform and programming language. The interface definition encapsulates the specific implementations so that a SOA is independent of a specific development technology such as Java and .NET . The software components thus become very reusable because the interface is standards compliant and is independent from the underlying implementation of the web service logic. In this context SOA is nowadays one of the preferred architecture paradigms for fulfilling the needs of fast changing business requirements. It provides more agility by splitting monolithic applications into components that can be re used and orchestrated to get new functionality on demand. New or changed business processes can be implemented by combining existing services or other types of SOA assets. The person skilled in the art will appreciate that SOA is not only popular for implementing business applications processes but likewise for implementing complex technical systems such as the distributed controlling logic of a large assembly line in a factory or large distributed computing systems which serve for processing large data sets such as weather forecast models or gene analysis models.

In summary the implementation of a distributed SOA based computing system leads to a vast collection of distributed and loosely coupled computing components such as services. However the individual computing components are typically developed individually so that at any given time the components of a SOA based system may be in different phases i.e. one component may already be in productive use another component may still being tested and yet another component may be under development. In other words the individual computing components undergo a series of distinct phases during their lifetime which is called a lifecycle . In this context lifecycle management i.e. the controlling of the correct transition of the computing components from one lifecycle state to the next is a complex and difficult task. It goes without saying that if a computing component is set to productive although the necessary tests have not been passed this could lead to catastrophic consequences such as the failure of the overall computing system. Managing the lifecycle of services and other SOA assets is thus a critical requirement when governing a Service Oriented Architecture i.e. when controlling its correct behavior.

Another emerging application area for lifecycle management is API Application Programming Interface management. API management enables organizations to publish and promote their APIs in a large scale environment such as the Internet. Since such APIs are typically exposed to a large community of users managing the lifecycle of API assets is a very important feature of API management solutions.

Lifecycle management is typically performed on metadata stored in a registry wherein such metadata represents the SOA and or API assets the lifecycle of which should be managed i.e. controlled. Due to its importance for the correct operation of the underlying computing system lifecycle management capabilities are nowadays provided by several existing SOA governance and API management products e.g. CENTRASITE of applicant WEBSPHERE Service Registry and Repository WSRR of IBM SYSTINET Registry of HP and Lifecycle Manager of SOA Software. In a SOA registry lifecycles are typically represented with a lifecycle model. A lifecycle model typically comprises lifecycle states that can be assigned to SOA and API assets. The lifecycle states are connected via lifecycle state transitions which define the allowed state changes an asset can run through. A simple lifecycle model LCM is shown in and comprises the lifecycle states Under Development In Testing In Production and Retired 

Applying this lifecycle model to the managed assets i.e. computing components such as services ensures that all assets are in one of the four states. In the example of the initial state is Under Development from there services can be moved to In Testing . Services in the In Testing state can either be moved back to Under Development or they can be moved to In Production . Once services have reached their end of lifetime they can be moved from In Production to Retired . Complex lifecycle models not only comprise lifecycle states but may also lifecycle stages which in turn comprise a plurality of nested lifecycle states. Lifecycle stages are needed in advanced development environments where SOA assets do not just run through multiple states but also through multiple stages. Hereinafter it will not be distinguished between state and stage transitions for the sake of simplicity.

To provide a computer aided management of the lifecycle policies can be assigned to the transitions of a lifecycle model. Simple policies may define a condition to make sure that an asset can only run through a lifecycle transition if it fulfills one or more requirements. For example only those services can be moved to In Production that are WS I Web Services Interoperability compliant. More advanced policies may not only check conditions but may also trigger actions. For example a policy may perform an automatic deployment of a Web service once said Web service is assigned the In Testing or In Production lifecycle state. This policy can thus be used to annotate the transitions pointing to the In Testing and In Production states so that the respective asset is automatically deployed to a testing or production environment.

It is apparent from the foregoing that changing the lifecycle state of assets can have a significant impact on the operation of the underlying computing system. Therefore dedicated governance i.e. controlling or management of the lifecycle transitions is needed. An effective method is to apply approval processes. For example users and or groups of users may request a lifecycle transition for a single or a collection of assets. Such a request may raise an approval request to more privileged users or groups such as SOA architects responsible to review all the assets that are entering the In Production state. The approving users or approving group can approve or reject the requested transition. In the prior art approvals are typically defined by attaching approval triggering policies to lifecycle transitions. When such a policy is configured an approval process is triggered once the transition is requested for an asset. The approval process triggered by the approval policies may be simple such as the sending of an email to the responsive approving user group or may comprise a complex process workflow. If the approval process is successful the asset changes its lifecycle state or stage according to the requested transition. If the approval is rejected the asset stays in source state or stage of the requested transition. shows the exemplary lifecycle model of with two approval policies controlling the transition from In Testing to In Production and from In Production to Retired 

This prior art approach of allowing to either approve or reject a requested lifecycle state transition is provided already in the existing SOA governance and API management products mentioned further above. Likewise also the U.S. Pat. No. 7 131 071 B1 titled Defining an approval process for requests for approval which proposes a system for defining an approval process graphically does not disclose how to integrate approval processes with lifecycle management in particular not beyond the options to approve or reject an approval request. US patent application 2007 0088585 A1 titled Capturing the result of an approval process workflow and declaring it a record describes how the results of approval processes can be captured to collect log and history information. This information enables the tracking of approval workflow states but the patent application does not describe how this can be combined with lifecycle management. Further the U.S. Pat. No. 8 239 819 B2 titled Method and system for managing the lifecycle of a service oriented architecture of applicant and the related European patent 1 898 345 B1 of applicant discloses a method and system for performing complex lifecycle management in SOA registries but also proposes only options for rejecting or accepting lifecycle transitions. Finally the US patent application 2011 0314439 A1 titles Software approval process using service governance shows how lifecycle management and approvals can be used to automatically deploy SOA assets such as web services.

However the prior art approach of providing only the option to reject or accept a requested lifecycle transition makes the approval quite inflexible. For example when requesting to move an asset into the In Production lifecycle state the approver could generally agree to the requested transition but may want additional tests to be executed before moving the asset. With the capability of only approving or rejecting the requested transition the approver has to reject the transition or wait with the approval until the additional tests have been performed. Rejecting the transition however does not cover the approver s intention. Moreover once rejected the transition has to be requested again later on and the approval process has to be performed again which wastes processing time and resources. On the other hand waiting with the approval until the testing has been done also does not cover the intention of the approver. Moreover the approver has to do the final approval once the testing is completed which again creates unnecessary waiting times and requires processing resources and time that could be used more productively.

It is therefore the technical problem underlying certain example embodiments to provide an approach for controlling the lifecycle transitions of distributed computing components in a more efficient and flexible yet secure way thereby at least partly overcoming the above explained disadvantages of the prior art.

This problem is according to one aspect solved by a lifecycle management system for at least one computing component. In the embodiment of claim the lifecycle management system comprises 

Accordingly the embodiment defines a lifecycle management system operating on a lifecycle model which ensures that the managed computing component s can only transition from one lifecycle state to the next in a controlled manner. This is achieved in that the lifecycle management system is adapted for interpreting one or more conditions e.g. defined in one or more policies assigned to the lifecycle state transitions connecting the lifecycle states and for allowing the assignment of a requested lifecycle state target lifecycle state to a computing component only if the respective condition s e.g. defined in the policy policies is are fulfilled. In particular one of the lifecycle states of the lifecycle model is a productive state hereinafter also referred to the In Production state and the lifecycle management system ensures that a computing component can only be productively used i.e. used and or called by another computing component if it is assigned the production state.

Certain example embodiments depart from the inflexible approach known from the prior art to provide only the option to either approve or reject a given lifecycle transition request. To this end the lifecycle management system of certain example embodiments allows what is hereinafter called conditional approvals which involves the ability to choose the target lifecycle state for a requested lifecycle transition and thus makes the lifecycle management more flexible and efficient. Choosing the target lifecycle state may be accomplished by either selecting a target lifecycle state from a plurality of pre defined potential target lifecycle states which may be foreseen in the lifecycle model or by defining a new target lifecycle state i.e. the lifecycle model is dynamically extended at runtime .

In any case instead of just accepting or rejecting a requested lifecycle transition certain example embodiments allow to assign a lifecycle state to the at least one computing component which is different from the requested target lifecycle state. The different lifecycle state is in this context called a conditional lifecycle state and the lifecycle management system allows for specifying at least one condition that has to be fulfilled in order for the at least one computing component to be assigned the requested target lifecycle state.

Accordingly an approval process executed by means of the inventive lifecycle management system offers the approving user and or group three options The Direct Approval option follows the requested transaction and moves the asset to the requested lifecycle state. The Reject option moves the asset back to the original lifecycle state. The third option involves an additional lifecycle state and defines additional criteria for the computing component to be fulfilled before the requested lifecycle state is assigned. Once this these condition s is are fulfilled the lifecycle management system automatically assigns the requested target lifecycle state to the at least one computing component. In summary this provides for a more flexible and efficient handling of requested lifecycle transitions while it is still ensured that the computing components only evolve through their lifecycles in a controlled and consistent manner so that the proper operation of the underlying computing system is ensured.

In one aspect the lifecycle management system is adapted for automatically deploying the at least one computing component to a productive environment when the at least one computing component is assigned the production state. Accordingly it is ensured that other computing components cannot use a computing component unless it is present in the productive environment.

In another aspect the at least one condition is defined in at least one policy and comprises at least one parameter the value of which can be specified by an approving entity. Accordingly this aspect provides not only fixed policies but policies that can be parameterized leading to more flexibility and customizability of the lifecycle management. For example a testing policy may provide a parameter that allows specifying the tests that have to be executed and or a runtime invocation policy may provide a duration parameter for specifying a monitoring time period.

Furthermore at least one policy associated with the lifecycle transition request may comprise a plurality of conditions and the lifecycle management system may be adapted for ensuring that the at least one computing component is assigned the requested target lifecycle state if any of the plurality of conditions is fulfilled or if all of the plurality of conditions are fulfilled. This is particularly advantageous in case an approval has to be given by a group of users wherein the decisions of the approving users have to be consolidated. It will be appreciated that the use of policies is optional and that any other equivalent means to define certain conditions is suitable.

Preferably the lifecycle management system comprises a registry which stores a description of the at least one computing component wherein the description comprises a lifecycle property which indicates the current lifecycle state of the computing component. Even more preferably the lifecycle management system further comprises an event channel and a policy engine wherein the registry is adapted for issuing an event on the event channel indicating a lifecycle transition request for the at least one computing component and wherein the policy engine is adapted for consuming the event and for processing the lifecycle transition request in accordance with at least one associated policy. Accordingly the lifecycle management is in this aspect implemented based on the event driven architecture EDA paradigm which allows for a particularly timely processing of the lifecycle management as well as for improved extensibility as will be further explained in the detailed description further below.

In one example the requested target lifecycle state is the production state the conditional lifecycle state is an extended testing state and the at least one condition of at least one associated policy specifies at least one test that has to be passed by the computing component before it is assigned the production state. This aspect ensures that computing components are only propagated to the productive state and become usable by third parties when all necessary tests have been successfully passed. In addition or alternatively the requested target lifecycle state may be an out of production state also referred to as Retired state the conditional lifecycle state may be a retirement pending state and the at least one condition of at least one associated policy may specify that the computing component can be assigned the out of production state if it is not invoked for a defined time period. Accordingly this aspect ensures that a given computing component is only set to out of production when it is no longer used by third parties thereby again ensuring the proper operation of the underlying computing system.

As already mentioned further above the at least one computing component may be a Service oriented architecture SOA asset such as a Web service and or an Application Programming Interface API asset. Also the lifecycle model may comprise at least one lifecycle state which comprises a plurality of nested lifecycle states. Accordingly a lifecycle state may be a lifecycle stage which in turn comprises multiple lifecycle states i.e. a lifecycle stage may define a sub process within the overall lifecycle model.

Certain example embodiments also provide a computer implemented method for managing the lifecycle of at least one computing component by a lifecycle management system. In the embodiment of claim the method comprises the steps of defining a lifecycle model comprising a plurality of lifecycle states which can be assigned to the at least one computing component wherein the plurality of lifecycle states comprises a production state and wherein the lifecycle management system ensures that the at least one computing component can be productively used only if it is assigned the production state receiving a lifecycle transition request for assigning a requested target lifecycle state of the lifecycle model to the at least one computing component assigning a conditional lifecycle state to the at least one computing component which is different from the requested target lifecycle state and specifying at least one condition that has to be fulfilled in order for the at least one computing component to be assigned the requested target lifecycle state and automatically assigning the requested target lifecycle state to the at least one computing component when the at least one condition is fulfilled.

Further advantageous modifications of embodiments of the method are defined in further dependent claims.

Lastly certain example embodiments also concern a computer program comprising instructions for implementing any of the above described methods.

Managing the lifecycle of computing components i.e. controlling that the computing components only transition from one lifecycle state to the next in a well defined manner is a central prerequisite for ensuring a proper operation of the computing system implemented by the computing components. Certain example embodiments depart from the simple concept of either approving or rejecting a requested lifecycle transition as was explained further above in connection with and by introducing the concept of conditional approvals.

For example when it is requested to move the status of a computing component hereinafter also referred to as asset into an In Production lifecycle state the approver could generally agree with the requested transition but may want additional tests to be executed before moving the asset. Instead of having to reject the requested lifecycle transition which would involve a complete additional iteration in the approval process the approver is enabled to give the approval under the condition that certain additional tests are performed. If these tests are passed the asset can automatically be moved to the In Production lifecycle state without the involvement of the approver which saves processing time and resources. In certain embodiments conditional approvals can also be combined with runtime events. For example in the event of a request to change the lifecycle state of an asset from In Production to Retired also referred to as the out of production lifecycle state the approver may be fine with the requested change but to be sure that the asset is no longer in use the approver wants to ensure that there are no invocations for a certain period of time before the asset can be retired. The condition in this example is that there are no runtime invocation events for a certain period of time.

In certain embodiments conditional approvals can be implemented by extending the definition of an approval process beyond just accepting rejecting a requested lifecycle transition. More flexibility can be achieved by allowing the approver to decide on the target lifecycle state for a requested lifecycle transition. If the target lifecycle state can be chosen by an approver conditional approvals can be implemented by introducing additional lifecycle states with additional transitions to the target state. These transitions can be annotated with policies governing the final lifecycle state transitions. One advantage of this approach is that the status of the approval is indicated properly when looking at the asset.

Further certain embodiments provide policies that can be parameterized. For example the testing policy can provide a parameter that allows specifying the tests that have to be executed and the runtime invocation policy can provide a duration parameter for specifying the monitoring time period. It is proposed that these parameters can be specified by an approving user or group via so called fulfillment annotations which will be explained in more detail below.

Moreover events and event stream consuming policies can be used in certain embodiments to combine conditional approvals with runtime and or design time monitoring of SOA and or API management assets. To address the previously described use cases it is assumed that events channels transport test result events generated by testing tools and or runtime invocation events generated by runtime policy enforcement points. Based on this event driven approach other development and or governance tooling can be easily combined with conditional approvals.

The various aspects of embodiments summarized above will be explained in more detail in the following 

One concept underlying certain example embodiments is to add more flexibility to lifecycle management. Instead of just accepting or rejecting a requested lifecycle transition it is proposed to extend the possible results of a lifecycle transition request. Accordingly an approval process takes as input a requested lifecycle transition and returns a target lifecycle state or stage. This flexibility can be exploited for conditional approvals.

The approval offers the approving group or user three options. The Direct Approval option follows the transaction requested by the user from In Testing to In Production and moves the asset to the In Production state so that it can be productively used by third parties. The Reject option moves the asset back to the In Testing state . The third option provided by certain example embodiments goes over an additional lifecycle state in this example the Extended Testing state which has a transition to the In Production state . This transition carries the condition of the conditional approval. The condition is defined by a policy that checks that a certain test set has been passed. The test set can be specified via a parameter labeled x in to have greater flexibility. The test set can be specified by the approving user or the approving user group when extended testing is needed. These kinds of condition parameters are also called fulfillment annotations.

The above described example shows how the conditional approval is attached to the standard lifecycle and how the lifecycle transition can be changed by the approval to a lifecycle state in this case state different to the requested target state in this case . This means that the conditional approval does not simply accept or reject a requested lifecycle state change but allows the approving user or group to determine the target lifecycle state of the considered asset and to specify one or more fulfillment annotations.

Apparently this approach can be used to not just introduce a simple intermediate lifecycle state but a whole sub lifecycle process. For example the Extended Testing state may be expanded to comprise a complete sub lifecycle containing several states so that the lifecycle state is actually a lifecycle stage. The conditional approval then can be used to trigger the sub lifecycle covering the extended testing based on the choice made by the approving user or group.

If an approval has to be given not just by a group of users the decisions of the approving users have to be consolidated. For conditional approvals it is not sufficient to just resolve the accept and reject decisions. Also the conditions that have been chosen by the approving users have to be considered. Furthermore multiple users may choose the same condition but with different fulfillment annotations. This means that also the variety of fulfillment annotations needs to be taken into account. The resolution strategies for simple approvals can be extended to conditional approvals in the following way 

So far it is left open how the successful passing of the extended tests can be verified. Amongst other possibilities this can be done by so called event based design time monitoring. Design time monitoring refers to the monitoring of metadata in a registry cf. representing SOA API and or other assets . Design time monitoring can be extended to also cover the development and testing of assets . For example test sets can also be stored in the registry and assets or respectively their descriptions in the registry can be annotated with the test sets they already have passed.

For event based extended design time monitoring it is assumed that an event channel cf. again transports events generated by the registry on changes to the metadata . These changes are not limited to create update and delete operations but may also cover lifecycle state changes and or versioning. The events on the event channel can be consumed by policies stored in the registry . The event consuming policies can react on single events as well as on whole event streams to verify complex conditions like the absence of certain events within a certain period of time. Another exemplary complex condition is to check for the existence of a certain number of events with a given time period.

This event channel can also transport events from other tools. For example a testing tool may send its test results as an event on the event channel . These events may carry information about the test set and the asset that has been tested. This information can be checked by policies that verify test results.

Another advantage of conditional approvals can be leveraged by combining it with runtime monitoring. illustrates another variation of the lifecycle model discussed further above which comprises the lifecycle states Under developement In Testing In Production and Retired . In the lifecycle model of the conditional approval can move a given asset to the Retirement Pending state if the given asset is supposed to be retired i.e. put out of production. The Retirement Pending state is another example of the additional conditional lifecycle state explained further above and has a transition to the Retired state mod that is annotated with a policy that considers the invocation and or usage of the given asset . With this lifecycle model an approval user or group can define a grace period before the considered asset is finally retired. For not being limited to a fixed time period the condition of the conditional approval has a fulfillment annotation that maps to a parameter of the policy attached to the transition between Retirement Pending and Retired . The parameter defines the grace period of the asset retirement.

The example highlights the advantage of having the status of the approval transparently represented by additional lifecycle states . The Retirement Pending state can be considered equivalent to the Retired state mod for certain aspects. Assuming a policy that disallows the registration of new consumers cf. of an asset in the Retired state mod this policy can be extended to also reject a new consumer of the asset in the Retirement Pending state . Since the grace period can be e.g. defined terms of days and weeks it is important to have a transparent lifecycle state assignment to perform lifecycle based governance during that time.

In this example runtime invocations of the asset are monitored. Such a monitoring can be performed e.g. by integrating runtime enforcement points and the registry that is performing the lifecycle management via an event channel . As for the design time monitoring the registry can execute policies consuming single events or whole event streams from the event channel . In this example a policy verifies that there are no runtime invocation events on the runtime event channel for a certain period of time. Runtime events can be created by runtime enforcement points in different ways. One approach is to provide virtual endpoints for native services. All calls to the virtual endpoint are mediated and forwarded to the native service. While doing this the runtime policy enforcement point collects various kinds of runtime monitoring data such as invocation events and or processing time.

As already explained above the inventive concept of conditional approvals is particularly advantageous for the lifecycle management of computing components such as SOA assets and or API assets.

Nevertheless the present invention is not restricted to lifecycle management but the concept of conditional approvals may also be applied e.g. to consumer management in a SOA and or API management registry . Consumer registration generally refers to introducing a consumes relationship between a consumer asset and a service asset as exemplarily illustrated in

The introduction of a consumer registration can be controlled with a simple lifecycle model that applies to the consumes relationship between the consumer and the service asset . As illustrated in the exemplary lifecycle model comprises the lifecycle states Registration Requested and Registration Approved . The transition therebetween has an approval policy controlling the consumer registration via human interaction.

The approval can be extended to a conditional approval to allow the approving user or group to a consumer registration under a condition that could be runtime related. For example the consumer registration may become effective only if a certain service level agreement SLA has not been violated for a certain period of time. The SLA can be verified by checking the runtime events sent via the runtime event channel . The corresponding lifecycle model is shown in which comprises the additional lifecycle state Registration Pending which has a transition to the final Registration Approved lifecycle state. A policy is attached to the transition which checks that there are no SLA violations for a certain period of time. The time period can again be specified by the approving user or group via a fulfillment attachment of the conditional approval.

In the following an exemplary application scenario for lifecycle management with conditional approvals is provided. In this example a company SampleState.com provides an API that offers services to access the company s real estate database. SampleState.com provides the following service via the API 

Since the database is growing a service such as GetRealEstates which returns all information does not make sense anymore. Therefore SampleState.com has developed new services which are ready to be put into production. These are 

The old service GetRealEstates needs to be retired i.e. put out of production and the new services GetRegion and GetRealEstatesByRegion need to be put into production in a controlled way. Moreover SampleState.com foresees a need for extending their service offer in the near future. To maintain the lifecycle of their services SampleState.com has deployed the lifecycle model exemplarily shown in . As can be seen the lifecycle model shown in is a combination of the models described further above which comprise the lifecycle states Under development In Testing In Production and Retired . In the example of the transition see the arrow in between the In Testing state and the In Production state is annotated with a conditional approval policy . The Retirement Pending state also shown in is another example of a conditional lifecycle state which has a transition to the Retired state and which is annotated with another conditional approval policy . The service GetRealEstates is currently in the lifecycle state In Production . The new services GetRegions and GetRealEstatesByRegion have the lifecycle state In Testing respectively.

The first lifecycle transition request is to move the service GetRegions to the lifecycle state In Production . Anne is a software architect of SampleState.com who is in charge of reviewing all services that are moved from In Testing to In Production Anne decides that the service GetRegions is already ready for production and approves the requested transition right away. Accordingly the lifecycle management system assigns the lifecycle state In Production to the service GetRegions .

The next request is to move the service GetRealEstatesByRegion to the lifecycle state In Production . Here Anne thinks that the service is in principle ready for production but to be sure that there will be no problems in production she request some additional testing. The additional tests verify that GetRealEstatesByRegion can deal with large result sets Anne does not reject the transition but moves the services into the lifecycle state Extended Testing . Services in Extended Testing are not yet considered to be in production which means that consumers cannot register to these services.

After the new services have reached the In Production lifecycle state it is time to retire the old service GetRealEstates . The requested transition needs to be approved by the product manager Paul in this example. Paul is concerned that the service GetRealEstates is still used although he has informed all customers of the planned retirement. Therefore Paul decides to wait thirty more days until the service can be finally moved to the Retired lifecycle state and moves the service to the Retirement Pending lifecycle state . New consumers cannot register to services being in this state but services in this state can still be used by existing consumers .

In the following it will be described how conditional approvals can be implemented. In a preferred embodiment the components of the implementation comprise cf. also 

The implementation of runtime enforcement points is not the subject of these particular embodiments but can be readily achieved using existing technology. The implementation of event channels is also provided by already existing enterprise service bus ESB technologies or using frameworks such as the Apache Camel integration framework. The same is true for the implementation of metadata registries providing policy lifecycle management and approval capabilities. Therefore hereinafter the focus lies on the data needed to be processed through the event channel and the metadata which needs to be stored in the registry .

As already explained the basis for a SOA governance and or API management solution is a registry which manages the metadata for the SOA and or API assets . The metadata may be stored in XML format as used in the examples hereinafter or any other suitable storage format.

The simplified XML representation defines the name of the asset and its id identifier . In addition it defines the access URI element end point and the lifecycle state reference element lifecycle state . The service presently is assigned the lifecycle state Under Development and thus it references the Under Development lifecycle state of the following lifecycle model 

As asset metadata lifecycle models are also stored in the registry . The approval policies and the conditional approval policies are preferably stored in separate XML objects. A simplified XML representation of the conditional approval policy looks as follows 

The approval policy is a lifecycle model policy. It references the transition it is attached to and the action it is performing. Since it is an approval policy it references the approval action. Policy actions may be specified in an arbitrary scripting or programming language such as Java.

Beside the transition and the action the policy references action parameters. The action parameters of the approval policy comprise the approver the reject state and the possible result options. Each result option comes with a state reference and an optional parameter for the fulfillment annotation. The following simplified XML data shows the policy that verifies the runtime invocation 

The policy is attached to the transition from Retirement Pending to Retired . It references the action CheckRuntimeInvocations which verifies that there are no runtime invocations on a given asset for a given period of time. The time period is given by the duration parameter of the policy.

A possible implementation of the CheckRuntimeInvocations action is illustrated by the following pseudo code 

The pseudo code illustrates a simple algorithm which verifies for a requested lifecycle transition that there are no invocation events on the monitored event stream. The requested transition references the asset that is supposed to change its lifecycle state. The asset and the event are correlated via the end point of the asset. The event structure expected by the exemplary code is as follows 

Apparently the simple algorithm shown above may be replaced with any more advanced event processing technology without leaving the scope of the invention.

It will be appreciated that as used herein the terms system subsystem service engine module programmed logic circuitry computing component and the like e.g. including for example the term lifecycle management system may be implemented as any suitable combination of software hardware firmware and or the like. In other words these terms may include processing resources such as for example at least one processor and a memory suitable for carrying out instructions for performing specific functions. It also will be appreciated that the storage locations herein may be any suitable combination of disk drive devices memory locations solid state drives CD ROMs DVDs tape backups storage area network SAN systems and or any other appropriate tangible non transitory computer readable storage medium. Cloud and or distributed storage e.g. using file sharing means for instance also may be used in certain example embodiments. Such storage media may be used to store for example the registry descriptions events requests policies etc. described herein. It also will be appreciated that the techniques described herein may be accomplished by having at least one processor execute or otherwise perform instructions that may be tangibly stored on a non transitory computer readable storage medium.

