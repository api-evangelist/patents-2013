---

title: Declarative driver
abstract: A system and method for building a driver are disclosed. In one embodiment, the system includes one or more processors and a memory storing instructions that, when executed by the processor, cause the system to: obtain an interface description; obtain at least one mapping rule; operate a flow controller that controls a flow of operations, the operations using one or more of the interface description and the at least one mapping rule; obtain a protocol adapter; and implement access to a data source based on the operation of the flow controller using the obtained protocol adapter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09613117&OS=09613117&RS=09613117
owner: Progress Software Corporation
number: 09613117
owner_city: Bedford
owner_country: US
publication_date: 20131211
---
The amount of data being generated is increasing. There has been a corresponding growth in the number and variety of data sources including a growing number and variety of cloud data sources to store this data. A driver which is used by an application to access the data stored in such a data source must be built for each data source. Therefore an increasing number of drivers are being built.

However existing systems and methods for building drivers fail to deliver a short turnaround time from research to delivery of the driver fail to develop the driver using descriptive artifacts fail to provide a protocol neutral platform for access and interaction which includes pluggable protocol support and are not extensible and pluggable for custom use cases.

The present disclosure relates to building a driver. According to one innovative aspect of the subject matter in this disclosure a system having one or more processors and a memory storing instructions that when executed cause the system to obtain an interface description obtain at least one mapping rule operate a flow controller that controls a flow of operations the operations using one or more of the interface description and the at least one mapping rule obtain a protocol adapter and implement access to a data source based on the operation of the flow controller using the obtained protocol adapter.

In general another innovative aspect of the subject matter described in this disclosure may be embodied in methods that includes obtaining using one or more processors an interface description obtaining using one or more processors at least one mapping rule operating using one or more processors a flow controller that controls a flow of operations the operations using one or more of the interface description and the at least one mapping rule obtaining using one or more processors a protocol adapter and implementing using one or more processors access to a data source based on the operation of the flow controller using the obtained protocol adapter.

Other implementations of one or more of these aspects include corresponding systems apparatus and computer programs configured to perform the actions of the methods encoded on computer storage devices.

These and other implementations may each optionally include one or more of the following features. For instance the interface description includes a declarative file written in a platform data source agnostic language. For instance the operations may further include receiving a schema description the schema description defining a logical schema for the data source. For instance the operations further include receiving a set of query conditions and receiving a definition of one or more service identification rules for the set of query conditions. For instance the operations further include receiving a mapping rule for mapping a query from a client to a data source request and receiving a mapping rule for mapping a data source response to a logical schema defined by a schema description. For instance the operations further include reading the interface description and receiving a query originating from a client. For instance the operations further include retrieving from the at least one mapping rule one or more rules for mapping the query to a data source request parsing query to get search conditions converting the query from one semantic space to another semantic space based on one or more data mapping rules. For instance the operations further include modifying one or more of the interface description the at least one mapping rule and the protocol adapter that is obtained and implementing access to a different data source.

These implementations are particularly advantageous in a number of respects. For instance the technology described herein can rapidly build a driver for any cloud data source using declarative artifacts. It should be understood however that this list of features and advantages is not all inclusive and many additional features and advantages are contemplated and fall within the scope of the present disclosure. Moreover it should be understood that the language used in the present disclosure has been principally selected for readability and instructional purposes and not to limit the scope of the subject matter disclosed herein.

Systems methods and interfaces are disclosed. While the systems methods and interfaces of the present disclosure are described in the context of building drivers that provide accesses to data sources it should be understood that the systems methods and interfaces can be applied to other contexts.

The client devices in are used by way of example. While illustrates two client devices and the present disclosure applies to any system architecture having one or more client devices . Furthermore while only one network is coupled to the client devices and the data source in practice one or more networks can be connected to these entities. Furthermore while only one data source is shown the system can include one or more data sources .

The client devices can be one or more computing devices including one or more memory and one or more processors for example a laptop computer a desktop computer a tablet computer a server a mobile telephone a personal digital assistant PDA a mobile email device a portable game player a portable music player a television with one or more processors embedded therein or coupled thereto or any other electronic device capable of accessing a network . In one embodiment the system includes a combination of different types of client devices . For example a combination of a personal computer and a mobile phone. As will be described below it should be understood that the present technologies can operate on different models other than a client server architecture. It should also be understood that although only client device is illustrated as including a driver and a client application each of the one or more client devices may include an instance of a driver and a client application . The client device according to one embodiment is described in more detail with reference to .

The network enables communications between the client devices and the data source . Thus the network can include links using technologies including for example Wi Fi Wi Max 2G Universal Mobile Telecommunications System UMTS 3G Ethernet 802.11 integrated services digital network ISDN digital subscriber line DSL asynchronous transfer mode ATM InfiniBand PCI Express Advanced Switching etc. Similarly the networking protocols used on the network can include the transmission control protocol Internet protocol TCP IP multi protocol label switching MPLS the User Datagram Protocol UDP the hypertext transport protocol HTTP the simple mail transfer protocol SMTP the file transfer protocol FTP lightweight directory access protocol LDAP Code Division Multiple Access CDMA Wideband Code Division Multiple Access WCDMA Global System for Mobile communications GSM High Speed Downlink Packet Access HSDPA etc. The data exchanged over the network can be represented using technologies and or formats including the hypertext markup language HTML the extensible markup language XML etc. In addition all or some of links can be encrypted using conventional encryption technologies for example the secure sockets layer SSL Secure HTTP and or virtual private networks VPNs or Internet Protocol security IPsec . In one embodiment the entities can use custom and or dedicated data communications technologies instead of or in addition to the ones described above. Depending upon the implementation the network can also include links to other networks.

The network may have any number of configurations including a star configuration token ring configuration or other configurations. Furthermore the network may include a local area network LAN a wide area network WAN e.g. the Internet and or any other interconnected data path across which multiple devices may communicate. In one embodiment the network may be a peer to peer network. The network may also be coupled to or include portions of a telecommunications network for sending data in a variety of different communication protocols. In one embodiment the network includes short wavelength communication networks or a cellular communications network for sending and receiving data including via short messaging service SMS multimedia messaging service MMS hypertext transfer protocol HTTP direct data connection wireless application protocol WAP electronic messages etc.

The data source may be a non transitory memory that stores data. For example the data source may be a dynamic random access memory DRAM device a static random access memory SRAM device flash memory or some other memory device. In one embodiment the data source also includes a non volatile memory or similar permanent storage device and media for example a hard disk drive a floppy disk drive a compact disc read only memory CD ROM device a digital versatile disc read only memory DVD ROM device a digital versatile disc random access memories DVD RAM device a digital versatile disc rewritable DVD RW device a flash memory device or some other non volatile storage device.

In some embodiments the data source is included in a data server . The data server may be any class of data server including for example a SaaS application packaged on premise application relational application data warehouse etc. In one embodiment the data server may include one or more computing devices having data processing storing and communication capabilities. For example the data server may include one or more hardware servers server arrays storage devices systems etc. and or may be centralized or distributed cloud based. In some implementations the data server may include one or more virtual servers which operate in a host server environment and access the physical hardware of the host server including for example a processor memory storage network interfaces etc. via an abstraction layer e.g. a virtual machine manager . While one data server is illustrated the system may include any number of data servers .

The data server stores data in a data source . For example the data server may be associated with a web service such as Dropbox Evernote Google Docs Microsoft SkyDrive Salesforce Eloqua Hubspot Aprimo Marketo Sugar CRM Oracle s RightNow Microsoft Dynamics Hadoop Hive Amazon DynamoDB Google Bigtable PostgreSQL Enterprise DB Microsoft SQL Azure Amazon RDS Salesforce s database.com Redis Cassandra MongoDB CouchBase HBase Hive Impala SuccessFactors Taleo ADP Workday Intacct Concur NetSuite SAP Business by Design QAD Infor SAP HANA Intuit OData or any other web service that stores data.

A user interacts with the client device as represented by signal line . For example the user interacts with the client device to provide one or more of user input to build a driver e.g. an interface description and user input to use the driver e.g. a query .

It should be understood that the system illustrated in is representative of an example system for building a driver according to one embodiment and that a variety of different system environments and configurations are contemplated and are within the scope of the present disclosure. For instance various functionality may be moved from a server to a client or vice versa and some implementations may include additional or fewer computing devices services and or networks and may implement various functionality client or server side. Further various entities of the system may be integrated into to a single computing device or system or additional computing devices or systems may be included.

The communication unit is coupled to the network by signal line . The communication unit is also coupled to the bus . The communication unit transmits and receives data to and from the data source . The communication unit provides other conventional connections to the network using network protocols e.g. TCP IP HTTP HTTPS and SMTP. In some implementations the communication unit includes a port for direct physical connection to the network or to another communication channel. For example the communication unit includes a USB SD CAT 5 or similar port for wired communication with the client device . In some implementations the communication unit includes a wireless transceiver for exchanging data with the client device or other communication channels using one or more wireless communication methods including IEEE 802.11 IEEE 802.16 BLUETOOTH or another suitable wireless communication method.

The processor may include an arithmetic logic unit a microprocessor a general purpose controller or some other processor array to perform computations and provide electronic display signals to a display device. The processor is coupled to the bus for communication with the other components of the client device . Processor processes data signals and may include various computing architectures including a complex instruction set computer CISC architecture a reduced instruction set computer RISC architecture or an architecture implementing a combination of instruction sets. Although only a single processor is shown in multiple processors may be included. It should be understood that other processors operating systems sensors displays and physical configurations are possible.

The memory stores instructions and or data that may be executed by the processor . In the illustrated implementation the memory stores the driver . The memory is coupled to the bus for communication with the other components of the client device . The instructions and or data may include code for performing any and or all of the techniques described herein. For example in the illustrated embodiment the memory stores the driver which is executed by the processor .

In the illustrated embodiment the memory stores a client application which may use the driver to access data stored on a data source . Depending on the embodiment the client application may be a web browser a desktop client a mobile client or any other application that accesses a data source . The client application may be written in Java C C or any other programming language.

Depending on the embodiment the client application may use an application program interface API to communicate with the driver . For example the client application may be a Java Database Connectivity JDBC Open Database Connectivity ODBC ADO.NET or Object Linking and Embedding Database OLE DB client. For clarity and convenience the examples used herein may frequently refer to a JDBC client or an ODBC client as examples of a client application . However the disclosure herein is not necessarily limited to such client applications .

The memory includes a non transitory computer usable e.g. readable writeable etc. medium which may be any apparatus or device that may contain store communicate propagate or transport instructions data computer programs software code routines etc. for processing by or in connection with the processor . In some embodiments the memory may include one or more of volatile memory and non volatile memory. For example the memory may include but is not limited to one or more of a dynamic random access memory DRAM device a static random access memory SRAM device flash memory or some other memory device. In some implementations the memory also includes a non volatile memory or similar permanent storage device and media including a hard disk drive a floppy disk drive a CD ROM device a DVD ROM device a DVD RAM device a DVD RW device a flash memory device or some other mass storage device for storing information on a more permanent basis. It should be understood that the memory may be a single device or may include multiple types of devices and configurations.

The bus can include a communication bus for transferring data between components of a client device and or between computing devices e.g. between one or more of the client device and data source a network bus system including the network or portions thereof a processor mesh a combination thereof etc. In some implementations the schema tool its sub components and various other software operating on the computing device e.g. an operating system etc. may cooperate and communicate via a software communication mechanism implemented in association with the bus . The software communication mechanism can include and or facilitate for example inter process communication local function or procedure calls remote procedure calls an object broker e.g. CORBA direct socket communication e.g. TCP IP sockets among software modules UDP broadcasts and receipts HTTP connections etc. Further any or all of the communication could be secure e.g. SSH HTTPS etc. .

Still referring to in one embodiment the driver includes a declarative driver framework and artifacts . The driver may beneficially be configured to connect to any data source e.g. any cloud based data source by generating descriptive artifacts using the declarative driver framework . The declarative driver framework uses the descriptive artifacts to allow the driver to access the data source . Thus the declarative driver framework builds the driver by generating descriptive artifacts and along with the generated artifacts comprises the driver .

Referring now to an example of the artifacts generated and used by the declarative driver framework is shown according to one embodiment. In the illustrated embodiment the artifacts include an interface description data mapping rules and a binding strategy stack . In one embodiment the interface description includes a schema description and service identification rules . The various artifacts are discussed in detail below with reference to .

The system and method disclosed herein beneficially enable the building of a driver by generating a small number of files or artifacts . So a first driver instance for accessing a first data source may be built by generating and using a first set of artifacts associated with the first driver instance and a second driver instance for accessing a second data source may be built by generating a second set of artifacts associated with the second driver instance. Moreover a driver for accessing a first data source may be modified to access a second data source instead by modifying the artifacts .

Referring now to the declarative driver framework is described in more detail according to one implementation. In one embodiment the declarative driver framework includes a driver interface module a query processing module a data mapping module an interface description module a flow controller module and a protocol management module . Each of these components is coupled for communication with each other and the other components of the driver .

The driver interface module can be software or routines for handling communications between the driver and the client application . In one embodiment the driver interface module is a set of instructions executable by the processor . In one embodiment the driver interface module is stored in the memory of the client device and is accessible and executable by the processor . In one embodiment the driver interface module is adapted for cooperation and communication with the processor and other components of the client device .

The driver interface module handles communications between the driver and the client application . In one embodiment the driver interface module receives a query from a client application and returns results to a client application . For example assume the client application is a JDBC or ODBC client and uses structured query language SQL in one embodiment the driver interface module receives a SQL query from the JDBC or ODBC client and transmits a result using SQL to the JDBC or ODBC client. Query as used herein may refer to any request. Examples of queries include but are not limited to fetching writing modifying updating and inserting data stored by the data source and modifying a structure stored in the data source e.g. add drop a table column relationship etc. .

In one embodiment the driver interface module passes a query to the query processing module . In one embodiment the driver interface module stores the query in memory or any other non transitory storage medium communicatively accessible and the other modules of the declarative driver framework e.g. the query processing module may retrieve the query from the memory or other non transitory storage medium .

In one embodiment the driver interface module returns results to a client application . For example in one embodiment the driver interface module passes results which are converted by the data mapping module from the semantic space of the data source to that of the client application to the client application .

The query processing module can be software or routines for processing a query. In one embodiment the query processing module is a set of instructions executable by the processor . In one embodiment the query processing module is stored in the memory of the client device and is accessible and executable by the processor . In one embodiment the query processing module is adapted for cooperation and communication with the processor and other components of the client device .

The query processing module processes a query. In one embodiment the query processing module processes a query for use by the flow controller module . For example in one embodiment the query parsing module obtains the query e.g. from the driver interface module processes the query and sends the processed query to the flow controller module .

In one embodiment processing a query may include one or more of parsing a query validating a query and generating a query plan. Parsing a query may beneficially identify errors prior to execution of a flow controller. For example assume again that the client application is a JDBC or ODBC client and therefore the query is a SQL query. In one embodiment the query processing module parses the query and identifies the operation s e.g. SQL statements and parameters e.g. table names column names values to be inserted etc. and determines whether the query is semantically and syntactically correct. For example the query processing module may determine the query SELECT last name email FROM contacts is semantically and syntactically correct and passes the query which may be referred to occasionally as a processed query to the flow controller module but may determine SELECT last name is a fragment which is syntactically incorrect and does not pass the query fragment to the flow controller module . In one embodiment the query processing module may validate the query by determining whether the client application has the appropriate privileges to make such a query.

In one embodiment the query processing module passes the processed query to the flow controller module . In one embodiment the query processing module stores the processed query in memory or any other non transitory storage medium communicatively accessible and the other modules of the declarative driver framework e.g. the flow controller module may retrieve the processed query from the memory or other non transitory storage medium .

The data mapping module can be software or routines for generating data mapping rules . In one embodiment the data mapping module is a set of instructions executable by the processor . In one embodiment the data mapping module is stored in the memory of the client device and is accessible and executable by the processor . In one embodiment the data mapping module is adapted for cooperation and communication with the processor and other components of the client device .

The data mapping module generates data mapping rules . Data mapping rules may include one or more rules used to convert from one semantic space to another. For example assume the client application is a JDBC client and the data source is a cloud based Eloqua database in one embodiment the data mapping module uses the data mapping rules to convert a SQL query i.e. a first semantic space query to one or more requests native to and recognizable by Eloqua i.e. a second semantic space and for converting a response received from Eloqua i.e. first semantic space into SQL results i.e. second semantic space . In another example the data mapping rules may convert Java objects to XML JSON objects.

For clarity and convenience some of the examples herein may refer to Eloqua. However it should be noted that Eloqua is just one example of a data sources and one example of a cloud based data source which the driver may be built using the declarative driver framework to access and that other data sources and other cloud based data sources exist and may be used without departing from the teachings herein.

The data mapping module generates data mapping rules based on user input. For example in one embodiment the data mapping module includes an Expression Language EL based data mapping framework and the user inputs one or more XML based rules for manipulating data. In one embodiment the data mapping rules includes a plurality of rules and the plurality of rules may be one or more of hierarchical to the ndegree conditional looped and grouped. An example data mapping rules is shown in .

The mapping rules indicate how to map a query received from the client application to a request for the data source and a response from the data source to results for the client application . In one embodiment the data mapping module executes one or more of the data mapping rules at the direction of the flow controller module to map a query or response from one semantic space to another. For example assume the client application is a JDBC client and the data source is a cloud based Eloqua database. Also assume that the query processing module has processed the query and the flow controller module using the service identification rules has identified one or more services and or operations based on the processed query. In one embodiment the data mapping module applies the data mapping rules to the processed query data to convert a SQL query i.e. a first semantic space to a request native to and recognizable by Eloqua i.e. a second semantic space to invoke the identified one or more services and or operations. The data mapping module may also applydata mapping rules to convert a response subsequently received from Eloqua i.e. a first semantic space into SQL results i.e. a second semantic space .

A query or processed query that has been mapped or converted by the data mapping module is occasionally referred to herein as a request or a data source request. In one embodiment the data mapping rules passes a request to the protocol management module . In one embodiment the data mapping module stores the request in memory or any other non transitory storage medium communicatively accessible and the other modules of the declarative driver framework e.g. the protocol management module may retrieve the request from the memory or other non transitory storage medium .

A response from a data source that has been mapped or converted by the data mapping module is occasionally referred to herein as converted results mapped results or simply as results. In one embodiment the data mapping rules passes converted results to the flow controller module . In one embodiment the data mapping module stores the converted results in memory or any other non transitory storage medium communicatively accessible and the other modules of the declarative driver framework e.g. the flow controller module may retrieve the converted results from the memory or other non transitory storage medium .

The interface description generation module can be software or routines for generating an interface description. In one embodiment the interface description module is a set of instructions executable by the processor . In one embodiment the interface description module is stored in the memory of the client device and is accessible and executable by the processor . In one embodiment the interface description module is adapted for cooperation and communication with the processor and other components of the client device .

The interface description module generates an interface description. In one embodiment the interface description module generates an interface description based on user input. Referring now to in one embodiment an interface description is one of the artifacts that is generated by the declarative driver framework and used by the declarative driver framework to provide a client application access to data stored in a data source . In one embodiment an interface description includes a schema description file and a service identification rules file including one or more service identification rules.

The schema description describes a logical schema of the data source the driver is to access once built. For example assume the driver is being built to access Eloqua as a data source in one embodiment the schema description describes the logical schema of the Eloqua database to be accessed. In one embodiment the interface description module generates the schema description by receiving user input. For example in one embodiment the interface description module receives a schema description from the user . In one embodiment the interface description module invokes an API associated with the data source and automatically generates a schema description using the API.

In one embodiment the schema description uses a platform data source agnostic language. A platform data source agnostic language is a language that does not depend on the platform e.g. the operating system of the client device and or the type e.g. Java C C etc. of client application and or the data source e.g. the type data source the query language used etc. For example in some embodiments the schema description is written by a user using the Interface Description Language IDL i.e. a platform data source agnostic language and defines the schema of the data source . For example assuming again that the driver is being built to access an Eloqua database i.e. a cloud based data source in one embodiment the interface description module receives a declarative description of the schema e.g. the tables table columns indexes relationships such as foreign key relationships between tables etc. of the Eloqua database in a platform data source agnostic language. An example of at least a portion of a schema description using the IDL is shown in .

The service identification rules identify the services and or operations that may be invoked at the data source . In one embodiment the service identification rules include one or more declarative rules. For example in one embodiment the service identification rules include one or more XML based rules. In some embodiments the service identification rules support conditionality and may be modified to insert new behavior as new query conditions or data source services and or operations are introduced e.g. through updates to the client application and or data source .

In one embodiment the interface description module generates the service identification rules by receiving user input. For example in one embodiment the interface description module receives a set of query conditions from the user and service identification rules describing the operations methods that should be invoked at the data source when a query condition is met. For example assuming the client application is a JDBC client and the data source is a Cassandra database which is a NoSQL database the user may define query conditions such as a SQL query and or SQL query type e.g. SELECT INSERT DELETE UPDATE etc. and service identification rules such as how that query or query type is invoked in Cassandra Query Language CQL which may require invoking one or more operations defined by the service identification rules .

In one embodiment the interface description module passes the interface description to the flow controller module . In one embodiment the interface description module stores the interface description in memory or any other non transitory storage medium communicatively accessible and the other modules of the declarative driver framework e.g. the flow controller module may retrieve the interface description from the memory or other non transitory storage medium .

The flow controller module can be software or routines for controlling an execution flow. In one embodiment the flow controller module is a set of instructions executable by the processor . In one embodiment the flow controller module is stored in the memory of the client device and is accessible and executable by the processor . In one embodiment the flow controller module is adapted for cooperation and communication with the processor and other components of the client device .

The flow controller module controls an execution flow by determining what to invoke and in what order and by supplying contextual information. For example in one embodiment the flow controller module receives a processed query from the processing module invokes the service identification rules to identify an operation invokes a binding a strategy stack directing the data mapping module to create a data source request and invokes the protocol management module to pass the data source request and any associated data to the data source . In another example the flow controller receives a data source response after the protocol management module has stripped the associated protocol from the response invokes a binding strategy e.g. a mapping binding strategy which invokes the data mapping module to convert the response into results determines whether the results are complete and if the results are complete passes the results to the driver interface to be sent to the client application . If the results are not complete the flow controller module may invoke the data mapping module to create another data source request to repeat the previous operation or may invoke the service identification rules to identify a different operation and invoke the data mapping module to create a data source request for the next operation.

In one embodiment the flow controller module invokes and executes a binding strategy stack . In one embodiment the binding strategy stack is a Spring Configuration file to permit the inclusion of additional binding functionality by adding an entry to the Spring Configuration file. illustrates an example of a binding strategy stack according to one embodiment. In one embodiment a binding strategy stack includes a root nested binding strategy which includes one or more of a mapping binding strategy which may itself include a post mapping binding strategy a rules based binding strategy and an authentication scheme specific binding strategy . The vertical ellipses in indicate that any number of binding strategies may be included and nested at any level in the root nested binding strategy.

In one embodiment the mapping binding strategy commands or invokes the data mapping module causing the data mapping module to execute and apply the data mapping rules to map from one semantic space to another. In one embodiment the post mapping binding strategy allows for one or more of exception handling e.g. when an error occurs when mapping from one semantic space to another and data beautification e.g. data cleaning or massaging . In one embodiment the rules based binding strategy allows the binding to comply with one or more rules. For example assume a data source and or client application require as a rule that a query or a result include a certain piece of information e.g. each query and or result is tagged with an employee ID session ID user ID and password or some other information . In one embodiment the rules based binding strategy applies that piece of information to comply with the rule. In one embodiment an authentication scheme specific binding strategy may handle any security certificates and authentication handshakes that may be required between the client application and the data source .

As mentioned above the flow controller module may provide contextual information. For example in one embodiment when the flow controller executes a binding strategy to create a data source request the flow controller may pass information associated with the query i.e. contextual information. For example assume a query is to insert data in one embodiment the flow controller module passes the data to be inserted i.e. contextual data from the processed query to the data mapping module and the data mapping module creates the appropriate data source request.

In one embodiment the flow controller module passes the result of the binding to the driver interface module . For example the flow controller module determines whether mapped results received from the data mapping module is complete and sends the mapped result to the driver interface module to be sent to the client application .

The protocol management module can be software or routines for managing one or more protocols for communicating with a data source . In one embodiment the protocol management module is a set of instructions executable by the processor . In one embodiment the protocol management module is stored in the memory of the client device and is accessible and executable by the processor . In one embodiment the protocol management module is adapted for cooperation and communication with the processor and other components of the client device .

The protocol management module manages one or more protocols for communicating with a data source . In one embodiment the protocol management module manages the one or more protocols by determining a protocol to use and configuring the determined protocol. Depending on the data source the driver is built to access the protocol may vary. For example some cloud based data sources may communicate using REST protocol others may communicate using Web Services WS and still others may communicate using Java Messaging Service JMS . It should be recognized that REST WS and JMS are merely examples of protocols and that other protocols exist and may be used without departing from the disclosure herein.

In one embodiment the protocol management module determines a protocol based on a user input. For example in one embodiment the protocol management module receives an input indicating that the data source uses REST determines to use a REST protocol and configures the REST protocol. For example the protocol management module receives a query that has been converted into the semantic space of the cloud data source and applies the REST protocol to that query. The protocol management module receives a response from the data source determines the response received uses the REST protocol and strips the protocol from the response and sends the response to the data mapping module to be mapped to a client result. In one embodiment the protocol management module sends the response stripped of the protocol to the data mapping module at the direction of the flow controller module . In one embodiment the driver interface module passes a data source request to the data source using the determined protocol. In one embodiment the protocol management module passes a data source request to the data source using the determined protocol at the direction of the flow controller module .

In one embodiment the protocol management module can allow the interaction between a protocol and any protocol specific component. In one embodiment the protocol management module can plug any protocol specific component to interact with the protocol by providing configurability of protocol specific processors. In one embodiment the protocol management module can plug any protocol specific component to interact with the protocol by providing configurability of open source endpoints. For example the protocol management module can build the protocol in and provide the configurability of Apache Camel endpoints.

In one embodiment the protocol management module can provide inbuilt support for one or more common protocols including for example REST WS and JMS invocations. In one embodiment the protocol management module can provide integration for open source frameworks e.g. CXF for protocol specific invocations. The protocol management module can provide inbuilt support for advanced features for these frameworks. For example the advanced features may include WS Security and WS Reliable Messaging.

At block the flow controller module determines whether the same operation needs to be invoked to receive query results based on the parsed query and one or more service identification rules. When the flow controller module determines that the same operation needs to be invoked to receive query results Yes the method B continues at block and block and may be repeated until the flow controller module determines that the same operation does not need to be invoked to receive query results No . When the flow controller module determines that same operation does not need to be invoked to receive query results No the method B continues at block .

At block the flow controller module determines whether another operation needs to be invoked to receive query results based on the parsed query and one or more service identification rules. When the flow controller module determines that another operation needs to be invoked to receive query results Yes the method B continues at block and block and may be repeated until the flow controller module determines that another operation does not need to be invoked to receive query results No . When the flow controller module determines that another operation does not need to be invoked to receive query results No the method B continues at block .

At block the data mapping module converts the results for the client based on the data mapping rules. At block the driver interface module sends the converted results to the client.

In the above description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. However it should be understood that the technology described herein may be practiced without these specific details. Further various systems devices and structures are shown in block diagram form in order to avoid obscuring the description. For instance various implementations are described as having particular hardware software and user interfaces. However the present disclosure applies to any type of computing device that may receive data and commands and to any peripheral devices providing services.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

In some instances various implementations may be presented herein in terms of algorithms and symbolic representations of operations on data bits within a computer memory. An algorithm is here and generally conceived to be a self consistent set of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout this disclosure discussions utilizing terms including processing computing calculating determining displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Various implementations described herein may relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium including but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards flash memories including USB keys with non volatile memory or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The technology described herein may take the form of an entirely hardware implementation an entirely software implementation or implementations containing both hardware and software elements. For instance the technology may be implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the technology may take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium may be any non transitory storage apparatus that may contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

A data processing system suitable for storing and or executing program code may include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements may include local memory employed during actual execution of the program code bulk storage and cache memories that provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution. Input output or I O devices including but not limited to keyboards displays pointing devices etc. may be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems storage devices remote printers etc. through intervening private and or public networks. Wireless e.g. Wi Fi transceivers Ethernet adapters and modems are just a few examples of network adapters. The private and public networks may have any number of configurations and or topologies. Data may be transmitted between these devices via the networks using a variety of different communication protocols including for example various Internet layer transport layer or application layer protocols. For example data may be transmitted via the networks using transmission control protocol Internet protocol TCP IP user datagram protocol UDP transmission control protocol TCP hypertext transfer protocol HTTP secure hypertext transfer protocol HTTPS dynamic adaptive streaming over HTTP DASH real time streaming protocol RTSP real time transport protocol RTP and the real time transport control protocol RTCP voice over Internet protocol VOIP file transfer protocol FTP WebSocket WS wireless access protocol WAP various messaging protocols SMS MMS XMS IMAP SMTP POP WebDAV etc. or other known protocols.

Finally the structure algorithms and or interfaces presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method blocks. The required structure for a variety of these systems will appear from the description above. In addition the specification is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the specification as described herein.

The foregoing description has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the specification to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the disclosure be limited not by this detailed description but rather by the claims of this application. As will be understood by those familiar with the art the specification may be embodied in other specific forms without departing from the spirit or essential characteristics thereof. Likewise the particular naming and division of the modules routines features attributes methodologies and other aspects are not mandatory or significant and the mechanisms that implement the specification or its features may have different names divisions and or formats.

Furthermore the modules routines features attributes methodologies and other aspects of the disclosure may be implemented as software hardware firmware or any combination of the foregoing. Also wherever a component an example of which is a module of the specification is implemented as software the component may be implemented as a standalone program as part of a larger program as a plurality of separate programs as a statically or dynamically linked library as a kernel loadable module as a device driver and or in every and any other way known now or in the future. Additionally the disclosure is in no way limited to implementation in any specific programming language or for any specific operating system or environment. Accordingly the disclosure is intended to be illustrative but not limiting of the scope of the subject matter set forth in the following claims.

