---

title: Using stack data and source code to rank program changes
abstract: A computer accesses a stack data and a source code of a program. The computer searches for a first change made to the program, wherein the first change is one of a change to a method of the program, a change to a class of the program, a change to a method that is invoked by the program, or a change to a class containing a method that is invoked by the program. The computer identifies the first change that was made to the program and determines the probability that the identified first change caused one or both of an error and a regression. The computer generates a ranked list of identified changes based, at least in part, on the probability that the identified first change caused one or both of an error and a regression.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924932&OS=08924932&RS=08924932
owner: International Business Machines Corporation
number: 08924932
owner_city: Armonk
owner_country: US
publication_date: 20130411
---
The present invention relates generally to the field of program development and more particularly to the identification and ranking of code changes that may have caused program error.

The need for a logical way to organize and control revisions has existed for almost as long as writing has been in existence. However revision control has become much more important and complicated with the advent of computer programs.

Large modern software development projects are often developed from complex designs. Often a software development project can become very complex as the design evolves from the prototype stage to the fully fledged commercialization of the software project. Thus when developers or others write code based upon a complex design errors are inevitable. Often the complexity of the design increases as the software moves from prototyping to commercialization because of additional functionality that is incorporated into the prototype or from oversights and shortcomings in the design that become apparent to designers and developers over time. Therefore revision control has become increasingly important for software development.

Often as a program is developed program bugs arise from the process of patching or fixing problems in the program. As the program bugs are patched new program bugs can be unexpectedly produced. A program bug is an error flaw mistake failure or fault in a computer program or system that produces an incorrect or unexpected result or causes the program to behave in unintended ways. A software regression is a type of program bug that makes a program feature stop functioning as intended after a certain event e.g. a program patch is executed. A program performance regression is a type of software regression where the program still functions correctly but performs slowly or uses more memory when compared to previous versions of the program.

Typically program bugs arise from mistakes and errors made by people in either a program s source code or design and a few are caused by compilers producing incorrect code. Program bugs can trigger errors that can in turn have a wide variety of ripple effects e.g. a systemic spread of an error with varying levels of inconvenience to the user of the program. Certain program bugs can have subtle effect on a program s functionality and therefore may go undetected for an extended period of time. In contrast more serious program bugs may cause the program to completely cease functioning i.e. a program crash.

In an effort to reduce the time spent tracking down the sources of program bugs revision control systems are often employed to generate records of the changes made to programs which can take the form of changesets. A changeset can be helpful in identifying the changes that were made to data included in the program. However a changeset may not be sufficient to identify the source of a program bug. For example a changeset may not identify the source of a program bug if the program bug resulted from the interaction of one program with another. Further as programs are developed numerous updates to line numbering file names method classes and methods can make it very difficult to track down the actual source of a program bug. Tracking down the source of a program bug can be further complicated by compiling errors and errors resulting from two interacting programs being written in different program languages. While revision control systems are helpful in identifying numerous possible causes for a given error an identification of the actual cause of the error can remain both difficult and time consuming.

Embodiments of the present invention disclose a method computer program product and system for using stack data and source code to rank program changes. A computer accesses a stack data and a source code of a program. The computer searches for a first change made to the program wherein the first change is one of a change to a method of the program a change to a class of the program a change to a method that is invoked by the program or a change to a class containing a method that is invoked by the program. The computer identifies the first change that was made to the program and determines the probability that the identified first change caused one or both of an error and a regression. The computer generates a ranked list of identified changes based at least in part on the probability that the identified first change caused one or both of an error and a regression.

A Java virtual machine JVM is a program which executes certain other programs namely those containing Java byte code instructions. In general a JVM is often implemented to run on an existing operating system but can also be implemented to run directly on hardware. A JVM provides a run time environment in which Java byte code can be executed enabling features such as automated exception handling which provides root cause debugging information for every program error an exception . A JVM is distributed along with Java Class Library which is a set of standard class libraries in Java byte code that implement the Java application programming interface API . These libraries bundled together with the JVM form the Java Runtime Environment JRE .

When a Java virtual machine JVM encounters hangs a slowing of program execution looping code deadlocks or an insufficient memory condition it is common practice to generate a set of Java core files. A Java core file is a formatted and pre analyzed text file that is created by the JVM during an event or created by manual intervention. A Java core file contains information about the running JVM process such as the JVM command line environment information loaded libraries snapshot information about all running threads stack traces and monitors locks held by the threads GC Garbage Collection history and storage management memory information. When deadlocks are detected the deadlock event is recorded in the Java core file.

The occurrence of an exception or a thread dump is usually reflected in a Java call stack or method stack. In general a call stack or a method stack is a particular kind of abstract data type. Call stacks and method stacks are collections of data in which the principal or only operations on the collection are the addition of an entity to the collection known as a push and the removal of an entity known as a pop. A dump is in general a record that illustrates some aspect of a program often the program activity. A thread dump is a dump of the stacks of all live threads of the program. Thus a thread dump can be useful for analyzing the activities of the program up to some point in time. If done at intervals a thread dump can be helpful in diagnosing certain types of program execution problems e.g. thread deadlock .

In object oriented programming a method is a subroutine or procedure associated with a class. Methods define the behavior exhibited by instances of the associated class at program run time. Methods have a special property that at runtime allow methods to have access to data stored in an instance of the class they are associated with and are thereby able to control the state of the instance. A call stack is a stack data structure that stores information about the active subroutines i.e. the methods of a computer program. The call stack type of stack data structure is also known as an execution stack control stack run time stack or machine stack and is often shortened to just the stack .

Although maintenance of the call stack is important for the proper functioning of most programs the details are normally hidden and automatic in high level programming languages. In general a call stack or method stack are used for several related purposes a common reason for having a stack is to keep track of the point at which each active subroutine should return control when the subroutine finishes executing. An active subroutine is one that has been called but has yet to complete execution after which control should be handed back to the point of call. Such activations of subroutines may be nested to any level recursive as a special case hence the stack data structure. If for example a subroutine named ChopFruit calls a subroutine ChopBanana from four different places ChopBanana must know where to return to when execution of ChopBanana completes. To accomplish this the address following the call instruction the return address is pushed i.e. added onto the call stack with each call.

The stack of the running Java program is modeled by three interfaces namely a frame a frames source and a context. The frame interface encapsulates the data stored in a single stack frame such as the operand stack and local variables. The frame source interface encapsulates the allocation and layout of frames and controls a variety of program attributes such as the argument passing mechanism. The context interface encapsulates the storage and management of the call stack as well as the locking logic required by synchronized methods.

In object oriented programming an instance is a copy also called an occurrence of an object whether currently executing or not. Instances of a class share the same set of attributes yet typically differ in what those attributes contain. For example the class Employee would describe the attributes common to all instances of the Employee class. For the purposes of the task being solved Employee objects can be generally alike but often vary in such attributes such as for example name and salary . The description of the class itemizes such attributes and defines the operations or actions that are relevant for the class for example increase salary or change telephone number. It is common for various instances of an object to be referred to by different names. For example one instance of the Employee object can then be referred to with the name of Jane Doe and another instance of the Employee object can be referred to with the name of John Doe .

In object oriented programming a class is a construct that is used as a blueprint to create instances of itself which can be referred to as class instances class objects instance objects or objects. A class defines constituent members that enable these class instances to have a given state and behavior. Data field members member variables or instance variables enable a class object to maintain a given state. Other kinds of members especially methods enable a behavior of the class object. Class instances are of the type of the associated class. A class usually represents a noun such as a person a place a thing or something that has been nominalized. For example all fruits bananas apples and such would be instances of the class Fruit a Fruit object . The instance is of the type Fruit . This should not be confused with sub types of . Bananas are a sub type of Fruit but the class of Bananas itself would not be an instance of Fruit .

Given the complexity of many programs it can be difficult to easily determine the source of a program bug an error . Often as a program is developed many programmers using different computer systems and software interact to update or change numerous aspects of the program. Changes to methods classes locking times objects and instances can be common and these changes are typically tracked using revision control systems. However tracking the changes may not be very useful when many changes have been made that may have caused the error.

The larger and the more complex the program is the more possible causes there are for an error. A common starting point for identifying the source of an error is an examination of the stack. However the stack can contain large amounts of data and can still yield many possible sources for the error. Therefore it can be useful to further reduce the number of possible sources of the error to only those which are most likely to have generated a given error which can include a regression of the program a slowing of the program execution speed . By looking at the most probable sources of error first it may be possible to identify the actual source of error in a much shorter time period. Identifying the most probable source of error is facilitated by a program logging specific stack information when an error occurs.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code instructions embodied thereon.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on a user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The present invention will now be described in detail with reference to the Figures. For the purpose of simplifying the disclosure the disclosed exemplary embodiments have in general been configured for use with a Java based program. However this is not to be interpreted as a limitation to Java based programs as other exemplary embodiments can be configured for use with other computer programming languages.

In alternative embodiments change ranking program can be stored externally to computing device and accessed through network . Network can be for example a local area network LAN a wide area network WAN such as the Internet or a combination of the two and may include wired wireless fiber optic or any other connection known in the art. In general network can be any combination of connections and protocols that will support communications between computing device and storage device in accordance with an exemplary embodiment of the present invention.

In various embodiments of the present invention computing device is a computing device that can be a standalone device such as a server laptop computer tablet computer netbook computer personal computer PC or desktop computer. In another embodiment computing device represents a computing system utilizing clustered computers and components to act as a single pool of seamless resources. In general computing device can be any computing device or a combination of devices with access to change ranking program application code and stack data and is capable of running change ranking program . Computing device may include internal and external hardware components as depicted and described in further detail with respect to .

In various embodiments of the present invention storage device is a data storage device in communication with computing device . In general storage device is a data storage device used to store data such as the data included in application code and stack data . Typically the data included in data included in application code and stack data is accessed as needed by computing device via network . In some embodiments storage device is integral with computing device .

In exemplary embodiments change ranking program in general uses information included in a stack to query a program code repository to identify changes that may have caused a program error. The identified changes are ranked by change ranking program according to the probability that the change caused a given error. In general the more probable a given change to the program is to have caused the error the higher the given change is ranked. In some exemplary embodiments an output from change ranking program includes a report that includes a ranked list of the identified changes.

In exemplary embodiments change ranking program identifies changes between various builds versions of a program. Change ranking program also uses the stack data and the program code to identify other methods which are not indicated by the stack data. Methods not indicated by the stack data are methods that were invoked within the call structure that may have caused the error. In general the invoked methods are methods that have changed between builds and are identified within the call structure to a specific depth herein designated a recursive depth parameter.

Generally a recursive depth parameter relates to a parent child method where a parent method calls a child method into execution thereby forming a chain of methods. A change in any one of the child methods may be the cause of the error. In some instances the child method in question can be included in another program and therefore would be more difficult to identify as the cause of the error. Depending on the method there may be one or several child methods called by a single parent. In summary by examining the child methods for changes a more detailed determination of the possible causes for a given error can be made by change ranking program .

Generally in an exemplary embodiment if the recursive depth parameter exceeds five then the recursive depth parameter leads to increasing degrees of false positive identification of possible causes of error. For that reason most recursive depth parameter values would be set to two or three. However in other embodiments additional filtering techniques can be applied to reduce the number of false positive identifications with increased recursive depth parameter.

In general in exemplary embodiments application code is a stored copy of the source code for a given program being developed. Application code can in some embodiments include multiple versions of a program with various updates applied to the source code of the program. By comparing the various versions of a program changes made to the source code can be identified.

In general in exemplary embodiments stack data includes information about the active subroutines methods of a computer program. More specifically stack data includes data produced at the time a given program experienced an error or regression. The types of data stored in stack data are not restricted to only stack data. In general stack data includes data such as the thread state data and the thread stack data of a given program that experienced an error. Stack data also includes the causes of error that are identified along with the reports that are generated by change ranking program . In some embodiments stack data can include other types of data for example program patches.

An example of the output of change ranking program is shown in part below along with the application of a depth parameter to invoked methods.

Continuing with the above example after querying the program code repository and identifying the methods that were changed the classes that were changed and the invoked methods to for example a depth of two. Using a depth of two change ranking program would identify the following changes and generate a list of possible error sources such as for example 

In continuation of the above example change ranking program would then determine the most probable causes of the error and generate a report such as for example 

In exemplary embodiments change ranking program identifies changes to methods included in a given program as highly likely to have caused an error and flags them accordingly e.g. HIGH . Since changes to a class are considered to be moderately likely to have caused error they are flagged as for example MEDIUM . In general invoked methods are not likely to have caused error and are therefore flagged accordingly as for example LOW . Using the identified and ranked changes the most likely causes of a given error can be addressed first which can reduce the time required to develop update a program.

In an exemplary embodiment change ranking program in general identifies the recursive depth parameter to be applied to a search along with the stack data such as a Java stack associated with the program that experienced the error in step . The stack data is retrieved from stack data . The recursive depth parameter can be a preset value or can be a value entered by a user.

In an exemplary embodiment in step change ranking program runs a search using the recursive depth parameter the stack data and program source code that is included in application code to identify potential changes that may have caused the error. In general the change ranking program queries the source code for changes that occurred between two or more different builds versions of the program which includes changes to methods classes and invoked methods. The search using the recursive depth parameter is typically carried out by following a chain of methods with respective changes as discussed previously in the detailed description. For example if the recursive depth parameter is set to three then change ranking program follows the reference from a first method to a second and stop at the third method. The three identified methods are then designated as potential changes that may have caused the error.

In an exemplary embodiment in decision step change ranking program determines if there are any new changes found meaning the changes have not been classified i.e. flagged as high medium low or unknown see steps and for further details . If there are new changes found then change ranking program proceeds to step decision step yes branch . If there are no new changes found then change ranking program proceeds to step decision step no branch . In general change ranking program is rarely unable to identify any changes that may have caused a program error. However if there are no changes identified during the search in step then change ranking program determines that there were no new changes and proceed to step .

In an exemplary embodiment change ranking program proceeds through a series of decision steps to identify the type of change that was found in step . In decision step change ranking program determines if the change found is a method change. In decision step change ranking program determines if the change found is a class change. In decision step change ranking program determines if the change found is an invoked method change. If change ranking program is unable to identify the type of change as a method class or invoked method change then change ranking program proceeds to step decision step no branch and flags the change as unknown indicating that the type of change was not identifiable by change ranking program . If change ranking program is able to identify the type of change as a method class or invoked method change then change ranking program proceeds to step respective yes branches of decision steps and .

In an exemplary embodiment change ranking program determines if the identified change from respective steps or has been identified before in decision step . As changes are identified by change ranking program the changes are included as part of application code . To identify whether or not a change has been identified change ranking program compares a newly identified change to the changes included in application code . If the identified change has not been identified before decision step no branch then change ranking program proceeds to step . If the identified change has been identified before decision step yes branch then change ranking program proceeds to step and flags the change as already found. The determination of whether a change has already been identified allows change ranking program to eliminate unnecessary redundancy in the final report produced in step . This can be very useful if the recursive depth parameter is set to any number above one.

In an exemplary embodiment in step change ranking program identifies and applies the appropriate flag to the changes respectively identified in decision steps and . Method changes are flagged as HIGH indicating that they are highly likely to have caused a given error. Class changes are flagged as MEDIUM indicating that they are moderately likely to have caused a given error. Invoked methods are flagged as LOW indicating that they are unlikely to have caused a given error.

In an exemplary embodiment in step change ranking program records the details associated with the changes respectively flagged in steps and . The recorded details relating to the flagged changes form the basis for the report generated and presented by change ranking program in step . In general the details regarding the identified and flagged changes are stored as part of stack data .

In an exemplary embodiment change ranking program compiles the details regarding the identified and flagged changes in step . In step change ranking program generates a report that includes the identified changes which are ranked according to the likelihood that a given change is the cause of a given error.

In certain alternative embodiments a numerical value can be applied to the identified changes to further differentiate the most likely cause of an error. Additional probability can also be calculated from the level of an error in the stack data. For example in the table following paragraph 30 a change in Class3.method1 would rank higher than a change in Class1.method1 . The numerical value can for example be based on the statistical probability that a given change is responsible for the error. For example method A is identified as having been changed and is further identified as a child method in ten other methods B K that have been identified as potential causes of the error. Based on the number of occurrences of method A in the total number of identified possible causes a statistical value is calculated and assigned to method A indicating that method A is likely to have caused the error. Methods B K however receive a lower statistical value due to their low occurrence rate in the identified possible causes of the error.

Computing device includes communications fabric which provides communications between computer processor s memory persistent storage communications unit and input output I O interface s . Communications fabric can be implemented with any architecture designed for passing data and or control information between processors such as microprocessors communications and network processors etc. system memory peripheral devices and any other hardware components within a system. For example communications fabric can be implemented with one or more buses.

Memory and persistent storage are computer readable storage media. In this embodiment memory includes random access memory RAM and cache memory . In general memory can include any suitable volatile or non volatile computer readable storage media.

Change ranking program application code and stack data are stored in persistent storage for execution and or access by one or more of the respective computer processors via one or more memories of memory . In this embodiment persistent storage includes a magnetic hard disk drive. Alternatively or in addition to a magnetic hard disk drive persistent storage can include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices including resources of storage device . In these examples communications unit includes one or more network interface cards. Communications unit may provide communications through the use of either or both physical and wireless communications links. Change ranking program application code and stack data may be downloaded to persistent storage through communications unit .

I O interface s allows for input and output of data with other devices that may be connected to computing device . For example I O interface may provide a connection to external devices such as a keyboard keypad a touch screen and or some other suitable input device. External devices can also include portable computer readable storage media such as for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention e.g. change ranking program application code and stack data can be stored on such portable computer readable storage media and can be loaded onto persistent storage via I O interface s . I O interface s also connect to a display .

Display provides a mechanism to display data to a user and may be for example a computer monitor or a television screen.

The programs described herein are identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular program nomenclature herein is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

