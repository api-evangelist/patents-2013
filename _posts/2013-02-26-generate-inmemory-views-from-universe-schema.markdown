---

title: Generate in-memory views from universe schema
abstract: In one aspect, a Universe designed and built in a database is used for modeling data in an in-memory database. The Universe is loaded in a front-end development application to display a universe schema contained in the Universe. The logic built in the front-end development application enables parsing the universe schema, to determine patterns matching in-memory views such as attribute views and analytic views. The determined patterns are generated as attribute views and analytic views, and displayed for user selection. Selected attribute views and analytic views are stored in the in-memory database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09110935&OS=09110935&RS=09110935
owner: SAP SE
number: 09110935
owner_city: Walldorf
owner_country: DE
publication_date: 20130226
---
Today enterprises have a rich choice of databases. Customers may choose to migrate from their existing database to any new database offered by their enterprise vendors. The new database may comprise some new features or functionalities that are not available in the existing database. In such a scenario customers may be required to understand the methodology in which such new features are to be designed in the new database. Typically this is a manual process where customers invest a lot of time and effort in understanding and designing the new features of the new database.

Embodiments of techniques for generating in memory views from universe schema are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Enterprises store enormous amount of data in storage repositories such as databases. In any database data is organized in a data structure supported by that database. Enterprises may have a need to migrate from one database to another or to upgrade the version of database software being used. In some of these cases a major data transformation process may be required since the underlying data format can change significantly. In one embodiment the modeling and accessing techniques of one database may significantly differ from other databases such as in memory databases.

According to one embodiment in memory database typically relies on main memory for computation and storage. The in memory database may be a relational database an object oriented database or a hybrid of both. In memory technology utilizes the maximum capabilities of the underlying hardware to increase application performance. Information required for processing is usually available in the main memory so computation and read operations can typically be executed in the main memory without involving a hard disk input or output operation for instance.

Traditionally a database table is a two dimensional data structure with cells organized in rows and columns. However according to one embodiment within an in memory database memory organization is linear. In a linear memory organization data may be stored as a row store or a column store. In the row store the fields of every row in the table are stored in a row sequentially whereas in the column store the fields of a column are stored in a column in contiguous memory locations. Row based storage and column based storage store data that can be modeled and accessed by various components of the in memory management system such as any front end development application database application a query processing engine and the like.

Customers may choose to migrate from an existing database to the in memory database for various reasons such as increased performance. In one of the steps of such a migration data needs to be transformed and modeled to the data structure of the in memory database. Typically this is a manual process where customers spend a substantial amount of time in understanding the data structure functionalities and modeling techniques of the in memory database. In a first approach of manual modeling customers create tables views etc. manually in the in memory database. Second approach of manual modeling allows the customer to point their database connection to the in memory database. In the second approach if the existing database supports structured query language SQL queries in a particular syntax after the manual modeling by pointing the database connection to the in memory database SQL queries syntax may vary requiring significant effort by the customer to get the SQL syntax compatibility with the in memory database. Therefore these manual approaches are inefficient and time consuming.

Thus customers require a mechanism to perform data modeling to increase performance by using a semantic layer of the existing database at a front end development application. Some databases have a semantic layer that is an intermediary layer between the database or data source and dependent queries reports or dashboards. The semantic layer enables an end user to interact with data without having to understand the complexities of database logic or the physical data that is stored. One such semantic layer is the Universe which a file that contains a structure and layout of classes and objects schema of tables views and joins from the database contexts connection information to the database and mapping details of the structures to the database.

Such universe designed and built in any database can be used for modeling data in the in memory database. The front end development application can be built by implementing the required logic to enable such modeling. In one embodiment the front end development application may be a software application providing developers or customers the facility to work with the underlying database a web application a desktop application a software as a service application and the like by coding software program or visually modeling a software program using an underlying prebuilt code.

In one embodiment the in memory database allows users to model data as tables and views. Tables are tabular data structures each row identifying a particular entity and each column having a unique name. The data fields of one row are called the attributes of the entity. Views are combinations and selections of data from tables modeled to serve a specific purpose. Views can be a simple selection of some columns and or rows from any table. Universe schema refers to the structure of the database its tables and the relationships between them. Various types of databases comprising various types of schemas often contain many more tables and join relationships both in number and type depending on the business purpose.

In one embodiment an exemplary sales universe created in the database can be used to generate in memory views in the in memory database . Sales universe is loaded and correspondingly a sales universe schema can be viewed in the front end development application tool as shown in of . The sales universe schema comprising tables such as Country Region City Customer etc. along with the join relationships is displayed to the user in the front end development application . The join relationship between the Country table and the Region table indicates a one to many join relationship between them. One country can have many regions and hence the join relationship is one to many. The Country table has a primary key country id and the Region table has a corresponding foreign key country id . The join relationship between the Customer table and the City table indicates a many to one relationship between them. The sales universe schema is parsed by the logic built in the front end development application to determine patterns that would match the in memory views of the in memory database .

In one embodiment a star schema consists of one or more fact tables referencing any number of dimension tables. A fact table is the central table in the star schema and the fact table stores quantitative or factual measures of a business process for analysis. Dimension tables hold descriptive data that reflects the dimensions or attributes of the business. Queries issued by the user use the join between the fact and dimension tables and filter the data to return selected information. The fact table and the dimension table differ from each other in their use with the universe schema. For example a sales manager analyzes revenue actuals budget etc. These items belong to the Sales analysis fact table as they are analyzed by the sales manager. Business dimensions by the item are product line item etc. and they belong to the dimension table Product info . Therefore to analyze revenue by product the query joins the Sales analysis fact table and the Product info dimension table and filter the data in these two tables to return selected information.

If the adjacent table Sample B has just one join it is implied that the one join relationship is with table Sample A . The logic to determine attribute view pattern is executed to determine if table Sample A has one to many join relationship with table Sample B . Upon successful determination the attribute view with Sample A and Sample B is generated as shown in . Alternatively if the adjacent table Sample B has two joins and the table Sample A has one to many join relationship with the table Sample B then also the attribute view with Sample A and Sample B is generated as shown in . In one embodiment add to attribute view pattern comprises the second table with two joins and a one to many join relationship with a third table where the second table is already a part of the generated attribute view along with the first table. Add to attribute view pattern is referred to as a third pattern . In a scenario where the attribute view is already generated with a table Sample X and the table Sample A . Here the table Sample A is adjacent to the table Sample X and the table Sample B is adjacent to the table Sample A . The logic in to determine the add to attribute view pattern is executed and accordingly it is determined if the adjacent table Sample B has two joins and if the table Sample A has one to many join relationship with the table Sample B . Upon successful determination of add to attribute view pattern the table Sample B is added to the previously generated attribute view as shown in .

An example embodiment to illustrate the logic involved in determining the attribute view pattern add to attribute view pattern and generating the attribute view with reference to the sales universe schema of is provided below. The Country table has one join and the logic parses the sales universe schema to get the adjacent table Region and the number of joins of Region table as 2 . Since the adjacent table Region has two joins the logic in is executed to determine if the Country table and the Region table have one to many join relationship with each other. Upon successful determination of the attribute view pattern attribute view AT is generated with the Country table and the Region table. In a scenario where the City table has two joins and the attribute view AT is already generated with the Country table and the Region table the logic in is executed to determine if the Region table has one to many join relationship with the City table. Upon successful determination of the add to attribute view pattern the City table is added to the previously generated attribute view AT . In one embodiment the execution of the logic involved in determining and generating the attribute view is repeated until there are no more tables to parse in the sales universe schema or a table with more than two joins is determined.

In one scenario the table Sample F has more than one numeric field and many to one join relationship with the adjoining tables in the star schema. Upon successful determination of the analytic view pattern the analytic view is generated with the fact table Sample F and the adjoining tables as shown in . In another scenario if the table Sample F does not match the criteria of the fact table the table Sample F and an adjoining table Sample G can be processed to determine if any new attribute view pattern or add to attribute view pattern can be determined. If the table Sample F has many to one join relationship with the adjoining table Sample G a new attribute view can be generated with the tables Sample F and Sample G as shown in . Alternatively if the table Sample F has many to one join relationship with the adjoining table Sample G and the table Sample G is already part of the previously generated attribute view the table Sample F is added to the previously generated attribute view as shown in . In one embodiment one attribute view can comprise one or more attribute views.

An example embodiment to illustrate the logic involved in determining the analytic view pattern and generating the analytic view with reference to sales universe schema of is provided below. The logic determines if Customer table is the fact table. The Customer table has more than two joins more than one numeric field and many to one join relationship with the adjoining tables such as Age group table Sponsor table City table in the star schema. Upon successful determination of the analytic view pattern analytic view AN is generated with the Customer table and the adjoining tables Age group Sponsor and City .

In a scenario where Customer table did not match the criteria for the fact table the Customer table and the adjoining table City table can be processed to determine if any new attribute view pattern or add to attribute view pattern can be determined. If Customer table has many to one join relationship with one of the adjoining tables such as City the new attribute view pattern matches and a new attribute view can be generated with the Customer table and the City table. Alternatively if the Customer table has many to one join relationship with the adjoining table City and the City table is already part of the previously generated attribute view AT the add to attribute view pattern matches and the Customer table is added to the previously generated attribute view AT .

In one embodiment the data in the tables of the previously generated attribute view AT is instrumental in determining if the Customer table can be added to the previously generated attribute view AT . For example if adding the Customer table to the previously generated attribute view AT results in data loss in the tables of AT a new attribute view is generated with the Customer table and the City table. This new attribute view can reside in AT and therefore one attribute view can reside within another attribute view. In one embodiment the execution of the logic involved in determining the analytic view pattern and generating the analytic view is repeated until there are no more tables to parse in the sales universe schema .

In one embodiment the generated attribute views and analytic views can be displayed to the user for validation and selection as shown in of . The selected attribute views and analytic views are stored in the in memory database . illustrates an exemplary user interface in the front end development application for displaying the generated attribute views and analytic views. For example the attribute view AT and the analytic view AN generated in is displayed in the user interface as and respectively. Similarly various attribute views such as AT AT and analytic views such as AN AN and AN generated by the execution of the logic in the flow diagram and the flow diagram is displayed to the user in for the user to validate and select.

Users can specify the selection of attribute views and analytic views in the indicated locations associated with the views. Accordingly the attribute views AT and AT and the analytic views AN . AN and AN are marked for selection by the user. Selected attribute views AT and AT and the selected analytic views AN AN and AN are received by the logic in the front end application and stored in the in memory database as in memory views . In memory views is shown storing AT AT AN . AN and AN . Attribute view AT is not selected for storing in the in memory database by the user and accordingly the attribute view AT is not stored in the in memory database . In one embodiment the list of possible attribute views and analytic views with the tables used and the type of joins they have are displayed to the user for selection.

Similarly on continuing to parse the sample universe schema the logic determines that the table T and table T match the attribute view pattern . Based on the determined attribute view pattern attribute view AT is created with the tables T and T . The sample universe schema displaying the generated attribute views AT and AT is shown in . The logic in the flow diagram involved in determining the analytic view pattern corresponding to the analytic view and generating the determined analytic view is executed in the sample universe schema shown in . The sample universe schema is parsed and the logic determines that the table T matches the criteria of the fact table. The logic determines if the fact table T the adjoining tables T T and the tables in the attribute view AT match the analytic view pattern . Based on the determined analytic view pattern analytic view AN is created with tables T T and tables in the attribute view AT . The sample universe schema displaying the generated analytic view AN is shown in .

The various embodiments described above have a number of advantages. For example for a customer requiring migration from database X to the in memory database it is easy and convenient for the customers to use the universe schema in the database X for modeling in the in memory database since the customer has prior knowledge and understanding of the universe schema. Thus this approach eliminates the substantial time spent using manual approach of modeling in the in memory database. Therefore performance of modeling using the universe schema in the front end application provides a significant improvement over the manual approach of modeling. The logic built in the front end application reduces the time taken to generate in memory views drastically. The display of the generated in memory views in the front end application provides ease of use for the customers in validation and selection of the in memory views.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a mark up language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as. Open Data Base Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in detail.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the one or more embodiments are described herein for illustrative purposes various equivalent modifications are possible within the scope as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

