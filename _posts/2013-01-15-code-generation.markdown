---

title: Code generation
abstract: In one embodiment, input code is received having a plurality of functional elements that process data elements. At least one criterion for generated code is also received. A first intermediate representation of the input code is built that has a plurality of nodes that represent the functional elements. Block sizes are assigned to two or more nodes of a first intermediate representation. The first intermediate representation is modified to create a second intermediate representation that satisfies the at least one criterion, and organizes at least some of the nodes of the first intermediate representation based on the block sizes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009690&OS=09009690&RS=09009690
owner: The MathWorks, Inc.
number: 09009690
owner_city: Natick
owner_country: US
publication_date: 20130115
---
This application is a continuation of U.S. patent application Ser. No. 11 841 990 filed on Aug. 20 2007 by Donald P. Orofino II et al. and entitled Code Generation now U.S. Pat. No. 8 359 586 the content of which is hereby incorporated by reference herein in its entirety.

Scientists and engineers often create computational systems in order to process large data sets. For example an image processing program may be created to process image files. illustrates an example of an image that may be processed by an image processing program or procedure. The image includes a plurality of columns M such as column and a plurality of rows N such as row whose intersections such as intersection define cells or records that store data e.g. one or more pixels. In this example the image has 1024 columns and 768 rows and thus has a size of 1024 by 768 or 1024 768. The image may use the M N Z C image space model where M and N represent column and row information as mentioned above C represents color information and Z represents a frame where image is part of a video data stream.

A large memory store such as main memory is typically required to process large data sets such as image files. Providing such large memory stores however is typically expensive consumes processing time and is not always practical depending on the architecture or the capacity of the computational device that executes the computational system. To reduce memory demands a computational system and or device may be configured to operate on portions e.g. blocks of the input data structure rather than operate on the entire input data structure at once. Typically a computational system and or device operates over a sequence of blocks of the input data structure until all blocks that make up the input data structure have been operated upon.

For example image can be divided into a series of non overlapping rectangular blocks such as blocks each of which is for example 8 by 8 pixels in size. An image processing program may be designed to operate on only one block at a time thereby substantially reducing the memory requirements of the computational system and or device. Here a block may be brought into memory processed and then removed from memory. This process may be repeated for each block. When the last block has been processed the processed blocks may then be re assembled to produce a processed image. By bringing only a single block into memory as opposed to the entire image memory requirements may be reduced.

In an illustrative embodiment the present invention relates to a system and method for code generation. The system includes a code generator that receives input code from a developer. The input code may include 1 code that processes a data set such as an image file and 2 a plurality of functional elements such as graphical blocks statements commands modules scripts components etc. The developer specifies one or more criteria for the code being generated from the input code. The specified criteria may be a goal for the generated code such as minimizing memory requirements maximizing execution speed reducing power consumption etc. or it may be a constraint to be satisfied by the generated code which is driven by the particular target device such as a Field Programmable Gate Array FPGA .

In an embodiment of the invention the functional elements of the input code are configured with one or more parameters regarding the block sizes e.g. matrix sizes that the respective functional element can process. Here each functional element is configured with at least three such parameters. The first parameter indicates the available block size s that the functional element can handle. The second parameter indicates a preferred block size which is preferably a single block size and the third parameter indicates a preferred data order such as row major or column major. The preferred block size corresponds to the block size that the respective functional element can process most efficiently i.e. fastest. The code generator further includes a query engine that queries the functional elements of the input code to obtain their available and preferred block sizes and preferred data order. The code generator also includes an intermediate representation IR builder for generating one or more intermediate representations such as a graph of connected nodes from the input code. The code generator also includes an IR customizer that utilizes the block size and data order information obtained from the functional elements to modify re organize and schedule the IR graph so as to achieve the specified criteria.

In particular the IR customizer performs an assessment of the available and preferred block sizes and data orders of the functional elements of the input code. The IR customizer also performs an assessment of the criteria specified by the developer. In the illustrative embodiment the IR customizer performs a down selection of optional block sizes in order to arrive at a single block size to use for each functional element. In addition the IR customizer may group those functional elements that operate on the same size blocks into computational sequences.

The IR customizer may employ heuristic or dynamic programming principles to customize the IR graph to meet the criteria. The IR customizer includes a set of tools such as a fragmentation inserter a reassembly inserter and a loop inserter for inserting fragmentation code reassembly code and loop code into various locations of the IR graph respectively. It may also insert instructions to perform padding and or clipping of the total data set as required to meet looping constraints. The code generator further includes a code generation engine. After grouping modifying re organizing and schedules ing the IR graph so that it achieves the criteria the code generation engine produces generated code.

The code generator may also include a report facility. The report facility monitors or receives information regarding the changes and modifications made to the IR graph. The report facility may also produce estimations of the speed memory usage and other performance characteristics of the final generated code for review by the developer. In addition a report may be generated to explicitly represent the modifications made by the code generator.

The main memory stores a plurality of modules such as an operating system a software development environment an input code file and a code generator as described in more detail herein.

The removable medium drive is configured to accept and read a computer readable medium such as a CD DVD floppy disk flash memory or other medium. The removable medium drive may further be configured to write to the computer readable medium .

Suitable computational devices include personal computers PCs workstations laptops and palm computers. Nonetheless those skilled in the art will recognize that other computational devices such as digital cameras smart phones etc. may be used to implement the invention. Suitable operating systems include the Windows series of operating systems from Microsoft Corp. of Redmond Wash. the Linux operating system and the UNIX operating system among others.

A developer utilizes the keyboard mouse and display of the user interface to operate the software development environment and create the input code file .

Suitable software development environments for use with the present invention include the MATLAB and SIMULINK technical computing environments from The MathWorks Inc. of Natick Mass. the LabVIEW programming system from National Instruments Corp. of Austin Tex. the Visual Engineering Environment VEE from Agilent Technologies Inc. of Santa Clara Calif. the Khoros development system now from AccuSoft Corp. of Northborough Mass. a C programming system a JAVA programming system and a C programming systems among others. Those skilled in the art will recognize that the computer system need not include any software development environment at all.

The input code file created by the developer represents a program or procedure designed to process a data set. The data set moreover may be arranged or organized as a matrix of data cells such as an image file having a plurality of pixels. Thus for example a data set may be an image file or a video stream and an input code file may contain input code that corresponds to an image processing procedure that processes the image or video stream. The program or procedure is preferably written in a highlevel language such as the MATLAB language the SIMULINK language C C C Java JavaScript etc.

It will be understood by those skilled in the art that the IR builder the query engine IR customizer the report facility and the code generation engine may each comprise registers and combinational logic configured and arranged to produce sequential logic circuits. In the illustrated embodiment the IR builder the query engine IR customizer the report facility and the code generation engine are preferably software modules or libraries containing program instructions pertaining to the methods described herein that may be stored on computer readable media such as computer readable medium and executable by one or more processing elements such as CPU . Other computer readable media may also be used to store and execute these program instructions. Nonetheless those skilled in the art will recognize that various combinations of software and hardware including firmware may be utilized to implement the present invention.

In operation the developer utilizes the software development environment to create the input code file . The input code file includes a plurality of functional elements each of which corresponds to a particular function or operation or multiple functions or operations. Examples of functional elements may include mathematical logical statistical or input output I O operations filters programming constructs or operations such as IF THEN ELSE etc. The developer may specify the functional elements and their order of execution if any either textually graphically or a combination of textually and graphically depending on the software development environment being used.

The model of is meant for illustrative purposes only. Those skilled in the art will recognize that other e.g. simpler more complex or other models e.g. having different types or arrangements of components etc. may be created by the developer. For example in one embodiment one or more of the graphical blocks may represent a subsystem which itself comprises a plurality of interconnected icons.

For an input code file specified textually the functional elements may correspond to commands subroutines callbacks etc. An example of a textual input code file that may be used with an exemplary embodiment is an M file that is compatible with the MATLAB technical computing environment.

In an embodiment of the invention at least some and possibly all of the functional elements of the input code file which are represented by the icons of the model are configured programmatically by the creator of the functional element with one or more parameters regarding the block size s that can be processed by the respective functional element and the functional element s data format and or data organization. In this embodiment each functional element is configured with at least three parameters. First each functional element has an available block size parameter. The available block size which represents the block size s of input values that the respective functional element can process may be a range of block sizes such as 1 by N to M by N or 2 by 2 to 64 by 64 where M by N represents M rows and N columns of a data matrix. Second each functional element may have a preferred or desired block size parameter which represents the preferred input block size for the functional element. The preferred block size may be a single block size which represents the block size that the respective functional element can process most efficiently e.g. fastest. Third each functional block has a data order or organization on which it prefers to operate such as row major order or column major order. If the functional element prefers to operate on rows of data e.g. scan lines then it may specify a row major order preference e.g. 1 by M. If the functional element prefers to operate on columns of data then it may specify a column major order preference e.g. N by 1. In an embodiment the block size and data organization parameters may be properties of the corresponding functional elements.

The creator of the functional elements may specify their block size parameters and preferred data organization or order as part of the functional element. These parameters may be determined by testing modeling estimating simulating etc. the functional elements. Alternatively or additionally one or more of these parameters such as the available and or preferred block size s may be determined automatically by the functional element based on other parameters of the functional element and or its environment including the size of the input data matrix processing rate data types whether the data is real or complex valued and so on.

Those skilled in the art will recognize that other parameters such as data type size etc. also may be specified for the functional elements.

Not every functional element of a computational system may offer the option of block processing. Some subset of the functional elements of the input code file may participate while other functional elements may only operate on the entirety of the given input data structure with no opportunity to decompose the input data structure. In other systems all functional elements may participate. As used herein the term block processing refers to the processing of an input array of data elements over sub regions of the input array such as blocks illustrated in tiles etc. The sub regions moreover may be non overlapping or overlapping.

The block sizes of one or more functional elements of the computational system may appear on a dialog or another interface. The sizes may be interactive parameters that the user can directly enter or choose from among a set of alternative choices. On the other hand the block sizes of a functional element may be fully determined by the comas piler or processing system and feedback as to the sizes chosen by the code generator may be provided to the user. Finally a combination of the approaches may be adopted in which a user establishes block sizes for some of the functional elements and leaves other block sizes to be chosen automatically by the code generator or processing system.

In a further embodiment the available and preferred block sizes may be programmatically determined by the functional elements based on one or more compiletime characteristics made available to each functional element during an early stage of code generation. These early stage compile time characteristics may include the full image data size to be processed the data type of individual elements of the image data complexity sample rates etc.

Programming the functional elements to automatically assess and provide block sizes may allow intimate algorithm specific decisions to be programmed into the functional element by the creators of the functional elements. In addition configuring the functional elements with this information simplifies and reduces the knowledge that the code generator itself must have. It also allows the creator of the functional elements to convey retain and or maintain the information with the functional elements only.

Constraints illustratively refer to limitations of a target device on which the generated code is to be implemented. Examples of target devices may include substantially any type of device that performs processing operations such as but not limited to a digital or smart camera a laboratory instrument factory automation equipment test equipment etc. A target device moreover may have one or more Digital Signal Processors DSPs . Furthermore if the generated code is intended to be run on a DSP then a relevant characteristic and thus constraint may be the size of the DSP s cache. Another relevant characteristic may be whether the DSP is an 8 bit 16 bit or 32 bit microprocessor. Yet another relevant characteristic of the target device may be the input output I O rates data sizes power limits data formats number of analog to digital A D converters etc. of the target device or platform.

It should be understood that a developer may specify multiple criteria for the generated code. Furthermore one or more of the criteria may be derived from higher level requirements specified for the system utilizing the generated code. For example the developer may specify that all selected functional elements or just selected functional elements are to be implemented on a particular type of processing element such as a DSP an FPGA a Complex Programmable Logic Device CPLD an Application Specific Integrated Circuit ASIC etc.

Those skilled in the art will recognize that the code generator may use or rely on different mechanisms or techniques to receive the criteria from the developer. In an embodiment the software development environment together with the code generator presents the developer with one or more user interfaces UIs through which the developer specifies the criteria for the generated code.

The first element may be a list of goals that are available for selection by the developer. It may include a vertical scroll bar that may be used by the developer to view all of the available goals. A developer may select one or more goals from first element by highlighting them. As shown in the developer has selected the minimize memory requirements and minimize number of replications goals from first element . The second element may be a list of the constraints available for selection and it similarly may include a scroll bar . As shown the developer has selected the FPGA constraint which means that the generated code for the graphical elements of Group 1 is to be run on an FPGA. The third element may be a list of the input data organizations that are available for selection and it too may have a scroll bar . As shown the developer has selected the row major input data organization for Group 1.

The second area of the user interface similarly includes a first element for specifying one or more goals a second element for specifying one or more constraints and a third element for specifying an input data organization. As illustrated the developer has selected the maximize execution speed goal the CPU constraint and the row major input data organization for icons of Group 2.

Those skilled in the art will understand that other mechanisms or techniques may be used to pass the one or more criteria and input data organization selections to the code generator besides user interface .

Referring again to FIGS. and A B the query engine queries each of the functional elements of the input code file to obtain the available block sizes the preferred block size and the preferred data organization for that functional element as indicated at step . Those skilled in the art will recognize that query engine may be configured in different ways to query the functional elements and receive their block sizes. For example the query engine may use a predefined Application Programming Interface API to issue one or more calls to the functional elements which may respond by returning their available and preferred block sizes such as Get Available Block Sizes and Get Preferred Block Size . The arguments of such API calls may be the name and or path of the functional element and or attributes of the input data such as its size data type sample rate etc. Alternatively the functional elements which may be objects in accordance with Object Oriented Programming OOP principles may support one or more execution methods which if invoked by the query engine returns the available and or preferred block sizes of the functional element object. The query engine may store the block size information received from the functional elements in the parameter store as indicated at step .

Those skilled in the art will recognize that the query engine may be configured to obtain the parameters of the functional elements all at once or it may be configured to obtain the parameters sequentially or iteratively as necessary depending on the criteria specified by the developer. The query engine may also obtain additional or other information such as the functional elements preferred traversal order of a data set its preferred data organization etc.

The query engine may also be configured to query the hardware on which the code generator in running to obtain constraints that are based on the hardware s characteristics. For example the query engine may query the hardware elements of computer system and determine the speed and bit size of the CPU the CPU s cache size s and the size of main memory among other things. If the code to be generated is not going to be executed on the host machine characteristics of the target hardware may be made available to the code generator so that it can impose appropriate constraints to generate optimal code for the target hardware. For example the developer may override or limit the parameters of the functional elements and or the hardware based constraints. Suppose the developer is creating and simulating the input code file on a general purpose computer system such as a workstation but intends to target the output code to a cell phone or digital camera. In this case the developer may override the constraints that the query engine would otherwise obtain by querying the general purpose computer system on which the developer is working. Similarly the developer may narrow or limit the range of available block sizes for one or more functional elements or may specify a zigzag or diagonal based order of an image to be processed as opposed to a row based or column based order.

In an embodiment the software development environment may display the information obtained from the functional elements to the developer. Specifically the report facility may collect the obtained information and present the information to the developer through a user interface that is displayed on display .

It should be understood that the information contained in user interface may be presented to the developer prior to the selection of the one or more criteria and the input data organizations.

Referring again to FIGS. and A B the IR builder of the code generator creates an intermediate representation IR from the input code file as indicated at step . The IR may be represented as a graph of connected nodes. As understood by those skilled in the art the IR graph may be a control flow graph a data flow graph a control data flow graph and or another type of graph or data representation. A suitable procedure for creating an IR is described in U.S. Patent Publication No. 2006 0064670A1 entitled Generation of Code from a Graphical Model which is hereby incorporated by reference in its entirety.

Each node of the IR graph typically corresponds to a single functional element of the model . However several nodes e.g. nodes and may correspond to the same functional element e.g. graphical block of the model . Thus for each node of the IR graph the available and the preferred block sizes are known. In the preferred block size is shown below each node of the IR graph . For example the preferred block size for node is 16 by 16 while the preferred block size for node is 2 by 2. As indicated above the available and preferred block sizes may be made available to the IR by direct query by dedicated storage or other means. In an embodiment the block parameters are retained in the IR graph . The criteria and user specified overrides may also be retained in the IR graph .

Referring now to FIGS. and A B the IR customizer evaluates the IR graph and modifies it to achieve the one or more criteria specified by the developer as indicated at step . For example suppose that the criterion specified by the developer is to maximize execution speed of the generated code. In this case the IR customizer chooses the preferred block size for each node. Had the one or more criteria been to minimize memory requirements the IR customizer may have chosen the smallest block size available by each node.

By evaluating the IR graph the IR customizer discovers that adjacent nodes and and and all have a preferred block size of 2 2. Accordingly the IR customizer preferably groups these four nodes of the IR graph together. Furthermore as the upstream node has a preferred block size of 4 by 4 the fragmentation code inserter preferably inserts fragmentation code after node to divide the blocks being output by node from a block size of 4 4 into a block size of 2 by 2 for processing by nodes and . As downstream node has a preferred block size of 8 by 8 the re assembly code inserter preferably inserts re assembly code ahead of node that converts the blocks being output from nodes and from a block size of 2 2 to a block size of 8 8 for processing by node . In addition the loop code inserter may place a loop such as a FOR loop around nodes and so that they are repeated 16 times to produce an 8 8 block size for use by node

This process of evaluating the available and preferred block sizes of the nodes and organizing the nodes into groups having the same preferred block size is repeated throughout the IR graph by the IR customizer . The result is an IR graph that maximizes execution speed.

It should also be understood that the IR customizer may determine that by grouping those nodes of the IR graph that share the same preferred block size e.g. 4 4 the IR customizer can further increase the execution speed of the generated code by applying an optimization such as loop fusion where these nodes are placed within a single common FOR loop.

In an embodiment the IR customizer uses heuristic or dynamic programming based algorithms to evaluate and modify the IR graph to achieve the one or more criteria specified by the developer. For example a cost may be associated with each of the nodes and or the paths between nodes of the IR graph . These costs moreover may be a function of the preferred and or available block sizes for the functional elements cores responding to the respective nodes. The IR customizer builds a model such as a matrix of points using these costs. The IR customizer then determines a path through this model that satisfies the one or more criteria specified by the developer.

Examples of suitable dynamic programming algorithms for use with the invention are described in R. Bellman 2003 and suitable heuristic programming methods are described in D. Levy et al. Heuristic Programming in Artificial Intelligence The First Computer Olympiad 1989 . Other known algorithms that may be advantageously applied to the invention include Pairwise Grouping of Adjacent Nodes PGAN Acyclic PGAN APGAN Recursive Partitioning Based on Minimum Cuts RPMC and Multi Dimensional Statically Schedulable Data Flow MDSSDF . These algorithms are examples of dataflow schedule computation algorithms that are based on principles of dynamic programming.

It should be understood that the IR builder may perform any number of transforms on the IR graph to produce other IR representations. For example the IR builder may perform lowering transforms elaboration transforms or optimization transforms as part of its processing of the input code. At least one of the IRs moreover may provide non language specific primitive constructs that may be used to generate code in many different languages or formats such as C C C Java JavaScript VHDL Verilog etc. Furthermore the evaluation and modification performed by the IR customizer may start on any of these different IR representations.

By applying fragmentation and reassembly adjacent IR graph nodes representing functional elements or groups of functional elements that process dissimilar block sizes nonetheless may be selected for grouping. In particular the larger block size utilized by a first functional element s may be subdivided or fragmented into sub blocks whose size equals the smaller block size utilized by a second functional element s . Each subblock of the larger block is visited sequentially or in parallel and presented to the second functional element that takes the smaller block for processing. An order of visitation of sub blocks is determined preferably in response to the requirements of preceding and or subsequent computations and by constraints of the system such as memory organization cache characteristics etc. The result of each computation on the smaller block is retained in a reassembly storage area. In this way the second functional element s operating on the smaller block size can produce an output the same size as the larger block processed by the first functional element s .

The graph which comprises nodes A B and C has a block processing size equal to a two dimensional 2 D least common multiple LCM of the block sizes of the individual nodes. In the vertical dimension this is LCM 16 4 2 or 16. For the horizontal dimension this is LCM 16 4 8 or 16. The LCM is computed individually for each dimension and this may be denoted by the shorthand notation LCM length height . Thus the block size for the system is 16 16. The number of tiles or the number of times sub blocks of the block size are accessed in order to consume a full input matrix is found by dividing the 480 640 source size by the 16 16 system block size. This leads to 1200 block memory accesses forming a grid of 30 40 blocks.

The order of processing of the 1200 blocks within the full source matrix may be application dependent and may be selected based on architectural factors of the target device. For example a first application may process the blocks in rows while a second application may process them in columns etc.

A scheduling algorithm is selected to schedule this graph of two dimensional 2 D nodes for execution. In an embodiment a novel variation of the pair wise grouping of adjacent nodes PGAN algorithm is selected. PGAN as it stands may be used to schedule one dimensional 1 D synchronous dataflow graphs however it does not schedule graphs of 2 D nodes does not decompose the data input to the node as a group of blocks or tiles and does not accommodate 2 D ordered visitation of blocks in that decomposition. The PGAN algorithm however may be modified as described herein to perform these functions.

As mentioned above those skilled in the art will understand that other scheduling algorithms besides the modified PGAN scheduling algorithm described herein may be selected.

Pairs of nodes that are topologically connected and that lead to a consistent two node schedule are preferably grouped together. For example nodes and nodes B and C have preferred block sizes of 4 4 and 2 8 respectively. In accordance with the method of the present invention these two nodes and are analyzed to determine an execution schedule.

Node node B must be executed twice to process a sufficient number of blocks to execute node node C twice. Moreover the two 4 4 blocks input to node node B cannot be arbitrarily selected. Instead the two executions of node node B must form a contiguous 4 8 block from the input data so that node node C can be properly executed. Accordingly the data input to node node B must be fragmented into 4 4 blocks and it must be done so in two adjacent horizontal blocks. The resulting 4 8 block must form a 1 2 tiling of 4 4 blocks. illustrates the output data of node node B which comprises two adjacent horizontal 4 4 blocks . This execution schedule for node node B may be denoted as 1 2 B.

Node node C may then be executed on the reassembled 4 8 output data of node node B . The execution schedule for node node C may be denoted as 2 1 C specifying a fragmentation of the 4 8 input block into two vertical and one horizontal adjacent blocks of size 2 8. These blocks are then executed upon by node node C . As indicated above this execution schedule is denoted by 2 1 C. illustrates the input data of node node C which comprises two adjacent horizontal 2 8 blocks .

Taken as a pair the scheduling for execution of nodes and i.e. nodes B and C respectively may be denoted as 1 2 B 2 1 C. A new IR graph is created in which the two nodes may be joined together to form a new replacement node node P . The new replacement node node P replaces the pair wise grouping of adjacent nodes and nodes B C . The replacement node node P moreover has a block size LCM B C of 4 8.

The process of pair wise grouping of nodes as described above for nodes and nodes B and C is repeated for adjacent nodes and nodes A and P . Nodes and nodes A and P have preferred block sizes of 16 16 and 4 8 respectively. Accordingly for each execution of 1002 node A node node P is executed eight times. That is the 16 16 block of output data of node node A must be fragmented into eight 4 8 blocks. Specifically the 16 16 output block is fragmented into four vertical and two horizontal 4 8 blocks for processing by node node P .

Taken as a pair the scheduling for execution of nodes and nodes A and P may be denoted as A 4 2 P. A new IR graph is created in which the two nodes and nodes A and P are collapsed together to form another new node node P . The block size of node node P is LCM A P or 16 16 . As mentioned above and as illustrated in node node A executes once and node node P executes eight times four blocks vertically by two blocks horizontally. The traversal order of the 16 16 output block to obtain the eight 4 8 input blocks for node node P can be selected to fulfill architectural constraints such as row major or column major data ordering cache fill orientation etc. In any event the eight 4 8 output blocks of node node P may be reassembled to form a 4 2 grid of 4 8 blocks to form a 16 16 result.

At this point only one node node P remains and the operating of the scheduling process terminates. The complete schedule for original nodes nodes A C may be reconstructed by back tracking through all the sub schedules of the pair wise groups collecting them together as follows 

To implement the final execution schedule it may be read inside out using algebraic rules for interpreting the precedence of the parentheses. That is execution of the functional element s represented by node node B is looped twice executing the functional element s on two data blocks that are contiguous in the same row of the source data matrix. Recall that node node B performs a 4 4 block computation which produces a 4 8 data block from its two scheduled executions. The input to node node B is 16 16.

This 4 8 data block is a transitive result and is stored in a memory buffer allocated for this purpose. It should be understood that this buffer may be used to store other transitive results needed elsewhere in the execution of the system when the output of node B is no longer need.

Then the functional element s represented by node node C executes twice on two data blocks that are contiguous in the same column of the source data matrix. The source of data for the functional element s of node node C is of course the output of the functional element s for node node B which as described above is 4 8. This follows as the functional element s for node node C process 2 8 block sizes and two such blocks exist in the output of the functional element s of node node B after it has finished both of its iterations.

The final block size 16 16 was predicted by the LCM computed across all original block sizes. The fragmentation of the input data of size 480 640 must be performed to provide 16 16 blocks to node node P . Also reassembly of the output blocks from node node P must also be performed to reconstruct the 480 640 output data.

Once the IR graph has been modified so as to achieve the one or more criteria the code generation engine generates code from the modified IR graph as indicated at step . The generated code is output by the code generator as indicated by arrow and made available to the developer.

The generated code may be source code object code a compiled executable a library forming an executable of a model or any other form of executable instructions. The generated code may also be a hardware description language net list or bit stream for configuring a programmable hardware element.

As indicated above the code may correspond to any language or format suitable for use on a programmable software or hardware element. It may be an intermediate language such as C C VHDL Verilog etc. which itself may be compiled into a form that can be executed directly on a processor or synthesized into a final bit stream suitable for configuring the gates of a programmable hardware element such as an FPGA. The developer may load the generated code or a compiled or synthesized derivative of it onto selected processing hardware and execute it to perform the procedure s for which the input code was created.

In addition in a preferred embodiment the report facility generates a report that describes the modifications that have been made to achieve the one or more criteria. This report which may take the form of a text file is also output by the code generator as indicated by step and by arrow and made available to the developer for review. At this point processing is complete as indicated by end terminal .

Graphs used with the illustrative embodiments may be configured to satisfy one or more requirements assumptions objectives etc. For example the graph satisfies the following assumptions 

1 the block sizes selected by each of the nodes functional elements for processing are non overlapping 

3 edge effects may be ignored e.g. node node C produces an output of size 3 1 even though the height of two data elements fits into seven more than three times.

As in the prior example the transformation produces an implementation that fits the block preferences constraints reported by each functional element and the constraints specified by the user.

Depending on the information contained in the reports the developer may decide to repeat the code generation process changing the one or more criteria. If the IR customizer is unable to modify the IR graph in such a way as to achieve the one or more criteria specified by the developer this failure and the modifications that were tried may be reflected in the reports .

By reviewing report a developer can quickly see how many buffers are required and their sizes. The developer can also see the memory access bandwidth for the buffers and the total size of the buffers. In many cases memory access bandwidth can have a profound influence on performance. Accordingly if report shows one or more buffers with a high memory access bandwidth such as buffer number 2 row the developer may consider repeating the process with different typically larger block size choices in order to reduce the memory access bandwidth and thus improve performance.

In an embodiment the IR customizer may compare a total memory access bandwidth value calculated for all of the buffers to a corresponding total threshold to determine whether the process should be repeated with one or more new block sizes. In a further embodiment the IR customizer may omit comparing the memory bandwidth access values to a threshold and instead produce several IR graphs using different block size selections chosen by the IR customizer and or by the developer. The buffer sizes and memory access bandwidth values for these different IR graphs may then be presented to the developer by the report facility e.g. in a form similar to report . The developer may then review these reports and select one of the IR graphs for code generation.

In an embodiment the report facility may be configured to generate a new or updated graphical model of the input code based on the modified IR. This updated graphical model could then be displayed to the developer for evaluation. A suitable mechanism for generating a new or updated graphical model from a modified IR is described in U.S. Patent Publication No. 2007 0067761A1 entitled System and Method for Transforming Graphical Models which is hereby incorporated by reference in its entirety.

For example if the source language of the input code is a graphical model a new graphical model which may be operated upon e.g. edited run etc. by the developer may be generated. This new graphical model represents the block processing modifications performed on the source graphical model. This new graphical model may be further modified by the developer. If the source is a textual program a new textual program may be generated that incorporates the modifications.

In an embodiment a functional element may change its available block size s its preferred block size or its preferred data organization based on one or more parameters received by the functional element as part of the input code . For example graphical block of model may receive a parameter from an upstream graphical block e.g. graphical block . The functional element represented by graphical block moreover may be configured to utilize this received parameter to compute or reset its available and or preferred block size s . For example given an input data matrix that contains real valued elements a first functional element may propose a preferred block size of 8 8 elements due to a element limit of a hardware cache line. However upon a subsequent change to the model a second and upstream functional element now produces complex data values which are input to the first functional element. Complex data elements require twice the total storage area as compared to real valued data elements. The first functional element thus determines that a 4 4 or a 4 8 block size is more appropriate to remain within the size of the hardware cache line.

In an embodiment the invention relates to a compiler provided with an API for communicating with the functional elements of a computational system. The functional elements are configured with a single block size such as a preferred block size multiple distinct block sizes such as available block sizes a finite range of sizes an infinite range of sizes and or a preferred data order. The compiler utilizes the API to obtain the block sizes of the functional elements of the input code and chooses a block size for each functional element based at least in part on the one or more criteria that have been specified. The compiler also builds one or more IRs which may be a connected graph of nodes from the input code. The compiler groups or clusters various sets of the IR nodes based on the block sizes and derives a node visitation pattern. The IR is transformed using FOR loops and or repetitive execution fragmentation and reassembly. The final result of the compilation process are simulation code generation reports and or new computational systems or models.

The foregoing description has been directed to specific embodiments of the present invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. For example a project developer may obtain input code developed by others and provide that code to the code generator of the present invention together with one or more goals and one or more constraints if any depending on the system being implemented.

Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

