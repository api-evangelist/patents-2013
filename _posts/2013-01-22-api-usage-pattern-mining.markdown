---

title: API usage pattern mining
abstract: Techniques for mining API method usage patterns from source code are described. These techniques include parsing the source code to generate API method call sequences that include an API method. These call sequences are clustered to obtain clusters. Based on the clusters, frequent closed sequences are determined and then clustered to obtain an API usage pattern. In addition, optimal clustering parameters may also be determined. In some instances, a graphical representation is generated based on the API usage pattern in response to a query associated with the API method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104525&OS=09104525&RS=09104525
owner: Microsoft Technology Licensing, LLC
number: 09104525
owner_city: Redmond
owner_country: US
publication_date: 20130122
---
To improve software productivity programmers often reuse previous software or software knowledge to build new software. The application programming Interface API method is an important form of software reuse and API reuse has been widely used in practice. For example to construct new software systems the programmers may resume existing software libraries or framework e.g. .NET of MICROSOFT and Java Development Kit of SUN by invoking API methods included in the software libraries. However these API methods are often complex and usage of these API method are not well documented. Although some techniques have been developed to identify API usage from the software libraries these existing techniques lack metrics to measure the quality of API usage. In addition results generated by the existing techniques are highly redundant therefore posing significant barriers to be adopted in practice.

Described herein are techniques for mining API usage patterns from source code. The techniques may parse the source code to generate API call sequences that include an API method. The API call sequences may then be clustered to generate multiple clusters. Based on the multiple clusters frequent closed sequences may be determined using a frequent closed sequence mining algorithm and then clustered to generate an API usage pattern of the API method.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

This disclosure is directed in part to mining API usage patterns from a codebase. Embodiments of the present disclosure may mine succinct and high covering API usage patterns from the codebase and present the API usage patterns in probabilistic graphs.

In accordance with the embodiments a code file associated with the codebase may be parsed to generate API call sequences that include an API method. The API call sequences may be clustered to obtain first multiple clusters based on similarities among these call sequences. Based on the first multiple clusters frequent closed sequences may be determined and further clustered to generate second multiple clusters corresponding to API usage patterns. As used herein the term a frequent closed sequence means that a sequence is determined as a frequent closed sequence if the sequence is frequent and there are no proper super sequences of the sequence that have the same support as the sequence. In addition the support of a sequence may be a number of sequences in a sequence set that are a super sequence of the sequence. For example a call sequence is determined as a frequent closed sequence if the support of the call sequence is not less than a predetermined minimum support threshold and there are no other call sequences that are super sequences of the call sequence and have the same support as the call sequence.

After generation of the second multiple clusters an API usage pattern of the obtained API usage patterns may be determined and illustrated using a graphical representation in response to a query associated with the API method.

Existing techniques for API usage mining include Mining API usage Pattern from Open source repositories MAPO . MAPO mines API usage patterns from open source code. However results mined by MAPO are redundant and sometimes inaccurate. But embodiments of the present disclosure include determination of frequent closed sequences associated with API methods and a two step clustering strategy before and after mining the frequent closed sequences from source code. These embodiments effectively reduce redundancy and improve succinctness and accuracy of the mined API usage patterns.

In the illustrated embodiment the techniques are described in the context of the user operating a computing device to interact with a processing engine . The processing engine may be implemented by the computing device or a host server of a host . The processing engine may include a parser a miner and a result generator which are discussed in greater detail below in the discussion of .

In the architecture the processing engine acquires a query through an interface that is operating on the computing device . The query may be associated with an API method. The processing engine performs a search based on an API usage pattern and returns a result e.g. graphical data to the interface . The interface may surface an API search result on the computing device . The API search result includes a graphical representation indicating the usage of the API method and sample code associated with the graphical representation.

To generate the API usage pattern the processing engine acquires code e.g. a source code file from the codebase . The codebase is stored and or maintained on the host server and includes collections of source code for particular applications or component e.g. .NET of MICROSOFT and Java Development Kit of SUN or other . The source code may be available at any existing codebase and include external source code e.g. open source and forums database and or internal source code e.g. enterprise codebase and a user defined codebase for his her working project .

In the architecture The computing device may be a mobile telephone a smart phone a tablet computer a laptop computer a network a personal digital assistance PDA a gaming device a media player or any other mobile computing device that includes a display and can interface with a user via a user interface and connect to one or more networks to exchange information with the host server or another server providing an API search and or API usage pattern mining.

The network s may include wired and or wireless networks that enable communications between the various computing devices described in the architecture . In some embodiments the network s may include local area networks LANs wide area networks WAN mobile telephone networks MTNs and other types of networks possibly used in conjunction with one another to facilitate communication between the various computing devices i.e. the computing device and or the host server . The computing devices are described in greater detail with reference to the following figures.

In some embodiments the parser may identify the object types of the instances and match the object types to the API method calls. For example the parser may use a parsing tool e.g. MICROSOFT Roslyn or other parsing tool to construct Abstract Syntax Tree AST for the code . In some embodiments the parser creates the index for individual API methods. In these instances an API method may be indexed to include a complete file path class method attributes e.g. return value method name parameter list startLine endLine and so on API name and line number of the API.

In some embodiments the parser may also filter out some common logging and assertion API methods e.g. log.Info and Assert. AreEqual which may be irrelevant to the program logic. In these instances the irrelevant API methods may be filtered out based on a predetermined blacklist that includes the irrelevant API methods.

After identifying API methods and or indexing API methods the parser may collect the set of API method calls and then generate corresponding API method call sequences . Based on the API method call sequences the miner may generate API usage pattern the mining process is indicated by a dash box in .

The miner may cluster the API method call sequences to generate first clusters including multiple clusters e.g. cluster 1 cluster 2 . . . cluster N . In some embodiments the first clusters may be generated using a probability algorithm e.g an n gram model .

After being generated the first clusters may be mined to identify the frequent API usages using a frequent closed sequence mining algorithm e.g. BI Directional Extension based frequent closed sequence mining BIDE . For example the BIDE algorithm may be applied to each cluster of the first clusters to generate frequent closed sequences. Here the BIDE algorithm may build projected datasets and find frequent API method call sequences. The processing engine may determine whether these frequent API method call sequences are closed using bi directional extension. Using the BIDE algorithm the miner may generate frequent closed sequence FCS sets for individual clusters of the first clusters . The FCS sets may include multiple FCS sets e.g. FCS set 1 FCS set 2 . . . FCS set N corresponding to the multiple clusters included in the first clusters .

After being generated the FCS sets may be merged to obtain a consolidated FCS set of API methods. The consolidated FCS set may be clustered to generate second clusters that include multiple clusters. Each cluster of these multiple clusters may indicate an API usage pattern for an API method. The API method may have one or more API usage patterns e.g. pattern 1 pattern 2 . . . and or pattern M corresponding to one or more clusters derived from the consolidated FCS set .

After the API usage patterns are generated the result generator may generate graphical representations. The graphical representations e.g. a graph and a sample code may be then acquired by the interface and surfaced on the computing device . In some embodiments a graph e.g. the graph may denote an API usage pattern. A node of the graph may indicate an API method and an edge indicates a temporal relationship between two methods. Each edge is associated with a probability value that indicates the probability of calling a first method right after calling a second method among all occurrences of this usage pattern in the code . The graph and the generation of the graph are discussed in a greater detail in .

At the host server may receive the query for an API usage pattern of an API method. In some embodiments the user may request the API usage pattern and submit the request through the interface . Then the processing engine may formulate the query and submit the query to a web service hosted by the host server .

At the processing engine may mine API method usages to generate one or more API usage patterns for the API methods. In some embodiments the processing engine may collect a set of call sequences i.e. API method call sequences that includes the API method and then perform clustering on the set of call sequences to generate multiple clusters based on the similarity of the sequences. The processing engine may then mine API usage patterns from each cluster of the multiple clusters using a frequent closed sequence mining algorithm e.g. BIDE and perform clustering again to group the frequent closed sequences into API usage patterns. In these instances the processing engine may identify one or more API usage patterns corresponding to the API method associated with the query .

At the processing engine may generate a probabilistic graph to visualize the identified API usage patterns. At the processing engine may also identify code snippets for the API method that are associated with the identified API usage patterns. In some embodiments the processing engine may transmit the API usage patterns and the code snippets as the result to the interface which then surfaces and presents the API usage patterns and the code snippets to the user on the computing device .

At the processing engine may index individual API methods identified based on the code . In some embodiments the parser may create index files for individual API methods included in the code . In some embodiments the parser may output the results based on an order of files and or an order of API methods. The parser may index the APIs with complete file path class method attributes e.g. return value method name parameter list startLine endLine and so on API name and line number of API.

At the processing engine may extract a set of API method call sequences e.g. the API method call sequences from method bodies or source files of a codebase. Each API method call sequence may contain a usage pattern of the API method. At the processing engine may remove irrelative API methods from the collected method sequences. In some embodiments the irrelative API methods may be removed based on a predetermined blacklist which includes one or more context irrelative API methods. In these instances the relative API methods may be associated with certain contexts or tasks that the user may desire to achieve.

In some embodiments the relative API methods may be found in source code files at a frequency that is higher than a predetermined value. In these instances the corresponding source code snippets may be associated with certain contexts or tasks that the user may desire to achieve. An API method may be irrelative regarding a source code file but relative regarding another source code file.

In the illustrated embodiments at the miner may cluster a set of API method call sequences e.g. the API method call sequences that are extracted from the code and associated with an API method. The API method call sequences may be clustered to generate the first clusters including multiple clusters.

The first clustering may be performed to avoid the problem of imbalanced usage distribution. For example for some very common API usages the associated sequences may be frequent and gain a large support. However for some less common API usages the associated frequency may be low and thus may not reach a minimum support threshold. Clustering the API method call sequences before mining frequent patterns may increase a probability that less frequent patterns are mined out. In these instances the less frequent patterns may satisfy only a minimum support within a group of the API method call sequences i.e. a cluster of the first clusters instead of the API method call sequences .

In some embodiments the miner may cluster the API method call sequences using an n gram based technique e.g. a sequence similarity based method SeqSim to compute the similarity of any two sequences. The definition of n gram for a sequence X xx. . . x is as follows gram Also two method sequences are more similar if they share longer common subsequences. Thus the longer a common subsequence is the higher is the weight associated with the common subsequence. Then the similarity of any two call sequences s1 and s2 is calculated using equation 1 as follows.

Suppose that s1 abc and s2 acb and the weight of ab a bi gram is 2. The weight of ab appears in the denominator since s2 does not contain it and the weight of a a uni gram is 1. As a result the similarity between these two sequences can be computed as 0.176.

Based on the SeqSim values the API method call sequences may be clustered with a threshold a which is discussed in a greater detail in Illustrative Determination of the Optimal Coefficients below. In some embodiments a complete linkage clustering technique may be applied to the first clustering. In these instances every pair of call sequences in a cluster may be less that the threshold a. In addition a distance between two clusters may be computed as the maximum distance between a pair of objects in two clusters. In some embodiments the distance between two clusters may be computed as the maximum distance among partial or all pairs of objects in two clusters.

At the miner may identify the frequent closed sequences for individual clusters of the first clusters . The miner may generate the FCS sets including multiple frequent closed sequence sets. In some embodiments the miner may apply a frequent closed sequence mining algorithm e.g. BIDE to identify frequent closed sequences.

For example given a minimum support threshold min sup a sequence S may be a frequent sequence if the support of S sup S min sup. Here the support sup S is the ratio of the occurrences of S to the total number of sequences. If sequence Sis contained in sequence S Sis called a subsequence of Sand Sa supersequence of S. Thus S may be determined to be a frequent closed sequence if sequence S is frequent and there exists no proper super sequence of S with the same support. Similarly a call sequence may be regarded as redundant when it is a subset of the other call sequences that have the same support as the call sequence.

In some embodiments the BIDE may be applied to each cluster of the first clusters and frequent closed sequences may be produced for the cluster. For example suppose that the three sequences in a cluster are ab abc and abd. If the min sup is 2 then BIDE produces frequent closed sequences ab. While other frequent sequence miners such as Bitmap i.e. a sequence mining algorithm used in MAPO return a b and ab. Clearly since ab is frequent a and b are also frequent and need not be listed. BIDE returns only the longest sequences if there are subsequences with the same support.

After generating FCS sets the miner may merge the frequent closed sequences to generate the consolidated FCS set at . Here while sequences that are not similar are divided into different clusters the frequent closed sequences mined from different clusters may be similar causing redundancy among the resultant patterns.

At the miner may cluster the consolidated FCS set and generate multiple clusters corresponding to API usage patterns. To consolidate the frequent closed patterns mined from different clusters a second clustering may be performed to generate multiple clusters. Each resultant cluster may represent an API usage pattern associated with the API method.

For example suppose that the frequent closed sequence abc and ab are mined from different clusters. After clustering these two sequences are grouped together as one pattern which is shown as abc. With this technique the number of redundant sequences in the mined API usage patterns may be reduced. In the second clustering the complete linkage clustering technique with a threshold may be used which is discussed in a greater detail in Illustrative Determination of the Optimal Coefficients below.

In the illustrated embodiments an API method and an API method may be connected by a connector . The connector may include a directed line i.e. a line with an arrowhead and a parameter i.e. 51.75 . The connector may indicate that the API method may be called right after the API method and the corresponding probability is 51.75 . In addition a connector may indicate another call sequence associated with API method . Specifically the API method may be called after the API method and the corresponding probability is 42.25 .

Similarly a connector may indicate that the API method may be called after being called previously and the corresponding probability is 59.35 . And the API method may be called after the API method is called and the corresponding probability is 40.07 . Further the illustrated amendment may also show that an API method is always called after the API method in this API usage pattern since the corresponding probability is 100 .

The algorithm may generate a graph with probabilities on edges of the graph based on frequent closed call sequences in individual cluster of the second clusters . The algorithm may perform two iterations to compute the probabilities of one method call following the other one. In some embodiments the algorithm may add an End node to a set of nodes which are all the distinctive method calls in the cluster to differentiate among a method call following another method call in a sequence a method call following the method call itself in the sequence and a method call being the last call in the sequence. In some embodiments the algorithm may present different API usages as different patterns and one graph may include one or more patterns.

In the illustrated embodiment the algorithm may include lines which may input a set of frequent closed patterns i.e. API method sequences that are in a cluster of the second clusters and output an API method call graph with associated probability of a calling relationship. In lines 5 25 the algorithm may implement two steps to build the graph. The algorithm may first collect set of distinct API methods in all patterns i.e. method call set . And then the algorithm may calculate a probability P i.e. m1 m2l m1 all of invoking API method m2 given all possible invoked API methods after invoking API method m1 i.e. probability matrix .

In this disclosure a two step clustering process may be implemented to identify less common API usages whose frequency in a call sequence set does not satisfy the minimum support. In some embodiments the two step clustering process may involve two coefficients a i.e. a threshold for clustering the API method call sequences and b i.e. a threshold for clustering the consolidated FCS . In these instances values of the two coefficients may vary independently. Different combinations of a and b may result in different clustering performances and different numbers of patterns thus affecting quality of mined usage patterns.

In some embodiments the optimal threshold values may be determined automatically. The optimal threshold values may be implemented to maximize both the coverage and succinctness of mined API usage patterns. Measuring the number of resultant patterns may reflect the succinctness of the mined API usage patterns. To cover API usage using a minimal number of the mined API usage patterns the mined patterns are as dissimilar as possible from one another. To measure to what extent the mined API usage patterns are dissimilar to each other an overall dissimilarity metric D i.e. dissimilarity of resultant pattern graphs may be defined.

The metric D is defined as an average dissimilarity between the graphical representations of the two usage patterns using Equation 2 below.

In the illustrated embodiment the interface may include a title section a search box and a patterns returned section . The user may input the full or partial name of an API method in the search box and the processing engine may acquire the information. The processing engine may return API usage patterns that are listed in the patterns returned section . The pattern returned section may include one or more usage pattern sub sections e.g. usage pattern 1 usage pattern 2 . . . usage pattern N .

The usage pattern sub sections may include a number indicating a popularity of an API usage pattern e.g. the usage pattern 1 in the code . The popularity may indicate occurrences of an individual API usage pattern in the code . In some embodiments based on the popularities usage pattern 1 usage pattern 2 . . . usage pattern N may be ranked in the patterns returned section . The usage pattern sub section may also include an API method list including API methods of the API usage pattern e.g. the usage pattern 1 . In some embodiments the usage pattern sub section may include a feedback selection . The user may click the feedback selection to provide feedback e.g. like or dislike regarding search results.

The interface may also include a resultant pattern section . The resultant pattern section may further include a graph selection a code section and a graph section . In some embodiments if the user clicks the graph selection the interface may surface in the graph section a graph e.g. the graphical representation derived from the API usage pattern e.g. the usage pattern 1 . In other embodiments if the user clicks the code section the interface may surface in the resultant pattern section code snippets associated with the API usage pattern. The interface may also include scrollbars that enable the user to read the search results.

Alternatively or in addition the functionally described herein may be performed at least in part by one or more hardware logic components. For example and without limitation illustrative types of hardware logic components that may be used include Field programmable Gate Arrays FPGAs Program specific Integrated Circuits ASICs Program specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs etc.

In a very basic configuration the computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device the system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. The system memory typically includes an operating system one or more program modules and may include program data . For example the program modules may includes the parser the miner and result generator as discussed in the architecture the scheme and or the illustrative processes .

The operating system includes a component based framework that supports components including properties and events objects inheritance polymorphism reflection and the operating system may provide an object oriented component based application programming interface API . Again a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.

The computing device may have additional features or functionality. For example the computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer readable media may include at least two types of computer readable media namely computer storage media and communication media. Computer storage media may include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. The system memory the removable storage and the non removable storage are all examples of computer storage media. Computer storage media includes RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other non transmission medium that can be used to store the desired information and which can be accessed by the computing device . Any such computer storage media may be part of the computing device . Moreover the computer readable media may include computer executable instructions that when executed by the processor unit s cause the computing device to perform various functions and or operations described herein.

In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transmission mechanism. As defined herein computer storage media does not include communication media.

The computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. In some embodiments input methods may be implemented via Natural User Interface NUI . NUI may include any interface technology that enables a user to interact with a device in a natural manner free from artificial constraints imposed by input devices such as mice keyboards remote controls and the like. Examples of NUI methods may include those relying on speech recognition touch and stylus recognition gesture recognition both on screen and adjacent to the screen air gestures head and eye tracking voice and speech vision touch gestures and machine intelligence. Categories of NUI technologies may include touch sensitive displays voice and speech recognition intention and goal understanding motion gesture detection using depth cameras such as stereoscopic camera systems infrared camera systems RGB camera systems and combinations of these motion gesture detection using accelerometers gyroscopes facial recognition 3D displays head eye and gaze tracking immersive augmented reality and virtual reality systems all of which provide a more natural interface as well as technologies for sensing brain activity using electric field sensing electrodes EEG and related methods . Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and are not discussed at length here.

The computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. These networks may include wired networks as well as wireless networks. The communication connections are one example of communication media.

It is appreciated that the illustrated computing device is only one example of a suitable device and is not intended to suggest any limitation as to the scope of use or functionality of the various embodiments described. Other well known computing devices systems environments and or configurations that may be suitable for use with the embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor base systems set top boxes game consoles programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and or the like. For example some or all of the components of the computing device may be implemented in a cloud computing environment such that resources and or services are made available via a computer network for selective use by mobile devices.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts are disclosed as example forms of implementing the claims.

