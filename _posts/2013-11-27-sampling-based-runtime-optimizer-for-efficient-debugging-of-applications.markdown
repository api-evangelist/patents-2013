---

title: Sampling based runtime optimizer for efficient debugging of applications
abstract: A method of reproducing runtime environment for debugging an application is disclosed. The method includes accessing an optimizer file from a non-volatile storage medium. The optimizer file includes a runtime environment, application definition information, and a log. The log includes summaries of a plurality of events, the plurality of actions, and a time mark of occurrence for each of the plurality of actions. A runtime environment for debugging the application is then defined and the application runtime is set up using the application definition information in the optimizer file. Further, the method includes running the application and attaching an optimizer, then triggering each of the plurality of actions to occur at each time mark of occurrence associated with the each of the plurality of actions, and analyzing each of the plurality of actions and the plurality of events associated with the each of the plurality of actions, the analyzing includes comparing the events produced by running the application with the plurality of events in the optimizer file. If a fault is produced by the triggering, a debugger is invoked to analyze the fault.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09146831&OS=09146831&RS=09146831
owner: Oracle America, Inc.
number: 09146831
owner_city: Redwood Shores
owner_country: US
publication_date: 20131127
---
This application is a continuation of co pending U.S. patent application Ser. No. 11 945 989 filed Nov. 27 2007 entitled Sampling Based Runtime Optimizer for Efficient Debugging of Applications which is incorporated herein by reference.

The present invention generally relates to debugging applications. More particularly the present invention is directed to efficient debugging of applications by the use of a sampling based runtime optimizer.

Various events are triggered during a runtime of applications in a computing system. Collecting and analyzing these events help in debugging of the applications if a need arises to investigate or reproduce a fault that may have occurred during the application runtime. A fault is not necessarily an explicit runtime error seen by the user it can be subtle mismatch of a certain micro processor state that is only visible through system development tools. However to check every runtime state at each single execution step is time consuming and often a prohibitive task. Traditionally performing sampling on hardware performance counters in a computing system is practiced to reduce overhead while maintaining statistical correctness of the measurements. However there is a drawback of the sampling method. When the sampling rate is below the rate of occurrence of the events the sampling method fails to capture all the events thereby preventing reproduction of same runtime environment for debugging. Inconsistency on the support of hardware performance counters across runtime platforms also prevents the same event behavior from being monitored on different runtime platforms.

Thus there is a need for an event record and action reproduce system to assist the sampling based debugging.

A sampling based runtime optimizer and methods for efficient debugging of optimized applications are disclosed. Embodiments of the present invention discloses methods of creating optimizer files including a log and using the optimizer file to reproduce a substantially similar debugging environment to reproduce a substantially similar behavior of applications in different runtime and hardware environments.

In one embodiment a method of event sampling for an application is disclosed. The method includes attaching a runtime optimizer to the application at runtime running the application and recording a plurality of events during runtime the recording of the plurality of events includes capturing an event type for each of the plurality of events. The method further includes recording a plurality of actions the recording of the plurality of actions includes capturing a time mark at which each of the plurality of actions occurred. The method concludes by creating an optimizer file including the recorded events actions and time marks for the actions. The optimizer file is stored on a non volatile storage medium.

In another embodiment a method of reproducing runtime environment for debugging an application is disclosed. The method includes reading an optimizer file from a non volatile storage medium. The optimizer file includes a runtime environment application definition information and a log. The log includes summaries of a plurality of events the plurality of actions and a time mark of occurrence for each of the plurality of actions. The method further includes defining a runtime environment for debugging the application and setting up the application runtime using the application definition information in the optimizer file. Further the method includes running the application and attaching an optimizer then triggering each of the plurality of actions to occur at each time mark of occurrence associated with the each of the plurality of actions and analyzing each of the plurality of actions and the plurality of events associated with the each of the plurality of actions the analyzing includes comparing the events produced by running the application with the plurality of events in the optimizer file. If a fault is produced by the triggering a debugger is invoked to analyze the fault.

In yet another embodiment a computer readable medium having program instructions for reproducing runtime environment for debugging an application is disclosed. The computer readable medium includes program instructions for reading an optimizer file from a non volatile storage medium. The optimizer file includes a runtime environment application definition information and a log. The log includes summaries of a plurality of events the plurality of actions and a time mark of occurrence for each of the plurality of actions. The computer readable medium further includes program instructions for defining a runtime environment for debugging the application the defining uses the runtime environment provided by the optimizer file program instructions for setting up the application runtime using the application definition information in the optimizer file and program instructions for running the application and attaching an optimizer. The computer readable medium also includes program instructions for triggering each of the plurality of actions to occur at each time mark of occurrence associated with the each of the plurality of actions and program instructions for analyzing each of the plurality of actions and the plurality of events associated with the each of the plurality of actions. The analyzing includes comparing the events produced by running the application with the plurality of events in the optimizer file. If a fault is produced by the triggering a debugger is invoked to analyze the fault.

The advantages of the embodiments of the present invention are numerous. Most notably the systems and methods described herein provide reproduction of a debugging environment for applications to enable the applications capable of being debugged independent of hardware or software environment.

Other aspects and advantages of the present invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the present invention.

The figures are provided in order to provide a thorough understanding of the present invention. The figures should not be construed as limiting the breath of the invention in any manner.

A sampling based runtime optimizer and methods for efficient debugging of applications are disclosed. Embodiments of the present invention discloses methods of creating optimizer files including a log and using the optimizer file to reproduce a substantially similar debugging environment to reproduce a substantially similar behavior of applications in different runtime and hardware environments. While the present invention has been particularly shown and described with reference to the foregoing preferred embodiments those skilled in the art will understand that many variations may be made therein without departing from the spirit and scope of the invention as defined in the following claims. The scope of the invention should be not therefore not be limited to the description of the invention rather the scope of the invention should be defined by the claims including the full scope of equivalents thereof.

Sampling on hardware performance counter is a powerful tool for reducing overhead while maintaining statistical correctness for most measurements. A runtime optimizer in one embodiment uses sampling to reduce the overhead of application monitoring. However there is a drawback to this use of the sampling. It is not possible to reproduce the results when the sampling rate is below the period of occurrence of the events i.e. sampling is being done slower than occurrence of the events. Further inconsistencies on the hardware performance counters across platforms also prevent the same event behaviors from being monitored on different micro architectures. However reproducibility of the results is necessary when performing effective debugging and testing of the runtime system or application.

In general debugging is best done on the same system because the new system may have variation in hardware and software settings and these variations can perturb system or application action performance. However in practice it is not always possible to use the same system for debugging and fault finding in the application. For example a customer may report issues with the application execution or performance optimization of the application. However the vendor of the application and or system may not be co located and would want to reproduce the issues on a different system at a remote location.

In one embodiment the hardware system information runtime application information various paths and creation times execution options environment variables and other information that is necessary to run the application being debugged are recorded. Further time marks of actions along with event types and the frequency of the events that occurred prior to the timestamp of each of the actions are also recorded. The executable name path and creation time execution options and environment variables are used to obtain and re execute the execution binary. The re execution can be performed on a different system having different hardware and runtime environment. The hardware system information and timestamps of the occurrence of each of the actions are used to determine when to apply the exact action at a correct time mark during the re execution so that a reproduction of a substantially similar application runtime can be obtained. The event types and frequency are used to guide the exact action at the approximately same time during the re execution.

In one embodiment the time mark is defined as a point in time with respect to a previously occurred point in time. The time mark is represented in terms of milliseconds elapsed since a fixed point in time. In another embodiment the time mark can be represented in terms of executed instructions since the beginning of the application execution. In yet another embodiment number of execution cycles since the beginning of the application execution can also be used for representing the time mark. In yet another embodiment any other scheme can be used to represent the time mark so long as a length of a period between the occurrence of an event or action with respect to a fix point in time can be measured and such scheme is supported by the underlying platform.

The recording of the necessary information allows the runtime results to be reproduced. In addition a different system that can run the application using the same execution criteria can be used for debugging of the application. This is true even if the new system does not provide hardware performance counters or the performance counters works differently in comparison with the system that was used for initial execution of the application. With this overview in mind the following figures will illustrate example structure and functionality of sampling based runtime optimizer for efficient debugging of applications.

The runtime optimizer provides the application execution optimization. When the application is launched the runtime optimizer is attached to the application binary executable image in memory. For example in UNIX and UNIX like runtime environments LD PRELOAD environment variable may be used to attach the runtime optimizer to the application . Other runtime environments also provide similar instructions or commands for attaching external libraries or external applications to an application at runtime. The runtime optimizer makes necessary modifications to the executable code to improve application execution performance. The sampler and the logger are invoked to monitor and log system or processor events and actions. Cache miss operations and memory write operations memory page miss operations and input output write operations are few examples of processor events. In one embodiment an action is an application action. In another embodiment the action is a system action.

Still referring to the runtime optimizer also retrieves application definition information . The application definition information pertains to the application with which the runtime optimizer is attached at runtime. In one embodiment the application definition information includes name version info security info input variables and command line inputs for the application . In another embodiment the application definition information includes all necessary information that is relevant to running the application in a same or similar state on a different computer system. Further the optimizer file includes the log data . The details of the log data have been discussed in . In other embodiments the optimizer file can include other information that is relevant to the reproduction of runtime environment application environment events and actions so long as the information can be retrieved from the computer system on which the application runs.

Referring now to which illustrates a flow diagram of reproduction of the runtime environment application environment events and actions. In one embodiment the process illustrated in is performed on computer system that is different from the computer system on which the application previously ran and a fault in the optimization was reported during the execution of the application . The flow starts at operation in which the optimizer file is read. The optimizer file is created during a previous run of the application on a different computer system. The system runtime environment information is retrieved from the optimizer file and a same or similar system runtime environment is reproduced using the information included in the system runtime environment information . The control then moves to operation in which the application setup is performed using the information provided by the application definition information . Then in operation the application is run and the runtime optimizer is attached in a same or similar manner as in the previous run of the application on a different computer system.

Still referring to . The control then moves to operation in which the log information is read from the optimizer file . In one embodiment the entire log information is read and cached in the memory. In other embodiment the log information is read one row at a time. From the first row of the log information the time mark of the occurrence of the first action is identified. The system waits for that time mark of occurrence of the action and in operation the action is invoked at that time mark. From the time of the attachment of the runtime optimizer to the application all relevant events are monitored. Before the invocation of the action in operation the runtime optimizer ensures that all events that occurred during the previous run of the application and during which time the optimizer file was created including the event summary are forced to occur during the current run of the application . Hence for example if event e1 occurred fifty times during the previous run of the application before action A occurred see the runtime optimizer ensures that during the current run of the application event e1 such as cache miss is force to occur fifty times before action A is invoked in operation . The purpose of this method is to ensure the application in its current run is provided with the same or substantially similar runtime environment so as to enable reproduction of faults because a fault that occurred on one system during one run of the application often times can t be reproduced in another run of the application on same or different system . It may be noted that even though term different computer system is being used to illustrate the methods in another embodiment the process described herein can also be used to reproduce faults on the same system.

Next in operation the system checks for an occurrence of a fault. If no fault occurs the control goes back to operation in which a next row is read from the log information . If the fault occurs a debugger is invoked to debug the application and runtime optimizer code to pinpoint the source of the fault.

With the above embodiments in mind it should be understood that the invention may employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing.

Any of the operations described herein that form part of the invention are useful machine operations. The invention also relates to a device or an apparatus for performing these operations. The apparatus may be specially constructed for the required purposes such as the carrier network discussed above or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The programming modules page modules and subsystems described in this document can be implemented using a programming language such as Flash JAVA C C C Visual Basic JAVA Script PHP XML HTML etc. or a combination of programming languages. Commonly available application programming interface API such as HTTP API XML API and parsers etc. are used in the implementation of the programming modules. As would be known to those skilled in the art that the components and functionality described above and elsewhere in this document may be implemented on any desktop operating system which provides a support for a display screen such as different versions of Microsoft Windows Apple Mac Unix X Windows Linux etc. using any programming language suitable for desktop software development.

The programming modules and ancillary software components including configuration file or files along with setup files required for installing the widget dock and related functionality as described in this document are stored on a computer readable medium. Any computer medium such as a flash drive a CD ROM disk an optical disk a floppy disk a hard drive a shared drive and an storage suitable for providing downloads from connected computers could be used for storing the programming modules and ancillary software components. It would be known to a person skilled in the art that any storage medium could be used for storing these software components so long as the storage medium can be read by a computer system.

The invention may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributing computing environments where tasks are performed by remote processing devices that are linked through a network.

The invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which can thereafter be read by a computer system. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs DVDs Flash magnetic tapes and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer systems so that the computer readable code is stored and executed in a distributed fashion.

While this invention has been described in terms of several preferable embodiments it will be appreciated that those skilled in the art upon reading the specifications and studying the drawings will realize various alternation additions permutations and equivalents thereof. It is therefore intended that the present invention includes all such alterations additions permutations and equivalents as fall within the true spirit and scope of the invention.

