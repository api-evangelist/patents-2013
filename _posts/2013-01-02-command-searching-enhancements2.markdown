---

title: Command searching enhancements
abstract: A user can access a searching component that allows the user to enter search terms to search for commands associated with a computer program. Some specific embodiments pertain to methods for supporting user access to the searching component, to methods for processing search terms submitted by the user, and to methods for guiding the user in terms of their formulation and selection queries. Methods for generating, organizing and manipulating the search results are also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09632650&OS=09632650&RS=09632650
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09632650
owner_city: Redmond
owner_country: US
publication_date: 20130102
---
The present application is a continuation of and claims priority of U.S. patent application Ser. No. 11 701 125 filed Feb. 1 2007 which is a continuation in part application of and claims priority to U.S. patent application Ser. No. 11 372 545 filed Mar. 10 2006 now U.S. Pat. No. 7 925 975 issued Apr. 12 2011 the content of which is hereby incorporated by reference in its entirety.

A wide variety of different types of computer applications are currently in use. Such computer applications often fall into three or more different categories. For instance rich client applications are typically applications that run on a client device such as a desktop computer or laptop computer. Other software applications include web based applications in which a client interacts with a web based device such as a server using a web browser in order to run the application. Still other software applications include mobile device applications. Mobile device applications might run on mobile devices such as personal digital assistants PDAs telephones handheld computers etc.

In running a software application a user typically wishes to perform one or more different tasks. As used herein the term task means anything that a user wishes to do in the context of a given software application.

In order to allow users to accomplish the desired tasks many current software applications provide a graphical user interface. The user executes one or more commands on the graphical user interface to accomplish a desired task. There are substantially three main ways by which people accomplish tasks using a graphical user interface and they depend on how frequently the user performs a given task. For tasks that are performed frequently by the user the user might learn or memorize the sequence of steps or commands required to perform the task with the graphical user interface. Also with frequently performed tasks applications might expose the user interface elements for performing the most popular tasks prominently in the user interface.

A second group of tasks are those that are performed infrequently by the user. The user may typically browse the menus or tool bars displayed by the graphical user interface in order to attempt to locate the user interface element that can be used to perform the desired task. Another way in which users perform infrequent tasks is to seek the help of other people to find out how to perform the task. In doing this the user might go to a news group or simply ask another individual how to perform the task.

Finally when the user does not remember how to perform the task and cannot find out how to perform the task by asking others users might typically invoke a help mechanism associated with the application. For instance some applications are associated with help documentation stored on a client or on a web site. The help documentation allows a user to search for a help topic that often explains what to do in order to accomplish a task that a user wishes to perform.

Of course there are a number of problems associated with these types of current systems. Unless the user has the steps for performing a task memorized it can be fairly cumbersome for the user to find out how to perform the task. Asking news groups or physically asking other persons how to perform a task takes a relatively large amount of time and thus reduces efficiency.

In addition even where the user attempts to hunt through the user interface to find the user interface element necessary to accomplish the desired task the user may encounter problems. For instance in most graphical user interfaces the features or elements associated with the graphical user interface are categorized under other elements. In other words the user may go to the File drop down menu to look for a particular feature or element of the graphical user interface. The user may also go to the Edit drop down menu to look for another feature. Of course if the sought after feature is under an unexpected drop down menu this can result in frustration and extra time required for the user to find that feature.

Similarly attempting to determine how to perform a task using help documentation often requires a fairly high level of knowledge about the task. For instance some help documentation is simply an alphabetical listing of different tasks. This may be extremely unhelpful to a user who does not know the technical term for the task to be performed. By way of example in one spreadsheet software application adding rows and columns to a spreadsheet is performed using an insert command. Of course it would take a user a fairly long time to track this command down if the user was simply looking under the add commands in the help documentation.

Similarly many help mechanisms provide information that is not useful in a given context. For instance assume the user is in a word processing application which has no tables in it but the user wishes to add a table. The help mechanism might typically be arranged with all information related to tables found in a plurality of different spots within the help documentation. Thus the help documentation might include modifying existing tables adding or deleting rows or columns from tables and a wide variety of other information dealing with already existing tables. Of course since the user s document has no already existing tables this information is completely useless to the user. Yet the user must sift through this information in order to identify the steps necessary to add a table.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

A user can access a searching component that allows the user to enter search terms to search for commands associated with a computer program. Some specific embodiments pertain to methods for supporting user access to the searching component to methods for processing search terms submitted by the user and to methods for guiding the user in terms of their formulation and selection queries. Methods for generating organizing and manipulating the search results are also provided.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The claimed subject matter is not limited to implementations that solve any or all disadvantages noted in the background.

The present subject matter deals with searching for commands associated with software applications and executing those commands. However before that subject matter is discussed in more detail two illustrative computing devices will be described.

Embodiments are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with various embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

Embodiments may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Some embodiments are designed to be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules are located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing some embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is illustratively allocated as addressable memory for program execution while another portion of memory is illustratively used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is illustratively executed by processor from memory . Operating system is illustratively designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device .

Client is shown with a platform . In one embodiment platform is for example an operating system that supports a plurality of different applications . In the embodiment shown in platform includes command searching and processing component and command store . As is described in greater detail below component is exposed to user through application or independent of application such that the user can search for commands associated with application and optionally execute the desired commands. In one embodiment platform exposes an interface such as an application programming interface which can be invoked by application .

Client is also shown with an optional speech recognition component . This can be used as described below.

In the embodiment shown in client is also connected to a server though a network . Network can be any desired network such as a wide area network a local area network etc.

In accordance with one embodiment user begins to enter a search request. In one embodiment user can enter the search request through speech recognition component by simply speaking the desired search request. For purposes of the present discussion however it will be assumed that the user types in the search request one letter at a time but the invention is not to be so limited.

In any case shows one graphical user interface which can be used to receive entry of the search request. User interface in illustrates that application is a presentation program referred to as Program A . Command searching and processing component exposes text box through user interface of application to the user. The user can enter a search request letter by letter into text box .

Therefore after the user types in a first letter in text box on user interface the letter is transmitted as a search request to command searching and processing component in platform . In order to do this in one embodiment application provides the search request through the interface exposed by component . Receiving the first letter at command searching and processing component is indicated by block in .

Component then calculates likely words that complete the letter string entered thus far. For instance if the user has typed ins the most likely completion of this prefix might be insert . This is indicated by block in and is described in more detail below with respect to the example shown in .

In one embodiment component also receives the context of application . For instance the context will illustratively identify the particular application for which a command is sought and provide an indication of the particular contents of the window currently open and under focus in the application a position of the cursor relative to the elements on the open window etc. Examples of context are described in greater detail below and the optional step of receiving the context is indicated by block in .

Once the first letter is received likely completions are calculated and the context component performs a search through command store that stores the commands associated with a plurality of different applications. This search is performed based on the received letters likely completions and the context. Performing the search is indicated by block in .

In performing the search component identifies possible commands and calculates a score indicative of how likely it is that each of the possible commands is being requested by the user in the search request. This is indicated by block in . While the search can be performed in any desired way in one embodiment the search is performed using a search engine that is trained with prior probabilities of commands.

Once the calculation has been made component returns the search results through interface where they are displayed at user interface through application . Of course the results can be returned without going through application as well. In any case in one embodiment component not only displays the most likely commands given the search request but also displays them in ranked order given the score calculated for each command in block . Displaying the ranked commands is indicated by block in .

User can then either select one of the displayed commands or continue typing additional letters in the search request. This is indicated by block in . In the embodiment in which the user does not select one of the commands but instead continues to type letters processing reverts back to block and another search is performed scores are calculated and the likely commands are again displayed in ranked order as indicated by blocks and .

Assume for the sake of the example shown in that the user wishes to insert a table in the particular application which is open. In the embodiment shown in user interface shows that user has typed into text box the letters ins . The context has also been provided to component . The context indicates among other things that the open application is a presentation application. Component calculates the probabilities of commands associated with the input ins stored in command store . In the particular example shown in component determines that the most probable completion of ins is insert and component displays as search results commands which relate to inserting or adding in the given context.

It will be noted from this example that component illustratively not only searches based upon the particular letters input but based upon synonyms of the most likely completions of those letters. In other words the most likely completion of the letters ins in the present context is insert . Therefore component identifies synonyms for insert such as add and searches for commands that are for inserting or adding things and that would be most likely given the current context of the application .

As shown in component returns the search results ranking them in order. It can be seen that the first command returned is insert slide which is more probable than any of the other commands in the list. The other commands in the list are rank ordered according to the score calculated by component which can be a likelihood or probability or other desired measure and they are numbered according to their rank. In the embodiment shown in the first nine results are number according to their rank and a plurality of other commands are also provided but are not numbered.

The user can select one of the commands from the list of returned results by simply clicking on the displayed command. However in one embodiment the user can also select one of the numbered search results by simply typing that number in box . Any other desired way of selecting a command from the list can be used as well.

In accordance with the example shown in the user selects the insert table command. Having component receive a command selection is indicated by block in .

Once the user has selected a command from list if more dialog with the user is required in order to further refine or disambiguate the command component can conduct that additional dialog. This is discussed in greater detail below with respect to . Determining whether the extra dialog is required and conducting that dialog is indicated by blocks and in .

Once the dialog is complete or if no further dialog is required that means that the selected command has been fully disambiguated by component . Component can then either provide additional information to user about the selected command such as tutorial information or component can simply execute the command selected by the user. Providing the additional information is described in more detail below with respect to and executing the selected command is indicated by block in .

As an example of executing the commands where the user has selected the insert table command component after it determines that no additional dialog is necessary controls application such that application takes the user to the appropriate place in the application to execute the insert table command. displays the appropriate user interface mechanism that allows the user to execute the insert table command.

As an example of conducting additional dialog to refine a command component may conduct a dialog with the user as at block in to determine the size of the table which the user wishes to add. Component then adds it automatically. In another embodiment component simply allows the user to walk though the insert table functionality provided by application once component has taken the user to that place in the user interface provided by application .

Also the additional dialog may further define what the user wishes to do. For example if the user inputs delete cell and table the component may respond with an inquiry such as which table or which cell and then delete the specified table or cell based on the response from the user.

In accordance with another embodiment component or another component invoked by component automatically performs the command selected by the user receiving user inputs where necessary. For instance user can select the desired user interface elements to insert a table from the list of possible commands. Component or another component invoked by component can then assume control of application and begin to automatically perform that command. However when it comes to the point where the user interface asks the user to specify the size of the table in terms of columns and rows component simply highlights the field to be modified by the user and pauses until the user has input the desired information and clicked OK . In that example component or other component simply waits until the user has selected the desired number of columns and rows and clicked OK and component or other component then walks the application through the remainder of the steps necessary to perform the command of inserting the desired size table within the application at the specified spot. Automatically executing the command is indicated by block in .

Of course if component is not configured to automatically execute the command selected by the user the user can continue to use component as the user is taking the steps to execute the command. For instance if in the user again types ins into text box component again identifies the possible commands and calculates the scores for the various commands and again displays a list of possible commands given the new context. This is shown in . Specifically illustrates that component has now calculated the highest scores for the commands of inserting rows and inserting columns in a table because the context indicates that the table has already been added as shown in .

As briefly mentioned above component can convey additional information to the user and not just execute the command. This is indicated in . For instance component may illustratively be configured to provide user with tutorial information or guided help in executing the command. In doing so component first determines that it must convey this additional information e.g. the guided help to the user as indicated at block . The decision to provide the additional information can be predetermined by the developer or set by the user using any desired user interface element or based on any other desired criteria. Component then retrieves and conveys the additional information as indicated by block . In the embodiment discussed herein the additional information is the guided help or tutorial help which can be offered to a user in executing a command and an example of this is illustrated in .

For instance assume for the sake of example that the user types back in text box as shown in . Component then calculates the most probable commands given the input back and given the present context and provides the ranked results shown in list . also shows that the user has selected the first result in the list i.e. the change the background wizard command . The selected command is actually comprised of a command bundle of subcommands that are executed to perform the overall command or task of changing the background. Component then launches the change background command bundle associated with application . In the embodiment illustrated one example of the guided help is shown in .

From the above discussion it will be clear that the particular user interface for conducting command searching can take a wide variety of different forms. For instance shows another embodiment of user interface . In the embodiment shown in the user has entered open in text box and the possible commands are shown in list . The user can ask for additional results using elements .

From the description thus far it is clear that the command searching and processing component and the subject matter related to it are applicable not only to rich client applications such as word processing applications spreadsheets presentation software etc. that reside on a client such as a desktop or laptop computer but that the subject matter is also applicable and useful in an environment in which application resides on a mobile device such as a personal digital assistant a mobile telephone a handheld computer etc. However illustrate that the command searching and processing component and the associated subject matter are also useful in other environments. In one such environment application resides on a client but command searching and processing component resides remotely such as on a server. In another such environment application and command searching and processing component both reside remotely from the client such as on a server. Items in are numbered similarly to corresponding items in .

More specifically shows that command searching and processing component and command store are no longer resident on client . Instead component resides on server and component is shown coupled to component and can reside at any desirable location. In the embodiment shown in search request and context are provided through platform over network to component on server . Component performs the search calculates the scores associated with the results and provides the ranked search results back through network and platform to application where they are provided to user through user interface .

It can thus be seen that the present system uses language to find substantially any command that a user wishes to execute in an application. The user can provide a search request in the user s own language and the present system illustratively maps that language to the correct command by searching based on prior probabilities given context. The commands that are returned are likely the most relevant ones for a given search request in the current context. Commands returned once selected can be automatically performed for the user or a user interface can be brought up based on the selected command a wizard can be launched a rich wizard can be launched or a tutorial can be run based on the selected commands.

It should also be noted that the present system pivots functionality of the application around the particular command that the user wishes to execute. For instance if the user wishes to find all commands in the system that have to do with printing it may be difficult in conventional systems to find those specific commands because printing commands are often located in various different user interface locations. However the present component can be used to gather all of that information into a single place in response to a search request for a printing related command.

A variety of specialized features can be incorporated into the described command searching systems and methods. is a schematic illustration of a command searching and processing component . shows component comprising a variety of different individual components for supporting specialized features. The specialized features are illustratively categorized into access support components command search processing components post selection enhancement components result set features components and search refining components . Those skilled in the art will appreciate that all of the specialized components illustrated in are illustratively optional enhancements that may or may not be included in a given implementation. Further the illustrated specialized components need not necessarily be implemented from within command searching and processing component . The illustrated implementation is but one example of how implementation can be accomplished.

Access support components include input device access components . is a flowchart demonstrating functionality associated with one implementation of an input device access component . In accordance with step a user input is received and is indicative of command search functionality. In accordance with step the received input is responded to by initiating display of user interface components configured to support command search functionality. In one embodiment a key on a keyboard or a combination of keystrokes is configured to upon actuation by a user initiate display of a user interface component configured for command searching. In one embodiment the displayed component is a floating user interface that enables a user to search for commands and then disappears after the command is executed. It should be noted that the present invention is not limited to keyboard initiated access to command searching components. User initiated inputs from other input devices e.g. a mouse a voice activated command etc. can illustratively be configured to initiate a command searching process. Those skilled in the art will understand that inputs from most devices can be mapped to various functions which in the present case includes the command searching functionality.

Command search processing components include search input pre processing components . is a flowchart demonstrating one implementation of a search input pre processing component . In accordance with step a command search input is received. In accordance with step the search input is pre processed in some manner. Finally in accordance with step the pre processed and or original search input is included as search terms in the command searching process. In one embodiment of the pre processing step the received command search input e.g. the words typed into the search query area is evaluated and expanded so that the command search will match additional command results. Command search inputs can illustratively be expanded utilizing a variety of techniques such as but not limited to synonym generation morphological transformation of query terms e.g. stemming etc. spelling correction generating functionally equivalent terms etc.

It should be pointed out that query expansion and other pre processing are not the only ways to enable a broader and or more accurate set of command results. illustrates a method of providing a command search index that maps multiple forms of a potential search term to the same command result. An example of this is illustrated in the partial screenshots A and B. Each of these screenshots shows a set of command search results that were illustratively returned in response to an execution of a command search utilizing a search term shown in box . In the search term was open . In the search term was opening . Notably the result set is the same in both instances. This outcome is illustratively supported by the search input pre processing components such as but not limited to the methods demonstrated in .

Command search processing components illustratively include a rank biasing component . is a flowchart demonstrating steps associated with one implementation of a rank biasing component . In accordance with step a command search input is received. In accordance with step a search process is executed based on the received command search input. As is shown in the user interface of command search results can illustratively be ranked within the output display. In accordance with step the search results are organized in the output display based on one or more biasing criteria. As is demonstrated by block one example of a biasing criteria is the command selection history of one or more users. For example commands that are more frequently utilized by the user that initiated the same or similar search can be configured to be more likely to appear higher in the ranking. In addition or alternatively commands frequently used by many users in general e.g. users of the same computing device upon which the search is being initiated and or users of other computing devices can be configured for bias toward ranking higher. Those skilled in the art will appreciate that ranking determinations can be configured to account for a variety of different factors including but not limited to quality of a match command selection history etc.

Search refining components include query feedback component . is a flowchart demonstrating one implementation of a query feedback component . In accordance with step a command search input is received. In accordance with step based on the command search input alternate related queries are determined and presented to the user. In accordance with step a selection of one of the alternate queries is received. Finally in accordance with block a command search is executed based on the selected alternate query. In one embodiment the alternate queries are simply related optional queries or queries that may predictably simply be of interest to the user i.e. determined based on one or more characteristics of their input query . In one embodiment the alternate queries are options from which the user can choose to expand or narrow the scope of their search. In one embodiment the alternate queries are queries that have proven e.g. based on an object criteria such as click patterns etc. to be useful to one or more users that have made the same or similar query. Alternate queries can be implemented as described for any purpose without departing from the scope of the present invention.

Search refining components include query clarification component . is a flowchart demonstrating one implementation of a query clarification component . In accordance with step a command search input is received. In accordance with step based on the command search input the user is presented with a proposed clarification of the input query. In accordance with step an input is received from the user in the form of either a conformation of the proposed clarification or a new query that is a version of the first entered query revised to incorporate the proposed clarification. Finally in accordance with block a command search is executed based on the clarified query i.e. based on the first entered query modified either by the user or by the system to reflect the proposed clarification.

An example of this is illustrated in the partial screenshot of . This screenshot shows a user interface illustratively returned in response to an execution of a command search utilizing a search term shown in box . In the search term was spill. In response a proposed query clarification is presented in panel namely the system asks the user whether the intended query was for spell instead of spill. In one embodiment not by limitation proposed clarifications are made only when no results or results believed based on an object criteria to be an unlikely fit for the user s expectations are identified based on the query input by the user. However this need not necessarily be the case.

As is shown in panel in addition to presenting a proposed clarified query the user can be presented with a help option and or an option for providing specific or general feedback about the command search system. In one embodiment feedback provided by the user is utilized as a basis for modification of the command search system used by the user providing the feedback and or similar search systems utilized by others e.g. the user provides feedback indicating that the term spill should be linked to a particular command . . . subsequently the user s system and or the system of another is updated to include the link . It is to be understood that the help and feedback features shown in panel are not limited to being presented to the user in the context of query clarification. For example the features of panel can be presented with any query result set or otherwise presented to the user.

It should be noted that while the example provided in is related to query clarification the form of a spelling correction this is but one example of a query clarification. Those skilled in the art will appreciate that the present invention is not so limited.

Result set features components include related command component . is a flowchart demonstrating one implementation of a related query component . In accordance with step a command search input is received. In accordance with step based on the command search input a result set i.e. corresponding to the received search input is provided along with one or more alternate queries. In accordance with step a selection indicative of an alternate query is received. Finally in accordance with step another result set is provided but this time the result set is based on the selected alternate query.

In one embodiment the alternate queries provided in accordance with step are simply related optional queries or queries that may predictably simply be of interest to the user i.e. determined based on one or more characteristics of their input query . In one embodiment the alternate queries are options from which the user can choose to expand or narrow the scope of their search. In one embodiment the alternate queries are queries that have proven e.g. based on an object criteria such as click patterns etc. to be useful to one or more users that have made the same or similar query. Alternate queries can be implemented as described for any purpose without departing from the scope of the present invention.

Result set features components include result categorization component . is a flowchart demonstrating one implementation of a result categorization component . In accordance with step a command search input is received. In accordance with step based on the command search input search results are determined i.e. corresponding to the received search input . In accordance with step the search results are output to the user at least partially broken down by category. For example results related to controls for adjusting text characteristics are identified i.e. in a user interface component as being associated with a first category while control for adjusting display functions are associated with a second category. Not all search results need necessarily be identified with a category.

Result set features components include title management component . is a flowchart demonstrating one implementation of a title management component . In accordance with step a command search input is received. In accordance with step based on the command search input a result set i.e. corresponding to the received search input is determined. In accordance with step the result set is output to the user in a format that is customized to match the received command search input. For example terminology utilized in the user input is incorporated into one or more titles output in connection with the search results.

An example of this is illustrated in the partial screenshots A and B. Each of these screenshots shows a set of command search results that were illustratively returned in response to an execution of a command search utilizing a search term shown in box . In the search term was portrait . In the search term was landscape . Notably the result set includes the same command results but the titles in each instance have been altered to reflect the terminology incorporated into the respective box .

Unrelated to title management component it is worth pointing out that include a navigation panel . Within panel are previous and next buttons that enable the user to navigate through search results in panel when not all the results are simultaneously displayed.

Result set features components include slot filling component . is a flowchart demonstrating one implementation of a slot filling component . In accordance with step a command search input is received. In accordance with step based on the command search input the user is presented with a result having control item filled in based on information in the received search input. An example of this is illustrated in the partial screenshot of . This screenshot shows a user interface illustratively returned in response to an execution of a command search utilizing a search term shown in box . In the search term was arial. In response a font control menu is provided with information from the input query i.e. arial automatically filled in. This is but one of many potential examples of how slot filling functionality can be implemented.

It should be noted that the present invention is not limited to filling in a combo box as illustrated in . Other types of controls can be automatically manipulated as described without departing from the scope of the present invention. Also it is part of the present invention to return a control menu in response to a command search. That being said the present invention is not limited to returning a font control menu as shown in . Other control menus can be returned e.g. in response to different queries without departing from the scope of the present invention.

Result set features components include gallery display component . is a flowchart demonstrating one implementation of a gallery display component . In accordance with step a command search input is received. In accordance with step based on the command search input the user is presented with a result set in a gallery format. An example of this is illustrated in the partial screenshot of . This screenshot shows a user interface illustratively returned in response to an execution of a command search utilizing a search term shown in box . In the search term was math symbol. In response a math symbol gallery is provided. Optional buttons enable the user to scroll through the gallery i.e. these button are implemented when fewer than all symbols can be simultaneously displayed .

Result set features components include data provider component . is a flowchart demonstrating one implementation of a data provider component . In accordance with step a command search input is received. In accordance with step the command search input is analyzed and a request for data is identified. In accordance with step the requested data is provided as part of search results displayed to the user in response to the query input. In one example of the method of a user inputs show application version. The system analyzes this query and identifies the fact that the user is looking for information. In response the system provides the requested version information in the area where command search results are typically displayed. The information may or may not be displayed with search results that also match the query input. This is but one example of an implementation of the command search functionality to enable a user to request and receive information.

Post selection enhancement components include tagging renaming component . is a flowchart demonstrating one implementation of a tagging renaming component . In accordance with step a tag or name is received in relation to a command. In accordance with step system parameters are adjusted such that the command will implement functionality related to the received command or tag. In one embodiment in this manner a user is able to rename a command e.g. a command identified by the system as spelling can be renamed to spell checking . In another embodiment in this manner a user is able to attach a tag to a command e.g. a user can add a term that will impact when the command will be considered matching a given query . It is to be understood that the present invention extends to attaching tags or renaming for any reason.

Post selection enhancement components include command pinning component . is a flowchart demonstrating one implementation of a command pinning component . In accordance with step a request to pin is received in relation to a command. In accordance with step the system is adjusted as necessary to respond to the request to pin the identified command. In one embodiment in this manner a user is able to add a command from the search result list to a menu toolbar quick access toolbar etc. In one embodiment in this manner a user can click and drag a command from the search result list so as to create a separate user interface component in a different location the separate user interface component being linked to the associated command functionality.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

