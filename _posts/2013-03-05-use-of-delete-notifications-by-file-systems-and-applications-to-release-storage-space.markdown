---

title: Use of delete notifications by file systems and applications to release storage space
abstract: In accordance with one or more aspects, one or more portions of at least one file that have been freed are determined. One or more delete notifications are generated that identify the one or more portions of the at least one file. Each portion is identified as a range of data on a storage device, and each delete notification includes one or more ranges of data on the storage device. A determination is made as to when to send the generated delete notifications based on one or more threshold-based criteria. These generated delete notifications are then sent to a storage stack.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08862643&OS=08862643&RS=08862643
owner: Microsoft Corporation
number: 08862643
owner_city: Redmond
owner_country: US
publication_date: 20130305
---
This application is a continuation of and claims priority to U.S. patent application Ser. No. 12 435 229 filed on May 4 2009 the entire disclosure of which is incorporated by reference herein.

Computing devices typically store data and instructions in files on a storage device such as a hard disk drive optical disc drive solid state memory and so forth. A file system typically interacts with the storage device to create delete and or modify files. This interaction can be direct or indirect through one or more intermediate components. Oftentimes when the file system deletes a file it does not communicate the details of the space freed due to the delete operation in which case the storage device and any intermediate components have no knowledge of the space being freed. This manner of deleting files can be problematic as the storage device and any intermediate components oftentimes have no knowledge of which portions of the storage device do and do not store data for valid files.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In accordance with one or more aspects one or more portions of each of multiple files that have been freed are determined. One or more delete notifications are generated identifying the one or more portions of the multiple files. Each portion is identified as a range of data on a storage device and each delete notification includes one or more ranges of data on the storage device. These generated delete notifications are then sent to a storage stack.

In accordance with one or more aspects a determination is made in a device of one or more ranges of data of a storage device that are to be freed. In the absence of a file system on the device a delete notification is sent to a storage stack identifying the one or more ranges of data of the storage device that are to be freed.

The use of delete notifications by file systems and applications to release storage space is discussed herein. A storage device has a corresponding storage stack that includes multiple components such as filters. A file system as well as other applications that manage their own storage can access the storage device via this storage stack. This access can include sending delete notifications to the storage device via the storage stack that notify the storage device as well as the components of the stack of a portion of a storage device that is no longer occupied by a file or portion of a file . Delete notifications can be sent to the stack individually or alternatively multiple delete notifications can be grouped and sent to the stack together. Additionally when the file system or an application sends a delete notification indicating a portion of the storage device is no longer in use the file system or application waits until it has received confirmation from the stack that the portion of the storage device has been released before re using that area of the storage device.

Consumer device includes a file system an application a storage stack and a storage device . Consumer device can also be coupled to another storage device . Storage device is included as part of computing device and can be a fixed or removable storage device. Storage device is separate from consumer device and can be a local device coupled to consumer device using a variety of different wired or wireless techniques e.g. Universal Serial Bus USB coupling wireless USB coupling IEEE 1394 coupling infrared IR coupling and so forth. Storage device can also be a remote device coupled to consumer device via a network the Internet a local area network LAN a telephone network an intranet other public and or proprietary networks and so forth. Each of storage devices and can be a variety of different storage devices such as magnetic disks optical discs solid state memory e.g. Flash memory and so forth.

File system and application are both programs or program modules that are typically implemented in software and or firmware. These programs or program modules are executed by one or more processing units not shown in of consumer device to carry out the functionality of the programs or program modules. File system and application can interact with storage devices and via storage stack .

Storage stack is typically implemented in software firmware and or hardware and includes one or more x filters . Each filter is a component situated between a program or program module e.g. file system or application and a physical storage medium in a storage device e.g. device or . Each filter can receive and pass on read and or write requests and optionally provide additional functionality. Each of these filters can provide a variety of different functionality. For example a filter can be a snapshot filter that manages snapshots of a volume. By way of another example a filter can be a write aggregation filter that aggregates data to be written to primary locations in one or more storage devices in a set of lazy writes e.g. writes that are delayed until an idle or less busy time . By way of yet another example a filter can be a disk verification filter that produces checksums of data as the data is written to a storage device. The disk verification filter can also compare those checksums with checksums of the same data as the data is read from the storage device thereby verifying the integrity of the data being read. By way of a further example a filter can be a performance boosting filter that caches data on some alternative storage media such as RAM a USB storage device or flash media that is faster than a main storage media. This cached data can be used to enhance computer performance such as to more quickly boot a consumer device .

Different filters can be grouped together allowing storage stack to be viewed as having multiple different portions or alternatively as being multiple different stacks. For example storage stack may include a first portion that represents storage areas in terms of storage device addresses e.g. using logical block addressing or cylinder head sector addressing . On top of the first portion can be a second portion that is a volume stack that represents storage areas in terms of locations in one or more logical disks or volumes.

In one or more embodiments file system and storage stack are both part of an operating system of consumer device . Alternatively storage stack can be implemented in other manners. For example one or more filters of storage stack could be implemented as part of storage device and or .

File system manages files stored on storage devices and or on behalf of other applications running on consumer device . Oftentimes applications are designed to interact with file system to create delete and or modify files on storage devices and or . Thus rather than interacting with storage stack directly such applications interact with file system which in turn interacts with storage stack . Typically a consumer device has a single file system although alternatively consumer device can have multiple file systems.

Application on the other hand manages its own storage. Thus application can direct the creation deletion and or modification of files on storage devices and or . Application can be a variety of different applications such as a database application an application responsible for formatting storage devices an application responsible for repositioning data on or otherwise managing storage devices and so forth. Although a single application is illustrated in it is to be appreciated that multiple applications can be included on consumer device each such application managing its own storage.

In one or more embodiments application interacts with storage stack directly to create delete and or modify files on storage devices and or . In such embodiments no file system is typically present on consumer device . Alternatively if file system is present on consumer device then file system is bypassed by application . In such situations different sections of storage devices and or can be partitioned for use by application while other sections are for use by file system .

In other embodiments application interacts with storage stack via file system . In such embodiments application can still direct the creation deletion and or modification of files on storage devices and or . However requests to create delete and or modify files are passed through file system in such embodiments.

Both file system and application can send read and or write requests as well as delete notifications to storage stack . Application can pass such read and or write requests and delete notifications to storage stack via file system or alternatively interact with storage stack directly as discussed above.

A read request can be passed down storage stack to storage device or to have particular data read from the storage device. Similarly a write request can be passed down storage stack to storage device or to have particular data written to the storage device.

A delete notification is an indication that a portion or portions of a storage device is no longer occupied by a file or portion of a file . Each portion of a storage device that is no longer occupied by a file or portion of a file is referred to as a freed range of data on the storage device. The delete notification indicates to filters that the range of data is no longer occupied by a file or portion of a file and thus that the range of data can be freed or otherwise released. The delete notification can identify the freed range of data in a variety of different manners such as specifying a particular data range by starting point and length specifying a particular data range by beginning and ending specifying particular blocks or sectors and so forth.

Additionally the filters in storage stack can be viewed as being stacked on top of one another so that filter receives delete notifications from file system or application and can pass those delete notifications to filter filter in turn receives delete notifications form filter and can pass those delete notifications to filter and so forth. Each filter can receive a delete notification process the delete notification and forward on the delete notification to the next filter in storage stack . The processing of a delete notification by a filter can include modifying the delete notification such as by increasing decreasing or otherwise changing one or more portions or ranges of data that the delete notification identifies creating one or more new delete notifications performing a particular function or action in response to the delete notification and so forth.

It should be noted that file system application and or one or more filters can optionally maintain various metadata corresponding to the freed range of data identified in a delete notification. The specific metadata maintained can vary based on the particular file system application and or filter as well as the desires of the developer of the particular file system application and or filter. Such metadata is flushed or otherwise deleted by the file system application and or filter before sending or passing on the delete notification.

Similarly information such as confirmations discussed below can be passed back up storage stack . For example filter can receive a confirmation or can generate a confirmation that it passes up to filter filter in turn receives the confirmation from filter and passes the confirmation up to filter and so forth.

File system and application can each send delete notifications to storage stack individually or alternatively multiple delete notifications can be grouped and sent to storage stack together. In situations where delete notifications are sent to storage stack individually when file system or application determines that one or more portions of a storage device are no longer occupied by a file or portion of a file a delete notification is sent to storage stack identifying each of those one or more portions as a freed range of data. Each delete notification can identify one or multiple freed ranges of data. File system and application do not wait until they have determined that one or more other delete notifications are to be sent to storage stack .

In situations where multiple delete notifications are sent to storage stack grouped together file system and application each group together multiple delete notifications and send those multiple delete notifications together to storage stack . Each of these multiple delete notifications that are grouped together can identify one or multiple freed ranges of data. This grouped together notification can be for example a single message or packet that includes or otherwise identifies the multiple delete notifications. The determination of when the multiple delete notifications are to be sent can be made in a variety of different manners. For example file system and application can determine that the multiple delete notifications grouped together are to be sent at regular intervals e.g. every 30 seconds during periods of inactivity or low usage of storage devices and by file system or application after a particular number of delete notifications have been grouped together after a particular number of freed ranges of data have been identified in the delete notifications that have been grouped together and so forth.

Application can interact with storage devices and via storage stack by way of file system or directly as discussed above. As application manages its own storage in one or more embodiments application need not send delete notifications to file system . Alternatively application can notify file system of the delete notifications that application sends to storage stack allowing file system to know which portions of the storage devices and are being used and managed by application .

In one or more embodiments storage stack or file system exposes an application programming interface API that can be invoked by application . This API exposes a delete method that allows application to identify one or more ranges of data of a storage device that are to be freed. This delete method can be invoked by application to send a delete notification to storage stack directly or via file system . For example the delete method of the API can have as parameters a file handle an offset value and a length value. The file handle is an identifier of the particular file for which the one or more portions are to be freed. The offset value indicates an offset into the file e.g. a number of bytes or blocks from the beginning of the file that is the beginning of the one or more portions that are to be freed. The length value indicates an amount of the file e.g. a number of bytes or blocks that are to be freed beginning at the location in the file identified by the offset value.

It is to be appreciated that this delete method is an example of a delete method and that various modifications can be made. For example multiple offset and length value pairs can be included to identify multiple ranges of data of a storage device to be freed. By way of another example rather than an offset value and a length value a beginning offset value and an ending offset value can be used to indicate that the range of data between the beginning offset value and the ending offset value is to be freed.

When file system or application sends a delete notification to storage stack identifying one or more freed ranges of data file system or application waits for a confirmation from storage stack that those one or more freed ranges of data have been released by storage stack . This confirmation serves as an acknowledgment that the delete notification was passed down storage stack to storage device or and that the filters to which the delete notification was passed have been made aware of the delete notification. The last or bottom filter filter generates the confirmation and returns the confirmation back up storage stack to the one of file system and application from which the delete notification was received. File system and application do not re use the one or more portions of the storage device on which the freed one or more ranges of data were stored until the confirmation that those one or more ranges of data have been released is received.

Which of file system and application a confirmation is returned to can be identified in different manners. In one or more embodiments each delete notification includes an identifier of file system or application and when filter generates the confirmation corresponding to the delete notification it includes this identifier in the confirmation. In other embodiments each delete notification has an identifier and when filter generates the confirmation corresponding to the delete notification it includes this identifier in the confirmation. Filter also maintains a record of which delete notification identifiers were received from file system and which delete notification identifiers were received from application and can readily determine based on the identifier in the confirmation which of file system and application the confirmation is to be returned. In still other embodiments the confirmation includes an indication of the one or more ranges that were freed and these confirmations are returned to both file system and application . File system and application can in turn determine which of the confirmations apply to ranges that they are managing.

In process a determination is made that one or more portions of one or more files have been freed act . These one or more portions that have been freed refer to one or more portions of the storage device that are no longer occupied by the one or more files or by portions of the one or more files . The one or more portions of a file can be an entire file or part of a file. In one or more embodiments the particular one or more portions that have been freed are identified by the component or module implementing process . For example file system can receive a user request to delete a file. As file system manages the storage of that file file system can readily identify the one or more portions of the storage device that are no longer occupied by the file.

Alternatively the particular one or more portions of the one or more files that have been freed can be identified by another component or module which in turn informs the component or module implementing process of the one or more portions. The one or more portions can be determined in a variety of different manners such as by receiving an indication from a user or other component or module that a particular portion is no longer needed that a particular file is no longer needed and so forth.

Regardless of the component or module determining that a portion is to be freed it is to be appreciated that such portion can be determined in a variety of different manners. For example rules or algorithms can indicate that the portion is no longer to be used e.g. due to the size of a file that includes the portion the age of data in a file that includes the portion and so forth in response to a user request to delete a file or portion of the file and so forth.

One or multiple delete notifications for the one or more portions determined in act are generated act . Each delete notification identifies one or more freed ranges of the storage device. Each of these freed ranges is a portion of the storage device that is no longer in use. It should be noted that a delete notification can identify multiple freed ranges.

Whether one or more multiple delete notifications are to be generated can be determined in a variety of different manners. For example such a determination can be based on a frequency with which read and or write requests are being sent to the storage stack e.g. group multiple delete notifications together if read and or write requests are being sent to the storage stack at greater than a threshold rate . By way of another example such a determination can be based on a number of freed ranges of data identified in the delete notifications e.g. group multiple delete notifications together until at least a threshold number of freed ranges are identified in the delete notifications . By way of yet another example such a determination can be based on whether the delete notifications identify freed ranges of data in the same file e.g. group multiple delete notifications together if the delete notifications identify freed ranges of data in the same file .

The one or multiple delete notifications generated in act are sent to the storage stack act . As discussed above the determination of when the one or multiple delete notifications are to be sent can be made in a variety of different manners. Multiple delete notifications can be sent to the storage stack together in act with each of these multiple delete notifications identifying one or more freed ranges.

The component or module implementing process then waits for confirmation that the portions identified in the one or multiple delete notifications have been released before re using the portions act . This confirmation indicates that the storage stack has received and processed the delete notifications and that the identified portions have been released by the storage stack and storage device.

File system and application can each send read and or write requests to storage stack . Storage stack can include a logical disk functionality that represents storage units to file system and application in terms of storage volumes where each volume may represent a single storage device part of one or more storage devices or multiple storage devices. In such situations storage stack includes a volume stack which can provide this functionality and can also provide additional functionality. A device stack is positioned below volume stack and represents storage positions to volume stack in terms of positions within storage device .

Alternatively storage stack can be configured in other manners in other embodiments. For example in one or more embodiments volumes coincide with storage devices such as in a basic disk configuration. In such a configuration storage stack may not need to convert storage positions between volume space and device space. As another example storage stack could include program modules that are part of applications other than an operating system. Additionally there could be one or many file systems disk and or volume stacks and or devices interacting with each other in storage stack .

As an example of how storage positions can be represented in the different layers of the storage stack consider a situation where a 50 megabyte file is written to a storage device. File system or application can receive or generate a request to write the file. The file system or application can then determine an appropriate position in the volume to store the file. To do this file system or application typically tracks occupied space that contains valid data which file system or application may need to retrieve at some point. The file system or application also typically tracks free space that contains invalid data where either no data has been stored by the operating system or where data has been deleted i.e. de allocated or freed by the file system or application . In one implementation the file system or application can maintain a freespace bitmap file that can represent free space in a storage volume as 1 s and occupied space in a storage volume as 0 s. If megabytes 974 through 1024 of the volume are freespace in the freespace bitmap file then the file system or application can pass a write request down storage stack with the data for the file to be written specifying that the data to be written is to be stored in megabytes 974 through 1024 of the volume. That request can be passed down the volume stack and the volume stack can convert the request from volume space to device space.

For example if a volume spans two storage devices including one gigabyte of a first device megabytes 0 through 999 of the volume and one gigabyte of a second device megabytes 1000 through 1999 then volume stack could split the request into two write requests one to write the first 25 megabytes of the file on megabytes 975 to 999 of the first device and one to write the last 25 megabytes of the file on megabytes 0 to 24 of the second device. Those write requests can then be passed down device stack to the storage devices. It is to be appreciated that the storage devices e.g. storage device can each include its own internal stack of software firmware and or hardware components such as additional storage stack filters that can be part of the storage stack and the storage devices can each include several physical storage mediums e.g. multiple disks within a disk drive .

File system or application can delete a file by switching occupied space corresponding to the file to freespace such as in the freespace bitmap. As discussed above this deletion can be done without notifying storage device or the other components of storage stack . However a delete notification can be sent down storage stack when the file system or application deletes a file. As discussed above the delete notification can be an individual notification or can be grouped together with one or more other delete notifications. This notification can specify a region of the volume that the file system or application has deleted e.g. switched to freespace . Storage device can use this notification to provide improved internal performance and efficiencies such as by ceasing to maintain the invalid data in the specified region.

The filters of storage stack can also use such delete notifications to provide additional enhancements. Filters in storage stack can modify delete notifications in a variety of manners such as to exclude data being protected by those filters to notify lower level storage stack components that data has been deleted e.g. one or more portions of the storage device has been freed and so forth. For example a filter in storage stack can receive a delete notification modify the delete notification and pass the modified delete notification to a next filter in storage stack . By way of another example a filter in storage stack can create a new delete notification. This new delete notification can be created directly by the filter or indirectly by the filter e.g. by instructing some other software firmware and or hardware component to create the new delete notification .

Referring back to as another example of an enhancement using a delete notification a filter of storage stack can use a delete notification to identify storage resources that are not needed and can be released. As yet another example the delete notification can include a flag indicating whether the notification applies to an entire volume and one or more of the filters of storage stack can react differently to the notification when the notification applies to the entire volume.

Following is a discussion of some example filters of storage stack . As is indicated by the vertical lines with arrow tips between the filters in storage stack each filter can be configured to communicate with the filter directly above it and directly below it in the storage stack . The filters can optionally include interfaces such as user interfaces to send and receive instructions and other communications between the filter and other software firmware and or hardware modules or components inside or outside storage stack . In the illustrated example volume stack includes from top to bottom a snapshot filter below the file system or application a performance boosting filter a write aggregation filter an encryption filter and a volume manager filter . The device stack includes from top to bottom a partition manager filter below the volume manager filter a device stack functional device object referred to as disk class driver a data verification filter and port driver above the storage device . However storage stack could alternatively include fewer filters additional filters and or filters that behave differently or are positioned elsewhere in storage stack .

Snapshot filter manages volume snapshots and can also function as a functional device object FDO for volume stack . Filters below the FDO but above a physical device object PDO in a stack are typically considered lower level filters while filters above the FDO in a stack are typically considered upper level filters. The FDO refers to a filter that represents a device e.g. storage device in to a driver or module that provides the operation interface for the device e.g. to file system application or partition manager in . The PDO refers to a filter at the bottom of a stack that represents a device e.g. storage device in to another stack or device e.g. to device stack or storage device in . Managing volume snapshots can include taking snapshots of a storage volume at a particular point in time. This allows users and or programs to go back in time to the storage volume as the volume existed when the snapshot was taken.

Managing snapshots can be done by making a copy of an entire volume at a point in time and not allowing any modifications to that copy. Referring to it is typically more efficient to maintain snapshots by only copying those regions of a primary storage volume where changes have taken place since the time of the snapshot. These copies of the modified regions can be saved in one or more differencing files . According to this technique if a region of primary data that is subject to a snapshot has not yet been copied then such a region and the primary data stored in the region can be protected by snapshot filter .

If snapshot filter receives a write request from the file system or application to write data to a protected region then snapshot filter can copy the data in the protected region of the primary storage to the differencing file . Then the data in the primary storage region can be marked as unprotected and snapshot filter can pass the write request down the storage stack . Thus snapshot filter can maintain a copy of the data for an entire volume as the volume existed at the time of the snapshot with some of the data being stored with the primary data where the primary data has not been altered since the time of the snapshot and some of the copy being stored in one or more differencing files where the primary data has been altered since the time of the snapshot .

As noted snapshot filter can include one or more maps to track which regions of the primary storage are protected because the regions are covered by a snapshot and have not yet been copied to a differencing file and which are unprotected because the regions are not covered by a snapshot or have been copied to a differencing file . For example for each snapshot the snapshot filter can maintain a bitmap showing which regions are protected or unprotected by that snapshot such as with 1 s representing unprotected regions and 0 s representing protected regions for that snapshot. These bitmaps can be examined to determine whether a region is protected and is to be copied prior to data being written to the region.

When snapshot filter receives a delete notification the snapshot filter determines whether a range of data that the delete notification indicates is being deleted overlaps with a range of protected primary data. If there is an overlap then snapshot filter copies the protected primary data to differencing file prior to passing the delete notification down storage stack . However the copied data in the differencing file takes up storage space and the copy operation can also take up storage resources including processing resources.

Accordingly instead of copying the protected data that overlaps with the range of the delete notification snapshot filter can modify the range of the existing delete notification to exclude the portion of the range that overlaps with the protected data range. This can result in the modified delete notification having one contiguous contracted range or a contracted range that includes disconnected sub ranges. The modified delete notification can be in the form of a single notification or multiple notifications. The modified delete notification with the contracted range can then be passed down storage stack to the performance boosting filter .

For example if the received delete notification applies to a range of 100 megabytes to 200 megabytes of a volume and a range of 50 megabytes to 150 megabytes of the volume is protected then snapshot filter can modify the delete notification to have a contracted range of 151 megabytes to 200 megabytes. As another example if the received delete notification applies to a range of 100 megabytes to 200 megabytes of a volume and ranges of 120 to 145 megabytes and from 160 to 165 megabytes of the volume are protected then snapshot filter can modify the delete notification to have a contracted range including sub ranges of 100 to 119 megabytes from 146 to 159 megabytes and from 166 to 200 megabytes. The entire contracted range could be included in a single modified delete notification with sub ranges or each sub range could be included in a separate modified delete notification.

The modified delete notification s can be passed down the storage stack to the performance boosting filter . Thus the protected data will not be modified in response to the delete notification and the protected data will not need to be copied at that time. Similar techniques could be used by other storage stack filters that protect data that can be covered by a delete notification .

Snapshots can be deleted in some implementations and can be deleted manually by a user or automatically. For example a user can configure snapshot filter so that the snapshot data secondary data corresponding to the primary data at the time of the snapshot such as the data in one or more differencing files takes up only a certain percentage of the storage volume. If a user specifies a maximum of fifteen percent then as the amount of snapshot data approaches fifteen percent of the storage volume snapshot filter can delete snapshots according to a scheme such as deleting the oldest snapshots. At that time snapshot filter can inform file system or application that one or more differencing files that were used only by the deleted snapshots contain invalid data and can be deleted. In response the file system or application can mark the storage regions of those one or more differencing files as invalid data and send delete notifications for those regions down the storage stack .

In addition when a snapshot is deleted snapshot filter can issue additional delete notifications for primary storage regions that the snapshot filter had omitted from previous delete notifications because the notifications indicated delete regions that overlapped with protected regions being protected by the snapshot filter . If those regions are no longer protected after the snapshot is deleted then the snapshot filter can send down the delete notifications for those regions. This can free up storage resources in the same manner as other delete notifications issued by file system or application .

Snapshot filter can identify these regions by tracking all regions where delete notifications were withheld or modified by snapshot filter because the notifications indicated ranges that overlapped with protected data. Alternatively snapshot filter can compute regions that can be deleted in other manners without tracking those regions. When a snapshot is deleted snapshot filter can calculate the product of all the bitmaps that track unprotected areas for active snapshots after the snapshot deletion. This produces an ignorable product bitmap that shows all storage regions that are unprotected by snapshot filter after the snapshot deletion such as by having 1 s for those regions. Snapshot filter can also take the product of that ignorable product bitmap and the freespace bitmap discussed above to produce a bitmap that shows areas that are considered freespace by the file system or application and are unprotected by the snapshot filter such as by having 1 s corresponding to such areas. Snapshot filter can create new delete notifications for all such areas and pass the new delete notifications down storage stack to performance boosting filter .

If snapshot filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume then snapshot filter can react differently than it would to a delete notification that applies to less than the entire volume. For example if snapshot filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume then snapshot filter can delete all snapshots for the volume and snapshot filter can disable itself. Snapshot filter can continue to be disabled until it is re enabled such as by a user or another component or module. For example snapshot filter can be re enabled the next time a snapshot is created automatically or in response to user input.

Referring to performance boosting filter can communicate with snapshot filter above it and write aggregation filter below it to receive and pass on delete notifications and read write requests and data . In addition the performance boosting filter can copy parts of a primary storage region into a cache on some other media that is faster than the primary storage device e.g. the other media can be RAM a USB drive or flash media if the primary storage volume is on one or more hard disks . The data can be read from the cache instead of primary storage to enhance system performance. For example the stored data can be instructions that are used when booting a computer system thereby speeding the boot process.

The performance boosting filter can pass on delete notifications without taking other actions. If a delete notification applies to a region of primary storage that corresponds to the cache then the cache can get out of synchronization with the primary data. Such situations would likely not affect the integrity of the cache data because there would be no reason for the cache data corresponding to the deleted primary data to be read in the future. However space in the cache is often limited. For example in some implementations the cache can be limited to about 300 megabytes. Accordingly performance boosting filter can optionally determine whether data in the cache corresponds to data in primary storage covered by a delete notification and if so then performance boosting filter can delete the corresponding cache data. This can include the performance boosting filter marking the deleted region of the cache as invalid so that more cached data can be stored in the region.

If performance boosting filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume then performance boosting filter can react differently than it would to a delete notification that applies to less than the entire volume. For example if the performance boosting filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume performance boosting filter can disable itself or it can remain enabled but start caching operations from scratch. If performance boosting filter is disabled it can remain disabled for a set period of time or until it is re enabled by an action of another program and or user input.

Referring to write aggregation filter can communicate with performance boosting filter above it and encryption filter below it to receive and pass on delete notifications and read write requests and data . In addition write aggregation filter can provide the additional functionality of managing write aggregation and lazy writes of aggregated write requests. When data is written to primary storage on storage device the write operation may involve making updates in several different primary data locations in the volume. Instead of writing data to be written to the primary storage locations at the time the requests are made write aggregation filter can write the data to be written to one or more log files . Write aggregation filter can also update an in memory map which can be a table that correlates the primary locations of the data to be written with the positions of the data to be written in log file . Log file can be stored in the same volume as primary storage or alternatively elsewhere. The data to be written can be drained from log file to the primary location s in primary storage in lazy write operations which can be done at idle times when storage device would otherwise be idle. In memory map can be examined to determine which drain operations still need to be done. After data is drained from log file entries in the in memory map that correspond to the drained data can be removed.

If read requests for locations of the data to be written in primary storage come down storage stack before the data to be written is drained from log file write aggregation filter can use in memory map to redirect the requests to the appropriate places in log file . After the data to be written is drained to its primary locations in primary storage write aggregation filter can allow read requests for that data to be passed down the stack unmodified.

In one or more embodiments log file is a circular file and a storage region is allocated for log file . Data to be written is added to log file which moves through the storage region as data to be written is added to and drained from log file . Specifically data to be written can be added to a head of log file when write requests are made during busy times and the data to be written can be drained from a tail of log file when lazy writes are made such as at idle times. When the head reaches the end of the storage region data can continue to be written at the beginning of the storage region so long as the beginning has been drained. In this way log file can travel a circular path through the storage region. As data is added to the head or drained from the tail the in memory map can be updated.

If write aggregation filter receives a delete notification write aggregation filter checks in memory map to determine whether the regions of primary storage covered by the delete notification overlap with the primary locations of any corresponding data to be written that is stored in log file . If so then those areas can be trimmed from the in memory map so that areas associated with the delete notification will not be drained to the primary storage and storage resources storage device processors that can be used for storage operations etc. can be freed for other uses.

In addition write aggregation filter can create new delete notifications that cover unused areas of the log file storage region. For example if the unused area expands to include an additional unused storage area write aggregation filter can issue a delete notification covering the additional unused storage area. It should be noted that the file system or application may still view the unused storage area as containing valid data because the unused storage area is in the storage region that has been allocated for use by write aggregation filter . Thus a storage device such as a flash memory device can prepare this additional unused storage area for writing and can cease maintaining data that is stored in the additional unused storage area.

Referring to and write aggregation filter can have a handshake operation with snapshot filter . In this handshake snapshot filter can request that write aggregation filter copy data from a protected primary storage area to a differencing file . Instead of sending this request down storage stack write aggregation filter can notify snapshot filter that the copy operation was completed successfully. Write aggregation filter can add the location in primary storage and the location in differencing file to the write aggregation filter s in memory map . Write aggregation filter can then redirect any read requests for the differencing file location to the primary storage area location using in memory map . If this is done write aggregation filter can protect the data by modifying delete notifications to remove areas that overlap with copy protected areas that have not yet been copied. This can be done in a manner that is similar to the delete notification modifications done by snapshot filter to protect data as discussed above.

If write aggregation filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume then write aggregation filter can react differently than it would to a delete notification that applies to less than the entire volume. For example if write aggregation filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume write aggregation filter can disable itself or the write aggregation filter can remain enabled but cancel all ongoing draining operations and delete log file . If write aggregation filter is disabled it may remain disabled for a set period of time or until it is re enabled by an action of another program and or user input.

Referring to encryption filter can communicate with write aggregation filter above it and volume manager filter below it to receive and pass on delete notifications and read write requests and data . Encryption filter can also perform additional functions such as encrypting an entire volume. In one or more embodiments the encryption technique employed by encryption filter is the BitLocker drive encryption technique available from Microsoft Corporation of Redmond Wash. Alternatively other public and or proprietary encryption techniques can be employed by encryption filter .

If encryption filter receives a delete notification with a flag indicating that delete notification applies to the entire volume then the encryption filter can react differently than it would to a delete notification that applies to less than the entire volume. For example if the encryption filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume encryption filter can disable itself or encryption filter can remain enabled but cancel all ongoing encryption operations. If encryption filter is disabled it may remain disabled for a set period of time or until it is re enabled by an action of another program and or user input.

Volume manager filter can communicate with encryption filter above it and partition manager filter in device stack below it to receive and pass on delete notifications and read write requests and data . Volume manager filter can communicate with the appropriate one or more device stacks involved in the configuration whether there are one or several such device stacks. In addition volume manager filter can be the PDO for volume stack . Before passing on delete notifications volume manager filter can convert read write requests and delete notifications between volume space and device space.

For example in a striping configuration megabytes 0 to 99 of a volume may correspond to megabytes 0 to 99 of a first storage device megabytes 100 to 199 of the volume may correspond to megabytes 0 to 99 of a second storage device megabytes 200 to 299 of the volume may correspond to 100 to 199 megabytes of the first device megabytes 300 to 399 of the volume may correspond to megabytes 100 to 199 of the second storage device and so forth. In this example volume manager filter can split a delete notification that applies to megabytes 49 to 150 of the volume into one delete notification that applies to megabytes 49 to 99 of the first storage device and another delete notification that applies to megabytes 0 to 50 of the second storage device. Similar conversions can be done for other configurations such as where a volume spans multiple storage devices or where a volume takes up only part of a storage device. This conversion between volume and storage device space i.e. from volume relative range s to device relative range s is an example of modifying the delete notifications . As an example of this type of modification consider a disk 0 to 99 megabytes with two volumes on it where volume 1 resides from 1 to 24 megabytes and volume 2 resides from 25 to 99 megabytes. If volume manager filter receives a delete notification for range 10 to 14 megabytes on volume 1 filter can adjust that range to 11 to 15 megabytes and if volume manager filter receives the same delete notification on volume 2 a notification for 10 to 14 megabytes on volume 2 filter can adjust that range to 35 to 39 megabytes.

Referring to in many fault tolerant volume storage configurations in addition to maintaining a primary storage volume volume manager filter can maintain redundant storage which can be used to recreate part or all of primary storage volume in the case of storage device failure. For example this can be done with some types of redundant arrays of independent disks RAID such as mirroring or RAID 5. In the case of mirroring redundant storage includes a copy mirror image of primary storage volume . Redundant storage can be created and maintained on one or more separate storage devices. In the case of RAID 5 at least three plexes can be used where a plex is typically a set of one or more storage devices. One of the plexes redundant storage can be an XOR of the other plexes primary storage . If one of the primary storage plexes crashes the plex can be recreated using the remaining primary storage plexes and the redundant XOR plex.

Redundant storage such as a RAID 5 XOR plex or a mirror image sometimes needs to be synchronized with primary storage volume . For example synchronization is typically done when a RAID 5 XOR plex or a mirror image is first created or after system failure such as a dirty shutdown. Synchronization can involve volume manager filter examining primary storage volume comparing primary storage volume to redundant storage performing any appropriate calculations and writing any appropriate data to synchronize redundant storage with primary storage . With mirroring synchronization can include performing a series of read and copy operations and with RAID 5 synchronization can include read and write operations as well as XOR calculations.

Referring to when volume manager filter is performing a synchronization operation with primary storage and redundant storage volume manager filter can omit from its synchronization operations those areas of primary storage that have been covered by delete notifications unless subsequent write operations have been executed in those areas. This can be done whether the delete notifications are received before the synchronization operation begins or even while the synchronization operation is ongoing. By foregoing some of these synchronization operations storage resources can be freed.

In addition volume manager filter can modify a received delete notification by expanding a range of data covered by the received delete notification to cover not only the data in primary storage indicated by the received delete notification but also corresponding data in redundant storage .

If volume manager filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume then volume manager filter can react differently than it would to a delete notification that applies to less than the entire volume. For example if volume manager filter receives a delete notification with a flag indicating that the delete notification applies to the entire volume volume manager filter can remain enabled but cancel all ongoing synchronization operations. When volume manager filter receives an existing delete notification that applies to the entire storage volume and this is indicated by a flag volume manager filter can modify the delete notification by replacing the flag with one or more delete notifications for one or more device relative ranges that span the entire volume before passing the modified delete notification s down the storage stack .

Referring to partition manager filter can communicate with volume manager filter above it and disk class driver below it to receive and pass on delete notifications and read write requests and data . Thus partition manager filter can be the upper most filter in device stack . In addition partition manager filter can manage the partitions for the associated storage device . If it is desired to remove the partitions on the associated storage device partition manager filter can create a new delete notification that applies to the entire storage device and pass the new delete notification down disk stack to disk class driver .

Disk class driver can communicate with partition manager filter above it and data verification filter below it to receive and pass on delete notifications as well as read write requests and data . Disk class driver can also be the FDO for device stack . If disk class driver receives a delete notification that applies to the entire storage device then disk class driver can treat that delete notification the same as other delete notifications because the disk class driver s operations do not involve caching or transforming data.

Referring now to data verification filter can communicate with disk class driver above it and port driver below it to receive and pass on delete notifications and read write requests and data . Data verification filter can perform calculations on a block of data to be written to primary storage and produce and store a checksum e.g. a cyclical redundancy check CRC or other checksum from that data. The checksums can be used as checksums to detect accidental alteration of data by the storage device . The checksums can be stored in a checksum table which can be stored in memory such as RAM or in some other storage area. When the primary data is later read from primary storage data verification filter can calculate the checksum of the data received from storage device and compare that new checksum to the corresponding checksum stored in memory. If the stored and new checksums match then the data is verified. If the stored and new checksums do not match then data verification filter can indicate that the data received from storage device is invalid.

Data verification filter can pass on delete notifications without taking other actions. If a delete notification applies to a region of primary storage that corresponds to stored checksums then the stored checksums can get out of synchronization with the primary data. Such situations would likely not affect the integrity of the checksums because there would be no reason for the checksums corresponding to the deleted primary data to be read in the future. However space in checksum table is often limited. For example in some implementations checksum table may be limited to a small percentage or fixed amount of available RAM space. Accordingly data verification filter can optionally determine whether checksums in the checksum table correspond to data in primary storage covered by a delete notification and if so data verification filter can delete the corresponding checksums .

If data verification filter receives a delete notification that applies to the entire storage device then data verification filter can cancel ongoing operations throw away all checksums for storage device and start operating from scratch.

Port driver can communicate with data verification filter above it and storage device below it to receive and pass on delete notifications and read write requests and data . This communication with storage device can be done using an existing or new protocol such as by having a delete notification function in the existing ATA protocol. If a delete notification is for a range that is greater than a maximum range that can be represented in a single delete notification protocol command port driver can issue multiple delete notification protocol commands with adjacent ranges. If port driver receives a delete notification that applies to the entire storage device then port driver can treat that delete notification the same as other delete notifications because the port driver s operations do not involve caching or transforming data. If the protocol to communicate with storage device does not include the ability to indicate that a delete notification applies to the entire range of storage device for example with a flag then port driver can modify the existing delete notification that applies to the entire device by generating one or more delete notifications with one or more adjacent ranges that describe the entire range of storage device .

After port driver issues the appropriate delete notification protocol command or commands to storage device port driver returns a confirmation for the delete notification to data verification filter . This confirmation is then passed back up stack to the one of file system and application from which the delete notification was received. Alternatively port driver can wait to return the confirmation until after port driver has received a notification from storage device that storage device has received or otherwise acknowledged the delete notification protocol command or commands.

Computing device includes one or more processors or processing units one or more computer readable media which can include one or more memory and or storage components one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Computer readable media and or one or more I O devices can be included as part of or alternatively may be coupled to computing device . Bus represents one or more of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port a processor or local bus and so forth using a variety of different bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

The techniques discussed herein can be implemented in software with instructions being executed by one or more processing units . It is to be appreciated that different instructions can be stored in different components of computing device such as in a processing unit in various cache memories of a processing unit in other cache memories of device not shown on other computer readable media and so forth. Additionally it is to be appreciated that the location where instructions are stored in computing device can change over time.

One or more input output devices allow a user to enter commands and information to computing device and also allows information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier wave or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

Generally any of the functions or techniques described herein can be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module and component as used herein generally represent software firmware hardware or combinations thereof. In the case of a software implementation the module or component represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices further description of which may be found with reference to . The features of the use of delete notifications by file systems and applications to release storage space techniques described herein are platform independent meaning that the techniques can be implemented on a variety of commercial computing platforms having a variety of processors.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

