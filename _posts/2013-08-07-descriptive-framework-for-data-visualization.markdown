---

title: Descriptive framework for data visualization
abstract: Described herein is a descriptive framework to facilitate data visualization. In accordance with one aspect of the framework, one or more module manifests are provided, wherein a module manifest describes a module that represents a particular component of a visualization. A chart manifest may be used to coordinate the one or more module manifests. A visualization may be rendered based on the chart manifest.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262850&OS=09262850&RS=09262850
owner: Business Objects Software Ltd.
number: 09262850
owner_city: Dublin
owner_country: IE
publication_date: 20130807
---
The present disclosure relates generally to data visualizations and more specifically to a descriptive framework for composing data visualizations.

Graphical representations of data can greatly facilitate analysis and understanding of the data. Different types of charts or graphs such as a bar chart an area chart a pie chart a line chart a column graph a scatter plot and so forth may be generated from the data set to suit different needs. Such visualizations are instrumental in facilitating the understanding of complex business data sets.

A developer may use chart or charting libraries to add web based visualization support to web applications. A chart library typically provides commands that are used to render a visualization. It may include a library of predefined chart components e.g. legends axes titles tooltip plot area etc. that may be used as building blocks for a new visualization. Different charts may share several common chart parts. For instance a bar chart and a line chart may share the same legend while a multi bar chart can share the same plot area as a single bar chart.

However one of the problems with conventional chart libraries is that although different charts may share common chart parts such chart parts are not easily reusable. To generate a new visualization all the different chart parts have to be redefined from the code level. In addition each customer may have different requirements. For example a customer may require a pie chart to have two titles e.g. main title and sub title or a bar chart to have a value axis on the top. However chart libraries typically only support pre defined charts and customers are not able to customize or extend the charts by themselves. Therefore if the chart library only provides a default pie chart with one title or a default bar chart with a value axis at the bottom such charts cannot be generated unless the chart library is customized to accommodate such specific requirements.

A descriptive framework for facilitating data visualization is described herein. In accordance with one aspect of the framework pre defined module manifests are provided in a manifest system stored in a memory module wherein a pre defined module manifest describes a module that represents a particular component of a visualization. A new module manifest may be generated based on at least one of the pre defined module manifests. A chart manifest referencing the new module manifest or at least one of the pre defined module manifests may be provided. The visualization may then be rendered based on the chart manifest.

In accordance with another aspect of the framework one or more module manifests are provided wherein a module manifest describes a module that represents a particular component of a visualization. A chart manifest may be used to coordinate the one or more module manifests. A visualization may then be rendered based on the chart manifest.

With these and other advantages and features that will become hereinafter apparent further information may be obtained by reference to the following detailed description and appended claims and to the figures attached hereto.

In the following description for purposes of explanation specific numbers materials and configurations are set forth in order to provide a thorough understanding of the present frameworks and methods and in order to meet statutory written description enablement and best mode requirements. However it will be apparent to one skilled in the art that the present frameworks and methods may be practiced without the specific exemplary details. In other instances well known features are omitted or simplified to clarify the description of the exemplary implementations of the present framework and methods and to thereby better explain the present framework and methods. Furthermore for ease of understanding certain method steps are delineated as separate steps however these separately delineated steps should not be construed as necessarily order dependent in their performance.

A framework for facilitating a descriptive approach to composing data visualizations is described herein. In accordance with some implementations visualizations are composed by first developing smaller reusable modules that represent components or parts of a chart such as the axis legend title container plot area etc. Unlike conventional systems where chart components have to be defined from code level the modules according to the present framework may be defined using configuration files or module manifests. They may stand alone or be combined with other modules via at least one chart manifest or configuration file to form a visualization. Existing modules from a manifest system may be used to compose the visualization. In addition existing modules may be extended or customized to generate new modules to add to the manifest system . A chart manifest describes the visualization in terms of its component modules and relationships between the component modules. The chart manifest may be extensible and easily authored by the user without need for advanced programming knowledge or skill.

Accordingly the present framework advantageously achieves reusability customizability and extensibility. It enables a chart library provider s customers to tailor their chart libraries according to their requirements by customizing or extending existing module or chart manifests to create new module or chart types. In addition customers can implement their own modules and add them to existing data visualizations or create new visualizations.

The framework described herein may be implemented as a method a computer controlled apparatus a computer process a computing system or as an article of manufacture such as a computer usable medium. These and various other features will be apparent from the following description.

The computer system may be communicatively coupled to one or more data sources . Data source may be for example any database e.g. relational database in memory database etc. an entity e.g. set of related records or a data set included in a database. Data source may be any suitable data including a buffer or data that resides in a local volatile memory and need not directly relate to a database.

It should be appreciated that the different components and sub components of the computer system may be located on different machines or systems. It should further be appreciated that the components of the client computer may also be located on the computer system or vice versa.

Computer system includes a central processing unit CPU an input output I O unit and a memory module . Other support circuits such as a cache a power supply clock circuits and a communications bus may also be included in computer system . In addition any of the foregoing may be supplemented by or incorporated in application specific integrated circuits. Examples of computer system include a handheld device a mobile device a personal digital assistance PDA a workstation a server a portable laptop computer another portable device a mini computer a mainframe computer a storage system a dedicated digital appliance a device a component other equipment or some combination of these capable of responding to and executing instructions in a defined manner.

Memory module may be any form of non transitory computer readable media including but not limited to dynamic random access memory DRAM static random access memory SRAM Erasable Programmable Read Only Memory EPROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory devices magnetic disks internal hard disks removable disks magneto optical disks Compact Disc Read Only Memory CD ROM any other volatile or non volatile memory or a combination thereof.

Memory module serves to store machine executable instructions data and various software components for implementing the techniques described herein all of which may be processed by CPU . As such the computer system is a general purpose computer system that becomes a specific purpose computer system when executing the machine executable instructions. Alternatively the various techniques described herein may be implemented as part of a software product. Each computer program may be implemented in a high level procedural or object oriented programming language e.g. C C Java JavaScript Advanced Business Application Programming ABAP from SAP AG Structured Query Language SQL etc. or in assembly or machine language if desired. The language may be a compiled or interpreted language. The machine executable instructions are not intended to be limited to any particular programming language and implementation thereof. It will be appreciated that a variety of programming languages and coding thereof may be used to implement the teachings of the disclosure contained herein.

In one implementation the memory module of the computer system includes a visualization composition framework a rendering component and a manifest system . Visualization composition framework may include a set of function modules or programs designed to facilitate a descriptive approach to composing visualizations that are reusable customizable and extensible. The visualizations may be composed in the form of chart manifest files or configuration files that are stored in the manifest system which will be described in more detail later. Rendering component may retrieve data e.g. chart manifest files from the manifest system and or or data source and generate a visual representation based on the data.

Manifest system is similar to a configuration registry that manages numerous manifests or manifest files . Besides managing manifests the manifest system may further support manifest inheritance and extension so as to facilitate manifest creation and or maintenance. In some implementations each manifest is a configuration file that is authored using simple human readable language such as JavaScript Object Notation JSON Extensible Markup Language XML etc. that can be written or read conveniently without advanced programming knowledge or skill.

In some implementations the manifest may be a module manifest or a chart manifest. A module manifest describes a module which is the smallest unit that makes up a visualization or chart . A module manifest defines a new module by for example describing the features of the module e.g. type properties etc. . A chart manifest is similar to an application that coordinates the modules to behave as expected for the visualization. A chart manifest defines a new chart by describing how the chart is composed by existing modules e.g. hierarchical relationship and how the modules interact. A module manifest or chart manifest may generate a new module or chart respectively by customizing extending or reusing one or more existing modules or charts. Different interfaces may be defined for different module types to ensure they coordinate well together. Users may implement their own modules and use them in charts if they are compatible with these interfaces.

Manifest system may further include one or more components or application programming interfaces APIs for providing manifest management functions. For instance manifest system may include a registerCategory API for creating a new category. A category generally refers to a type of manifest. For example manifest system may manage the module and chart manifests in two categories chart category and module category. Manifest system may further include a register API for mounting a new manifest into a category an index system that is based on manifest id and supports referencing of one or more easy to use accessor APIs for locating and accessing configuration items in manifest and or base abstract keywords to enable inheritance that can be used to extend and reuse existing manifests easily.

In some implementations manifest system provides one or more pre defined module manifests. Each module represents a particular type of component of a visualization such as a legend title axis plot tooltip and so forth. Different types of modules may be defined for different types of components of a visualization. Generally there may be five types of modules 1 container 2 layout 3 supplementary 4 chart and 5 behavior.

A container type module is one that contains other modules. It serves to coordinate its sub modules in for example a data dispatch an event dispatch etc. Each container type module may specify a particular layout module to arrange the visual parts represented by its sub modules in a visualization. Exemplary container type modules may include but are not limited to commonContainer modules tableContainer modules matrixContainer modules and so forth. Each container type module may represent a different coordination pattern. For example a tableContainer module and a matrixContainer module may implement different data dispatch algorithms.

A layout type module serves to arrange the sub modules of the container type module that it is assigned to. It is defined separately from the container type module and allows the user to specify different layouts for a single container type module. Exemplary layout type modules may include but are not limited to gridLayout xyLayout chartLayout and so forth.

A supplementary type module does not represent data directly but serves to facilitate user interpretation of the data. Exemplary supplementary type modules include but are not limited to title module axis module e.g. value axis module category axis module etc. legend module e.g. color legend module size legend module etc. tooltip module and the like.

A chart type module directly represents data in a visual form. Exemplary chart type modules include but are not limited to a bar module e.g. column bar module stacked bar module etc. line module pie module scatter or bubble plot module radar module and the like.

A behavior type module serves to define and control the behavior of the visualization. Exemplary behavior type modules include but are not limited to selection module export module and so forth.

Visualization composition framework is communicatively coupled to manifest system . Visualization composition framework may construct an output visualization based on input options from the user e.g. custom module or manifest definitions and or existing module and or chart manifests in the manifest system respectively.

Manifest system includes various types of existing modules such as a chart module i.e. bar module supplementary modules e.g. title module legend module a container module e.g. XYContainer module and possibly other module that represents any other module. Each module is associated with a respective module manifest that defines the features of the module . For instance bar module is associated with manifest of bar module title module is associated with manifest of title module legend module is associated with manifest of legend module XYContainer module is associated with manifest of XYContainer module and other module is associated with manifest of other module

Each module manifest may further be associated with a chart manifest respectively. In some implementations multiple module manifests are associated with each chart manifest or . Each chart manifest describes how a chart is composed of various modules. For instance a manifest of bar chart may describe how a bar chart is composed of a bar module a title module a legend module an XYContainer module and other module . The chart manifest may reference one or more modules from the manifest system and specify special properties of the modules to generate instantiations of those modules.

More particularly a solid arrow from a first manifest to a second manifest indicates an inheritance relationship where the second manifest is inheriting attributes or behavior from the first manifest i.e. base . For instance to simplify definition of a module manifest a chart manifest may inherit certain attributes or behavior from a pre existing parent chart manifest. As shown donut chart manifest may inherit from pie chart manifest line chart manifest waterfall chart manifest and vertical bar chart manifest may inherit from base vertical chart manifest dual horizontal chart manifest and dual bar chart manifest may inherit from horizontal line chart manifest and bar chart manifest respectively which may both inherit from base horizontal chart manifest .

An arrow with a broken line from a third manifest to a fourth manifest indicates a reference relationship where the third manifest includes a reference to the fourth manifest. For example a chart manifest may reference one or more module manifests to compose a chart. As shown bar chart manifest may reference root container manifest . Module manifests may also reference other module manifests. For instance root container manifest may reference Tooltip manifest Background manifest XYContainer Root manifest title manifest and legend manifest . XYContainer Root manifest may further reference xAxis Axis manifest yAxis Axis manifest Behavior manifest and Bar manifest .

The keyword targetModule may be used to specify the target module path while the keyword sourceModule may be used to specify the source module path. A module path is used to find a certain module when the framework is resolving value dependencies. The module path reflects the composition structure of the module from its chart root module. For example the source module path main.plot indicates that the source module is defined by a module reference named plot which is a child of another module reference named main .

Any module may have any dependency on any other module via the specified source and target functions. With object dependency interfaces for all possible dependencies may have to be predefined. In other words modules that are depended upon by other modules may need to be configured with interfaces. This may limit the implementation of the other modules. For instance if module A depends on module B based on the function X any other module C that wants to be depended on by module A should have the same signature as function X. The implementation of module C may be limited given that module C may use function X for other functionality. With value dependency however the function signature may be included in the value dependency configuration and module C can use any other function regardless of its signature as long as it provides the right value to module A.

At the visualization composition framework receives a request to compose a visualization. Generally composing a visualization includes creating modifying and or importing a visualization. The user request may be received from for example a user interacting via the associated user interface . The user request may indicate for example user selections of desired module or chart manifests for composing the visualization. The user may choose to customize one or more existing modules from the manifest system .

At the visualization composition framework determines if all user selected modules already exist in the manifest system . If all the user selected modules already exist the process continues to generate the manifest file of the chart at .

At visualization composition framework determines if a customized container module is required. A customized container module may be required when for instance a special coordination pattern layout or other property not found in an existing container module is required. If only a special layout is required a customized layout module may be implemented at . If a property other than a special layout is required a new container module may be implemented at .

More particularly if a customized container module is required the process continues at to determine if a customized layout module is required. A customized layout module may be required when the pre existing layout modules in the manifest system do not satisfy the user s requirements. For example a table layout instead of a default flow chart layout may be required. If a customized layout module is required the process continues at to implement the layout module. The layout module may be implemented by customizing or extending an existing layout module. In some implementations the user may write the layout module manifest file via the associated user interface to implement the layout module.

If a customized layout module is not required the process continues at to implement a container module. The container module may be implemented by customizing or extending an existing container module. In some implementations the user may write the container module manifest file via the associated user interface . The layout and container module manifest files may be programmed in accordance with the descriptive approach described herein using for example simple human readable language such as JavaScript Object Notation JSON Extensible Markup Language XML etc.

If a customized container module is not required the process continues at to determine if a customized module is required. A customized module may be required when existing modules in the manifest system do not meet the user s requirements.

If a customized module is required the process continues at to implement the module. The module may be implemented by customizing or extending an existing module retrieved from the manifest system . For example the user may choose to modify predefined properties dependencies and or events in the existing module. In some implementations the user may write the module manifest file via the associated user interface to implement the customized module. It should be appreciated that in situations where more than one customized module is required step may be repeated as many times as desired.

If a customized module is not required or all desired modules already exist in the manifest system the process continues at to write a chart manifest file. In some implementations the user may write the chart manifest file via the associated user interface . The chart manifest file may be programmed in accordance with the descriptive approach described herein using for example simple human readable language such as JavaScript Object Notation JSON Extensible Markup Language XML etc. In the chart manifest file the user may choose to reorganize component modules and or define a new chart type. The user may also replace module implementations e.g. container chart or supplementary in an existing chart type with new modules implemented in steps and or .

At the new chart type is registered with the manifest system for use in building a new visualization. For instance the manifest system may invoke a registerCategory API to create a new category and a register API to mount the new chart type manifest into the new category. Other methods of registration are also useful.

At the rendering component receives a chart manifest file. The chart manifest file may be received in response to for example a user selection of the chart via the user interface .

At the rendering component determines if the chart associated with the chart manifest exists. The chart exists if its manifest file is valid or may be found in the manifest system . If the chart already exists the process ends. If the chart does not exist the process continues at .

At the rendering component reads the chart manifest file and checks its root module. At the rendering component determines if the root module is a container module. A container module may be optional and implemented when more than one module is required to compose the visualization. In other words the container module may not be necessary when only one module is specified to compose the visualization.

If the root module is a container module at the rendering component directly builds the module tree from the root module. The module tree is a data structure that represents the reference relationships between the modules. For example shows an exemplary module tree in the module manifests section . As shown the root container module references sub modules . The sub module XYContainer Root is also a container type module that references two axis module instances a behavior module instance and a bar plot module instance .

If the root module is not a container module a new module instead of a module tree is created at . At the rendering component resolves and or merges properties of the new module. The properties may be specified by the user when creating the chart instance. Alternatively the properties may be specified in the module reference included in the chart manifest.

At the rendering component constructs the layout of the chart by using the layout module specified in for example the chart manifest. The layout module is responsible for positioning and or sizing of all module instances. The desired layout properties may be specified by the user or in the module reference included the chart manifest. For instance referring to the common container module may be configured to use the default layout module e.g. border layout module . The default layout module may be configured by indicating one or more desired properties in the chart manifest. The default layout module may then arrange sub modules based on the indicated properties .

At the rendering component resolves any dependencies between modules referenced in the chart manifest. In some implementations value and or event dependencies are resolved. The dependencies are resolved to generate a dependency configuration that connects all the module instances. Step is generally performed after step as some dependencies are related to the size of layout components.

At the rendering component renders a visual representation of the chart. The rendering may be performed based on the module tree determined by step or the single module created by steps . In some implementations each child module instance in the module tree may be assigned a rendering element from its parent module instance. Each rendering element may be processed to render a visual component of the chart.

Although the one or more above described implementations have been described in language specific to structural features and or methodological steps it is to be understood that other implementations may be practiced without the specific features or steps described. Rather the specific features and steps are disclosed as preferred forms of one or more implementations.

