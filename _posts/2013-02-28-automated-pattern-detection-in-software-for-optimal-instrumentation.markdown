---

title: Automated pattern detection in software for optimal instrumentation
abstract: A technique for detecting patterns in the execution of an application. The technique identifies a sequence of methods which are invoked and obtains information regarding attributes of the methods. For example, attribute information such as a class hierarchy can be obtained from an instrumentation API. A data structure representing a hierarchy of the attributes can be created and compared to one or more reference data structures which describe patterns of interest. A decision can be made to provide instrumentation for the methods having the matching attributes. The decision can consider how frequently the pattern is detected and overhead costs of the instrumentation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021448&OS=09021448&RS=09021448
owner: CA, Inc.
number: 09021448
owner_city: New York
owner_country: US
publication_date: 20130228
---
The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e commerce education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives and devote considerable resources to ensuring that they perform as expected. To this end various application management techniques have been developed. One approach involves monitoring the infrastructure of the application by instrumenting the application and using the instrumentation to collect data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example using the instrumentation a thread or process can be traced to identify each component that is invoked as well as to obtain runtime data such as the execution time of each component. However it is challenging to provide optimal instrumentation for an application.

Techniques are provided for detecting patterns in how an application executes and using these patterns to provide optimal instrumentation for the application.

A hierarchy of invoked methods of an application and attributes of the invoked methods are identified and a data structure representing the attributes is generated. The data structure has a hierarchy which is based on the hierarchy of the invoked methods. The data structure is compared to one or more reference data structures to detect a match for patterns of interest. Instrumentation can then be provided for methods whose attributes are involved in the match.

As will be appreciated by one skilled in the art aspects of the present disclosure may be illustrated and described herein in any of a number of patentable classes or context including any new and useful process machine manufacture or composition of matter or any new and useful improvement thereof. Accordingly aspects of the present disclosure may be implemented entirely in hardware entirely in software including firmware resident software micro code etc. or by combining software and hardware implementations that may all generally be referred to herein as a circuit module component or system. Furthermore aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable media having computer readable program code embodied thereon.

Any combination of one or more computer readable media may be utilized. The computer readable media may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an appropriate optical fiber with a repeater a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable signal medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages including an object oriented programming language such as JAVA Scala Smalltalk Eiffel JADE Emerald C C VB.NET Python or the like conventional procedural programming languages such as the C programming language Visual Basic Fortran 2003 Perl COBOL 2002 PHP ABAP dynamic programming languages such as Python Ruby and Groovy or other programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider or in a cloud computing environment or offered as a service such as Software as a Service SaaS .

Aspects of the present disclosure are described herein with reference to flowchart illustrations and or block diagrams of methods apparatuses systems and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable instruction execution apparatus create a mechanism for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that when executed can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions when stored in the computer readable medium produce an article of manufacture including instructions which when executed cause a computer to implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer other programmable instruction execution apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatuses or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

As mentioned at the outset techniques are provided for detecting patterns in how an application executes and using these patterns to provide optimal instrumentation for the application. Instrumentation can provide valuable information regarding the operation of an application. However identifying an optimal configuration to instrument an application is challenging. If there is too much instrumentation the overhead costs become too great and a lot of unnecessary data is generated. On the other hand if there is too little instrumentation useful information may be missed.

Techniques provided herein detect specific software patterns in an application and use the patterns to identify where to place instrumentation in the application. The type of instrumentation to use can also be identified. Moreover these patterns are detected in an efficient manner and without knowledge of the application code a code path analysis or installed instrumentation. The techniques are based on pattern detection. For example one or more logs can be provided which contain relationship information of the components such as methods of the application and the pattern detection can be based on an analysis of the logs. In one example implementation thread sampling is used to obtain and store information about call sequences in the logs.

Several advantages are achieved. First applications whose design is unknown can be instrumented in a more automated way. Second stack trace sampling limits overhead costs compared to other approaches such as providing byte code instrumentation of all methods of the application. Third by performing the pattern recognition at the server side processing resources CPU time are not taken away from the application server so that overhead costs to the application can be minimized. Fourth the processing of configuring agents for application performance management is simplified. Fifth the techniques can be used in a production environment as well as in test scenarios.

The manager server can be provided on a separate computing device such as a workstation which communicates with a user interface see also such as a monitor to display information based on data received from the agents. The manager server can also access a database to store data received from the agents. For instance some large organizations employ a central network operations center where one or more manager servers obtain data from a number of distributed agents at different geographic locations. To illustrate a web based e commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders from servers that process payments from servers at warehouses for tracking inventory and conveying orders and so forth. The manager server and user interface display might be provided at a corporate headquarters location. Other applications which are not necessarily web based or involve retail or other sales similarly employ agents and managers for managing their systems. For example a bank may use an application for processing checks and credit accounts. Moreover in addition to the multi computing device arrangements mentioned a single computing device can be monitored as well with one or more agents.

Various approaches are known for instrumenting software to monitor its execution. For example tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Pat. No. 7 870 431 issued Jan. 11 2011 titled Transaction Tracer and incorporated herein by reference. In one approach discussed therein object code or bytecode of an application to be monitored is instrumented e.g. modified with probes. The probes measure specific pieces of information about the application without changing the application s business or other logic. Once the probes have been installed in the bytecode of an application it is referred to as a managed application and a computing device on which the application runs is referred to as a managed computing device. The agent software receives information from the probes and may communicate the information to another process such as at the manager server or process the information locally such as to determine whether the information indicates an abnormal condition. The agent thus collects and summarizes information received from the probes. The probes collect information as defined by a directives file. For example the information from the probes may indicate start and stop times of a transaction or other execution flow or of individual components within a transaction execution flow. This information can be compared to pre established criteria to determine if it within bounds. If the information is not within bounds the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents are typically aware of the software executing on the local managed computing device with which they are associated.

The probes can report a standard set of metrics which include CORBA method timers Remote Method Invocation RMI method timers Thread counters Network bandwidth JDBC update and query timers Servlet timers JAVA Server Pages JSP timers System logs File system input and output bandwidth meters Available and used memory and EJB Enterprise JAVA Bean timers. A metric is a measurement of a specific application activity. Each of these metrics can be configured by agent metadata.

An agent reports information about transactions which identifies resources which are accessed by an application. In one approach when reporting about transactions the word Called designates a resource. This resource is a resource or a sub resource of a parent component which is a consumer. For example assume that Servlet A is the first component invoked in a transaction. Under the consumer Servlet A see below there may be a sub resource Called EJB. Consumers and resources can be reported by the agent in a tree like manner. Data for a transaction can also be stored according to the tree. For example if a Servlet e.g. Servlet A is a consumer of a network socket e.g. Socket C and is also a consumer of an EJB e.g. EJB B which in turn is a consumer of a JDBC e.g. JDBC D the tree might look something like the following 

In one embodiment the above tree is stored by the agent in a stack called the Blame Stack. A transaction is an execution path inside a system. A system can consist of multiple applications. Inside an application are multiple components which are invoked by a transaction. These components are pushed together with their parameters onto the stack. When the components have completed execution they are popped off the stack. In one embodiment each component on the stack has the following information stored type of transaction a name used by the system for that transaction a hash map or dictionary of parameters a timestamp for when the transaction was pushed onto the stack and sub elements. Sub elements are Blame Stack entries for other components e.g. methods process procedure function thread set of instructions etc. that are started from within the transaction of interest. Using the tree as an example above the Blame Stack entry for Servlet A would have two sub elements. The monitoring points for a Servlet represent a component on the stack inside a transaction. The first sub element would be an entry for EJB B and the second sub element would be an entry for Socket Space C. Even though a sub element is part of an entry for a particular transaction the sub element will also have its own Blame Stack entry. An example of an entry point to a transaction branch is a URL. As the tree above notes EJB B is a sub element of Servlet A and also has its own entry. The top or initial entry e.g. Servlet A for a transaction is called the root component. Each of the entries on the stack is an object.

Each agent adds instrumentation to an application and is configured based on one or more configuration files. For example agent may use configuration files such as an agent profile file a probe builder directives file and a probe builder list file.

The agent profile files are responsible for enabling disabling of agent features location of server type of communication e.g. plain socket SSL HTTP HTTP over SSL location of configuration files and log files metric sending frequency and so forth.

A probe builder directives file contains directives for the agent. Directives may contain information about the type and source of metrics to generate e.g. by specifying at least one method of a class or set of classes to monitor and a type of information to be collected in the application or information about a formatter for renaming a metric and so forth. Directives can also specify at least one method of a class or set of classes to instrument.

In one approach the application executes in an execution environment such as the JAVA runtime environment as discussed in connection with . The JAVA runtime environment uses a JAVA Virtual Machine JVM . Programs intended to run on a JVM are typically compiled into a standardized portable binary format which usually are in the form of .class files. A program may include many classes in different files. For easier distribution of large programs multiple class files may be packaged together in a JAVA Archive JAR file. The JVM runtime executes CLASS or JAR files emulating the JVM instruction set by interpreting it or using a just in time compiler JIT . JIT compiling as opposed to interpreting is often used in a JVM to achieve greater speed.

In another possible approach the application executes in the runtime environment of the .NET framework known as the Common Language Runtime CLR as discussed in connection with .

In step the system acquires a timestamp indicating the current time. In step a stack entry is created. In step the stack entry is pushed onto the Blame Stack. In one embodiment the timestamp is added as part of step . The process is performed when a transaction is started. A similar process is performed when a sub component of the transaction starts e.g. EJB B is a sub component of Servlet A see tree described above .

Note in one embodiment if the transaction tracer is off the system will still use the Blame Stack however parameters will not be stored and no component data will be created. In some embodiments the system defaults to starting with the tracing technology off. The tracing only starts after a user requests it as described above.

A database may be included in the storage device when the storage device is part of a computing device such as an application server manager and or user interfaces. The storage device can represent one or more storage devices which store data received from one or more agents and which can be accessed to obtain data to provide a user interface as described herein. The storage device can represent a data store. The processor can include a stack which identifies code which is executing in a thread. Examples are provided in . The stack can be periodically sampled to obtain thread stack traces which identify the executing code. The working memory can include a log of invoked methods of an application .

Further details are provided in connection with . The portions of the code can be provided in one or more working memories. In one approach the code is provided in the application server and the remaining code is provided in the manager server.

A top level of the business hierarchy is a domain level named Domain. A next level of the hierarchy is a Business Service level . An example of a Business Service relates to trading a stock using a web site. Thus Trading can be the name of a node at the Business Service level of the hierarchy. A next level of the hierarchy is a Business Transaction level. A Business Service can be made up of a number of Business Transactions. For example for Trading the Business Transactions can include Reports e.g. view a report regarding a stock or an account and Quotes e.g. obtain a quote for a stock price . Further a Business Transaction can be associated with one or more Business Transaction Components. In one approach a Business Transaction has only one identifying component. A Business Transaction Component can be a type of component of an application which is recognizable and measurable by a server such as a servlet or EJB. In one approach one of the components of an application is set as a Business Transaction Component which is an identifying transaction component for a Business Transaction.

The Business Transaction Component is the identifying transaction component for the transaction that is the identifying transaction for the Business Transaction. A transaction can represent a sequence of software components which are invoked in response to a request from a client to provide a corresponding response to the client. For example a Business Transaction Component can be identified by determining when component data reported by an agent match a set of rules. This definition can include e.g. a specified URL host name URL parameters HTTP post parameters cookie and or session manager parameters. Additionally or alternatively the definition may require a transaction to start with a specified URL host name. The agent or manager for instance can compare the component data against the set of rules to determine when a Business Transaction Component is present in a Business Transaction. If a Business Transaction Component is detected then the associated Business Transaction is of a specified type. For example if the Business Transaction Component is detected then the associated Business Transaction is Reports . If the Business Transaction Component is detected then the associated Business Transaction is Quotes .

Component oriented programming models are useful in allowing the programmer to assemble an application or other program from building blocks referred to as components. Each component can perform a specific function which fits in with an overall functionality of the software. Furthermore a component can call other components as well as calling itself in a recursive call so that a sequence of components is invoked in a program. One example of a component oriented programming model is J2EE JAVA Platform Enterprise Edition which can employ components such as a JAVA Server Page an EJB a servlet and a JAVA Database Connectivity JDBC component. JDBC is an Application Programming Interface API for the JAVA programming language that defines how a client may access a database. It provides methods for querying and updating data in a database. However other component oriented programming models such as the MICROSOFT CORP. .NET Framework may also be used. Moreover the programming model need not be object oriented.

This example provides details of the Reports and Quotes Business Transactions discussed previously. In one possible implementation each component of a Business Transaction includes one or more class method pairs. For example a servlet is a JAVA class. It is an object that receives a request and generates a corresponding response. A class method pair can be represented by the notation class.method. For example Reports could include a component C1 which displays a reports screen on a user interface UI to receive a user s input regarding a desired report. An example format of a class method pair for C1 is ServletA1.DisplayReportScreen. C1 is under a root . Thus whenever an agent detects that C1 has been invoked it concludes that the current transaction is part of Reports and associates its component data with Reports.

C1 can call C2 which relates to a requested report. C2 could include a class method pair such as ServletA2.RequestedReport which processes a user input of a requested report. This processing could include checking the format of the request for instance and if the format is valid making a call to a component C5 which receives the report request. For instance this call may be a cross process cross thread transaction or cross subsystem call. If the format is invalid the control flow returns to C1 which may call C3 to display an error message for instance.

An example format of a class method pair for C5 is ServletA3.ReceiveReportRequest. C5 can call C6 to access a database1 and or C7 to access a database2 such as based on the type of the report request. For example C6 and C7 can each include a JDBC driver call which invokes one or more SQL statements. The control flow then returns to C5 then to C2 and then to C1. Subsequently C1 calls C3 which relates to providing a display such as a display of the requested report based on data retrieved from the databases. The control flow then returns to C1.

Also under the root a component C4 can be provided which displays a quotes screen on a user interface UI to receive a user s input regarding a desired quote. C1 can call C2 which relates to a requested report. C2 can process the user input by checking the format of the request for instance and if the format is valid obtaining the requested quote such as from a data source which is local to subsystem1. If the format is invalid the control flow returns to C4 which may call C3 to display an error message for instance. The control flow then returns to C4. C4 can call C3 which relates to providing a display such as a display of the requested quote based on the data retrieved from the data source. C2 can also be called from C4.

Note that a component can continue executing after calling another component which begins executing in an asynchronous multi thread or multi process mode. Or a component can temporarily pause until the called component has finished executing in a synchronous single thread or single process mode. A component which is pausing can be considered to be in a wait interval while a component which is executing can be considered to be in an active executing mode. Also a component may be invoked more than once during a transaction.

In contrast a thread stack trace such as depicted in identifies invoked methods at a point in time without using instrumentation.

The transaction trace of involves components C1 C2 C5 and C6 represented by graph portions and respectively. C1 starts executing at t0 and ends or stops at t7. C2 which is called by C1 starts executing at t1 and ends at t6. C5 which is called by C2 starts executing at t2 and ends at t5. C6 which is called by C5 starts executing at t2 and ends at t4. The time increments are not necessarily equidistant.

The registers include a program counter pc which keeps track of where in the memory it should be executing instructions. The program counter identifies the next byte code to be executed. The frame register contains a pointer to the execution environment of the current method in the operand stack. The operand top optop register contains a pointer to the top of the operand stack and is used to evaluate arithmetic expressions. The variable vars register contains a pointer to local variables.

The operand stack supplies parameters to methods and operations and receives results back from them. All byte code instructions take operands from the stack operate on them and return results to the stack. The operand stack includes a stack frame of an executing method. The stack frame holds the state e.g. local variables and intermediate results of calculations for a particular invocation of a method. Specifically each JVM thread has a private JVM stack created at the same time as the thread. A JVM stack stores frames holds local variables and partial results and plays a part in method invocation and return. A frame is thus used to store data and partial results as well as to perform dynamic linking return values for methods and dispatch exceptions. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes whether that completion is normal or abrupt it throws an uncaught exception . Frames are allocated from the JVM stack of the thread creating the frame. Each frame has its own array of local variables its own operand stack and a reference to the runtime constant pool of the class of the current method.

The heap or memory allocation pool is garbage collected. The heap is the runtime data area from which memory for all class instances and arrays is allocated. The heap is created on virtual machine start up and heap storage for objects is reclaimed by an automatic storage management system known as a garbage collector. Specifically each program running in the JAVA runtime environment has a garbage collected heap assigned to it. Moreover each class in the heap has a constant pool associated with it. Because constants do not change they are usually created at compile time. Items in the constant pool encode all the names used by any method in a particular class. The class contains a count of how many constants exist and an offset that specifies where a particular listing of constants begins within the class description.

The method area stores byte code instructions that are associated with methods in the compiled code and a symbol table which the execution environment needs for dynamic linking Any debugging or additional information that might need to be associated with a method is stored in this area as well. The program counter always points to e.g. contains the address of some byte in the method area. The program counter is used to keep track of the thread of execution. After a byte code instruction has been executed the program counter will contain the address of the next instruction to execute.

The method area is shared among all JVM threads and stores per class structures such as the runtime constant pool field and method data and the code for methods and constructors including the special methods used in class and instance initialization and interface type initialization. The method area is created on virtual machine start up. A runtime constant pool is a per class or per interface runtime representation of the constant pool table in a class file. It contains several kinds of constants ranging from numeric literals known at compile time to method and field references that must be resolved at run time. Each runtime constant pool is allocated from the JVM s method area. The runtime constant pool for a class or interface is constructed when the class or interface is created by the JVM.

If the application byte code matches rules directives at a decision block the transformer adds probes in the form of tracer byte code. If the application byte code does not matches the rules at the decision block the transformer does not add instrumentation to the byte code. The transformer and the decision block may be considered to be part of a probe builder .

In this implementation the rules are a set of typically static rules that identify portions of the managed application which are to be instrumented. The rules are usually implemented when a class is defined in a virtual machine for the first time. A class can be loaded multiple times while being defined only once. For example there can be multiple class loaders loading the same class. Further components such as classes may be instrumented based on whether they are named a certain way whether they implement a certain interface whether they extend a certain subclass or super class and so forth. Such components are selected to be instrumented because it is believed they might provide performance data which is useful or otherwise interesting.

For instance a rule may indicate that all servlets should be instrumented since it is believed that at least some of the servlets may provide interesting data. In this case the rules may indicate that all components that are subclasses of the JAVA class HttpServlet should be instrumented. HttpServlet is an abstract class from which all servlets depend. However not all components can be instrumented and there is a tension in that over inclusive instrumentation results in excessive overhead costs and possibly impairing the operation of the application while under inclusive instrumentation results in the omission of important performance data.

Moreover the CLR is an implementation of a Common Language Infrastructure CLI which provides a language neutral platform for application development and execution including functions for exception handling garbage collection security and interoperability. The CLI includes the core class libraries Common Type System and the Common Intermediate Language CIL . As with JAVA byte code CIL is another example of intermediate byte code. JAVA and .NET provide example implementations only as other implementations are possible.

Here the process may be implemented by an agent in one possible approach. In one possible scenario some process in the .NET framework references a class by name and the CLR finds the class shows it to a transformer if any and uses the resultant CIL. In particular if the class matches rules at a decision block instrumentation is added. If the class does not match the rules at the decision block instrumentation is not added. The transformer and the decision block may be considered to be part of a probe builder .

In the example of a method MA is invoked followed by a method MB which is invoked by MA. This sequence can be represented by a notation MA MB. A method MC is invoked by MB then a method MD is invoked by MB. The arrow is a pointer indicating that MD is called by MB. Other information such as parameters which are passed between the methods can also be included in the stack. A method ME is invoked by MD.

In the example of MB is invoked followed by MD which is invoked by MB. A method MF is then invoked by MD.

In the example of MA is invoked followed by MB which is invoked by MA. MD is then invoked by MB and ME is invoked by MD. These are simplifications of stack data. A more specific example if provided further below.

Step involves identifying a hierarchy of invoked methods such as depicted in . Step includes identifying attributes of the invoked methods. In some cases an attribute can be determined from the sampling of the stack. In other case an attribute can be determined by sending a request to the agent with the method name. For example given the class of a method the agent can look up an attribute such as one or more superclasses of the method classes from which the class of the method inherits . Step includes generating a data structure representing the application as a hierarchy of the attributes based on the hierarchy of the invoked methods. See the example data structure of . Step includes comparing the data structure representing the application to one or more reference data structures e.g. in a library. Step identifies one or more matches.

See the example reference data structures of . In this case there is a match between the data structure and the reference data structures and but not . For example nodes and of data structure match nodes and of data structure . Also nodes and of data structure match nodes and of data structure . Nodes and of data structure do not match nodes and of data structure due to the intermediate attribute A2 in node . Thus a match can involve a match between a subset fewer than all of the nodes of the data structure and all nodes of a reference data structure.

Step determines whether instrumentation is warranted and a type of instrumentation for invoked methods whose attributes were involved in the match. For example in the match between nodes and of data structure and nodes and of data structure the attributes A1 and A2 in the sequence A1 A2 are involved in the match. The invoked methods whose attributes were involved in the match are therefore MB and MD from . Thus a determination is made as to whether instrumentation is warranted for these methods. In one approach determining whether instrumentation is warranted is based on whether the match occurs with at least a minimum frequency. For example does the sequence A1 A2 occur in 10 or more of the samples In another approach the attribute is a class or superclass of the method and determining whether instrumentation is warranted is based on usage of the class and an estimate of an overhead cost of instrumentation based on the usage. For example estimating the usage of the class can involve determining a number of occurrences of the class of the number of occurrences of a superclass. Or the value can be based on the frequency with which the class appears. A CPU cost can be associated with these values and the cost compared to a threshold. In one approach if the cost exceeds a threshold the method is not instrumented. If the cost does not exceed the threshold the method is instrumented.

In this example the detected hierarchy of the application of has a sequence of two attributes A1 and A2 which match the reference data structure of . Further two invoked methods MB and MD are associated with the two attributes of the detected hierarchy. The match involves one attribute A1 of the detected hierarchy associated with one of the invoked methods MB and another attribute A2 of the detected hierarchy associated with another of the invoked methods MD . Generally the pattern matching can involve multiple factors and can take into account the relationship among each of the monitored components methods their parameters and the execution flow.

Step also determined a type of instrumentation to add when instrumentation is warranted. The type of instrumentation or a method can be based on the associated attribute. For example for a method associated with an HTTP request it may be desirable for the instrumentation to capture parameters that are passed with the request. In other cases parameters may not be passed or may not be of interest so that the instrumentation does not capture such parameters. Instrumentation can be added on every possible component method in a system. Example components include a Struts Action an instance of a subclass of an Action class which implements a portion of a Web application such as by validating a user name and password or performing a computation a EJB method and a SQL Structured Query Language statement execution. Different types of instrumentation could obtain timing information error detection information exceptions a count of invocations sampling of transactional data and reading of object states.

Step involves obtaining a log of invoked methods. This log can contain information about the components of an application their sequence of execution and a map of data per component. In one possible implementation the log is obtained by sampling the stack of the application to obtain thread stack traces. Step involves filtering the log to remove irrelevant or redundant information and providing the filtered log to the server. Step involves receiving a request from the server to identify an attribute of a method or to identify one or more attributes of one or more methods. Step identifies the attribute. Step involves providing the attribute to the server. Step involves receiving a request from the server to instrument the invoked method with a specified type of instrumentation. Step involves instrumenting the invoked method with the specified type of instrumentation. See e.g. .

In further detail of an example implementation the sampling of the stack can occur while the application is being exercised. In one approach the application is exercised in its normal production environment. In another approach a tool such as a JMeter script is used. JMeter is an APACHE R product that can be used as a load testing tool for analyzing and measuring the performance of a variety of services including web applications. Samples of the thread stacks can be retrieved using the JMX console for instance on a sample interval e.g. every 1 msec. The JMX management beans allow retrieval of the thread stack programmatically. JMX refers to JAVA Management Extensions JMX Technology. The JMX Console enables one to monitor and manage services on a server.

These samples can be used e.g. to detect the way the classes of the applications call each other vertically through the stack. The sampling also produces a limited amount of horizontal information through time as the application is running.

The process of gathering these thread stacks is very effective and can be implemented efficiently by the JVM for instance. The agent can filter and discard the thread stacks that are deemed irrelevant or duplicate and send the relevant stacks to the manager server where the stacks are layered or superimposed and analyzed for pattern detection. Regarding the filtering typically many of the stack traces will be repetitions of the same pattern and usually end in the thread waiting on the object monitor. These stacks may be less relevant for instrumentation and can be discarded to improve performance. An example filtering algorithm would compare the stacks with a known base of non interesting stack traces and discard the stack traces that are not interesting. Regarding the layering this can involve grouping together the parts of the stacks that are common to the threads such as discussed in connection with the grouping of the data structures of and L to provide the data structure of . This allows common patterns to be detected. As more and more of these common stack calls are detected the common calls of the application are detected. For example even if we were not to know that the application is using J2EE and servlets we would quickly detect that the calls of the application all get channeled through the HttpServlet.service method. By superimposing the stack traces over a given amount of time the relevant execution patterns of the application are statistically bound to appear.

The server side may gather information on the hierarchy of the classes of the application that are detected in the stack traces. In some cases the server may ask the agent for this information. The agent can access the class hierarchy using the Instrumentation API that it has available. For example the java.lang.instrument package provides a JAVA programming language API for tools to instrument JAVA programming language applications. This API can be used to obtain the class hierarchy. As an example consider a hierarchy with class1 at the top class2 at the second level and class 3 at the third level. A method may be identified as being in class3 from the thread stack trace. The API can then be used to determine that class2 and class1 are superclasses classes at a higher level in the class hierarchy of class3. The server can communicate a request to the agent to provide the class hierarchy of class3.

Ultimately the patterns detected in the class calls are matched against a set of pre defined patterns available in a library that is configured and extended when appropriate. At this point it becomes a business decision regarding what classes to instrument. Through this process we also may gather an estimate of the usage of the classes so that an estimate of the instrumentation overhead can be determined. The usage may be indicated by how frequently the class appears in the samples. We can detect that the application uses one or more specific patterns for example a pattern in which some classes are called all the time or a pattern in which some other classes are often involved in error management because we can create a representation of the code calls of the application.

In one approach the stack is sampled by obtaining a thread dump e.g. a list of all the threads of the application that are currently active. In the case of JAVA this can be the threads that are currently active in the JVM. The specific commands used for sampling are based on the operating system on which the application runs. For Unix Mac OSX and Linux in the case of JAVA a thread dump is obtained by sending a QUIT signal to the JAVA process to tell it to output a thread dump to standard output e.g. a text file or screen display . The following command can be used kill QUIT where the pid is the process identifier. Another approach is to use the jstack tool which prints thread dumps to the command line console using this command jstack . Repeated thread dumps can be output to a file by using the console output redirect append directive jstack threaddumps.log.

The thread dump can provide various types of information for each thread such as a thread name which is associated with a Thread Id tid a thread type e.g. whether a thread is running in the background a thread priority a native Thread ID nid a Thread State and detail such as a current blocking condition and information on heap memory utilization. Another source of information from the thread dump is the thread stack trace. The thread stack trace can be provided as a textual output of lines which are read in an order starting from the bottom. For example consider this partial output 

 7 org.jboss.ws.core.jaxws.client.ServiceObjectFactoryJAXWS.getObjectInstance ServiceObjectFactoryJAXWS.java 

At line 1 Thread.run begins the execution of code in the current thread. This method is part of the java.lang package which provides classes that are fundamental to the design of the JAVA programming language.

Line 2 indicates that the originator of the thread is a JBoss APACHE Tomcat Web container. This example uses a JBoss 5 production environment. JBoss or JavaBeans Open Source Software Application Server is an application server that implements the JAVA Platform Enterprise Edition JAVA EE . A web container also known as a servlet container is the component of a web server that interacts with JAVA servlets. A web container manages the lifecycle of servlets mapping a URL to a particular servlet and ensuring that the URL requester has the correct access rights. APACHE R Tomcat is an open source web container. Class JIoEndpoint handles incoming TCP connections and implements a simple server model where one listener thread accepts on a socket and creates a new worker thread for each incoming connection.

Lines 3 5 indicate that a call to a web service is being made. Class javax.servlet.http.HttpServlet is an abstract class used for writing HTTP servlets and handling the HTTP protocol. In line 4 AbstractEndPointServlet extends HttpServlet and is a cross stack web service endpoint servlet. In line 5 class RequestHandlerImpl implements RequestHandler with mapping of snmp get set requests to JMX mbean attribute gets sets. Line 6 indicates that JBoss requires a Bean from its EJB3 pool. Line 7 indicates that JBoss attempts to get a JAXWS Service instance from its pool. ServiceObjectFactoryJAXWS reconstructs a javax.xml.ws.Service for a given Web Services Description Language WSDL when the web service client does a JAVA Naming and Directory Interface JNDI lookup . Lines 8 and 9 indicate that JBoss creates a new JAXWS Service instance. Line 10 and 11 indicate that the creation of the new JAXWS instance triggers an XML parsing operation. DOMParser can parse an XML or HTML source stored in a string into a Document Object Model DOM Document. Class XmlParser is a helper class for parsing XML into a tree of node instances.

Thus each line of the thread stack trace identifies methods which are invoked and a sequence in which they are invoked to allow a data structure of a hierarchy of invoked methods to be created such as in and L. Further the attributes of the invoked methods can be obtain from the thread stack trace and or from another source such as an agent to provide a data structure of a detected hierarchy of attributes such as in .

The attributes can represent any characteristics of the code. For example the attributes of invoked methods can indicate whether the invoked methods are at least one of an HTTP servlet an EJB a method in a class which is an EJB stub a method executing asynchronously a method connected with parameters of an HTTP request a factory method a design pattern that lets a class defer instantiation to subclasses a queue interface or a singleton the singleton pattern is a design pattern that restricts the instantiation of a class to one object . Generally applications are built using patterns of attributes. An example pattern involves an HTTP servlet that calls an EJB. The reference patterns can be developed to specify certain patterns of attributes of an application which are of interest.

Another example pattern involves a queuing mechanism inside an application. For example assume a request component of a Thread A is stored in any container. A Thread B iterates on that container and processes the elements according to the FIFO first in first out principle. After the processing of Thread B Thread A gets notified with a processing result. In this pattern we have the importance of the Thread name ownership . A container on Thread B can be presented by using the Java Collections framework JCF a set of classes and interfaces that implement commonly reusable collection data structures . An object with the identical request attributes shared by both threads matches the pattern.

As another example calls of an application that are channeled through the HttpServlet.service method line 3 of the above thread stack trace indicate that the application uses J2EE and servlets.

Moreover new reference patterns can be configured e.g. generated or extended based on results which are obtained from the sampling of the stack. For example an attribute pattern which is frequently detected can be used as a reference pattern.

Generally the techniques provided herein can encompass any type of design pattern in software engineering. Design patterns are re usable elements of object oriented software design. Various type of design patterns include creational structural and behavioral design patterns

Creational patterns are used to create objects for the designer rather than having the designer instantiate objects directly. This gives a program more flexibility in deciding which objects need to be created for a given case. Example creational patterns include the following. The Abstract Factory pattern groups object factories that have a common theme. The Builder pattern constructs complex objects by separating construction and representation. The Factory Method pattern creates objects without specifying the exact class to create. The Prototype pattern creates objects by cloning an existing object. The Singleton pattern restricts object creation for a class to only one instance.

Structural patterns concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality. Example structural patterns include the following. The Adapter pattern allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class. The Bridge pattern decouples an abstraction from its implementation so that the two can vary independently. The Composite pattern composes zero or more similar objects so that they can be manipulated as one object. The Decorator pattern dynamically adds overrides behavior in an existing method of an object. The Facade pattern provides a simplified interface to a large body of code. The Flyweight pattern reduces the cost of creating and manipulating a large number of similar objects. The Proxy pattern provides a placeholder for another object to control access reduce cost and reduce complexity.

Behavioral patterns are mainly concerned with communication between objects. Example behavioral patterns include the following. The Chain of responsibility pattern delegates commands to a chain of processing objects. The Command pattern creates objects which encapsulate actions and parameters. The Interpreter pattern implements a specialized language. The Iterator pattern accesses the elements of an object sequentially without exposing its underlying representation. The Mediator pattern allows loose coupling between classes by being the only class that has detailed knowledge of their methods. The Memento pattern provides the ability to restore an object to its previous state undo . The Observer pattern is a publish subscribe pattern which allows a number of observer objects to see an event. The State pattern allows an object to alter its behavior when its internal state changes. The Strategy pattern allows one of a family of algorithms to be selected on the fly at runtime. The Template method pattern defines the skeleton of an algorithm as an abstract class allowing its subclasses to provide concrete behavior. The Visitor pattern separates an algorithm from an object structure by moving the hierarchy of methods into one object.

The functionality described herein may be implemented using hardware software or a combination of both hardware and software. For software one or more non transitory tangible processor readable storage devices or apparatuses having processor readable code embodied thereon for programming one or more processors may be used. The non transitory tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media removable and non removable media.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various aspects of the present disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular aspects only and is not intended to be limiting of the disclosure. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of any means or step plus function elements in the claims below are intended to include any disclosed structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present disclosure has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the disclosure in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the disclosure. The aspects of the disclosure herein were chosen and described in order to best explain the principles of the disclosure and the practical application and to enable others of ordinary skill in the art to understand the disclosure with various modifications as are suited to the particular use contemplated.

