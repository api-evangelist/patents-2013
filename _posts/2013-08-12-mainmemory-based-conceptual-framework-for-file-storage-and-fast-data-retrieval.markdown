---

title: Main-memory based conceptual framework for file storage and fast data retrieval
abstract: A conceptual framework is built including a conceptual hierarchy, a containment hierarchy, and concept relationships. The concepts created in the conceptual framework are associated with resources located on the local file system. The resources are stored in the conceptual framework that is stored in the main memory of the system. Thus, search capabilities based on complex multivariate queries involving relationships and multiple conditions between concepts are provided. The conceptual framework is based on an in-memory engine that enables superfast resource access, reduced file storage redundancy, reduced updating errors, increased consistency, greater data integrity and independence from application level programs, query based concept and file access.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483479&OS=09483479&RS=09483479
owner: SAP SE
number: 09483479
owner_city: Walldorf
owner_country: DE
publication_date: 20130812
---
The field generally relates to the software arts and more specifically to methods and systems including main memory based conceptual framework for file storage and fast data retrieval.

Many file systems are organized hierarchically and the data files stored on the file systems are traditionally organized hierarchically as well. A hierarchy is an arrangement of entities in which the entities are represented as being above below or at the same level one to another. The hierarchy is simply an ordered set or an acyclic graph. The entities in the hierarchy can be linked directly or indirectly vertically or horizontally. In a simple scenario when a user wants to reach and open a given file the user can type a direct path to the file in a file system browser or search the file by some attributes as search criteria. In this case the search query may become too complex by including multiple search criteria. The system may take long time to display the needed files and data where multivariate queries are submitted involving complex relationships between file metadata and their associated semantics. Traditional file system browsers do not support fast searching of files with complex queries including multiple search criteria.

Embodiments of techniques for methods and systems including main memory based conceptual framework for file storage and fast data retrieval are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In an in memory database all relevant data is kept in the main memory. Disk based index structures for example are not needed any more for an in memory database. Disk storage is still needed to make changes durable but the required disk write operations happen asynchronously in the background. In addition disk storage may be used to store aged data that is not needed any more during normal operations. One of the features of the in memory database is provision of fast access when querying data.

In various embodiments a conceptual framework for organizing files based on a conceptual hierarchy a containment hierarchy and concept relationships is presented. The conceptual framework is modeled and created relationally and the physical files pertaining to their corresponding concepts may be stored in an in memory database. Thus fast access to the stored concepts is available. Methods and systems are provided for manually mapping an existing hierarchical file storage system to the generated conceptual framework to provide the traditionally existing hierarchical file storage system along with the conceptual framework based file storage system. In this way the user can speedily get needed files and data by submitting complex multivariate queries involving complex relationships between files metadata and their associated semantics.

The next level of the hierarchy of the conceptual framework includes concept concept and concept. They represent objects that may be of type concept or class concept . These concepts inherit concept or have type of super class concept. Concept is a container concept of concept concept and concept. The bottom level of the hierarchy of the conceptual framework includes instance concept concept instance concept concept and concept. All concepts in the conceptual framework are semantically inherited and nested thus forming a logical connection. The conceptual framework enables a particular concept located at any level to be queried efficiently by its parent concept or forefather concepts. In this way it is possible to drill down the hierarchy to the specific concept searched for as given in the query. Similarly the containment hierarchy of the conceptual framework can be used to get the nested hierarchical relationship between the container concept and the subsumed concept.

Further a role concept defines the role played by the target concept on the source concept thereby giving relationship predicate. For example John owns a car statement has a concept John and a concept car where owns is a role played by John on car . In this example the role is also modeled as a concept. The relationship also has a set of attributes that are both default and user defined and is of the form of key value pairs. An instance of the relationship may be defined. The purpose of having the conceptual and the containment hierarchy as part of the conceptual framework is to associate a semantic meaning to each and every file and folder in an existing hierarchical file storage system. In the process of modeling the conceptual framework two concepts can have the same name but each of them must have a different meaning in a different context. For example Java is a programming language as well as an island in Indonesia. Both the Java concepts have their own conceptual and containment parent to define whether the one queried is the programming language or the island. An important rule is that no two or more concepts can have same conceptual and containment hierarchy. This rule should be followed while adding a new concept or updating an existing concept in the conceptual framework.

Table represents a data model element that is used to create a concept in the conceptual framework . A concept can be defined with characteristics such as a unique identifier UUID a name a description and so on. Further a concept can be defined as a parent concept of a hierarchy with its ID e.g. is a concept uuid and also to which parent concept the current concept belongs by specifying the ID of the parent concept e.g. is in concept uuid . In addition the user creating or updating the concept can be defined by a user s ID. The time the concept is created and the time it was updated can also be defined by timestamps. One of the attributes for a concept from the set of default attributes is is enabled a Boolean attribute that specifies whether a concept is enabled. Similarly each concept file relationship type and relationship instance has a set of default and user defined attributes.

Table represents a data model element that is used to create an attribute for an object of type concept in the conceptual framework . The attribute may include a unique ID of the attribute the ID of the concept for which the attribute is modeled a description key value information the user creating or updating the attribute the time the attribute is created or updated by providing timestamps. Also the attribute may be modeled to specify if it is enabled or not by the is enabled property.

Table represents a data model element that is used to define the role type between two different concepts. For example a role relationship between a student and a professor can be defined where student and professor are both defined as concepts. In this relationship the professor plays the role of a teacher. The role type between two concepts may be defined with a unique ID the ID of the player concept that plays the role the ID of the role concept a role concept defines the role type the ID of the context of the role specified by the project uuid property. The context of the role may also be defined as a concept. Other information may also be included such as a description the user creating or updating the relationship the time the relationship is created or updated by providing timestamps. Also the role type may be modeled to specify if it is enabled or not by the is enabled property. Once the role type is defined role type attributes can be defined using table of .

Once the role type is defined a role instance of that type is created. Table represents a data model element that is used to define a role instance. The role instance may include a unique ID the ID of the player concept the ID of the role type defined via table . Other information may also be included such as a description the user creating or updating the relationship instance the time the relationship instance is created or updated by providing timestamps. Also the role instance may be modeled to specify if it is enabled or not by the is enabled property. Once the role instance is defined role instance attributes can be defined using table .

In this way every object in a file system can be modeled as a concept and defined as a role concept in a hierarchy. Further two or more concepts can be related with each other by specifying relationship types associations descriptions and so on. Table represents a data model element that is used to define concept options. The options that can be defined for a concept include a unique ID of the option name of the option ID of the concept a description the user creating or updating the attribute the time the attribute is created or updated by providing timestamps. Also the option may specify if it is enabled or not by the is enabled property.

Table of represents a data model element that is used to define concept option mapper. A concept option mapper describes the mapping between the option and the concept. The concept option mapper can be defined with a unique ID the ID of the concept the ID of the concept option a value of the concept option a description. Further the user can specify the time the file was last modified last accessed the time the file was created its size and so on. Once the mapping between the option and the concept is performed a complex query on the physical file is possible using the information specified for the file as search criteria.

Table represents a data model element that is used to define an association type between two different concepts. The association type between a source concept and a target concept may be defined with a unique ID the ID of the source concept the ID of the target concept the ID of the role concept. Other information may also be included such as a description the user creating or updating the association the time the relationship is created or updated by providing timestamps. Also the association type may be modeled to specify if it is enabled or not by the is enabled property. Once the association type is defined association type attributes can be defined using table .

Once the association is defined an association instance of that type is created. Table represents a data model element that is used to define an association instance. The association instance may include a unique ID the ID of the source concept the ID of the target concept the ID of the association type defined via table . Other information may also be included such as a description the user creating or updating the association instance the time the association instance is created or updated by providing timestamps. Also the association instance may be modeled to specify if it is enabled or not by the is enabled property. Once the association instance is defined association instance attributes can be defined using table .

Table represents a data model element that is used to import concepts into the conceptual framework. The imported concept may be defined with a unique ID the ID of the concept the ID of the container concept that will accommodate the imported concept the ID of the imported concept. Other information may also be included such as a description the user creating or updating the imported concept the time the imported concept is created or updated by providing timestamps. Also the imported concept may be modeled to specify if it is enabled or not by the is enabled property.

In the conceptual framework the data model is created in an in memory database that uses shared memory to store the concepts and the physical file s associated with a particular concept. Alternatively the files can be stored on hard disks and a pointer to the files can be stored in the in memory database instead of the actual files. In various embodiments the users may be provided with an application layer and via some application programming interfaces APIs to create and extend the conceptual framework. The repository containing the conceptual framework the database tables and other schema metadata created in the in memory database can be implemented by a distributed database physically located on a number of networked remote computers in one or more locations. In this scenario each of the remote computers has its respective memory space that is devoted to implementing the conceptual framework and the distributed in memory database provides location transparency fragmentation transparency and replication transparency.

If the result of the detection is negative the process continues at block . At block the user is prompted to select a container concept by displaying a list of all compositional concepts in the system. At block a selection of a container concept is received. At block the user is prompted to select if the concept the user is creating is an instance of a concept. At block a decision is performed. If the concept is an instance concept the process continues at block otherwise at block . At block a selection of an instance concept option is received. At block a selection of a non instance concept option is received. Both options continue at block .

At block the user is prompted to select if the concept can be compositional. This means that the concept can be a container concept. At block a decision is performed. If the concept is a compositional concept the process continues at block otherwise at block . At block a selection of is compositional option is received. At block a selection of is not compositional option is received. Both options continue at block . At block the new concept is created successfully in the conceptual framework. In various embodiments already existing concepts can be imported into the conceptual framework. If a concept is not present in the containment hierarchy of the conceptual framework it can be imported into a currently selected concept from the user.

At block the user is prompted to enter an attribute value for the selected attribute key. At block the attribute value is received. Finally at block the new attribute is added successfully for the currently selected concept. In various embodiments the application for creating the conceptual framework enables a user to modify concept attributes by editing the attribute key or value or both and by deleting the attribute. It should be noted that if the concept attribute is inherited by other concepts it may not be deleted. After the concept attribute is modified the user confirms the change and the concept attribute is updated in the system.

At block the user is prompted to select a role type concept from a list of role. The role type defines the relationship the role between the source concept and the target concept. At block a selection of a role type concept is received. This is a concept of type role . At block it is checked if the role for the concept is a duplicate. If so the found duplicate association s is displayed at block and the user is back to select a different role type concept at block . Otherwise the process continues at block . At block a description for the association is entered and received. Then the new association type is added for the selected concept at block . In addition one or more attributes with key value information can be added for a given association type concept.

At block the user is provided with a list of instance concepts of type of participating target concept in selected association type. Then a selection of an instance concept as target type concept is received at block . At block it is checked if the association type the source instance concept and the target instance concept are duplicates. If so the process is back at block . Otherwise the process continues at block . At block association instance description is entered and received. Then the new association instance is created in the conceptual framework at block .

Further the user may want to add one or more attributes for the association instance at block . Then the process continues at . Otherwise the process stops. At block an attribute key for the association instance is entered and received. At block it is checked if the attribute key is a duplicate. If so the process is returned at block to enter another attribute key for the association instance. At block it is checked if the attribute key is present in the association type. This is needed because the new attribute has to be checked against the attributed inherited from the selected parent association type relationship. If it is already inherited there is no need to create it again. If the attribute key is present in the association type the process is again returned at block to enter another attribute key for the association instance. Otherwise the process continues at block . At block the user is prompted to enter an attribute value for the attribute key for the association instance. At block the attribute value is received. The attribute for the association instance is added at block . If the user wants to add more attributes at block the process is returned at block .

At block the user is prompted to enter a path to the resource on the local system. At block the local resource path is received. At block a concept with a unique identifier as a name is created. At block a selection of a super class concept type is received. For example file super class concept this is a super class concept of type file . At block the super class concept type is marked as instance concept. At block a selection of a container concept for the instance is received. For example the container concept for a concept of type file may be a container concept of type system . At block as an attribute is added for the local resource path. At block a set of resource level attributes are automatically added to the resource concept including but not limited to file properties and access permissions.

Further in various embodiments one or more concept file role instances can be created. Initially the user selects a concept. Then the user is provided with a list of role types where the file concept is playing a role defined by the respective role type. A new role instance is added in the selected concept s family by selecting the appropriate file type instance. This is further described in . The user may add one or more role instance level attributes.

Further in various embodiments one or more concept file association instances can be created. Initially the user selects a concept. Then the user is provided with a list of association types where the file concept is playing a role defined by the respective association type. A new association instance is added in the selected concept s family by selecting the appropriate file type instance. This is further described in . The user may add one or more association instance level attributes.

At block an instance of the concept is created. One or more attributes can be added for the concept instance at block . Each attribute is defined with a key and a value. An attribute can be modified by editing or deleting the key and or the value data at block . After a change in the attribute is performed the user has to confirm the change and then the attribute data is updated. At block a selection of a second concept as a target concept is received. At block a role type concept between the source concept and the target concept and between the source concept instance s and the target concept instance s is added to the conceptual framework. At block an association type between the source concept and the target concept and between their instances is added to the conceptual framework. The association type is based on a role type. The role type defines the type of the role the source concept is playing on the target concept. The association type defines the relationship between two concepts the source concept and the target concept. In various embodiments the role type concept is defined as a separate concept.

At block a resource of a local file system is associated with the created concept. A location of the resource is received. In some embodiments the resource may be located on a remote system. Thus the resource is imported in the local file system if the resource is initially located on a remote file system. The resource location is added as an attribute for the source concept. In this way the physical file is associated with the concept by adding the resource path as an attribute to the concept. Finally at block the source concept the target concept the role type the association type and the resource are stored in the main memory of the local system.

The processes described in are based on the data model presented in . Further these processes form the creating of the conceptual framework starting from creating a concept creating a role type creating an association between two concepts adding attributes and so no. Thus building the conceptual framework through a conceptual hierarchy a containment hierarchy and relationships between concepts and physical files. In various embodiments the conceptual framework provides a search algorithm that performs a recursive query on the parent concept to get a recursive querying set containing all the child concepts satisfying the given query conditions. Multiple recursive querying is fast due to the in memory database and thereby reducing the overall query response time.

The conceptual framework and the file data stored in the in memory database provides the following functions 1 fast searching of files concepts associations and relationships in both the conceptual hierarchy and the containment hierarchy 2 search operations based on complex multivariate queries involving relationships and multiple conditions between concepts 3 in memory database based framework and file storage enabling superfast access reduced file storage redundancy single instance of file but multiple associations reduced updating errors increased consistency greater data integrity and independence from application level programs query based concept and file access improved data security reduced storage costs and data retrieval costs and so on.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in detail.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

