---

title: Convergence analysis in multithreaded programs
abstract: A basic block within a thread program is characterized for convergence based on mapping the basic block to an indicator subnet within a corresponding Petri net generated to model the thread program. Each block within the thread program may be similarly characterized. Each corresponding Petri net is enumerated to generate a corresponding state space graph. If the state space graph includes an exit node with an odd execution count attribute, such as by Petri net coloring, then the corresponding basic block is divergent. The corresponding basic block is convergent otherwise. Using this characterization technique, a thread program compiler may advantageously identify all convergent blocks within a thread program and apply appropriate optimizations to the convergent blocks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134979&OS=09134979&RS=09134979
owner: NVIDIA Corporation
number: 09134979
owner_city: Santa Clara
owner_country: US
publication_date: 20130206
---
The invention relates generally to compiler systems and more specifically to convergence analysis in multithreaded programs.

Certain computer systems include a parallel processing subsystem that may be configured to concurrently execute plural program threads that are instantiated from a common program. Such systems are referred to in the art as having single instruction multiple thread SIMT parallelism. An application program written for execution in an SIMT model may include sequential C language programming statements and calls to a specialized application programming interface API used for configuring and managing parallel execution of program threads. A function within an SIMT application that is destined for concurrent execution on a parallel processing subsystem is referred to as a thread program or kernel. An instance of a thread program is referred to as a thread and a set of concurrently executing threads may be organized as a thread group. Each thread may follow a different execution path based on certain identifying index variables or computational results.

During the course of following different execution paths one set of threads may execute one branch of a conditional statement while another set of threads may execute a different branch of the same conditional statement. In such a scenario the two different sets of threads execute divergent paths that need to converge at some point later during execution. A synchronization barrier may be used as an explicit convergence point and may implicate a certain portion of a thread program as convergent. Other techniques are known in the art for detecting convergence based on certain ad hoc rules but a general technique for identifying all convergent basic blocks is not presently known in the art. Each basic block includes one entry point and one exit point in execution flow. A given basic block may be represented as a corresponding node in a control flow graph CFG .

Certain beneficial optimizations may be applied to convergent basic blocks. In one exemplary optimization a convergent basic block may have related data allocated to common storage for greater access efficiency. In another exemplary optimization a convergent basic block may be scheduled to run on a specific thread processor for greater execution efficiency. Identifying each convergent basic block generally represents an opportunity to better optimize a thread program. However as alluded to above thread program compilers are conventionally unable to fully detect all convergent basic blocks in a general thread program and are therefore unable to fully optimize certain thread programs undergoing compilation.

As the foregoing illustrates what is needed in the art is a technique for identifying convergent basic blocks in a thread program.

One embodiment of the present invention sets forth a computer implemented method for characterizing a thread program the method comprising selecting a basic block within a control flow graph corresponding to the thread program wherein the control flow graph includes one or more block nodes corresponding to basic blocks within the thread program generating a Petri net representation of the control flow graph that includes an indicator subnet corresponding to the selected basic block enumerating a state space graph from the Petri net representation wherein the state space graph includes a plurality of state nodes corresponding to a state enumeration of the Petri net representation and determining whether the basic block is convergent based on the state space graph.

Other embodiments of the present invention include without limitation a computer readable storage medium including instructions that when executed by a processing unit cause the processing unit to perform the techniques described herein as well as a computing device that includes a processing unit configured to perform the techniques described herein.

One advantage of the disclosed technique is that a thread program compiler is able to advantageously detect all convergent basic blocks within a thread program. This is in contrast to prior art solutions that are only able to detect certain subsets of convergent blocks. Thus by implementing the disclosed technique the execution of a thread program can be more fully optimized relative to prior art approaches.

In the following description numerous specific details are set forth to provide a more thorough understanding of the invention. However it will be apparent to one of skill in the art that the invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the invention.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. Certain embodiments may include two or more CPUs and two or more parallel processing systems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

In one embodiment a thread program is compiled for execution by parallel processing subsystem by a thread program compiler . The thread program compiler translates a source representation of the thread program into a compiled representation of the thread program. For example the source representation may comprise original source code such as source code written by a developer and the compiled representation may comprise an intermediate code easily translated for execution by parallel processing subsystem . The compiled representation may also comprise an executable thread program suitable for direct execution by parallel processing subsystem . Thread program compiler may be implemented within a driver module for the parallel processing subsystem that compiles the executable thread program or as an application level module that generates either the intermediate code or executable thread program.

In addition to generating the compiled representation of the thread program thread program compiler also performs convergence analysis described below in greater detail. In one embodiment a convergence analysis function performs convergence analysis which allows the thread program compiler to statically determine when threads within a basic block are known to be convergent or divergent. Such analysis is significant for both program correctness and performance. In particular thread program compiler may use uniform or scalar operations for thread invariant values when threads are known to be convergent. Uniform operations may include uniform loads scalar register accesses and scalar instructions. Convergence analysis may enable scalarization to factor out uniform work from single instruction multiple thread SIMT threads. The uniform work may then be advantageously assigned to shared scalar resources to improve utilization efficiency of resources within parallel processing subsystem . Persons skilled in the art will recognize that convergence analysis techniques described herein are broadly applicable to many different multi threaded system architectures including any processor system that provides or models multi threaded execution in combination with scalar resources.

One way of interpreting thread convergence in a basic block is that all or none of the threads within a given basic block will be collected at the barrier which represents a convergence point. On exemplary type of barrier implemented in the CUDA runtime from NVIDIA is a  syncthreads call which blocks all associated threads until all the threads execute the same  syncthreads call.

Basic block convergence analysis begins with thread program compiler identifying basic block boundaries within a thread program. Each basic block is then represented as a node within a control flow graph CFG . Each CFG node is annotated to reflect whether the corresponding basic block includes a synchronization barrier such as the  syncthreads call.

Persons skilled in the art will recognize that a PN constructed with two tokens in an entry basic block faithfully captures the complete dynamic behavior of a corresponding thread program executed by two threads. An initial marking of the entry basic block may include two tokens.

In general a CFG may be modeled as a corresponding PN. For CFG nodes having a synchronization barrier the mapping illustrated in may be applied in generating portions of the corresponding PN. For CFG nodes without a synchronization barrier the mapping illustrated in may be applied in generating remaining portions of the corresponding PN.

A state space graph of a PN such as the corresponding PN represents instantaneous state of the PN. A marking is associated with each node of the state space graph. The marking is a list of places and a token count for each place. In general a place may have an arbitrary number of tokens however embodiments of the present invention limit each place in the corresponding PN to two tokens. Each one of the two tokens is associated with one of two different threads. A state space graph marking of the form pi pk is used herein where pi and pk each indicate the presence of one token in the indicated place within the corresponding PN. For example a state space graph marking of p p on a particular node indicates place p and place p within the corresponding PN each have one token. The state space graph is therefore a state graph with nodes comprising all possible states of the PN and edges comprising all possible state transitions within the PN.

As shown state space graph includes an entry node and an exit node . Exit node is marked p p representing an instance in time when both of two executing threads have arrived at node p within CFG . Equivalently marking p p indicates that both of two possible tokens are in place p within the corresponding PN.

Indicator subnet introduces an input place p i an output place p o two indicator places q and q and two transitions t t . Input place p i and output place p o respectively indicate arrival at and departure from the basic block as executed by a thread. Indicator place q and indicator place q together track how many times modulo the basic block was traversed by two different threads during execution. Indicator place q indicates an odd number of traversals while indicator place q indicates an even number of traversals. At some instant in time if indicator place q has a marking of 1 then the basic block was traversed an odd number of times by the two different threads. In one embodiment indicator place q starts with an initial marking of 1 indicating the basic block was traversed zero times or an even number of times.

Markings that include por parise because node p of CFG was modified in a corresponding PN not shown to an include input  i place and output  o place as illustrated in . Markings that include por parise because node p of CFG includes a synchronization barrier and is mapped to include an input place and an output place as illustrated in . Entry node is marked p p to indicate both threads start in p of CFG .

Each node of state space graph is designated as being either a red node or green node. A red node is depicted herein using a hash fill while a green node does not include a hash fill. A green node indicates that indicator place q of the modified node p in the corresponding PN had a 1 marking just before the thread program reached a state for the green node. That is just before the thread program reached a state associated with the node the basic block associated with p had been executed an even number of times by both threads. Similarly a red node indicates that just before the thread program reached a state associated with the red node the basic block associated with p had been executed an odd number of times by both threads.

Exit node p has two different corresponding exit nodes in state space graph . Node is a red node while node is a green node. Both nodes and have marking p p indicating both of two different threads arrived at node p. However in the process node p was executed an odd number of times by one of the two different threads while node p was executed an even number of times by the other of two different threads. In other words the execution count of the basic block associated with node p is different for each of the two different threads indicating the basic block is not convergent.

As shown method begins in step where a convergence analysis function such as convergence analysis function within thread program compiler generates a control flow graph CFG from a thread program. The CFG may be generated for a thread program using any technically feasible technique. In alternative embodiments a function other than the convergence analysis function generates the CFG. The thread program may be specified as source code tokenized code an intermediate code or any other technically feasible representation. In step the convergence analysis function selects a basic block from the CFG. In step the convergence analysis function generates a modified Petri net PN for the CFG based on the selected basic block. The modified PN represents the selected basic block as an indicator subnet such as indicator net of . In one embodiment the modified PN represents basic blocks within the CFG other than the selected basic block according to mappings illustrated in or . In step the convergence analysis function generates a state space graph based on the modified PN.

If in step the state space graph includes a red exit node then the method proceeds to step where the convergence analysis function marks the selected basic block as divergent. Otherwise if the state space graph does not include a red exit node then the method proceeds to step where the convergence analysis function marks the selected basic block as convergent. Assessing whether the state space graph includes a red exit node may be implemented using any technically feasible technique such as performing a graph search or identifying the red exit node upon generating the state space graph.

If in step the convergence analysis function is done then the method terminates in step . Otherwise the method proceeds back to step previously described herein. In one embodiment the convergence analysis function is done after all basic blocks within the CFG have been selected and marked as either divergent or convergent.

In sum a technique for characterizing each basic block within a thread program as being either convergent or divergent is disclosed. The technique involves representing the thread program as a control flow graph having one or more basic blocks which are then individually analyzed for convergence. Analysis involves representing a selected basic block as an indicator subnet within a Petri net mapping of the control flow graph. State information for the Petri net is then enumerated to generate a state space graph corresponding to the selected basic block. If the state space graph includes a red exit node then the selected basic block is identified as divergent otherwise the selected basic block is identified a convergent.

One advantage of the disclosed technique is that a thread program compiler is able to advantageously detect all convergent basic blocks within a thread program. This is in contrast to prior art solutions that are only able to detect certain subsets of convergent blocks. Thus by implementing the disclosed technique the execution of a thread program can be more fully optimized relative to prior art approaches.

While the foregoing is directed to embodiments of the invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the invention.

