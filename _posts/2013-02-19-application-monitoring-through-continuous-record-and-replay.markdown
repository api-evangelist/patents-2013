---

title: Application monitoring through continuous record and replay
abstract: A method, system, and computer-readable storage medium for application monitoring through continuous record and replay are described herein. The method includes continuously recording execution traces including external non-deterministic input data for an application at a user device and analyzing the recorded execution traces to identify relevant execution traces for determining a behavior of the application. The method also includes reporting the relevant execution traces to a server, wherein the server is configured to replay the relevant execution traces to determine whether the behavior of the application is as expected.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09129058&OS=09129058&RS=09129058
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09129058
owner_city: Redmond
owner_country: US
publication_date: 20130219
---
Many multi user operating systems associate privileges with user accounts. When a user installs an application the application runs in the name of the user and inherits the user s ability to access the system resources. However modern browsers and device operating systems such as smartphone operating systems often treat applications as mutually untrusting potentially malicious principals. In most cases applications are isolated except for explicit inter process or inter application communication IPC channels. In addition applications can be unprivileged by default requiring user permission for additional privileges. In other words permission to use devices and access user private data through system application programming interfaces APIs may be granted to individual applications by the user.

However modern permission systems may be undermined by the presence of malicious software within applications. Such malicious software may compromise users privacy or violate platform providers security policies. Current approaches focus on preventing malicious applications from reaching end users through manual review of each application that is added to the marketplace. However this process is costly and time consuming. Moreover although approaches exist for monitoring applications in the wild such as event logging and crash reports or online taint flow analysis these methods are limited by either the small quantity of data collected or the high performance overhead on the end user.

The following presents a simplified summary of the innovation in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key nor critical elements of the claimed subject matter nor delineate the scope of the subject innovation. Its sole purpose is to present some concepts of the claimed subject matter in a simplified form as a prelude to the more detailed description that is presented later.

An embodiment provides a method for application monitoring through continuous record and replay. The method includes continuously recording execution traces including external non deterministic input data for an application at a user device and analyzing the recorded execution traces to identify relevant execution traces for determining a behavior of the application. The method also includes reporting the relevant execution traces to a server wherein the server is configured to replay the relevant execution traces to determine whether the behavior of the application is as expected.

Another embodiment provides a system for application monitoring. The system includes a user device including an application configured to send execution traces including external non deterministic input data to an application programming interface API . The user device also includes a recording module configured to intercept the execution traces being sent to the API and continuously record the execution traces. The user device also includes a reporting module configured to analyze the recorded execution traces to identify relevant execution traces for determining a behavior of the application and report the relevant execution traces to a server. The system also includes the server including a replay module. The replay module is configured to store the relevant execution traces and replay the relevant execution traces to determine whether the behavior of the application is as expected.

In addition another embodiment provides a computer readable storage medium for storing computer readable instructions. The computer readable instructions provide the application monitoring system when executed by a processing device. The computer readable instructions include code configured to continuously record execution traces including external non deterministic input data for an application and analyze the recorded execution traces to identify relevant execution traces for analyzing a manner in which the application is behaving. The computer readable instructions also include code configured to report the relevant execution traces to a server wherein the server is configured to replay the relevant execution traces to determine whether the application is behaving in an authorized manner.

This Summary is provided to introduce a selection of concepts in a simplified form these concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The same numbers are used throughout the disclosure and figures to reference like components and features. Numbers in the 100 series refer to features originally found in numbers in the 200 series refer to features originally found in numbers in the 300 series refer to features originally found in and so on.

According to current technologies testing the software for applications or programs before releasing the applications does not provide for the identification of all the software bugs i.e. errors in the applications. Continuous monitoring of applications after installation is desirable for uncovering issues that were not found in pre release testing. Current techniques for monitoring deployed applications involve either checking logging and profiling events in a running application or collecting a memory snapshot after the application crashes. However such techniques result in the collection of only limited information regarding the application thus restricting the effectiveness of postmortem analysis. For example crash dumps provide limited value when bugs depend on specific configuration options or details of the user s environment and logged events can only capture exceptional conditions envisioned by the developers before release of the application.

Record and replay is a classic technique for storing and repeating a program s executions. Several current record and replay systems directly save all executed instructions. Such systems can support all kinds of applications without customization but have high performance overheads and large log sizes. Library based systems record the results of a set of functions and return the results instead of executing the functions during replay. While library based systems have more acceptable performance overheads and log sizes such systems cannot support a wide range of applications without customization because they depend on deep knowledge of thousands of function application programming interfaces APIs as well as some internal application semantics. Finally virtual machine based record and replay systems can support a wide range of applications with reasonable performance overhead. However replay for virtual machine based record and replay systems depends on the ability to access the virtual machine image rendering such systems unsuitable for reproducing users executions remotely.

Embodiments described herein set forth a method and system for application monitoring through implementation of a continuous record and replay procedure. The continuous record and replay procedure described herein allows for lightweight recording of sufficient client application information to reproduce full executions at a central server. Unlike library based solutions that attempt to understand and intercept thousands of internal APIs the continuous record and replay procedure treats an application as a virtual machine and focuses on the non deterministic external inputs that commonly drive an application s execution. While this technique may result in a less faithful replay than other techniques it is sufficient to reproduce a wide class of application errors at a modest cost.

The applications that are utilized according to embodiments described herein may include for example smartphone applications implemented on a mobile phone or Web applications implemented on a Web site among others. Moreover the applications may also include any types of computer programs which execute code that is related to any form of non deterministic data. Such a method and system may prevent applications from performing actions that are not desired by the user particularly in relation to non deterministic data.

As used herein the term non deterministic data refers to any data that is variable or inconstant such as data that is typed into the user device directly by the user multiple choice data or any type of user private data. For example non deterministic data may include a name a day of the week a day of the month a gender an age a phone number an email address a contact list a message inbox a message outbox a global positioning system GPS location a birthday or a credit card number among others. According to embodiments described herein external non deterministic input data is used for the continuous record and replay procedure. Such external non deterministic input data may include for example file data network data graphical user interface GUI data registry data or system information.

To implement the continuous record and replay procedure a number of execution traces for a particular application running on a user device may be recorded. As used herein an execution trace is a sequence of API calls and non deterministic data related to the API calls made by an application. Moreover in some embodiments execution traces may be recorded for a number of different applications running on any number of user devices.

In various embodiments the data recorded may include both the parameters passed to the API and the data returned from the API. Once the execution traces have been recorded they may be aggregated replayed and analyzed in order to determine whether the particular application is likely to be using the non deterministic data for malicious purposes. Moreover if it is determined that the application is likely to be malicious the application may be blocked from the marketplace or removed from the user devices or both.

As a preliminary matter some of the figures describe concepts in the context of one or more structural components variously referred to as functionality modules features elements etc. The various components shown in the figures can be implemented in any manner for example by software hardware e.g. discreet logic components etc. firmware and so on or any combination of these implementations. In one embodiment the various components may reflect the use of corresponding components in an actual implementation. In other embodiments any single component illustrated in the figures may be implemented by a number of actual components. The depiction of any two or more separate components in the figures may reflect different functions performed by a single actual component. discussed below provides details regarding one system that may be used to implement the functions shown in the figures.

Other figures describe the concepts in flowchart form. In this form certain operations are described as constituting distinct blocks performed in a certain order. Such implementations are exemplary and non limiting. Certain blocks described herein can be grouped together and performed in a single operation certain blocks can be broken apart into plural component blocks and certain blocks can be performed in an order that differs from that which is illustrated herein including a parallel manner of performing the blocks. The blocks shown in the flowcharts can be implemented by software hardware firmware manual processing and the like or any combination of these implementations. As used herein hardware may include computer systems discreet logic components such as application specific integrated circuits ASICs and the like as well as any combinations thereof.

As to terminology the phrase configured to encompasses any way that any kind of functionality can be constructed to perform an identified operation. The functionality can be configured to perform an operation using for instance software hardware firmware and the like or any combinations thereof.

The term logic encompasses any functionality for performing a task. For instance each operation illustrated in the flowcharts corresponds to logic for performing that operation. An operation can be performed using for instance software hardware firmware etc. or any combinations thereof.

As used herein terms component system client and the like are intended to refer to a computer related entity either hardware software e.g. in execution and or firmware or a combination thereof. For example a component can be a process running on a processor an object an executable a program a function a library a subroutine and or a computer or a combination of software and hardware.

By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and a component can be localized on one computer and or distributed between two or more computers. The term processor is generally understood to refer to a hardware component such as a processing unit of a computer system.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable storage device or media.

As used herein terms component search engine browser server and the like are intended to refer to a computer related entity either hardware software e.g. in execution and or firmware. For example a component can be a process running on a processor a processor an object an executable a program a function a library a subroutine and or a computer or a combination of software and hardware. By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and a component can be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable storage device or media.

Computer readable storage media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk and magnetic strips among others optical disks e.g. compact disk CD and digital versatile disk DVD among others smart cards and flash memory devices e.g. card stick and key drive among others . In contrast computer readable media generally i.e. not storage media may additionally include communication media such as transmission media for wireless signals and the like.

The user device may be any suitable type of computing device such as for example a mobile phone a tablet a desktop computer a laptop computer an electronic reader a television or a media player or any combinations thereof. Moreover the user device may be implemented within a server wherein the server may include for example a Web server or a cloud server. Furthermore the user device may be any computing system that utilizes any suitable type of application or program. For example the user device may be a system in a car or a home that is configured to perform any of a variety of different functions in response to execution traces generated through applications or programs.

The user device may include a processor that is adapted to execute stored instructions as well as a memory device that stores instructions that are executable by the processor . The processor may be a single core processor a multi core processor a computing cluster or any number of other configurations. The memory device can include random access memory RAM read only memory ROM flash memory or any other suitable memory systems. The stored instructions executed by the processor may implement a method for monitoring the applications running on the user device using execution traces for the applications according to a continuous record and replay procedure. The processor may be connected through a bus to any number of input and output devices.

The user device may include a human machine interface HMI . The HMI may connect the user device to any number of user interface devices such as a touchscreen a speaker or a pointing device among others. The user device may be linked through the bus to a display interface adapted to connect the user device to a display device . The display device may include a computer monitor or a display screen of a mobile device among others.

A network interface controller NIC may be included to connect the user device through the bus to the network . Through the network Web based applications may be downloaded to the user device and stored within a storage device of the user device . Alternatively the user device may access the Web based applications through a Web browser. Furthermore the user device may be communicably coupled to any number of other user devices through the network .

The storage device of the user device may include a hard drive an optical drive a thumbdrive an array of drives or any combinations thereof. The storage device may be adapted to store a continuous recording module and a reporting module . The continuous recording module may log execution traces including external non deterministic input data for any of the applications . The reporting module may analyze the recorded execution traces for each application to identify execution traces that may be useful for determining whether each application is behaving in an authorized manner. For example the reporting module may determine that the execution traces within a recorded log are useful if only new code is included within the log or if the application crashed during or shortly after generation of the execution traces. The reporting module may then send the identified execution traces for each application to the server via the network as discussed further below.

Furthermore the storage device may be adapted to store any number of application programming interfaces APIs for executing the applications on the user device . In various embodiments APIs corresponding to external non deterministic input data may be used for the continuous record and replay procedure described herein. For example APIs relating to file data network data GUI data registry data or system information corresponding to the user device may be used for the continuous record and replay procedure.

In various embodiments the server includes a storage device . The storage device of the server may include a hard drive an optical drive a thumbdrive an array of drives or any combinations thereof. The storage device may be adapted to store execution traces received from the reporting module of the user device .

In addition the storage device may include a replaying module . The replaying module may replay the received execution traces for each application to determine whether each application is behaving in an authorized manner. In some embodiments the replaying module stores application information corresponding to the behavior of each application and possible modifications that may improve the behavior of each application in the storage device . Furthermore the replaying module may determine modifications to any of the applications based on the behavior of each application . The server may then send information relating to the modifications to any of the applications to the user device via the network and the applications may be updated on the user device accordingly.

The block diagram of is not intended to indicate that the application monitoring system is to include all of the components shown in . Furthermore the application monitoring system may include any number of additional components not shown in depending on the details of the specific implementation.

The recording procedure executed by the continuous recording module may vary depending on the type of external non deterministic input data that is being recorded. For example external non deterministic input data relating to file data network data GUI data registry data and system information may be recorded by the continuous recording module according to different recording procedures as discussed further below.

In various embodiments the continuous recording module is configured to record execution traces relating to file data. In such embodiments copies of all files opened by the application may be made and included within the log. By making a copy at the beginning and then allowing the remaining file operations to go unintercepted very little to no overhead for individual reads and writes performed on the file may be incurred.

To copy files the APIs for file creation and opening may be intercepted. At recording time the name of the file being read or created may be noted. If the file exists on disk the entire file may be copied into the log. Then a unique identifier may be generated for the file and the mapping between the original file name and the saved copy may be saved. If the file does not exist or the file creation fails for some other reason the failure is logged so that the error code can be reproduced during replay. To replay the file name may be modified during the file create open call to redirect the access to the copy stored in the recorded log. If the same call failed during recording the stored error code may be returned without any redirection.

In some embodiments files opened in read only mode are not saved immediately. Instead the locations of the files may be noted and the copying of the files may be deferred until after the program has exited. For example a video player that opens a file as read only will not cause a copy to happen until the player exits. If the file is subsequently opened for writing or if an attempt is made to delete it the file may be copied immediately.

The log size may also be reduced by declining to copy well known files during the deferred copy. Many files opened by a program such as fonts system libraries and so on are available from other sources. A hash of a file may be checked once opened to ensure it is the same well known file present on the replay server. If the hashes match the file may not be included in the log. During replay these files may be directly obtained from the replay system.

In various embodiments the continuous recording module is configured to record execution traces relating to network data. Network record and replay for client applications may be challenging. Because no attempt to faithfully reproduce the ordering of threads during replay is made it is not possible to rely on ordering to determine which recorded data are associated with each connection. This problem may be especially challenging for asynchronous multithreaded applications that can open multiple connections to the same server and send multiple requests on each connection with an ordering that may change on each run.

For network applications such as web browsers communication typically follows a pattern of requests by the client and responses from the server occurring in pairs. When an application issues a request the request is saved and specific information e.g. a protocol about the request is extracted. For example in the case of HTTP the requested URI may be extracted. During replay this information may be used to identify the appropriate response for a client request even if the request occurs in a different order or on a different connection. For each pair of request and response events the IP and port information may also be saved.

To replay the recorded traffic a listening server may be created inside the application s process on the replay machine and all connections made by the application may be redirected to this server.

Aside from redirection an additional step may also be taken when replaying network traffic. After the connection is made the server may be informed of the intended IP and port for the connection using in band signaling. In other words the IP and port may be sent to the server on the same connection that will be used to transfer the content. Doing this notification in band allows for the avoidance of any synchronization issues when informing the server of the intended destination of the connection. The server then waits for requests from the application extracts protocol specific information and uses the protocol specific information in conjunction with the IP and port to identify the appropriate response. Using these strategies large multithreaded network applications may be replayed.

Network record and replay for server applications is generally more straightforward than for client applications. Since the sending of requests is controlled during replay it may be ensured that the requests sent on the same connection during recording are sent on the same connection and in the same order during replay.

Similar to replaying client applications a thread may be created inside the application s process on the replay machine. The thread may then be used to initiate connections to the server send requests and receive responses. This can also be done from different processes on the same or different machines in some cases.

When replaying server applications the time at which the client connections are to be initiated during replay may be determined. This may be accomplished by logging the time elapsed since the recording started when a new connection is accepted by the server application. During replay the connection is started only after the same amount of time has passed.

The continuous recording module may also be configured to record execution traces relating to GUI data. The approach to GUI data recording is similar to the approach for network data recording. During recording keyboard presses are intercepted as well as mouse movements and clicks. During replay a new thread is spawned within the application to send the recorded GUI events to the application.

As discussed above during network replay a response is sent after receiving a request. The difference in replaying GUI events is that there are no requests to trigger responses. The requests are changes in the visual state of the application that prompt users to respond with key strokes and mouse clicks. To solve this problem the timing of GUI events may be recorded. Then during replay the GUI events may be sent at the appropriate time.

In various embodiments the continuous recording module is also configured to record execution traces relating to registry data. The registry for an operating system may be a central key value store for configuration information. Because these configuration values can and usually do directly affect the behavior of applications queries to the registry may be recorded and replayed.

As with file and network data recording for registry data recording copies of the objects accessed by the program may be made during recording and calls to these saved objects may be redirected during replay. Also as with file data recording keys that were only read by the application are not copied until after the application has exited.

Furthermore the continuous recording module may be configured to record execution traces relating to system information. System information is often used by applications to drive their executions. For instance an application may decide whether a cached file is stale based on the current system time. To improve the fidelity of the replay procedure system information retrieved by the application may be recorded.

APIs for retrieving system information often have no input parameters that can be used to match a call at replay to a call at recording. In addition the order of API calls cannot simply be followed since threads may follow a different order between record and replay. In some embodiments two techniques may be used to solve this problem including call stack matching and thread matching. When intercepting a call to an API that retrieves some system information the call stack up may be recorded to a given number of frames as well as the value returned. During replay for an intercepted call to the same API the recorded value is returned from the call of the same call stack. Note that every recorded value may be used only once and in the same order as recorded. In addition to call stack matching thread matching may also be performed. A call intercepted on a thread during replay may only be matched with a call intercepted on the same thread during recording. Since thread pools are often used in large applications the launching order of threads cannot simply be used to label them. Instead the start address may be used to label a thread. For threads with the same start address their calls may be grouped to system information APIs together.

In some embodiments if random numbers differ between record and replay the application behavior may differ. During file replay a file name that contains a random number e.g. GUID may not match any recorded file names. Similarly a network request generated during replay may not match any recorded network request. For example some sites use random values in URLs related to advertising providers.

Other random number generation systems may use information that is not usually used to drive an application execution such as the value of a returned file handle. Furthermore imperfect replay fidelity will inevitably introduce noise and cause minor deviations in the execution during replay. This may affect random number generation as well.

To mitigate the effects of divergent random number generation a fuzzy matching scheme may be employed. For a file or network request in replay if the exact matched file name or network request cannot be found the edit distance between the replayed name and the recorded names may be computed and the one with the minimum edit distance may be chosen. Moreover during replay fidelity problems may be further mitigated by replaying a recorded trace multiple times. This may allow the system to explore different thread interleavings making it more likely that non deterministic information will be faithfully reproduced.

In various embodiments once the continuous recording module has recorded the execution traces relating to external non deterministic input data the continuous recording module may redirect the intercepted API calls back to the APIs as indicated by arrow . The APIs may then execute the API calls normally.

In addition the continuous recording module may send the recorded execution traces to the reporting module as indicated by arrow . The reporting module may analyze each execution trace to determine whether the execution trace is relevant to determining the behavior of the application .

In some embodiments in order to determine which execution traces are relevant the reporting module may measure the block coverage of each run and check if the recording executed any code not seen by other users. If the recording executed code not see by other uses the corresponding execution traces may be determined to be relevant to determining the behavior of the application .

Once the reporting module has determined the relevant execution traces the reporting module may send the relevant execution traces to the server as indicated by arrow . The server may store the execution traces within the storage device . Furthermore the reporting module may send the execution traces to the replaying module within the storage device of the server .

The replaying module may replay the relevant execution traces to determine whether the behavior of the application is as expected. If the behavior of the application is not as expected the application may be considered to be a malicious application that is behaving in an unauthorized manner. According to such embodiments modifications to the application that may cause the application to behave as expected may be identified. The identified modifications may be saved in the storage device of the server as the application information . In addition the application information may include information relating to the current behavior of the application .

In some embodiments the application information may be sent to the application running on the user device as indicated by arrow . The application information may be used to modify the application to correct software bugs or may be used to inform the user of the user device of possible issues with the application .

The process flow diagram of is not intended to indicate that the continuous record and replay procedure is to be implemented in the exact manner shown in . Rather the implementation of the continuous record and replay procedure shown in may be altered in a variety of different ways depending on the details of the specific implementation.

The method begins at block at which execution traces including external non deterministic input data for an application are continuously recorded at a user device. In various embodiments recording the execution traces includes redirecting an API call including the execution traces from an API to a recording module of the user device wherein the recording module is configured to log the execution traces relating to the API call and return the API call to the application to enable a normal execution of the API call.

At block the recorded execution traces are analyzed to identify relevant execution traces for determining a behavior of the application. In some embodiments this is accomplished by determining whether the application crashed during or after the recording of specific execution traces and if the application crashed during or after recording identifying the specific execution traces as relevant execution traces. In other embodiments this is accomplished by comparing the recorded execution traces to execution traces stored on the server and identifying only the recorded execution traces that are not already stored on the server as the relevant execution traces.

At block the relevant execution traces are reported to a server wherein the server is configured to replay the relevant execution traces to determine whether the behavior of the application is as expected. The server may be configured to replay the relevant execution traces by executing an API call using the relevant execution traces and utilizing a result of the API call to analyze the behavior of the application.

The application may be considered to be behaving as expected if the application is functioning in a manner that is authorized by a user or a service provider or both. Alternatively the application may be considered to not be behaving as expected if the application utilizes any non deterministic data in an unauthorized manner or for an unexpected purpose wherein the unexpected purpose may include any function that is not approved or authorized by a user or a service provider or both. For example an application that is behaving in an unexpected manner e.g. a malicious application may share non deterministic data with an unapproved third party in an unauthorized manner. Furthermore if the application is not behaving as expected modifications to the application may be determined and implemented in order to correct software bugs within the application.

The process flow diagram of is not intended to indicate that the blocks of the method are to be executed in any particular order or that all of the blocks are to be included in every case. Further any number of additional blocks may be included within the method depending on the details of the specific implementation. For example in some embodiments execution traces relating to external non deterministic input data for a number of applications are continuously recorded at the user device. The recorded execution traces may be analyzed to identify relevant execution traces for determining a behavior each application and the relevant execution traces may be reported to the server. The server may be configured to replay the relevant execution traces to determine whether the behavior of each application is as expected. Furthermore in some embodiments the server is configured to combine the relevant execution traces for the application received from the user device with relevant execution traces for the application received from a number of other user devices and replay the combined relevant execution traces to determine whether the application is behaving as expected.

Some of the software components discussed herein may be stored on the computer readable storage medium as indicated in . For example a continuous recording module may be configured to record a number of execution traces including external non deterministic input data for any number of applications from any number of user devices. In addition a reporting module may be configured to analyze the recorded execution traces to identify relevant execution traces for determining a behavior of each application. The reporting module may also be configured to report the relevant execution traces to a replaying module on a separate computer readable storage medium as discussed with respect to . Furthermore the computer readable storage medium may also include any number of additional software components not shown in .

Some of the software components discussed herein may be stored on the computer readable storage medium as indicated in . For example a replaying module may be configured to receive the relevant execution traces from the reporting module of the computer readable storage medium discussed above with respect to . The replaying module may also be configured to store the relevant execution traces and replay the relevant execution traces to determine whether the behavior of the application is as expected. Moreover the computer readable storage medium may also include any number of additional software components not shown in .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

