---

title: Command instruction management
abstract: Techniques are described for writing commands to memory units of a chain of memory units of a command buffer. The techniques may write the commands, and if during the writing, it is determined that there is not sufficient space in the chain of memory unit, the techniques may flush previously confirmed commands. If after the writing, the techniques determine that there is not sufficient space in an allocation list for the handles associated with the commands, the techniques may flush previously confirmed commands.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09165337&OS=09165337&RS=09165337
owner: QUALCOMM Incorporated
number: 09165337
owner_city: San Diego
owner_country: US
publication_date: 20130916
---
This application claims the benefit of U.S. Provisional Application No. 61 829 487 filed May 31 2013 the entire content of which is hereby incorporated by reference.

This disclosure relates to techniques for graphics processing and more particularly relates to techniques for storing commands for graphics processing.

Visual content for display such as content for graphical user interfaces and video games may be generated by a graphics processing unit GPU . A GPU may convert two dimensional 2D or three dimensional 3D graphical objects into a 2D pixel representation that may be displayed on a display device. To perform its functions the GPU executes commands issued by an application processor such as the central processing unit CPU . In general the CPU stores the commands in a command buffer and the GPU retrieves the commands from the command buffer for execution.

In general this disclosure describes confirm based command buffer queue generation techniques. For example the techniques describe confirming commands after the writing. By confirming the commands if a next set of commands cannot be written or there is not sufficient space in the allocation list for handles associated with the next set of commands as determined during the writing of the next set of commands the processor may submit the confirmed commands so that additional memory units can be utilized or the allocation list can be reset.

For instance if the processor is able to write the set of commands in the memory units of the command buffer the processor may identify a confirm point that identifies the location in the memory unit where the processor finished writing the set commands e.g. the location of an end of the set of commands in the memory unit . The processor may then write the next set of commands staring from the confirm point. If however the processor determines that the entire set of commands cannot be written to the memory units during the writing or determines after the writing of the commands that there is not sufficient allocation list space of the handles associated with the set of commands the processor may submit the commands prior to the confirm point. Submitting the commands prior to the confirm point may allow the processor to write the remaining commands of the set of commands in the additional memory units or create sufficient space for the handles associated with the commands after the confirm point.

In one example the disclosure describes a method for storing commands the method comprising writing with a processor a current set of commands to a chain of memory units in a command buffer starting from a current confirm point in a memory unit of the memory units. The method includes determining with the processor at least one of whether an end of the chain of memory units is reached with commands of the current set of command that have not yet been written to the chain of memory units during the writing of the current set of commands and whether there is sufficient space in an allocation list to store handles associated with the current set of commands after the writing of the current set of commands. The method also includes submitting with the processor previously confirmed commands that were stored by the processor in the chain of memory units before the writing of the current set of commands if based on the determination the end of the chain of memory units is reached with commands of the current set of commands that have not yet been written to the chain of memory units or if based on the determination there is not sufficient space in the allocation list to store handles associated with the current set of commands.

In one example the disclosure describes a device comprising a system memory comprising a command buffer and a processor. The processor is configured to write a current set of commands to a chain of memory units in the command buffer starting from a current confirm point in a memory unit of the memory units. The processor is also configured to determine at least one of whether an end of the chain of memory units is reached with commands of the current set of command that have not yet been written to the chain of memory units during the writing of the current set of commands and whether there is sufficient space in an allocation list to store handles associated with the current set of commands after the writing of the current set of commands. The processor is further configured to submit previously confirmed commands that were stored by the processor in the chain of memory units before the writing of the current set of commands if based on the determination the end of the chain of memory units is reached with commands of the current set of commands that have not yet been written to the chain of memory units or if based on the determination there is not sufficient space in the allocation list to store handles associated with the current set of commands.

In one example the disclosure describes a computer readable storage medium having instructions stored thereon that when executed cause one or more processors to write a current set of commands to a chain of memory units in a command buffer starting from a current confirm point in a memory unit of the memory units. The instructions also cause the one or more processors to determine at least one of whether an end of the chain of memory units is reached with commands of the current set of commands that have not yet been written to the chain of memory units during the writing of the current set of commands and whether there is sufficient space in an allocation list to store handles associated with the current set of commands after the writing of the current set of commands. The instructions also cause the one or more processors to submit previously confirmed commands that were stored by the one or more processors in the chain of memory units before the writing of the current set of commands if based on the determination the end of the chain of memory units is reached with commands of the current set of commands that have not yet been written to the chain of memory units or if based on the determination there is not sufficient space in the allocation list to store handles associated with the current set of commands.

In one example the disclosure describes a device comprising means for writing a current set of commands to a chain of memory units in a command buffer starting from a current confirm point in a memory unit of the memory units. The device also includes means for determining at least one of whether an end of the chain of memory units is reached with commands of the current set of command that have not yet been written to the chain of memory units during the writing of the current set of commands and whether there is sufficient space in an allocation list to store handles associated with the current set of commands after the writing of the current set of commands. The device further includes means for submitting previously confirmed commands that were stored by the processor in the chain of memory units before the writing of the current set of commands if the end of the chain of memory units is reached with commands of the current set of commands that have not yet been written to the chain of memory units or if there is not sufficient space in the allocation list to store handles associated with the current set of commands.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

The techniques described in this disclosure are directed to storing command instructions in a command buffer. For purposes of illustration the techniques of this disclosure are described with respect to the manner in which a processor stores command instructions for a graphics processing unit GPU in a command buffer.

For example an application executing on the processor e.g. central processing unit CPU causes the processor to generate graphics data as well as instructions that instruct another processor e.g. the GPU regarding the manner in which the data such as graphics data is to be processed. A graphics driver also executing on the processor converts the instructions into commands that the GPU can process and converts the graphics data into data packets that the GPU can process e.g. pm4 data packets . The term pm4 data packets refers generally to data packets that the GPU can process such as packets of commands or data. The processor via the graphics driver stores the commands and the generated graphics data in a system memory e.g. the memory of the device that includes the processor and the GPU . In general the processor via the graphics driver stores commands in a dedicated command buffer within the system memory. The operating system of the processor may dedicate a portion of the system memory as the command buffer.

According to the techniques described in this disclosure the processor may attempt to write a set of commands to memory units of the command buffer without first determining whether there is sufficient space in the command buffer to store the commands or whether there is sufficient space in an allocation list for handles associated with the commands. The command buffer can be considered as a chain of a plurality of memory units where each unit can store a plurality of commands. If the processor is able to write the set of commands in the chain of memory units and there is sufficient space in the allocation list for handles described in more detail below associated with the commands the processor may identify the location in the memory unit of the memory units where the processor finished writing the set of commands. The location in the memory unit where the processor finished writing the set of commands is referred to as a confirm point and the commands stored before the confirm point are referred to as confirmed commands. The processor may then write the next set of commands starting from the confirm point.

If the processor determines during the writing of the next set of commands that there is not sufficient space in the chain of memory units to write all of the commands of the next set of commands the processor may trigger a flush to submit all confirmed commands to the GPU for eventual execution by the GPU. If the processor determines after the writing of the next set of commands that there is not sufficient space in the allocation list for the handles associated with the next set of commands the processor may trigger the flush to submit all confirmed commands to the GPU for eventual execution by the GPU.

The submission of the commands to the GPU for eventual execution i.e. the flush allows the processor to add memory units to the chain of memory units for storing any remaining commands from the next set of commands that were not stored prior to the flush. Also the submission of the commands clears the allocation list which frees space the allocation list for the handles associated with the next set of commands.

In general when the processor submits confirmed commands to the GPU for eventual execution by the GPU the processor may be considered as utilizing any technique to make the commands available for execution. As one example the processor may transfer the commands to a command buffer for the GPU. As another example as part of submitting the confirmed commands the processor may indicate to the GPU the memory addresses for the memory units that store the confirmed commands and location of the confirm point so that when the GPU is to execute the confirmed commands the GPU can determine from where to access the commands. Other examples of submitting the confirmed commands to the GPU are possible and the techniques should not be considered limited to the above examples of submitting confirmed commands.

In some other techniques prior to writing to the command buffer the processor would determine whether there is sufficient space in the current chain of memory units to store the commands and sufficient space in the allocation list for the handles associated with the commands. For example the processor would determine how much memory space is needed for the commands that need to stored and determine how much space is currently available in the chain of memory units. Also the processor would determine how much space is needed for the handles associated with the commands and how much space is currently available in the allocation list for the handles. If there is not sufficient space the processor would perform a flush operation.

For instance in these other techniques if there is not sufficient space in the memory units or not sufficient space in the allocation list as determined prior to the writing the processor would submit the commands in the memory units and the allocation list clear the allocation list remove the memory units with the submitted commands from the chain and add more memory units to the chain on an as needed basis e.g. as part of the flush operation . However determining ahead of time how much memory is needed to store the commands how much memory is currently available in the current chain of memory units how much space in the allocation list is needed for the handles and how much space is currently available in the allocation list for the handles consumes considerable processing resources and increases processing time.

According to the techniques described in this disclosure the processor may not need to flush the chain of memory units ahead of time if there is not sufficient space in the chain of memory units for the commands or if there is not sufficient space in the allocation list for the handles associated with the commands. Rather the processor may first attempt to write the commands and if during the writing or immediately after the writing the processor determines that the chain of memory units should be flushed it is then that the processor flushes the chain of memory units.

It should be understood that although the techniques described in this disclosure are described with respect to commands that are executed by a GPU e.g. GPU command generation the techniques are not so limited. The techniques may be extended to non GPU related command generation and may be considered applicable to any stream generator of commands with multiple dependency e.g. where a processor generates commands to be executed by another processing unit .

Device includes processor graphics processing unit GPU and system memory . Processor may be the central processing unit CPU . GPU may be a processing unit configured to perform graphics related functions such as generate and output graphics data for presentation on a display as well as perform non graphics related functions that exploit the massive processing parallelism provided by GPU . For example GPU may execute both graphics applications and non graphics applications. Because GPU may provide general purpose processing capabilities in addition to graphics processing capabilities GPU may be referred to as a general purpose GPU GP GPU .

Examples of processor and GPU include but are not limited to a digital signal processor DSP a general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. In some examples GPU may be a microprocessor designed for specific usage such as providing massive parallel processing for processing graphics as well as for executing non graphics related applications. Furthermore although processor and GPU are illustrated as separate components aspects of this disclosure are not so limited. For example processor and GPU may reside in a common integrated circuit IC .

System memory is the system memory of device and may reside external to processor and GPU i.e. off chip with respect to processor and off chip with respect to GPU . Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM or an electrically erasable programmable read only memory EEPROM or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer or a processor. For instance system memory may be considered as a computer readable storage medium having instructions stored thereon that when executed cause one or more processors e.g. processor or GPU to implement techniques described in this disclosure. In some examples system memory may be removed from device and moved to another device. In some examples a storage device substantially similar to system memory may be inserted into device .

System memory may store applications that are executed by processor and GPU . For example processor may execute application operating system and graphics driver . System memory may store the object code for application operating system and graphics driver that processor retrieves for execution. Also although not illustrated GPU may execute graphics related shader applications such as vertex shaders fragment shaders geometry shaders and like and may also potentially execute non graphics related shader applications referred to as kernels or compute shaders. System memory may store the object code and possibly the source code as well of such graphics and non graphics related shader applications.

In some examples system memory may store data that GPU is to operate on when executing the commands. For example the data may include a list of graphics primitives e.g. points lines triangles quadrilaterals triangle strips etc. however other types of data may exist as well. System memory may also store data resulting from the execution of commands or applications by GPU . For example system memory may store any combination of texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like.

Furthermore system memory may store commands that are to be executed by GPU as well as the data that GPU is to utilize. For example as illustrated processor may execute application . Examples of application include video games web browsers e mail and generally any application that produces viewable content for display. To leverage the graphics processing of GPU application may generate commands that GPU is to execute as well as the data that GPU is to operate on as part of the execution of the commands.

Graphics driver executing on processor may convert the commands into commands that are executable by GPU . For example graphics driver may convert the commands to conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a DirectX API an X3D API a RenderMan API a WebGL API or any other public or proprietary standard graphics API.

As illustrated in system memory includes buffer and buffer . Buffer and buffer may together form a command buffer in which graphics driver stores commands that are to be executed by GPU . For instance buffer may be referred to as a first indirect buffer IB1 and buffer may be referred to as a second indirect buffer IB2 . Utilizing buffer and buffer to together form a command buffer may be a function of operating system executing on processor . For instance some operating systems such as operating system may limit the manner in which information can be stored the IB1 e.g. buffer .

To overcome the limitations placed on IB1 by operating system some techniques utilize an IB2 e.g. buffer to store information in a way that operating system does not allow for IB1. In such techniques IB1 stores references such as pointers to where information is stored in IB2 and IB2 stores the actual information. The techniques described in this disclosure are described with respect to an IB1 e.g. buffer and an IB2 e.g. buffer together forming a command buffer. However requiring both buffer and buffer to form a command buffer may be a limitation of operating system . For an operating system different than operating system it may be possible to form a command buffer in a single buffer e.g. in one of buffer or buffer .

Accordingly buffer and buffer together forming the command buffer is described for purposes of illustration and should not be considered limiting. For purposes of illustration the techniques are described with processor via graphics driver storing commands in buffer and storing information in buffer indicating where the commands are located in buffer .

As described above the techniques described in this disclosure are related to storing commands in a command buffer e.g. buffer and buffer . One example of commands is atomic commands. Atomic commands are a set of commands that need to be executed together. For example GPU may retrieve the atomic commands together for execution. During the execution of the atomic commands GPU may not execute other commands. For instance GPU may not pause the execution of commands of the atomic commands execute another set of commands and execute the remaining commands of the atomic commands. Because GPU may execute atomic commands together it may be desirable to store atomic commands together allowing GPU to retrieve the atomic commands together for execution.

For purposes of illustration the techniques of this disclosure are described with respect to a set of commands that need to be executed together. For instance the set of commands forms atomic commands. The term atomic operations is another term synonymous with atomic commands. However the techniques described in this disclosure should not be considered limited to atomic commands or operations and are generally applicable for storing commands in a command buffer.

To store commands in buffer operating system may allocate memory space in buffer and graphics driver may store the commands in the allocated memory space in buffer . In the techniques described in this disclosure the allocated memory space in buffer may be in form of a plurality of memory units. Each memory unit may be able to store a certain amount of commands.

In some examples processor via operating system may allocate a first memory unit in buffer and processor via graphics driver may write commands of a set of commands to the first memory unit. If there are additional commands in the set of commands that need to be written processor via operating system may allocate a second memory unit in buffer and processor via graphics driver may write additional commands of the set of commands to the second memory unit and so forth until processor via graphics driver completes the writing of the set of commands.

In these examples graphics driver may store pointer information in buffer that indicates where the first memory unit the second memory unit and so forth are located in buffer . For example the pointer information may be four bytes. In this sense the first memory unit the second memory unit and any additional memory units needed to store the set of commands in buffer may be considered conceptually as forming a chain of memory units. It should be understood that the first memory unit and the second memory unit need not necessarily be stored in contiguous locations within buffer . Rather with the pointer information in buffer GPU may be able to retrieve the set of commands stored across the different memory units in buffer together.

Graphics driver may define a maximum number of memory units that can be chained together e.g. define a chain size . The chain size may be user configurable based on various factors such as the storage capabilities of system memory an assumption as to the maximum number of commands in a set of commands and the like. For example application may be configured with a maximum or minimum number of atomic commands that application can issue and graphics driver may define the chain size based on the maximum or minimum number of atomic commands that application can issue. As one example application may issue atomic commands that require at least two memory units meaning that the minimum chain size may be two memory units. For purposes of illustration this disclosure describes a chain size of four memory units. However the chain size may be greater than or less than four memory units.

The commands of the set of commands may be associated with handles. A handle is a reference to an allocation of memory needed to process the associated command. In general handles may be considered as descriptors for the data operated on by the commands. For instance a command of a set of commands may operate on a set of input graphics data and the result of the operation on the input graphics data may be a set of output graphics data. The handle associated with the command may indicate the amount of memory that needs to be allocated for the input graphics data and the output graphics data. As one example a command may instruct GPU to perform operations on texture data. In this example the texture data may be handles associated with the command.

Processor via operating system may be configured to maintain an allocation list of handles for the set of commands. In some examples system memory may include operating system OS buffer which stores the handles associated with the set of commands. OS buffer is not necessary in every example and processor may implement any technique for maintaining the allocation list of handles.

When processor via graphics driver is to write a set of commands processor via operating system may create an allocation list for the handles associated with the set of commands. The allocation list may be a fixed sized array that indicates the handles associated with the commands. As processor via graphics driver writes the set of commands to the memory units in the chain of memory units processor via graphics driver may also update the allocation list with the handles associated with the commands of the set of commands.

As graphics driver writes commands to the memory units of the chain of memory units and associated handles to the allocation list the memory units of the chain of memory units and the allocation list starts to become full and may not be able to store additional commands or handles. As one example graphics driver may write a first set of commands to memory units of a chain of memory units. After writing the first set of commands to the memory units of the chain if graphics driver were to write commands of a second set of commands to the memory units all four memory units of the chain would be full and there would still be commands of the second set of commands that need to be written. In this case operating system may not be able to allocate another memory unit because the chain size of the chain is four memory units.

As another example graphics driver may write a first set of commands to memory units of a chain of memory units and store information of the handles associated with the first set of commands in the allocation list. In this example there may be sufficient space in the memory units to store a second set of commands. However there may not be sufficient space in the allocation list to store the handles associated with the second set of commands.

In some other techniques a graphics driver unlike graphics driver may first determine the amount of space needed to write a set of commands in the memory units of a chain determine the amount of space needed for the handles associated with the set of commands determine the amount of available space in the memory units of the chain of memory units and determine the amount of available space in the allocation list. For example the graphics driver in these other techniques may call a VerifySpace VerifyHandleSpace function to determine the amount of space needed to write a set of commands in the memory units of a chain determine the amount of space needed for the handles associated with the set of commands determine the amount of available space in the memory units of the chain of memory units and determine the amount of available space in the allocation list.

In these other examples the graphics driver would only write the commands to the memory units when there is sufficient space in the memory units and the allocation list. If there is not sufficient space in the memory units or the allocation list the graphics driver in these other techniques may execute a flush call. A flush call is described in more detail below.

There may be limitations with a graphics driver determining prior to the writing of the commands the amount of space needed to write a set of commands in the memory units of a chain the amount of space needed for the handles associated with the set of commands the amount of available space in the memory units of the chain of memory units and the amount of available space in the allocation list. For example it may be possible for certain types of application and for certain scenarios that processor needs to expend an undesirable amount of processing resources for executing the VerifySpace VerifyHandleSpace function.

The execution of the VerifySpace VerifyHandleSpace function may be considered as a small batch problem. For instance the amount of commands and handles that need to be written may be relatively small as compared to the vast amount of storage area that processor needs to check to determine whether there is sufficient space to store the commands and handles. In other words the VerifySpace VerifyHandleSpace function may check a relatively large amount of storage area to ensure that a small amount of data can be written which may result in processing inefficiencies.

The techniques described in this disclosure describe a confirm based command buffer queue generation technique in which processor via graphics driver may attempt to write a set of commands to buffer . If during the writing of the set of commands processor via graphics driver determines that there is not sufficient space in the memory units of the chain of memory units to store the set of commands then processor via graphics driver may execute a flush call.

In this way graphics driver may not need to execute the VerifySpace function to determine ahead of time whether there is sufficient space in the memory units of the chain of memory units to store the commands of the set of commands. In other words by writing the commands of the set of commands without determining a priori whether there is sufficient space in the memory units of the chain of memory units in the command buffer e.g. buffer the techniques described in this disclosure may promote processing efficiencies because processor may not need to waste processing resources determining whether there is sufficient space in the memory units of the chain of memory units to store the set of commands.

Also in the techniques described in this disclosure processor via graphics driver may determine after the writing of the set of commands whether there is sufficient space in the allocation list for the handles associated with the set of commands. If there is not sufficient space in the allocation list after the writing of the set of commands processor via graphics driver may execute a flush call.

In this way graphics driver may not need to execute the VerifyHandle function to determine ahead of time whether there is sufficient space in the allocation list for the handles associated with the set of commands. In other words by writing the commands of the set of commands without determining a priori whether there is sufficient space in the allocation list for the handles associated with the set of commands the techniques described in this disclosure may promote processing efficiencies because processor may not need to waste processing resources determining whether there is sufficient space in the allocation list for the handles associated with the set of commands.

As described above if during the writing of the set of commands graphics driver determines that there is not sufficient space in the memory units of the chain of memory units in the command buffer or if after the writing of the set of commands graphics driver determines that there is not sufficient space in the allocation list for the handles associated with the set of commands graphics driver may execute the flush call. The flush call may be the mechanism by which graphics driver frees space to write commands in memory units or frees space in the allocation list for the handles associated with the commands.

For example the result of the execution of the flush call may be that graphics driver submits already written commands for which there is sufficient space in the allocation list to GPU for eventual execution. For instance the submission of the commands means that GPU may be able to execute the commands. As one example graphics driver may indicate to GPU the memory addresses for the memory units that store commands so that GPU can retrieve the commands for eventual execution as a way to submit the commands to GPU . In general submitting commands may be considered as graphics driver utilizing any technique to make the commands available to GPU for eventual execution. GPU may immediately execute the commands or execute the commands at some later time based on when GPU is to execute the commands.

In addition the result of the execution of the flush call may be graphics driver releasing memory units from the chain of memory units that store already written commands. For example assume that processor via graphics driver wrote a first set of commands that filled up a first memory unit and a second memory unit and partially filled up a third memory unit. Also assume that in this example there was sufficient space in the allocation list for the handles associated with the first set of commands.

In this example processor via graphics driver may begin writing a second set of commands starting from where processor finished writing the first set of commands in the third memory unit. For instance the first set of commands may be considered as a previous set of commands and the second set of commands may be considered as a current set of commands. However in this example processor may not be able to write all of the commands of the second e.g. current set of commands in the remaining of the third memory unit and a fourth memory unit. In this example the chain size may be four memory units and so graphics driver may not be able to link a memory unit after the fourth memory unit in the chain of memory units.

After graphics driver fills up the fourth memory unit with commands from the second set of commands processor via graphics driver may execute the flush call. In response processor via graphics driver may submit the first set of commands to GPU for eventual execution e.g. make available by indicating the locations of where the first set of commands are stored . The commands of the second set of commands that processor via graphics driver was able to write in the memory units remain in the memory units and are not yet submitted to GPU .

Also in response to the execution of the flush call processor via graphics driver may release the first memory unit and the second memory unit from the chain of memory units because the first memory unit and the second memory unit stored commands only of the first set of commands. Releasing a memory unit from the chain of memory units may mean breaking the link of the memory unit with the other memory units in the chain. Processor via graphics driver may not be able to release the third memory unit from the chain of memory units because at least part of the third memory unit stores commands of the second set of memory unit.

With the release of the first memory unit and the second memory unit from the chain of memory units the chain of memory units may include two memory units e.g. the third memory unit and the fourth memory unit . Because the chain size is four memory units in this example operating system may allocate another memory unit in buffer and graphics driver may link this new memory unit to the end of the previous fourth memory unit.

At this juncture there may be three memory units in the chain of memory units i.e. the previous third and fourth memory units and the newly linked memory unit . Graphics driver may then write remaining commands of the second set of commands i.e. command remaining after graphics driver filled up the fourth memory unit in the newly linked memory unit. If graphics driver is not able to write all of the remaining commands of the second set of commands in the newly linked memory unit operating system may allocate another memory unit in buffer and graphics driver may link this new memory unit to the three memory units of the chain of memory units resulting in a chain of memory units with four memory units which is the chain size.

Moreover the execution of the flush call results in a resetting of the allocation list for the handles. For example in addition to submitting the first set of commands for eventual execution by GPU processor via graphics driver may clear the allocation list and store the handles associated with the second set of commands in the allocation list.

In the above example it was assumed that after writing the first set of commands there was sufficient space in the allocation list for the handles associated with the first set of commands. Also in the above example processor via graphics driver determined which commands to submit as part of the flush call. The following describes the manner in which processor via graphics driver may determine whether there is sufficient space in the allocation list for the associated handles as well as the manner in which processor via graphics driver may determine which commands to submit as part of the flush call.

For example during the writing of a set of commands graphics driver may periodically trigger a GetCmdSpace function without prior verification of whether there is sufficient space in the memory units for the set of commands. The GetCmdSpace function may indicate whether graphics driver has reached the end of a memory unit which is at the end of the chain of memory units i.e. whether graphics driver has reached the fourth memory unit of the chain of memory units with a chain size of four memory units . If the GetCmdSpace function indicates that graphics driver has not yet reached the end of the chain of memory units graphics driver may keep writing commands of the first set of commands.

If the GetCmdSpace function indicates that graphics driver has reached the end of the chain of memory units graphics driver may execute the flush call as described above. Also graphics driver may then re try the GetCmdSpace function. For example the flush call may free space for linking additional memory units that operating system allocates and graphics driver may then re try the GetCmdSpace function which will indicate that graphics driver has not yet reached the end of the chain of memory units.

However in some cases graphics driver may finish writing the commands of the set of commands and there may still be available space in the memory units for additional commands from a subsequent set of commands. In this case processor via graphics driver may execute a confirm write command referred to as ConfirmWrite . In general processor via graphics driver may execute the confirm write command after writing the commands of the set of commands to the command buffer. The execution of the confirm write command may serve one or more purposes.

Graphics driver with the execution of the confirm write command may indicate the point in the memory unit where graphics driver finished writing the set of commands so that graphics driver can start writing commands for the next set of commands starting from the point in the memory unit where graphics driver finished writing the set of commands. The location of an end of the set of commands in the memory unit is referred to as a confirm point. 

For example assume that processor via graphics driver wrote commands of a first set of commands in a first memory unit a second memory unit and partially in a third memory unit. In this example processor via graphics driver may identify the confirm point in the third memory unit where graphics driver finished writing the first set of commands e.g. the previous set of commands . For example where graphics driver finished writing the first set of commands in the third memory unit is the location of the end of the first set of commands in the third memory unit. In this case after the identifying the confirm point the first set of commands may be considered as previously confirmed commands. When writing a second set of commands which are now the current set of commands processor via graphics driver may begin writing the second set of commands starting from the confirm point in the third memory unit.

In addition graphics driver with the execution of the confirm write command may determine whether there is sufficient space in the allocation list for handles associated with the commands of the set of commands. For example as graphics driver is writing commands of a set of commands processor via graphics driver may execute the AddPendingHandle function. With the AddPendingHandle function graphics driver may add handles associated with the set of commands to a temporary allocation list also referred to as an unconfirmed handles list.

After writing the set of commands the unconfirmed handles list includes the handles associated with the set of commands. Graphics driver may then attempt to submit the handles in the unconfirmed handles list to operating system . For example processor via graphics driver may execute the AddHandle function. With the AddHandle function graphics driver may submit the handles in the unconfirmed handles list to operating system . In response processor via operating system may determine whether there is sufficient space in the allocation list for the handles of the unconfirmed handles list.

For example the allocation list may include handles of a previous set of commands and assume that the handles of the previous set of commands use 90 of the array of the allocation list. In this example graphics driver may submit handles in the unconfirmed handles list and if the handles in the unconfirmed handles list require less than 10 of the allocation list graphics driver may store the handles in the unconfirmed handles list in the allocation list. In some examples graphics driver may attempt to store the handles in the unconfirmed handle list into the allocation list without first determining whether there is sufficient space in the allocation list for the handles form the unconfirmed handle list.

If however the handles in the unconfirmed handle list require more than 10 of the allocation list e.g. the attempt to store the handles in the unconfirmed handle list into the allocation list was unsuccessful graphics driver may execute a flush call. In response to the flush call processor via graphics driver may submit the commands stored in the command buffer for which the allocation list currently stores the associate handles and associated handles in the allocation list to GPU for eventual execution. Also in response to the flush call processor via operating system may reset the allocation list i.e. clear out the allocation list with the handles which in turn allows graphics driver to store the handles associated with the just written set of commands in the allocation list.

In this way the execution of the confirm write command may be considered as indicating which commands and associated handles can be submitted to GPU in response to a flush call. For example assume that as graphics driver is writing a first set of commands graphics driver is maintaining the unconfirmed list of handles e.g. via the AddPendingHandle function . Also assume that graphics driver is able to write all commands of the first set of commands within the memory units of the chain of memory units.

In this example after writing the first set of commands graphics driver may execute the confirm write ConfirmWrite command. As part of the confirm write command graphics driver may submit the unconfirmed list of handles to operating system e.g. via AddHandle function . In this example assume that there is sufficient space in the allocation list for the handles of the unconfirmed list of handles. Accordingly graphics driver may add the handles of the unconfirmed list of handles to the allocation list and clear the unconfirmed list of handles. Because graphics driver was able to add the handles of the unconfirmed list of handles to the allocation list as part of the confirm write command graphics driver may identify the point i.e. confirm point where graphics driver finished writing the first set of commands. For examples graphics driver may identify the confirm point at a location of an end of the first set of commands in the memory unit. Processor via graphics driver may not yet submit the first set of commands and may wait until a flush call.

At this juncture processor may be considered as having written a frame. The term frame as used in this disclosure is used synonymous with a set of commands. The term frame should not be confused with rendered image which is also sometimes referred to as a frame.

In the techniques described in this disclosure after processor via graphics driver executes the confirm write command and the execution of the confirm write command is successful i.e. there is sufficient space in the allocation list processor via graphics driver may indicate that the first set of commands are confirmed commands. Processor via graphics driver may also identify which memory units store only confirmed commands.

For example assume that processor via graphics driver filled a first memory unit a second memory unit and partially filled a third memory unit of the chain of memory units with the first set of commands. In this example the first memory unit and the second memory unit only store confirmed commands and graphics driver may indicate that the first memory units and the second memory unit include only confirmed commands. For instance graphics driver may maintain a variable usedEntries for each memory unit of the chain of memory units.

For memory units that only store confirmed commands graphics driver for those memory units may set the variable usedEntries equal to confirmedEntries. In this example for the first memory unit and the second memory unit graphics driver may set the variable usedEntries equal to confirmedEntries to indicate that the first memory unit and the second memory unit only store confirmed commands. With respect to the third memory unit graphics driver may set the variable usedEntries to not confirmedEntries i.e. usedEntries confirmedEntries . This may be because the third memory unit only partially includes confirmed commands.

Processor via graphic driver may then write a second set of commands to the memory units of the chain of memory units starting from the confirm point. For example if the first set of commands is frame 0 processor via graphics driver may write frame 1 which is the second set of commands to the memory units of the chain of memory units starting from the confirm point.

During the writing of the second set of commands graphics driver may store the handles associated with the second set of commands in the unconfirmed list of handles. If during the writing of the second set of commands graphics driver reaches the end of the chain of memory units and there are commands of the second set of commands that have not yet been written graphics driver may execute the flush call.

In response graphics driver may submit all confirmed commands and handles associated with the confirmed commands e.g. submit the first set of commands and the handles in the allocation list associated with the first set of commands . In other words graphics driver may submit all commands prior to the confirm point and their associated handles. For instance keeping with the previous example graphics driver may submit all commands in the first and second memory units and the confirmed commands that partially fill up the third memory unit up to the confirm point. Graphics driver may also submit the handles in the allocation list and clear the allocation list.

Graphics driver may also release the first and second memory units from the chain of memory units and write the remaining commands of the second set of commands in additional memory units allocated by operating system . For memory units that do not store any confirmed commands graphics driver may set the variable confirmedEntries for those memory units equal to 0. Graphics driver may then execute the confirm write command after writing the second set of commands. In this case because graphics driver cleared the allocation list after flushing the first set of commands there will be sufficient space in the allocation list for the handles associated with the second set of commands which are temporally stored in the unconfirmed list of handles. Also in response to the confirm write command the second set of commands may be considered as confirmed commands and graphics driver may move the confirm point to the end of where graphics driver finished writing the second set of commands.

In the above case during the writing of the second set of commands graphics driver reached the end of the chain of memory units with commands of the second set of commands that have not yet been written to the chain of memory units. In some examples graphics driver may write all commands of the second set of commands and still not reach the end of the chain of memory units. In these examples because graphics driver is able to write all commands of the second set of commands and still not reach the end of the chain of memory units graphics driver may not execute a flush call and may therefore not submit the first set of commands i.e. confirmed commands and may not clear the allocation list of handles associated with the first set of commands.

Also in these examples after writing all commands of the second set of commands processor via graphics driver may execute the confirm write command. As part of the confirm write command graphics driver may attempt to add the handles in the unconfirmed list of handles to the allocation list. In this case the allocation list may include the handles associated with the first set of commands. If adding the handles of the second set of commands in the unconfirmed list of handles does not require the allocation list to store more handles than its fixed size will allow graphics driver add the handles of the second set of commands to the allocation list clear the unconfirmed list of handles and move the confirm point to the end of the second set of commands.

If adding the handles of the second set of commands in the unconfirmed list of handles requires the allocation list to store more handles than its fixed size will allow graphics driver may execute the flush call. In response graphics driver may submit all confirmed commands e.g. the first set of commands and the associated handles clear the allocation list and release memory units that only store confirmed commands. Graphics driver may then store handles of the second set of commands in the just cleared allocation list of handles move the confirm point to the end of the second set of commands and indicate that the second set of commands are confirmed commands.

For example in the chain of memory units includes memory unit A memory unit B memory unit C and memory unit D. Graphics driver may reference to memory units A B C and D via their respective pointers that identify the location in buffer where memory units A B C and D reside. For example illustrate the IB2 chain head pointer which points to the first memory unit e.g. memory unit A in the chain of memory units. Operating system may store the information for IB2 chain head pointer in buffer e.g. the IB1 buffer and memory units A B C and D may reside in buffer .

In graphics driver may write a first set of commands in memory unit A memory unit B and partially in memory unit C indicated by Cpartial . After the writing of the first set of commands graphics driver may execute the confirm write command. In the examples in graphics driver was able to store the handles associated with the first set of commands in the allocation list. In the examples in graphics driver may identify the confirm point in the middle of memory unit C e.g. at the end of Cpartial .

Because graphics driver was able to write all commands of the first set of commands in the memory units of the chain of memory units and was able to store the handles associated with the first set of commands in the allocation list the first set of commands may be considered as confirmed commands as illustrated with the gray shading. Also as illustrated because memory units A and B store only confirmed commands graphics driver may set the usedEntries variable equal to confirmedEntries. Because memory unit C only partially stores confirmed commands graphics driver may set the usedEntries variable not equal to confirmedEntries.

In graphics driver may then write a second set of commands to chain of memory units starting from the confirm point. For example graphics driver may maintain a pointer that indicates where graphics driver is to begin writing the set of commands referred to as a start pointer . Initially the start pointer points to the IB2 chain head pointer. After a successful execution of a confirm write command graphics driver may move the start pointer to confirm point. For example in graphics driver may move the start pointer to at the end of Cpartial.

In the writing of the second set of commands is illustrated with the unconfirmed commands. The second set of commands are unconfirmed commands because graphics driver has not yet successfully executed a confirm write command. In graphics driver needs to write commands of the second set of commands that fill up memory unit C Cnext and that fill up in or partially fill up in memory unit D. Because memory unit D only stores unconfirmed commands the confirmedEntries for memory unit D is set equal to 0.

In graphics driver may write the second set of commands and reach the end of the chain of memory units with there still being commands in the set of commands that have not yet been written. In this case graphics driver may execute the flush call and may submit all confirmed commands to GPU for eventual execution.

In graphics driver was able to write all commands of the second set of commands within the chain of memory units i.e. memory unit D is only filled until Dpartial . In graphics driver may execute the confirm write call however in this case there may not be sufficient space in the allocation list for the handles associated with the second set of commands. For instance during the writing of the second set of commands graphics driver may temporally store the handles associated with the second set of commands in the unconfirmed list of handles. With the execution of the confirm write command graphics driver may attempt to add the handles in the unconfirmed handles list to the allocation list. However the allocation list may already include the handles associated with the first set of commands i.e. confirmed commands and there may not be sufficient space in the allocation list for graphics driver to add the handles associated with the second set of commands to the allocation list. In this case graphics driver may execute the flush call and may submit all confirmed commands and associated handles to GPU for eventual execution.

In some examples as part of submitting the confirmed commands graphics driver may indicate to GPU the location of the start pointer and the respective pointers for the memory units that store the confirmed commands. In addition graphics driver may indicate to GPU the pointer that points to the confirm point. GPU may then be able to retrieve all of the confirmed commands from the command buffer e.g. buffer together based on the indicated pointers. After graphics driver confirms the next set of commands the pointer that points to the current confirm point becomes the start pointer for the next set of commands and the newly determined confirm point i.e. where graphics driver finished writing the second set of commands becomes the end point of the confirmed commands.

In this manner the techniques utilize a confirm based methodology to indicate which commands are ready to be submitted to GPU for eventual execution. The confirm based methodology allows graphics driver to write commands to the command buffer without needing to determine ahead of time whether there is sufficient space in the memory units to store the commands or sufficient space in the allocation list for the handles. It is when graphics driver determines during the writing of the commands that there is not sufficient space in the memory units that graphics driver executes the flush call rather than issuing the flush call prior to writing the commands. Also it is when graphics driver determines after the writing of the commands that there is not sufficient space in the allocation list for the handles associated with the commands that graphics driver executes the flush call rather than issuing the flush call prior to writing the commands.

Processor via graphics driver may write a current set of commands to memory units of a chain of memory units of a command buffer starting from a current confirm point . For example prior to writing the current set of commands processor may have written a previous set of commands to the chain of memory units and may have also written handles associated with the previous set of commands to a temporary list e.g. in an unconfirmed handle list .

After writing the previous set of commands processor may have executed a confirm write e.g. ConfirmWrite command. In this example assume that during the writing of the previous set of commands there was sufficient space in the chain of memory units to store all of the previous set of commands without reaching the end of the chain of memory units e.g. there are no commands of the previous set of commands that were not written to the chain of memory unit . As part of the execution of the confirm write command processor may have stored the handles in the temporary list into the allocation list e.g. there was sufficient space in the allocation list for the handles of the previous set of commands . In this example as part of the execution of the confirm write command processor may identify a current confirm point which is the point in a memory unit where processor finished writing the previous set of commands. Therefore for the current set of commands processor may start writing the commands of the current set of commands from the current confirm point.

Processor via graphics driver may store handles associated with the current set of commands in a temporary list e.g. in an unconfirmed handle list during the writing of the current set of commands . For example processor may create a new temporary list and store handles associated with the current set of commands in this newly created temporary list. As another example processor may clear the previous temporary list and store handles associated with the current set of commands in this now cleared temporary list. For instance after storing the handles associated with the previous set of commands from the temporary list into the allocation list processor may clear the temporary list allowing processor to store handles associated with the current set of commands in the temporary list.

As illustrated processor via graphics driver may determine whether an end of the chain of memory units is reached with commands of the current set of commands that have not yet been written to the chain of memory units during the writing of the current set of commands . If processor via graphics driver reaches the end of the chain of memory units with commands of the current set of commands that have not yet been written YES of processor via graphics driver may submit the previously confirmed commands for eventual execution .

For example the previously confirmed commands may be commands prior to the current confirm point that were previously stored in the chain of memory units by processor e.g. the previous set of commands . For instance the previously confirmed commands may be the previous set of commands that were stored by processor in the chain of memory units before the writing of the current set of commands for which processor was able to confirm that there was sufficient space in the chain of memory units and that there was sufficient space in the allocation list to store the handles associated with the previous set of commands.

If processor via graphics driver does not reach the end of the chain of memory units after writing the current set of commands NO of processor via graphics driver may determine whether there is sufficient space in an allocation list to store handles associated with the current set of commands . For example processor via graphics driver may determine whether adding the handles in the temporary list to the allocation list requires more space in the allocation list than available.

As one example processor may execute a confirm write command as part of the execution processor may attempt to add the handles in the temporary list to the allocation list. If the addition of the handles is unsuccessful processor may determine that adding the handles in the temporary list to the allocation list requires more space in the allocation than available. If the addition of the handles is successful processor may determine that adding the handles in the temporary list to the allocation list does not require more space in the allocation list than available. In this way processor may not need to determine ahead of time whether there is sufficient space in the allocation list to store the handles in the temporary list and may instead attempt without first checking if there is sufficient space in the allocation list to add handles in the temporary list to the allocation list.

If processor via graphics driver determines that there is not sufficient space in the allocation list to store the handles associated with the current set of commands NO of processor via graphics driver may submit the previously confirmed commands for eventual execution as described above . If processor via graphics driver determines that there is sufficient space in the allocation list to store the handles associated with the current set of commands YES of processor via graphics driver may move the confirm point to the end of the current set of commands . In addition graphics driver may store the handles associated with the current set of commands in the allocation list.

Processor may determine whether there is an additional set of commands that needs to be written to the command buffer . If there is an additional set of commands that needs to be written YES of the additional set of commands may be considered as the current set of commands the current set of command may be considered as the previously confirmed commands and the point to which processor moved the confirm point may be considered as the current confirm point. Processor may then write the current set of commands to memory units of the chain of memory units from the current confirm point e.g. the newly moved to confirm point . Processor may then repeat the example steps illustrated in . If there is not an additional set of commands that needs to be written NO of processor may end the writing of sets of commands until there is a set of commands that needs to be written.

Device may include additional modules or units not shown in for purposes of clarity. For example device may include a speaker and a microphone neither of which are shown in to effectuate telephonic communications in examples where device is a mobile wireless telephone or a speaker where device is a media player. Device may also include a video camera. Furthermore the various modules and units shown in device may not be necessary in every example of device . For example user interface and display may be external to device in examples where device is a desktop computer or other device that is equipped to interface with an external user interface or display.

Examples of user interface include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface may also be a touch screen and may be incorporated as a part of display . Transceiver module may include circuitry to allow wireless or wired communication between device and another device or a network. Transceiver module may include modulators demodulators amplifiers and other such circuitry for wired or wireless communication.

In some examples GPU may store a fully formed image in system memory . Display processor may retrieve the image from system memory and output values that cause the pixels of display to illuminate to display the image. Display may be the display of device that displays the image content generated by GPU . Display may be a liquid crystal display LCD an organic light emitting diode display OLED a cathode ray tube CRT display a plasma display or another type of display device.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on a computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

