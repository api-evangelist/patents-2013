---

title: Secure network labeling to control inter-process communications in a multi-tenant platform-as-a-service (PaaS) system
abstract: Implementations for secure network labeling to control inter-process communications in a multi-tenant Platform-as-a-Service (PaaS) system are disclosed. A method of the disclosure includes initializing, by a processing device of a node, a gear of an application on the node, wherein the node hosts a plurality of gears for a plurality of applications of a multi-tenant Platform-as-a-Service (PaaS) system, and wherein the plurality of applications comprising multi-tenant applications having different owners. The method further includes determining a user identifier (UID) of the gear, generating a custom network security label (NSL) of the gear, assigning the custom NSL to the gear, and applying the custom NSL to an outgoing network packet sent from the gear to another gear within the PaaS system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09300690&OS=09300690&RS=09300690
owner: Red Hat, Inc.
number: 09300690
owner_city: Raleigh
owner_country: US
publication_date: 20130703
---
The implementations of the disclosure relate generally to platform as a service PaaS environments and more specifically relate to secure network labeling to control inter process communications in a multi tenant PaaS system.

Currently a variety of Platform as a Service PaaS offerings exist that include software and or hardware facilities for facilitating the execution of web applications in a cloud computing environment the cloud . Cloud computing is a computing paradigm in which a customer pays a cloud provider to execute a program on computer hardware owned and or controlled by the cloud provider. It is common for cloud providers to make virtual machines hosted on its computer hardware available to customers for this purpose.

The cloud provider typically provides an interface that a customer can use to requisition virtual machines and associated resources such as processors storage and network services etc. as well as an interface a customer can use to install and execute the customer s program on the virtual machines that the customer requisitions together with additional software on which the customer s program depends. For some such programs this additional software can include software components such as a kernel and an operating system and or middleware and a framework. Customers that have installed and are executing their programs in the cloud typically communicate with the executing program from remote geographic locations using Internet protocols.

PaaS offerings typically facilitate deployment of web applications without the cost and complexity of buying and managing the underlying hardware software and provisioning hosting capabilities providing the facilities to support the complete life cycle of building delivering and servicing web applications are entirely available from the Internet. Typically these facilities operate as one or more virtual machines VMs running on top of a hypervisor in a host server. One of the goals of a PaaS offering is to provide the user as close to the same level of security that the user would get when running applications on machines that the user controlled.

Implementations of the disclosure provide for secure network labeling to control inter process communications in a multi tenant Platform as a Service PaaS system. Deployment of multiple applications of multiple users on a single node virtual machine VM is a cost efficient solution for PaaS providers. However deploying a multi tenant PaaS solution also raises a variety of concerns one of which includes security. Specifically security concerns exist in terms of separating multi tenant applications from accessing each other within a node as well as between nodes.

Some security solutions for PaaS systems provide that PaaS application instances called gears are separated using label based Mandatory Access Control MAC and uniquely assigned security labels within a node. As a result any gear is blocked from communicating with any other gear on the local node by the MAC security policy. A semi random yet unique security label may be selected for each one of the gears and its content with a security policy defined in such a way that blocks information flow between different gears on the system based on tenant agreements. If any gear tries to communicate with another gear with a different security label on the same node the MAC prevents the communication.

However such security solutions do not protect from inter process e.g. gear communication between nodes of the PaaS system. Furthermore standard procedures such as traditional firewalls are not ideal or capable of providing separation between processes. For instance firewalls typically do not have access to security label information to enforce the MAC security policy. In addition relying on each of the individual multi tenant applications to implement and enforce such inter process protection can be problematic and does not provide the same level of protection e.g. uniformity to the applications.

Implementations of the disclosure provide for an additional level of security for PaaS multi tenant applications by using network security labels NSLs to control inter process communication between nodes in a PaaS system. In particular MAC based security labeling can be extended over a network by assigning NSLs to network packets sent between nodes. Implementations may then enforce security policies on network traffic such that gears of a first application from a first node are able to communicate with gears of the first application on a second node while all other application gears from the first node would be blocked from communicating with the gears of the first application on the second node.

Clients and are connected to hosts on cloud and the cloud provider system via a network which may be a private network e.g. a local area network LAN a wide area network WAN intranet or other similar private networks or a public network e.g. the Internet . Each client may be a mobile device a PDA a laptop a desktop computer a tablet computing device a server device or any other computing device. Each host may be a server computer system a desktop computer or any other computing device. The cloud provider system may include one or more machines such as server computers desktop computers etc.

In one implementation the cloud provider system is coupled to a cloud controller via the network . The cloud controller may reside on one or more machines e.g. server computers desktop computers etc. and may manage the execution of applications in the cloud . In some implementations cloud controller receives commands from PaaS provider controller . Based on these commands the cloud controller provides data e.g. such as pre generated images associated with different applications to the cloud provider system . In some implementations the data may be provided to the cloud provider and stored in an image repository in an image repository not shown located on each host or in an image repository not shown located on each VM . This data provides applications for a multi tenant PaaS system managed by the PaaS provider controller .

In one implementation each host machine providing VMs running applications for the PaaS provider controller includes an operating system OS . Each OS may include a network security module to apply network labeling to network packets communicated between VMs . The network labeling provided by network security modules is used as part of a security policy applied to multi tenant applications running on the VMs providing the multi tenant PaaS system. In particular the security policy applied to the network labels on packets sent between VMs maintains a separation between applications on the VMs for security purposes such that a portion of a first application running on a first node e.g. VM may only communicate with another portion of that first application running on a second node e.g. VM and not portions of other applications running on the second node e.g. VM . Further details of the networking labeling for security in a PaaS systems are described below with respect to .

While various implementations are described in terms of the environment described above those skilled in the art will appreciate that the facility may be implemented in a variety of other environments including a single monolithic computer system as well as various other combinations of computer systems or similar devices connected in various ways. For example the data from the image repository may run directly on a physical host instead of being instantiated on a VM .

In one implementation the client layer resides on a client machine such as a workstation of a software developer and provides an interface to a user of the client machine to a broker layer of the PaaS system . For example the broker layer may facilitate the creation and deployment on the cloud via node layer of software applications being developed by an end user at client layer .

In one implementation the client layer includes a source code management system sometimes referred to as SCM or revision control system. One example of such an SCM or revision control system is Git available as open source software. Git and other such distributed SCM systems usually include a working directory for making changes and a local software repository for storing the changes for each application associated with the end user of the PaaS system . The packaged software application can then be pushed from the local SCM repository to a remote SCM repository such as app repost B at the node s running the associated application. From the remote SCM repository the code may be edited by others with access or the application may be executed by a machine. Other SCM systems work in a similar manner.

The client layer in one implementation also includes a set of command tools that a user can utilize to create launch and manage applications. In one implementation the command tools can be downloaded and installed on the user s client machine and can be accessed via a command line interface or a graphical user interface or some other type of interface. In one implementation the command tools expose an application programming interface API of the broker layer and perform other applications management tasks in an automated fashion using other interfaces as will be described in more detail further below in accordance with some implementations.

In one implementation the broker layer acts as middleware between the client layer and the node layer . The node layer includes the nodes on which software applications are provisioned and executed. In one implementation each node is a VM provisioned by an Infrastructure as a Service IaaS provider. In other implementations the nodes may be physical machines e.g. bare metal or VMs residing on a single physical machine and running gears discussed below that provide functionality of applications of a multi tenant PaaS system. In one implementation the broker layer is implemented on one or more machines such as server computers desktop computers etc. In some implementations the broker layer may be implemented on one or more machines separate from machines implementing each of the client layer and the node layer or may implemented together with the client layer and or the node layer on one or more machines or some combination of the above.

In one implementation the broker layer includes a broker that coordinates requests from the client layer with actions to be performed at the node layer . One such request is new application creation. In one implementation when a user using the command tools at client layer requests the creation of a new application or some other action to manage the application the broker first authenticates the user using an authentication service . In one implementation the authentication service may comprise custom authentication methods or standard protocols such as SAML OAuth etc. Once the user has been authenticated and allowed access to the system by authentication service the broker uses a server orchestration system to collect information and configuration information about the nodes 

In one implementation the broker uses the Marionette Collective MCollective framework available from Puppet Labs as the server orchestration system but other server orchestration systems may also be used. The server orchestration system in one implementation functions to coordinate server client interaction between multiple sometimes a large number of servers. In one implementation the servers being orchestrated are nodes which are acting as application servers and web servers.

In one implementation the broker manages the business logic and model representing the nodes and the applications residing on the nodes and acts as a controller that generates the actions requested by users via an API of the client tools . The server orchestration system then takes the actions generated by the broker and orchestrates their execution on the many nodes managed by the system.

In one implementation the information collected about the nodes can be stored in a data store . In one implementation the data store can be a locally hosted database or file store or it can be a cloud based storage service provided by a Storage as a Service SaaS provider such as Amazon S Simple Storage Service . The broker uses the information about the nodes and their applications to model the application hosting service and to maintain records about the nodes. In one implementation data of a node is stored in the form of a JavaScript Object Notation JSON blob or string that maintains key value pairs to associate a unique identifier a hostname a list of applications and other such attributes with the node.

In implementations of the disclosure the PaaS system architecture of is a multi tenant PaaS environment. In a multi tenant PaaS environment each node runs multiple applications that may be owned or managed by different users and or organizations. As such a first customer s deployed applications may co exist with any other customer s deployed applications on the same node VM that is hosting the first customer s deployed applications . In some implementations portions of an application are run on multiple different nodes . For example as shown in components of application are run in both node and node . Similarly application is run in node and node while application is run in node and node

In addition each node also maintains a cartridge library . The cartridge library maintains multiple software components referred to herein as cartridges that may be utilized by applications deployed on node . A cartridge can represent a form of support software or middleware providing the functionality such as configuration templates scripts dependencies to run an application and or add a feature to an application . In one implementation the cartridges support languages such as but not limited to JBoss PHP Ruby Python Perl and so on. In addition cartridges may be provided that support databases such as MySQL PostgreSQL Mongo and others. Cartridges may also be available that support the build and continuous integration environments such as a Jenkins cartridge. Lastly cartridges may be provided to support management capabilities such as PHPmyadmin RockMongo 10gen mms agent cron scheduler and HAProxy for example. Adding an instance of a cartridge from cartridge library to an application provides a capability for the application without the customer who owns the application having to administer or update the included capability.

Implementations of the disclosure provide for security between multi tenant applications hosted on nodes by assigning a custom network security label NSL to network packets sent between nodes . This custom NSL is unique to each application instance of the PaaS system and allows each node to prevent communications between different applications on different nodes . Each node may include an OS that implements a secure network labeling feature to apply to applications running on the node . The OS may include a network security module that provides custom NSLs for each application on the node and applies a security policy using the custom NSLs in order to protect applications from unauthorized communications. One embodiment of the interaction between nodes to implement secure networking labeling to control inter process communications in a multi tenant PaaS system is now described in more detail with reference to .

Each node also includes a server orchestration system agent configured to track and collect information about the node and to perform management actions on the node . Thus in one implementation using MCollective as the server orchestration system the server orchestration system agent can act as a MCollective server. The server orchestration system would then act as the MCollective client that can send requests queries and commands to the MCollective server on node 

As previously mentioned cartridges provide the underlying support software that implements the functionality of applications . In one implementation an application may utilize one or more cartridge instances that are run in one or more resource constrained gears on nodes . Cartridge library provides an OS based location outside of all application gears that acts as a source for cartridge instantiations that provide functionality for an application . An application may use more than one cartridge instance as part of providing functionality for the application . One example of this is a JavaEE application that uses a JBoss AS7 cartridge with a supporting MySQL database provided by a MySQL cartridge. Each cartridge instance may include a software repository that provides the particular functionality of the cartridge instance .

A gear is a resource constrained process space on the node to execute functionality of an application. In some implementations a gear is established by the node with resource boundaries including a limit and or designation of the amount of memory amount of storage and security types and or labels to be applied to any functions executed by the gear . In one implementation gears may be established using the Linux Containers LXC virtualization method. In further implementations gears may also be established using cgroups SELinux and kernel namespaces to name a few examples.

In some implementations cartridges instances for an application may execute in gears dispersed over more than one node as shown with application illustrated in . In other implementations cartridge instances for an application may run in one or more gears on the same node as shown with application on node in .

In one implementation OS includes a network security module that applies secure network labeling and policy enforcement to multi tenant applications that run on the node . Network security module includes a network labeling component and a security policy component . The network labeling component generates custom NSLs for each application running on the node . The security policy component applies network labeling security policies associated with the custom NSLs to the applications and their associated network traffic. Generally speaking the custom NSL is a security enhancement to an OS such as OS that allows administrators to label network packets with the security labels. These NSLs may then be used to constrain communication of the packet and processes i.e. applications trying to access the packet.

The network labeling component may generate custom e.g. unique NSLs to associate with each application instance running on the node . The custom NSL may be implemented using a Multi Category Security MCS feature of SELinux SELinux is an OS based feature that provides a flexible Mandatory Access Control MAC system.

The NSL may be a customization of the SELinux security context type. A security context in SELinux is a state given to a resource that uniquely identifies the permissions that are applicable to the resource. When a resource has no security context assigned to it SELinux gives the resource a default security context which generally has little permissions to perform any actions. The security context may be displayed using three to four definitions depending on the type of policy being run by SELinux . The definitions may include a user a role a type and a range of sensitivity levels and categories. In some implementations other security category labeling features from other OS vendors may be utilized.

Network labeling component may generate custom NSLs based on at least partially a unique user ID UID of the application . OS maintains a set of unique UIDs that are assigned to applications as they are installed on the node . In particular each gear of an application is assigned the UID of the application . In one implementation network labeling component generates the custom NSL for an application i.e. the gears of the application by applying a transform to the unique local UID of the application. In some implementations a SELinux label that is already associated with the application is used to generate the custom NSL for the application 

Because each application s UID is the same across nodes the custom NSL of an application is also the same across nodes . Thus the gears of application running on node have the same UID as the gears of application running on node . Accordingly all gears of application have the same UID and therefore the same custom NSL no matter which node they are running on. The mapping of UID to NSL may be stored by the network labeling component for example in a data store not shown of the node . In other implementations the mapping of UID to NSL may be performed on demand without storing the mapping. In some embodiments when the NSL is based on the SELinux security label the mapping of UID to NSL is not performed for purposes of generating the NSL.

After the custom NSLs are generated and mapped to their associated UIDs the networking labeling component applies the custom NSL to any network traffic i.e. network data packet sent from gear of an application to another node . In one embodiment the network labeling component applies the custom NSL as part of a header of an outgoing packet from a gear . In one implementation the custom NSL is part of a Commercial Internet Protocol Security Option CIPSO label of the outgoing packet. The CIPSO label is based on a labeling standard that defines an Internet Protocol IP security option that can be used to pass security information within and between computer systems. The CIPSO protocol supports a large number of security domains. Implementation of the disclosure may also support and implement security labeling protocols other than CIPSO as well. For example the Calipso labeling protocol or the IPsec labeling protocol may be utilized.

When a node receives network traffic the packet including the header information is parsed to determine the custom NSL associated with the packet. The security policy component may then use this custom NSL to apply security policies to the communication of the packet with respect to the destination gear of the receiving node . More specifically the security policy component determines whether the custom NSL associated with the destination gear of the packet is allowed to accept incoming network traffic having a a custom NSL of the received packet. If the security policy does not allow the interaction then the security policy component blocks denies communication of the packet to the destination. If the security policy does allow the interaction then the security policy component allows the communication of the packet to its destination gear .

As a result gears of the same application that are spread among multiple nodes can communicate with each other without being exposed to unwanted communications. For example gears of application running on node can receive communications from gears of application running on node but cannot receive communications from gears of application running on node

Method begins at block where a request to initialize a gear of a multi tenant application on a node of a PaaS system is received. In one embodiment the request is received at a server orchestration system agent of the node and includes a UID of the multi tenant application. At block a UID of the application associated with the gear is determined. As previously mentioned this UID may be part of the request to initialize the gear. In another implementation the node may request this information from a server orchestration system of the PaaS system.

At block a custom NSL for the gear is generated based on the determined UID. In one implementation a transform is applied to the UID to generate the custom NSL. The transform may be a transform that is universally applied to UID across the PaaS system to generate custom NSLs for gears. In other implementations the custom NSL is based on a SELinux security label that is already associated with the application. In this case the SELinux security label is determined based on the UID and utilized to generate e.g copy or apply some other function to the SELinux security label the custom NSL. Then at block the generated custom NSL is mapped to the UID of the gear. In one implementation the mapping is maintained in the data store of the node. In other implementations the mapping is not stored and block may be skipped.

Lastly at block when the gear sends any network packets to another node of the PaaS system the outgoing network packet is assigned a security label using the custom NSL. In one implementation the custom NSL is part of a security label in a header of the packet. For example the security label may be a CIPSO label. The custom NSL is added to any packets sent from the gear.

Method begins at block where an incoming network packet is received at a node of the PaaS system. The network packet may be directed to a gear of a multi tenant application running on the node. At block the packet is parsed to determine a first custom NSL. In one implementation the first custom NSL is part of a security label of the header such as a CIPSO label.

At block a second custom NSL that is associated with the destination gear of the node is determined. The second custom NSL may be determined by accessing a mapping of UIDs to custom NSLs maintained by the node. In one implementation the UID of the destination gear may be part of the header information of the received packet. In another implementation the SELinux security label of the receiving application is determined e.g. looked up and used as the second custom NSL.

At decision block it is determined whether a security policy of the OS of the node allows applications associated with the second custom NSL to received network packets labeled with the first custom NSL. In some implementations this first and second custom NSLs should match to satisfy the security policy. If so the method proceeds to block where the communication of the network packet is allowed to continue on to the destination gear. On the other hand if the first custom NSL and the second custom NSL do not match then method proceeds to block where the sending of the packet to the destination gear is block and or denied.

The computer system includes a processing device e.g. processor CPU etc. a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computer RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device communicably coupled to a network . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine accessible storage medium on which is stored software embodying any one or more of the methodologies of functions described herein. The software may also reside completely or at least partially within the main memory as instructions and or within the processing device as processing logic during execution thereof by the computer system the main memory and the processing device also constituting machine accessible storage media.

The machine readable storage medium may also be used to store instructions to implement a network security module to provide secure network labeling to control inter process communication in a multi tenant PaaS system such as the network security module described with respect to and or a software library containing methods that call the above applications. While the machine accessible storage medium is shown in an example implementation to be a single medium the term machine accessible storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine accessible storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instruction for execution by the machine and that cause the machine to perform any one or more of the methodologies of the disclosure. The term machine accessible storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

In the foregoing description numerous details are set forth. It will be apparent however that the disclosure may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the disclosure.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as sending receiving attaching forwarding caching referencing determining providing implementing or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The disclosure also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the method steps. The structure for a variety of these systems will appear as set forth in the description below. In addition the disclosure is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the disclosure as described herein.

The disclosure may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the disclosure. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. etc.

Whereas many alterations and modifications of the disclosure will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description it is to be understood that any particular implementation shown and described by way of illustration is in no way intended to be considered limiting. Therefore references to details of various implementations are not intended to limit the scope of the claims which in themselves recite only those features regarded as the disclosure.

