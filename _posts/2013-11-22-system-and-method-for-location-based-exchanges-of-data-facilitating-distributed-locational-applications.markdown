---

title: System and method for location based exchanges of data facilitating distributed locational applications
abstract: Provided is a distributed system and method for enabling new and useful location dependent features and functionality to mobile data processing systems. Mobile data processing systems (MSs) interact with each other as peers in communications and interoperability. Data is shared between mobile data processing systems to carry out novel Location Based eXchanges (LBX) of data for new mobile applications. Information which is transmitted inbound to, transmitted outbound from, or is in process at, a mobile data processing system, is used to trigger processing of actions in accordance with user configured permissions, charters, and other configurations. In a preferred embodiment, a user configurable platform is provided for quickly building well behaving LBX applications at MSs and across a plurality of interoperating MSs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09392408&OS=09392408&RS=09392408
owner: 
number: 09392408
owner_city: 
owner_country: 
publication_date: 20131122
---
This application is a continuation of application Ser. No. 12 287 064 filed Oct. 3 2008 and entitled System and Method for Location Based Exchanges of Data Facilitating Distributed Locational Applications which is a continuation in part of application Ser. No. 12 077 041 filed Mar. 14 2008 and entitled System and Method for Location Based Exchanges of Data Facilitating Distributed Locational Applications . This application contains an identical specification to Ser. No. 12 287 064 except for the title abstract and claims.

The present disclosure relates generally to location based services for mobile data processing systems and more particularly to location based exchanges of data between distributed mobile data processing systems for locational applications. A common connected service is not required for location based functionality and features. Location based exchanges of data between distributed mobile data processing systems enable location based features and functionality in a peer to peer manner.

The internet has exploded with new service offerings. Websites yahoo.com google.com ebay.com amazon.com and iTunes.com have demonstrated well the ability to provide valuable services to a large dispersed geographic audience through the internet ebay yahoo google amazon and iTunes Apple are trademarks of the respective companies . Thousands of different types of web services are available for many kinds of functionality. Advantages of having a service as the intermediary point between clients users and systems and their associated services includes centralized processing centralized maintaining of data for example to have an all knowing database for scope of services provided having a supervisory point of control providing an administrator with access to data maintained by users of the web service and other advantages associated with centralized control. The advantages are analogous to those provided by the traditional mainframe computer to its clients wherein the mainframe owns all resources data processing and centralized control for all users and systems clients that access its services. However as computers declined in price and adequate processing power was brought to more distributed systems such as Open Systems i.e. Windows UNIX Linux and Mac environments the mainframe was no longer necessary for many of the daily computing tasks. In fact adequate processing power is incorporated in highly mobile devices various handheld mobile data processing systems and other mobile data processing systems. Technology continues to drive improved processing power and data storage capabilities in less physical space of a device. Just as Open Systems took much of the load of computing off of mainframe computers so to can mobile data processing systems offload tasks usually performed by connected web services. As mobile data processing systems are more capable there is no need for a service to middleman interactions possible between them.

While a centralized service has its advantages there are also disadvantages. A service becomes a clearinghouse for all web service transactions. Regardless of the number of threads of processing spread out over hardware and processor platforms the web service itself can become a bottleneck causing poor performance for timely response and can cause a large amount of data that must be kept for all connected users and or systems. Even large web services mentioned above suffer from performance and maintenance overhead. A web service response will likely never be fast enough. Additionally archives must be kept to ensure recovery in the event of a disaster because the service houses all data for its operations. Archives also require storage processing power planning and maintenance. A significantly large and costly data center is necessary to accommodate millions of users and or systems to connect to the service. There is a tremendous amount of overhead in providing such a service. Data center processing power data capacity data transmission bandwidth and speed infrastructure entities and various performance considerations are quite costly. Costs include real estate required utility bills for electricity and cooling system maintenance personnel to operate a successful business with service s etc. A method is needed to prevent large data center costs while eliminating performance issues for features sought. It is inevitable that as users are hungry for more features and functionality on their mobile data processing systems processing will be moved closer to the device for optimal performance and infrastructure cost savings.

Service delivered location dependent content was disclosed in U.S. Pat. Nos. 6 456 234 6 731 238 7 187 997 Johnson . Anonymous location based services was disclosed in U.S. PTO Publication 2006 0022048 Johnson . The Johnson patents and published application operate as most web services do in that the clients connecting to the service benefit from the service by having some connectivity to the service. U.S. Publication 2006 0022048 Johnson could cause large numbers of users to inundate the service with device heartbeats and data to maintain depending on the configurations made. While this may be of little concern to a company that has successfully deployed substantially large web service resources it may be of great concern to other more frugal companies. A method is needed for enabling location dependent features and functionality without the burden of requiring a service.

Users are skeptical about their privacy as internet services proliferate. A service by its very nature typically holds information for a user maintained in a centralized service database. The user s preferences credential information permissions customizations billing information surfing habits and other conceivable user configurations and activity monitoring can be housed by the service at the service. Company insiders as well as outside attackers may get access. Most people are concerned with preventing personal information of any type being kept in a centralized database which may potentially become compromised from a security standpoint. Location based services are of even more concern in particular when the locations of the user are to be known to a centralized service. A method and system is needed for making users comfortable with knowing that their personal information is at less risk of being compromised.

A reasonable requirement is to push intelligence out to the mobile data processing systems themselves for example in knowing their own locations and perhaps the locations of other nearby mobile data processing systems. Mobile data processing systems can intelligently handle many of their own application requirements without depending on some remote service. Just as two people in a business organization should not need a manager to speak to each other no two mobile data processing systems should require a service middleman for useful location dependent features and functionality. The knowing of its own location should not be the end of social interaction implementation local to the mobile data processing systems but rather the starting place for a large number of useful distributed local applications that do not require a service.

Different users use different types of Mobile data processing Systems MSs which are also called mobile devices laptops tablet computers Personal Computers PCs Personal Digital Assistants PDAs cell phones automobile dashboard mounted data processing systems shopping cart mounted data processing systems mobile vehicle or apparatus mounted data processing systems Personal Navigational Devices PNDs iPhones iPhone is a trademark of Apple Inc. various handheld mobile data processing systems etc. MSs move freely in the environment and are unpredictably moveable i.e. can be moved anywhere anytime . Many of these Mobile data processing Systems MSs do not have capability of being automatically located or are not using a service for being automatically located. Conventional methods use directly relative stationary references such as satellites antennas etc. to locate MSs. Stationary references are expensive to deploy and risk obsolescence as new technologies are introduced to the marketplace. Stationary references have finite scope of support for locating MSs.

While the United States E911 mandate for cellular devices documents requirements for automatic location of a Mobile data processing System MS such as a cell phone the mandate does not necessarily promote real time location and tracking of the MSs nor does it define architecture for exploiting Location Based Services LBS . We are in an era where Location Based Services LBS and location dependent features and functionality are among the most promising technologies in the world. Automatic locating of every Mobile data processing System MS is an evolutionary trend. A method is needed to shorten the length of time for automatically locating every MS. Such a goal can be costly using prior art technologies such as GPS Global Positioning System radio wave triangulation coming within range to a known located sensor or the like. Complex system infrastructure or added hardware costs to the MSs themselves make such ventures costly and time constrained by schedules and costs involved in engineering construction and deployment.

A method is needed for enabling users to get location dependent features and functionality through having their mobile locations known regardless of whether or not their MS is equipped for being located. Also new and modern location dependent features and functionality can be provided to a MS unencumbered by a connected service.

LBS Location Based Services is a term which has gained in popularity over the years as MSs incorporate various location capability. The word Services in that terminology plays a major role in location based features and functionality involving interaction between two or more users. This disclosure introduces a new terminology system and method referred to as Location Based eXchanges LBX . LBX is an acronym used interchangeably contextually throughout this disclosure for the singular term Location Based Exchange and for the plural term Location Based Exchanges much the same way LBS is used interchangeably contextually for the single term Location Based Service and for the plural term Location Based Services . LBX describes leveraging the distributed nature of connectivity between MSs in lieu of leveraging a common centralized service nature of connectivity between MSs. The line can become blurred between LBS and LBX since the same or similar features and functionality are provided and in some cases strengths from both may be used. The underlying architectural shift differentiates LBX from LBS for depending less on centralized services and more on distributed interactions between MSs. LBX provide server free and server less location dependent features and functionality.

Disclosed are many different aspects to LBX starting with the foundation requirement for each participating MS to know at some point in time their own whereabouts. LBX is enabled when an MS knows its own whereabouts. It is therefore a goal to first make as many MSs know their own whereabouts as possible. When two or more MSs know their own whereabouts LBX enables distributed locational applications whereby a server is not required to middleman social interactions between the MSs. The MSs interact as peers. LBX disclosed include purely peer to peer interactions peer to peer interactions for routing services peer to peer interactions for delivering distributed services and peer to peer interactions for location dependent features and functionality. One embodiment of an LBX enabled MS is referred to as an lbxPhone .

It is an advantage herein to have no centralized service governing location based features and functionality among MSs. Avoiding a centralized service prevents performance issues infrastructure costs and solves many of the issues described above. No centralized service also prevents a user s information from being kept in one accessible place. LBS contain centralized data that is personal in nature to its users. This is a security concern. Having information for all users in one place increases the likelihood that a disaster to the data will affect more than a single user. LBX spreads data out across participating systems so that a disaster affecting one user does not affect any other user.

It is an advantage herein for enabling useful distributed applications without the necessity of having a service and without the necessity of users and or systems registering with a service. MSs interact as peers in preferred embodiments rather than as clients to a common service e.g. internet connected web service .

It is an advantage herein for locating as many MSs as possible in a wireless network and without additional deployment costs on the MSs or the network. Conventional locating capability includes GPS Global Positioning System using stationary orbiting satellites improved forms of GPS for example AGPS Adjusted GPS and DGPS Differential GPS using stationary located ground stations wireless communications to stationary located cell tower base stations TDOA Time Difference of Arrival or AOA Angle of Arrival triangulation using stationary located antennas presence detection in vicinity of a stationary located antenna presence detection at a wired connectivity stationary network location or other conventional locating systems and methods. Mobile data processing systems referred to as Indirectly Located Mobile data processing systems ILMs are automatically located using automatically detected locations of Directly Located Mobile data processing systems DLMs and or automatically detected locations of other ILMs. ILMs are provided with the ability to participate in the same LBS or LBX as a DLM Directly Located Mobile data processing system . DLMs are located using conventional locating capability mentioned above. DLMs provide reference locations for automatically locating ILMs regardless of where any one is currently located. DLMs and ILMs can be highly mobile for example when in use by a user. There are a variety of novel methods for automatically locating ILMs for example triangulating an ILM Indirectly Located Mobile data processing system location using a plurality of DLMs detecting the ILM being within the vicinity of at least one DLM triangulating an ILM location using a plurality of other ILMs detecting the ILM being within the vicinity of at least one other ILM triangulating an ILM location using a mixed set of DLM s and ILM s determining the ILM location from heterogeneously located DLMs and or ILMs and other novel methods.

MSs are automatically located without using direct conventional means for being automatically located. The conventional locating capability i.e. conventional locating methods described above is also referred to as direct methods. Conventional methods are direct methods but not all direct methods are conventional. There are new direct techniques disclosed below. Provided herein is an architecture as well as systems and methods for immediately bringing automatic location detection to every MS in the world regardless of whether that MS is equipped for being directly located. MSs without capability of being directly located are located by leveraging the automatically detected locations of MSs that are directly located. This is referred to as being indirectly located. An MS which is directly located is hereinafter referred to as a Directly Located Mobile data processing system DLM . For a plural acronym MSs which are directly located are hereinafter referred to as Directly Located Mobile data processing systems DLMs . MSs without capability of being directly located are located using the automatically detected locations of MSs that have already been located. An MS which is indirectly located is hereinafter referred to as an Indirectly Located Mobile data processing system ILM . For a plural acronym MSs which are indirectly located are hereinafter referred to as Indirectly Located Mobile data processing systems ILMs . A DLM can be located in the following ways 

In one example the mobile locations of several MSs are automatically detected using their local GPS chips. Each is referred to as a DLM. The mobile location of a non locatable MS is triangulated using radio waves between it and three 3 of the GPS equipped DLMs. The MS becomes an ILM upon having its location determined relative the DLMs. ILMs are automatically located using DLMs or other already located ILMs. An ILM can be located in the following ways 

Locating functionality may leverage GPS functionality including but not limited to GPS AGPS Adjusted GPS DGPS Differential GPS or any improved GPS embodiment to achieve higher accuracy using known locations for example ground based reference locations. The NexTel GPS enabled iSeries cell phones provide excellent examples for use as DLMs Nextel is a trademark of Sprint Nextel . Locating functionality may incorporate triangulated locating of the MS for example using a class of Radio Frequency RF wave spectrum cellular WiFi some WiFi embodiments referred to as WiMax bluetooth etc and may use measurements from different wave spectrums for a single location determination depends on communications interface s available . A MS may have its whereabouts determined using a plurality of wave spectrum classes available to it cellular WiFi bluetooth etc . The term WiFi used throughout this disclosure also refers to the industry term WiMax . Locating functionality may include in range proximity detection for detecting the presence of the MS. Wave forms for triangulated locating also include microwaves infrared wave spectrum relative infrared sensors visible light wave spectrum relative light visible light wave sensors ultraviolet wave spectrum relative ultraviolet wave sensors X ray wave spectrum relative X ray wave sensors gamma ray wave spectrum relative gamma ray wave sensors and longwave spectrum below AM relative longwave sensors. While there are certainly more common methods for automatically locating a MS e.g. radio wave triangulation GPS in range proximity detection those skilled in the art recognize there are methods for different wave spectrums being detected measured and used for carrying information between data processing systems.

Kubler et al U.S. PTO publications 2004 0264442 2004 0246940 2004 0228330 2004 0151151 disclosed methods for detecting presence of mobile entities as they come within range of a sensor. In Kubler et al accuracy of the location of the detected MS is not well known so an estimated area of the whereabouts of the MS is enough to accomplish intended functionality for example in warehouse installations. A confidence value of this disclosure associated with Kubler et al tends to be low i.e. not confident with lower values for long range sensors and higher values for short range sensors.

GPS and the abundance of methods for improving GPS accuracy has led to many successful systems for located MSs with high accuracy. Triangulation provides high accuracies for locating MSs. A confidence value of this disclosure associated with GPS and triangulating location methods tends to be high i.e. confident . It is preferred that DLMs use the highest possible accuracy method available so that relative ILMs are well located. Not all DLMs need to use the same location methods. An ILM can be located relative DLMs or other ILMs that each has different locating methodologies utilized.

Another advantage herein is to generically locate MSs using varieties and combinations of different technologies. MSs can be automatically located using direct conventional methods for accuracy to base on the locating of other MSs. MSs can be automatically located using indirect methods. Further it is an advantage to indirectly locate a MS relative heterogeneously located MSs. For example one DLM may be automatically located using GPS. Another DLM may be automatically located using cell tower triangulation. A third DLM may be automatically located using within range proximity. An ILM can be automatically located at a single location or different locations over time relative these three differently located DLMs. The automatically detected location of the ILM may be determined using a form of triangulation relative the three DLMs just discussed even though each DLM had a different direct location method used. In a preferred embodiment industry standard IEEE 802.11 WiFi is used to locate triangulate an ILM relative a plurality of DLMs e.g. TDOA in one embodiment . This standard is prolific among more compute trended MSs. Any of the family of 802.11 wave forms such as 802.11a 802.11b 802.11g or any other similar class of wave spectrum can be used and the same spectrum need not be used between a single ILM and multiple DLMs. 802.x used herein generally refers to the many 802.whatever variations.

Another advantage herein is to make use of existing marketplace communications hardware communications software interfaces and communications methods and location methods where possible to accomplish locating an MS relative one or more other MSs. While 802.x is widespread for WiFi communications other RF wave forms can be used e.g. cell phone to cell tower communications . In fact any wave spectrum for carrying data applies herein.

Still another advantage is for support of heterogeneous locatable devices. Different people like different types of devices as described above. Complete automation of locating functionality can be provided to a device through local automatic location detection means or by automatic location detection means remote to the device. Also an ILM can be located relative a laptop a cell phone and a PDA i.e. different device types .

Yet another advantage is to prevent the unnecessary storing of large amounts of positioning data for a network of MSs. Keeping positioning data for knowing the whereabouts of all devices can be expensive in terms of storage infrastructure performance backup and disaster recovery. A preferred embodiment simply uses a distributed approach to determining locations of MSs without the overhead of an all knowing database maintained somewhere. Positions of MSs can be determined on the fly without storing information in a master database. However there are embodiments for storing a master database or a subset thereof to configurable storage destinations when it makes sense. A subset can be stored at a MS.

Another advantage includes making use of existing location equipped MSs to expand the network of locatable devices by locating non equipped MSs relative the location of equipped MSs. MSs themselves help increase dimensions of the locatable network of MSs. The locatable network of MSs is referred to as an LN Expanse i.e. Location Network Expanse . An LN Expanse dynamically grows and shrinks based on where MSs are located at a particular time. For example as users travel with their personal MSs the personal MSs themselves define the LN Expanse since the personal MSs are used to locate other MSs. An ILM simply needs location awareness relative located MSs DLMs and or ILMs .

Yet another advantage is a MS interchangeably taking on the role of a DLM or ILM as it travels. MSs are chameleons in this regard in response to location technologies that happen to be available. A MS may be equipped for DLM capability but may be in a location at some time where the capability is inoperable. In these situations the DLM takes on the role of an ILM. When the MS again enters a location where it can be a DLM it automatically takes on the role of the DLM. This is very important in particular for emergency situations. A hiker has a serious accident in the mountains which prevents GPS equipped DLM capability from working. Fortunately the MS automatically takes on the role of an ILM and is located within the vicinity of neighboring nearby MSs. This allows the hiker to communicate his location operate useful locational application functions and features at his MS and enable emergency help that can find him.

It is a further advantage that MS locations be triangulated using any wave forms e.g. RF microwaves infrared visible light ultraviolet X ray gamma ray . X ray and gamma ray applications are special in that such waves are harmful to humans in short periods of times and such applications should be well warranted to use such wave forms. In some medical embodiments micro machines may be deployed within a human body. Such micro machines can be equipped as MSs. Wave spectrums available at the time of deployment can be used by the MSs for determining exact positions when traveling through a body.

It is another advantage to use TDOA Time Difference Of Arrival AOA Angle Of Arrival and Missing Part Triangulation MPT when locating a MS. TDOA uses time information to determine locations for example for distances of sides of a triangle. AOA uses angles of arrival to antennas to geometrically assess where a MS is located by intersecting lines drawn from the antennas with detected angles. MPT is disclosed herein as using combinations of AOA and TDOA to determine a location. Exclusively using all AOA or exclusively using all TDOA is not necessary. MPT can be a direct method for locating MSs.

Yet another advantage is to locate MSs using Assisted Direct Location Technology ADLT . ADLT is disclosed herein as using direct conventional location capability together with indirect location capability to confidently determine the location of a MS.

Still another advantage is to permit manual specification for identifying the location of a MS a DLM . The manual location can then in turn be used to facilitate locating other MSs. A user interface may be used for specification of a DLM location. The user interface can be local or remote to the DLM. Various manual specification methods are disclosed. Manual specification is preferably used with less mobile MSs or existing MSs such as those that use dodgeball.com trademark of Google . The confidence value depends on how the location is specified whether or not it was validated and how it changes when the MS moves after being manually set. Manual specification should have limited scope in an LN expanse unless inaccuracies can be avoided.

Another advantage herein is locating a MS using any of the methodologies above any combinations of the methodologies above and any combinations of direct and or indirect location methods described.

Another advantage is providing synergy between different locating technologies for smooth operations as an MS travels. There are large numbers of methods and combinations of those methods for keeping an MS informed of its whereabouts. Keeping an MS informed of its whereabouts in a timely manner is critical in ensuring LBX operate optimally and for ensuring nearby MSs without certain locating technologies can in turn be located.

It is another advantage for locating an MS with multiple location technologies during its travels and in using the best of breed data from multiple location technologies to infer a MS location confidently. Confidence values are associated with reference location information to ensure an MS using the location information can assess accuracy. A DLM is usually an affirmifier . An affirmifier is an MS with its whereabouts information having high confidence of accuracy and can serve as a reference for other MSs. An ILM can also be an affirmifier provided there is high confidence that the ILM location is known. An MS e.g. ILM may be a pacifier . A pacifier is an MS having location information for its whereabouts with a low confidence for accuracy. While it can serve as a reference to other ILMs it can only do so by contributing a low confidence of accuracy.

It is an advantage to synergistically make use of the large number of locating technologies available to prevent one particular type of technology to dominate others while using the best features of each to assess accurate mobile locations of MSs.

A further advantage is to leverage a data processing system with capability of being located for co locating another data processing system without any capability of being located. For example a driver owns an older model automobile has a useful second data processing system in the automobile without means for being automatically located. The driver also own a cell phone called a first data processing system which does have means for being automatically located. The location of the first data processing system can be shared with the second data processing system for locating the second data processing system. Further still the second data processing system without means for being automatically located is located relative a first set plurality of data processing systems which are not at the same location as the second data processing system. So data processing systems are automatically located relative at least one other data processing which can be automatically located.

Another advantage is a LBX enabled MS includes a service informant component for keeping a supervisory service informed. This prevents an MS from operating in total isolation and prevents an MS from operating in isolation with those MSs that are within its vicinity e.g. within maximum range at some point in time but to also participate when the same MSs are great distances from each other. There are LBX which would fit well into an LBS model but a preferred embodiment chooses to use the LBX model. For example multiple MS users are seeking to carpool to and from a common destination. The service informant component can perform timely updates to a supervisory service for route comparisons between MSs even though periods of information are maintained only at the MSs. For example users find out that they go to the same church with similar schedules or coworkers find out they live nearby and have identical work schedules. The service informant component can keep a service informed of MS whereabouts to facilitate novel LBX applications.

It is a further advantage in leveraging the vast amount of MS WiFi WiMax deployment underway in the United States. More widespread WiFi WiMax availability enhances the ability for well performing peer to peer types of features and functionality disclosed.

It is a further advantage to prevent unnecessary established connections from interfering with successfully triangulating a MS position. As the MS roams and encounters various wave spectrum signals that is all that is required for determining the MS location. Broadcast signaling contains the necessary location information for automatically locating the MS.

Yet another advantage is to leverage Network Time Protocol NTP for eliminating bidirectional communications in determining Time of Arrival TOA and TDOA Time Difference Of Arrival measurements TDOA as used in the disclosure generally refers to both TOA and TDOA . NTP enables a single unidirectional transmission of data to carry all that is necessary in determining TDOA provided the sending data processing system and the receiving data processing system are NTP synchronized to an adequate granulation of time.

It is an advantage of this disclosure to provide a competing superior alternative to server based mobile technologies such as that of U.S. Pat. Nos. 6 456 234 6 731 238 7 187 997 and U.S. PTO Publication 2006 0022048 Johnson . It is also an advantage to leverage both LBX technology and LBS technology in the same MS in order to improve the user experience. The different technologies can be used to complement each other in certain embodiments.

A further advantage herein is to leverage existing usual communications data transmissions for carrying new data that is ignored by existing MS processing but observed by new MS processing for carrying out processing maximizing location functions and features across a large geography. Alternatively new data can be transmitted between systems for the same functionality.

It is an advantage herein in providing peer to peer service propagation. ILMs are provided with the ability to participate in the same Location Based Services LBS or other services as DLM s in the vicinity. An MS may have access to services which are unavailable to other MSs. Any MS can share its accessible services for being accessible to any other MS preferably in accordance with permissions. For example an MS without internet access can get internet access via an MS in the vicinity with internet access. In a preferred embodiment permissions are maintained in a peer to peer manner prior to lookup for proper service sharing. In another embodiment permissions are specified and used at the time of granting access to the shared services. Once granted for sharing services can be used in a mode as if the sharing user is using the services or in a mode as if the user accepting the share is a new user to the service. Routing paths are dynamically reconfigured and transparently used as MSs travel. Hop counts dynamically change to strive for a minimal number of hops for an MS getting access to a desirable service. Route communications depend on where the MS needing the service is located relative a minimal number of hops through other MSs to get to the service. Services can be propagated from DLMs to DLMS DLMs to ILMs or ILMs to ILMs.

It is another advantage herein for providing peer to peer permissions authentication and access control. A service is not necessary for maintaining credentials and permissions between MSs. Permissions are maintained locally to a MS. In a centralized services model a database can become massive in size when searching for needed permissions. Permission searching and validation of U.S. PTO Publication 2006 0022048 Johnson was costly in terms of database size and performance. There was overhead in maintaining who owned the permission configuration for every permission granted. Maintaining permissions locally as described below reduces the amount of data to represent the permission because the owner is understood to be the personal user of the MS. Additionally permission searching is very fast because the MS only has to search its local data for permissions that apply to only its MS.

Yet another advantage is to provide a nearby or nearness status using a peer to peer system and method rather than intelligence maintained in a centralized database for all participating MSs. There is lots of overhead in maintaining a large database containing locations of all known MSs. This disclosure removes such overhead through using nearby detection means of one MS when in the vicinity of another MS. There are varieties of controls for governing how to generate the nearby status. In one aspect a MS automatically calls the nearby MS thereby automatically connecting the parties to a conversation without user interaction to initiate the call. In another aspect locally maintained configurations govern functionality when MSs are newly nearby or are newly departing being nearby. Nearby status alerts and queries are achieved in a LBX manner.

It is yet another advantage for automatic call forwarding call handling and call processing based on the whereabouts of a MS or whereabouts of a MS relative other MSs. The nearness condition of one MS to another MS can also affect the automatic call forwarding functionality.

Yet another advantage herein is for peer to peer content delivery and local MS configuration of that content. Users need no connectivity to a service. Users make local configurations to enjoy location based content delivery to other MSs. Content is delivered under a variety of circumstances for a variety of configurable reasons. Content maintained local to an MS is delivered asynchronously to other MSs for nearby alerts arrival or departure to and from geofenced areas and other predicated conditions of nearby MSs. While it may appear there are LBS made available to users of MSs there are in fact LBX being made available to those users.

Another advantage herein is a LBX enabled MS can operate in a peer to peer manner to data processing systems which control environmental conditions. For example automobile equipped or driver kept MSs encounter an intersection having a traffic light. Interactions between the MSs at the intersection and a data processing system in the vicinity for controlling the traffic light can automatically override light color changing for optimal traffic flow. In another embodiment a parking lot search by a user with an MS is facilitated as he enters the parking lot and in accordance with parking spaces currently occupied. In general other nearby data processing systems can have their control logic processed for a user s preferences as defined in the MS a group of nearby user s preferences and or situational locations see U.S. Pat. Nos. 6 456 234 6 731 238 7 187 997 Johnson for situational location terminology of nearby MSs.

Another advantage herein is an MS maintains history of hotspot locations detected for providing graphical indication of hotspot whereabouts. This information can be used by the MS user in guiding where a user should travel in the future for access to services at the hotspot. Hotspot growth prevents a database in being timely configured with new locations. The MS can learn where hotspots are located as relevant to the particular MS. The hotspot information is instantly available to the MS.

A further advantage is for peer to peer proximity detection for identifying a peer service target within the MS vicinity. A peer service target can be acted upon by an MS within range using an application at the MS. The complementary whereabouts of the peer service target and MS automatically notify the user of service availability. The user can then use the MS application for making a payment or for performing an account transfer account deposit account deduction or any other transaction associated with the peer service target.

Yet another advantage is for a MS to provide new self management capability such as automatically marking photographs taken with location information a date time stamp and who was with the person taking the picture.

Yet another advantage is being alerted to nearby people needing assistance and nearby fire engines or police cars that need access to roads.

A further advantage is providing a MS platform for which new LBX features and functionality can be brought quickly to the marketplace. The platform caters to a full spectrum of users including highly technical software developers novice users and users between those ranges. A rich programming environment is provided wherein whereabouts WDR information interchanged with other MSs in the vicinity causes triggering of privileged actions configured by users. The programming environment can be embedded in or plugged into an existing software development environment or provided on its own. A syntax may be specified with source code statements XML SQL database definitions a datastream or any other derivative of a well defined BNF grammar. A user friendly configuration environment is provided wherein whereabouts information interchanged with other MSs in the vicinity causes triggering of privileged actions configured by users. The platform is an event based environment wherein WDRs containing certain configured sought information are recognized at strategic processing paths for causing novel processing of actions. Events can be defined with complex expressions and actions can be defined using homegrown executables APIs scripts applications a set of commands provided with the LBX platform or any other executable processing. The LBX platform includes a variety of embodiments for charter and permission definitions including an internalized programmatic form a SQL database form a data record form a datastream form and a well defined BNF grammar for deriving other useful implementations e.g. lex and yacc .

It is another advantage to support a countless number of privileges that can be configured managed and processed in a peer to peer manner between MSs. Any peer to peer feature or set of functionality can have a privilege associated to it for being granted from one user to another. It is also an advantage for providing a variety of embodiments for how to manage and maintain privileges in a network of MSs.

It is another advantage to support a complete set of options for charters that can be configured managed and processed in a peer to peer manner between MSs. Charters can become effective under a comprehensive set of conditions expressions terms and operators. It is also an advantage for providing a variety of embodiments for how to manage and maintain charters in a network of MSs.

It is a further advantage for providing multithreaded communications of permission and charter information and transactions between MSs for well performing peer to peer interactions. Any signal spectrum for carrying out transmission and reception is candidate depending on the variety of MS. In fact different signaling wave spectrums types and protocols may be used in interoperating communications or even for a single transaction between MSs.

It is yet another advantage for increasing the range of the LN expanse from a wireless vicinity to potentially infinite vicinity through other data processing e.g. routing equipment. While wireless proximity is used for governing automatic location determination whereabouts information may be communicated between MSs great distances from each other provided there are privileges and or charters in place making such whereabouts information relevant for the MS. Whereabouts information of others will not be maintained unless there are privileges in place to maintain it. Whereabouts information may not be shared with others if there have been no privileges granted to a potential receiving MS. Privileges can provide relevance to what whereabouts WDR information is of use or should be processed maintained or acted upon.

Further features and advantages of the disclosure as well as the structure and operation of various embodiments of the disclosure are described in detail below with reference to the accompanying drawings. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number except that reference numbers through may be found on the first 4 drawings of . None of the drawings discussions or materials herein is to be interpreted as limiting to a particular embodiment. The broadest interpretation is intended. Other embodiments accomplishing same functionality are within the spirit and scope of this disclosure. It should be understood that information is presented by example and many embodiments exist without departing from the spirit and scope of this disclosure.

With reference now to detail of the drawings the present disclosure is described. Obvious error handling is omitted from the flowcharts in order to focus on the key aspects of the present disclosure. Obvious error handling includes database I O errors field validation errors errors as the result of database table data constraints or unique keys data access errors communications interface errors or packet collision hardware failures checksum validations bit error detections corrections and any other error handling as well known to those skilled in the relevant art in context of this disclosure. A semicolon may be used in flowchart blocks to represent and separate multiple blocks of processing within a single physical block. This allows simpler flowcharts with less blocks in the drawings by placing multiple blocks of processing description in a single physical block of the flowchart. Flowchart processing is intended to be interpreted in the broadest sense by example and not for limiting methods of accomplishing the same functionality. Preferably field validation in the flowcharts checks for SQL injection attacks communications protocol sniff and hack attacks preventing of spoofing MS addresses syntactical appropriateness and semantics errors where appropriate. Disclosed user interface processing and or screenshots are also preferred embodiment examples that can be implemented in other ways without departing from the spirit and scope of this disclosure. Alternative user interfaces since this disclosure is not to be limiting will use similar mechanisms but may use different mechanisms without departing from the spirit and scope of this disclosure.

Locational terms such as whereabouts location position area destination perimeter radius geofence situational location or any other related two or three dimensional locational term used herein to described position s and or locations and or whereabouts is to be interpreted in the broadest sense. Location field may include an area e.g. on earth a point e.g. on earth or a three dimensional bounds in space. In another example a radius may define a sphere in space rather than a circle in a plane. In some embodiments a planet field forms part of the location e.g. Earth Mars etc as part of field for which other location information e.g. latitude and longitude on Mars also part of field is relative. In some embodiments elevations or altitudes from known locatable point s distances from origin s in the universe etc. can denote where exactly is a point of three dimensional space or three dimensional sphere area or solid is located. That same point can provide a mathematical reference to other points of the solid area region in space. Descriptions for angles pitches rotations etc from some reference point s may be further provided. Three dimensional areas regions include a conical shape cubical shape spherical shape pyramidal shape irregular shapes or any other shape either manipulated with a three dimensional graphic interface or with mathematical model descriptions. Areas regions in space can be occupied by a MS passed through e.g. by a traveler by a MS or referenced through configuration by a MS. In a three dimensional embodiment nearby nearness is determined in terms of three dimensional information for example a spherical radius around one MS intersecting a spherical radius around another MS. In a two dimensional embodiment nearby nearness is determined in terms of two dimensional information for example a circular radius around one MS intersecting a circular radius around another MS. Points can be specified as a point in a x y z plane a point in polar coordinates or the like perhaps the center of a planet e.g. Earth or the Sun some origin in the Universe or any other origin for distinctly locating three dimensional location s positions or whereabouts in space. Elevation e.g. for earth or some other planet etc may be useful to the three dimensional point of origin and or for the three dimensional region in space. A region in space may also be specified with connecting x y z coordinates together to bound the three dimensional region in space. There are many methods for representing a location field without departing from the spirit and scope of this disclosure. MSs for example as carried by users can travel by airplane through three dimensional areas regions in space or travel under the sea through three dimensional regions in space.

Various embodiments of communications between MSs or an MS and service s will share channels e.g. frequencies to communicate depending on when in effect. Sharing a channel will involve carrying recognizable and processable signature to distinguish transmissions for carrying data. Other embodiments of communications between MSs or an MS and service s will use distinct channels to communicate depending on when in effect. The number of channels that can be concurrently listened on and or concurrently transmitted on by a data processing system will affect which embodiments are preferred. The number of usable channels will also affect which embodiments are preferred. This disclosure avoids unnecessary detail in different communication channel embodiments so as to not obfuscate novel material. Independent of various channel embodiments within the scope and spirit of the present disclosure MSs communicate with other MSs in a peer to peer manner in some aspects like automated walkie talkies.

Novel features disclosed herein need not be provided as all or none. Certain features may be isolated in some MS embodiments or may appear as any subset of features and functionality in other embodiments.

LBX character preferably includes at least Peer Interaction Processing PIP code Peer Interaction Processing PIP data self management processing code self management processing data WDR queue send queue receive queue service informant code and LBX history . Peer interaction processing PIP code comprises executable code in software firmware or hardware form for carrying out LBX processing logic of the present disclosure when interacting with another MS. Peer interaction processing PIP data comprises data maintained in any sort of memory of MS for example hardware memory flash memory hard disk memory a removable memory device or any other memory means accessible to MS . PIP data contains intelligence data for driving LBX processing logic of the present disclosure when interacting with other MSs. Self management processing code comprises executable code in software firmware or hardware form for carrying out the local user interface LBX processing logic of the present disclosure. Self management processing data contains intelligence data for driving processing logic of the present disclosure as disclosed for locally maintained LBX features. WDR queue contains Whereabouts Data Records WDRs and is a First In First Out FIFO queue when considering housekeeping for pruning the queue to a reasonable trailing history of inserted entries i.e. remove stale entries . WDR queue is preferably designed with the ability of queue entry retrieval processing similar to Standard Query Language SQL querying wherein one or more entries can be retrieved by querying with a conditional match on any data field s of WDR and returning lists of entries in order by an ascending or descending key on one or any ascending descending ordered list of key fields.

All disclosed queues e.g. and See are implemented with an appropriate thread safe means of queue entry peeking makes copy of sought queue entry without removing discarding retrieval insertion and queue entry field sorted search processing. Queues are understood to have an associated implicit semaphore to ensure appropriate synchronous access to queue data in a multi threaded environment to prevent data corruption and misuse. Such queue interfaces are well known in popular operating systems. In MS operating system environments which do not have an implicit semaphore protected queue scheme queue accesses in the present disclosure flowcharts are to be understood to have a previous request to a queue assigned semaphore lock prior to queue access and a following release of the semaphore lock after queue access. Operating systems without semaphore control may use methods to achieve similar thread safe synchronization functionality. Queue functionality may be accomplished with lists arrays databases e.g. SQL and other methodologies without departing from the spirit and scope of queue descriptions herein.

Queue alternate embodiments may maintain a plurality of WDR queues which segregate WDRs by field s values to facilitate timely processing. WDR queue may be at least two 2 separate queues one for maintaining the MS whereabouts and one for maintaining whereabouts of other MSs. WDR queue may be a single instance WDR in some embodiments which always contains the most current MS whereabouts for use by MS applications may use a sister queue for maintaining WDRs from remote MSs . At least one entry is to be maintained to WDR queue at all times for MS whereabouts.

Send queue Transmit Tx queue is used to send communications data for example as intended for a peer MS within the vicinity e.g. nearby as indicated by maximum range of the MS . Receive queue Receive Rx queue is used to receive communications data for example from peer MSs within the vicinity e.g. nearby as indicated by maximum range of the MS . Queues and may also each comprise a plurality of queues for segregating data thereon to facilitate performance in interfacing to the queues in particular when different queue entry types and or sizes are placed on the queue. A queue interface for sending receiving data to from the MS is optimal in a multi threaded implementation to isolate communications transport layers to processing behind the send receive queue interfaces but alternate embodiments may send receive data directly from a processing thread disclosed herein. Queues and or may be embodied as a purely data form or SQL database maintained at MS in persistent storage memory or any other storage means. In some embodiments queues and are not necessary since other character will already have accessible resources for carrying out some LBX character processing.

Queue embodiments may contain fixed length records varying length records pointers to fixed length records or pointers to varying length records. If pointers are used it is assumed that pointers may be dynamically allocated for record storage on insertions and freed upon record use after discards or retrievals.

As well known to those skilled in the art when a thread sends on a queue in anticipation of a corresponding response there is correlation data in the data sent which is sought in a response received by a thread at queue so the sent data is correlated with the received data. In a preferred embodiment correlation is built using a round robin generated sequence number placed in data for sending along with a unique MS identifier MS ID . If data is not already encrypted in communications the correlation can be encrypted. While the unique MS identifier MS ID may help the MS identify which e.g. wireless data is destined for it correlation helps identify which data at the MS caused the response. Upon receipt of data from a responder at queue correlation processing uses the returned correlation e.g. field to correlate the sent and received data. In preferred embodiments the sequence number is incremented each time prior to use to ensure a unique number otherwise it may be difficult to know which data received is a response to which data was sent in particular when many data packets are sent within seconds. When the sequence number reaches a maximum value e.g. 2 32 1 then it is round robinned to 0 and is incremented from there all over again. This assures proper correlation of data between the MS and responders over time. There are other correlation schemes e.g. signatures random number generation checksum counting bit patterns date time stamp derivatives to accomplish correlation functionality. If send and receive queues of Other Character are used then correlation can be used in a similar manner to correlate a response with a request i.e. a send with a receipt .

There may be good reason to conceal the MS ID when transmitting it wirelessly. In this embodiment the MS ID is a dependable and recognizable derivative e.g. a pseudo MS ID that can be detected in communications traffic by the MS having the pseudo MS ID while concealing the true MS ID. This would conceal the true MS ID from would be hackers sniffing wireless protocol. The derivative can always be reliably the same for simplicity of being recognized by the MS while being difficult to associate to a particular MS. Further still a more protected MS ID from would be hackers that take time to deduce how an MS ID is scrambled can itself be a dynamically changing correlation anticipated in forthcoming communications traffic thereby concealing the real MS ID e.g. phone number or serial number in particular when anticipating traffic in a response yet still useful for directing responses back to the originating MS with the pseudo MS ID e.g. correlation . A MS would know which correlation is anticipated in a response by saving it to local storage for use until it becomes used i.e. correlated in a matching response or becomes stale. In another embodiment a correlation response queue like CR queue can be deployed to correlate responses with requests that contain different correlations for pseudo MS IDs. In all embodiments the MS ID or pseudo MS ID of the present disclosure should enable targeting communications traffic to the MS.

Service informant code comprises executable code in software firmware or hardware form for carrying out of informing a supervisory service. The present disclosure does not require a connected web service but there are features for keeping a service informed with activities of MS LBX. Service informant code can communicate as requested any data or any other data processed at MS .

LBX history contains historical data useful in maintaining at MS and possibly useful for informing a supervisory service through service informant code . LBX History preferably has an associated thread of processing for keeping it pruned to the satisfaction of a user of MS e.g. prefers to keep last 15 days of specified history data and 30 days of another specified history data etc . With a suitable user interface to MS a user may browse manage alter delete or add to LBX History as is relevant to processing described herein. Service informant code may be used to cause sending of an outbound email SMS message outbound data packet or any other outbound communication in accordance with LBX of the MS.

PIP data preferably includes at least permissions charters statistics and a service directory . Permissions are configured to grant permissions to other MS users for interacting the way the user of MS desires for them to interact. Therefore permissions contain permissions granted from the MS user to other MS users. In another embodiment permissions additionally or alternatively contain permissions granted from other MS users to the MS user. Permissions are maintained completely local to the MS . Charters provide LBX behavior conditional expressions for how MSs should interact with MS . Charters are configured by the MS user for other MS users. In another embodiment charters additionally or alternatively are configured by other MS users for the MS user. Some charters expressions depend on permissions . Statistics are maintained at MS for reflecting peer MS to peer MS interactions of interest that occurred at MS . In another embodiment statistics additionally or alternatively reflect peer MS to peer MS interactions that occurred at other MSs preferably depending on permissions . Service informant code may or may not inform a service of statistics maintained. Service directory includes routing entries for how MS will find a sought service or how another MS can find a sought service through MS .

In some embodiments any code e.g. can access manage use alter or discard any data e.g. of any other component in MS . Other embodiments may choose to keep processing of LBX character and other character disjoint from each other. Rectangular component boundaries are logical component representations and do not have to delineate who has access to what. MS also MSs references discussed herein in context for the new and useful features and functionality disclosed is understood to be an MS MSs .

Regardless of the embodiment an MS can communicate with any of its peers in the vicinity using methods described below. Regardless of the embodiment a communication path between any two MSs is understood to be potentially bidirectional but certainly at least unidirectional. The bidirectional path may use one communications method for one direction and a completely different communications method for the other but ultimately each can communicate to each other. When considering that a path comprises two unidirectional communications paths there are N N 1 unidirectional paths for N MSs in a network . For example 10 MSs results in 90 i.e. 10 9 one way paths of communications between all 10 MSs for enabling them to talk to each other. Sharing of the same signaling channels is preferred to minimize the number of MS threads listening on distinct channels. Flowcharts are understood to process at incredibly high processing speeds in particular for timely communications processing. While the MSs are communicating wirelessly to each other path embodiments may involve any number of intermediary systems or communications methods for example as discussed below with .

The data processing system may also include a display device interface for driving a connected display device not shown . The data processing system may further include one or more input peripheral interface s to input devices such as a keyboard keypad Personal Digital Assistant PDA writing implements touch interfaces mouse voice interface or the like. User input user input user events and user actions used interchangeably to the data processing system are inputs accepted by the input peripheral interface s . The data processing system may still further include one or more output peripheral interface s to output devices such as a printer facsimile device or the like. Output peripherals may also be available via an appropriate interface.

Data processing system will include a communications interface s for communicating to another data processing system via analog signal waves digital signal waves infrared proximity copper wire optical fiber or other wave spectrums described herein. A MS may have multiple communications interfaces e.g. cellular connectivity 802.x etc . Other data processing system may be an MS. Other data processing system may be a service. Other data processing system is a service data processing system when MS communicates to other data processing system by way of service informant code . In any case the MS and other data processing system are said to be interoperating when communicating.

Data processing system programs also called control logic may be completely inherent in the processor s being a customized semiconductor or may be stored in main memory for execution by processor s as the result of a read only memory ROM load not shown or may be loaded from a secondary storage device into main memory for execution by processor s . Such programs when executed enable the data processing system to perform features of the present disclosure as discussed herein. Accordingly such data processing system programs represent controllers of the data processing system.

In some embodiments the disclosure is directed to a control logic program product comprising at least one processor having control logic software firmware hardware microcode stored therein. The control logic when executed by processor s causes the processor s to provide functions of the disclosure as described herein. In another embodiment this disclosure is implemented primarily in hardware for example using a prefabricated component state machine or multiple state machines in a semiconductor element such as a processor .

Those skilled in the art will appreciate various modifications to the data processing system without departing from the spirit and scope of this disclosure. A data processing system and more particularly a MS preferably has capability for many threads of simultaneous processing which provide control logic and or processing. These threads can be embodied as time sliced threads of processing on a single hardware processor multiple processors multi core processors Digital Signal Processors DSPs or the like or combinations thereof. Such multi threaded processing can concurrently serve large numbers of concurrent MS tasks. Concurrent processing may be provided with distinct hardware processing and or as appropriate software driven time sliced thread processing. Those skilled in the art recognize that having multiple threads of execution on an MS is accomplished in many different ways without departing from the spirit and scope of this disclosure. This disclosure strives to deploy software to existing MS hardware configurations but the disclosed software can be deployed as burned in microcode to new hardware of MSs.

Data processing aspects of drawings flowcharts are preferably multi threaded so that many MSs and applicable data processing systems are interfaced with in a timely and optimal manner. Data processing system may also include its own clock mechanism not shown if not an interface to an atomic clock or other clock mechanism to ensure an appropriately accurate measurement of time in order to appropriately carry out processing described below. In some embodiments Network Time Protocol NTP is used to keep a consistent universal time for MSs and other data processing systems in communications with MSs. This is most advantageous to prevent unnecessary round tripping of data between data processing systems to determine timing e.g. Time Difference of Arrival TDOA measurements. A NTP synchronized date time stamp maintained in communications is compared by a receiving data processing system for comparing with its own NTP date time stamp to measure TOA time of arrival i.e. time taken to arrive . Of course in the absence of NTP used by the sender and receiver TOA is also calculated in a bidirectional transmission using correlation. In this disclosure TOA measurements from one location technology are used for triangulating with TOA measurements from another location technology not just for determining how close . Therefore TDOA terminology is generally used herein to refer to the most basic TOA measurement of a wave spectrum signal being the difference between when it was sent and when it was received. TDOA is also used to describe using the difference of such measurements to locate triangulate . NTP use among participating systems has the advantage of a single unidirectional broadcast data packet containing all a receiving system requires to measure TDOA by knowing when the data was sent date time stamp in packet and when the data was received signal detected and processed by receiving system . A NTP clock source e.g. atomic clock used in a network is to be reasonably granular to carry out measurements and ensures participating MSs are updated timely according to anticipated time drifts of their own clocks. There are many well known methods for accomplishing NTP some which require dedicated thread s for NTP processing and some which use certain data transmitted to and from a source to keep time in synch.

Those skilled in the art recognize that NTP accuracy depends on participating MS clocks and processing timing as well as time server source s . Radio wave connected NTP time server s is typically accurate to as granular as 1 millisecond. Global Positioning System GPS time servers provide accuracy as granular as 50 microseconds. GPS timing receivers provide accuracy to around 100 nanoseconds but this may be reduced by timing latencies in time server operating systems. With advancements in hardware microcode and software obvious improvements are being made to NTP. In NTP use embodiments of this disclosure an appropriate synchronization of time is used for functional interoperability between MSs and other data processing systems using NTP. NTP is not required in this disclosure but it is an advantage when in use.

In another embodiment of the present disclosure GPS satellites such as satellite satellite and satellite provide information as is well known in the art to GPS devices on earth for triangulation locating of the GPS device. In this embodiment a MS has integrated GPS functionality so that the MS monitors its positions. The MS is preferably known by a unique identifier for example a phone number caller id device identifier or like appropriate unique handle.

In yet another embodiment of the present disclosure a physically connected device for example telephone computer PDA telephone and fax machine may be newly physically connected to a network. Each is a MS although the mobility is limited. Physical connections include copper wire optical fiber USB or any other physical connection by any communications protocol thereon. Devices are preferably known by a unique identifier for example a phone number caller id device identifier physical or logical network address or like appropriate unique handle. The MS is detected for being newly located when physically connected. A service can be communicated to upon detecting connectivity. The service may execute at an Automatic Response Unit ARU a telephony switch for example telephony switch a web server for example connected through a gateway or a like data processing system that communicates with the MS in any of a variety of ways as well known to those skilled the art. MS detection may be a result of the MS initiating a communication with the service directly or indirectly. Thus a user may connect his laptop to a hotel network initiate a communication with the service and the service determines that the user is in a different location than the previous communication. A local area network LAN may contain a variety of connected devices each an MS that later becomes connected to a local area network at a different location such as a PDA a server computer a printer an internet protocol telephone a computer or the like. Hard copy presentation could be made to printer and fax .

Current technology enables devices to communicate with each other and other systems through a variety of heterogeneous system and communication methods. Current technology allows executable processing to run on diverse devices and systems. Current technology allows communications between the devices and or systems over a plethora of methodologies at close or long distance. Many technologies also exist for automatic locating of devices. It is well known how to have an interoperating communications system that comprises a plurality of individual systems communicating with each other with one or more protocols. As is further known in the art of developing software executable processing of the present disclosure may be developed to run on a particular target data processing system in a particular manner or customized at install time to execute on a particular data processing system in a particular manner.

Once DLM is within the building a strategically placed antenna with a desired detection range within the building is used to detect the DLM coming into its proximity. Wall breakout is used to see the antenna through the building . The known antenna location is used to automatically detect the location of the DLM . In fact any DLM that travels within the coverage area served by antenna is identified as the location of antenna . The confidence of a location of a DLM is low when the antenna coverage area of antenna is large. In contrast the confidence of a location of a DLM is higher when the antenna coverage area of antenna is smaller. Travels of DLM can be limited by objects pathways or other limiting circumstances of traffic to provide a higher confidence of location of DLM when located by antenna or when located by any locating antenna described herein which detects MSs coming within range of its location. Location confidence is improved with a TDOA measurement as described above. Antenna can process all locating by itself with connected data processing system not shown as well known to those skilled in the art or with interoperability to other services as connected to antenna for example with connectivity described in . Antenna can be used to communicate the location of DLM to a service to the DLM to other MSs within its coverage area any combination thereof or to any connected data processing system or MS of FIG. E. Other in range detection antennas of a embodiment may be strategically placed to facilitate warehouse operations such as in Kubler et al.

In another embodiment blocks through are not required. A service connected antenna or cell tower periodically broadcasts its whereabouts WDR info e.g. and MSs in the vicinity use that directly at block . The MS can choose to use only the confidence and location provided or may determine a TDOA measurement for determining how close it is. If the date time stamp field indicates NTP is in use by the service and the MS is also using NTP then a TDOA measurement can be determined using the one unidirectional broadcast via the antenna by using the date time stamp field received with when the WDR information was received by the MS subtract time difference and use known wave spectrum for distance . If either the service or MS is not NTP enabled then a bidirectional correlated data flow between the service and MS is used to assess a TDOA measurement in terms of time of the MS. One embodiment provides the TDOA measurement from the service to the MS. Another embodiment calculates the TDOA measurement at the MS.

Network Time protocol NTP can ensure MSs have the same atomic clock time as the data processing systems driving antennas or cell towers they will encounter. Then date time stamps can be used in a single direction unidirectional broadcast packet to determine how long it took to arrive to from the MS. In an NTP embodiment the MS and or the antenna sends a date time stamp in the pulse beacon or protocol. Upon receipt the antenna or cell tower service data processing system communicates how long the packet took from an MS to the antenna or cell tower by comparing the date time stamp in the packet and a date time stamp of when it was received. The service may also set the confidence value before sending WDR information to the MS. Similarly an MS can compare a date time stamp in the unidirectional broadcast packet sent from a locating service with when received by the MS. So NTP facilitates TDOA measurements in a single broadcast communication between systems through incorporation to usual communications data with a date time stamp in Communications Key CK or alternatively in new data . Similarly NTP facilitates TDOA measurement in a single broadcast communication between systems through incorporation to usual communications data with a date time stamp in Communications Key CK or alternatively in new data .

The following template is used in this disclosure to highlight field settings. See descriptions. Fields are set to the following upon exit from block 

MS ID field is preferably set with Unique MS identifier of the MS invoking block . This field is used to uniquely distinguish this MS WDRs on queue from other originated WDRs.

DATE TIME STAMP field is preferably set with Date time stamp for WDR completion at block to the finest granulation of time achievable by the MS. The NTP use indicator is set appropriately.

LOCATION field is preferably set with Location of stationary antenna or cell tower as communicated by the service to the MS.

CONFIDENCE field is preferably set with The same value e.g. 76 for any range within the antenna or cell tower or may be adjusted using the TDOA measurement e.g. amount of time detected by the MS for the response at block . The longer time it takes between the MS sending a signal detected at block and the response with data back received by the MS block the less confidence there is for being located because the MS must be a larger distance from the antenna or cell tower. The less time it takes between the MS sending a signal detected at block and the response with data back the more confidence there is for being located because the MS must be a closer distance to the antenna or cell tower. Confidence values are standardized for all location technologies. In some embodiments of processing a confidence value can be set for 1 through 100 1 being lowest confidence and 100 being highest confidence wherein a unit of measurement between the MS and antenna or cell tower is used directly for the confidence value. For example 20 meters is used as the unit of measurement. For each unit of 20 meters distance determined by the TDOA measurement assign a value of 1 up to a worst case of 100 i.e. 2000 meters . Round the 20 meter unit of distance such that 0 meters to 

A service connected to the antenna or cell tower preferably uses historical information and artificial intelligence interrogation of MS travels to determine fields and . Block continues to block where parameters are prepared for passing to processing invoked at block . Parameters are set for WDRREF a reference or pointer to the WDR DELETEQ location queue discard processing and SUPER supervisory notification processing. Thereafter block invokes processing and processing terminates at block . processing will insert to queue so this MS knows at least its own whereabouts whenever possible. A single data instance embodiment of WDR queue will cause to update the single record of WDR information for being current upon exit from block this is true for all flowchart blocks invoking processing .

With reference now to depicted is a flowchart for describing a preferred embodiment of a procedure for inserting a Whereabouts Data Record WDR to MS WDR queue . Appropriate semaphores are used for variables which can be accessed simultaneously by another thread other than the caller. With reference now to procedure processing starts at block and continues to block where parameters passed from the invoking block of processing for example block are determined. The variable WDRREF is set by the caller to a reference or pointer to the WDR so subsequent blocks of can access the WDR. The variable DELETEQ is set by the caller so that block knows how to discard obsolete location queue entries. The DELETEQ variable can be a multi field record or reference thereof for how to prune. The variable SUPER is set by the caller so that block knows under what condition s and which data to contact a supervisory service. The SUPER variable can be a multi field record or reference thereof for instruction.

Block continues to block where the DLMV see and later discussions for DLMV DLM role s List Variable or ILMV see and later discussions for ILMV ILM role s List Variable is checked for an enabled role matching the WDR for insertion e.g. DLM location technology field technology and originator indicator when MS ID this MS ILM DLM or ILM indicator when MS ID not this MS . If no corresponding DLMV ILMV role is enabled for the WDR to insert then processing continues to block the WDR is not inserted to queue . If the ILMV DLMV role for the WDR is enabled then processing continues to block where the confidence of the WDR is validated prior to insertion. An alternate embodiment to will not have block i.e. block continues directly to block since appropriate DLM and or ILM processing may be terminated anyway when DLM ILM role s are disabled see B .

If block determines the data to be inserted is not of acceptable confidence e.g. field 70 then processing continues to block for checking the intent of the WDR insertion.

If block determines the WDR for insert is a WDR describing whereabouts for this MS i.e. MS ID matching MS of processing DLM or ILM B then processing continues to block . If block determines the WDR for insert is from a remote ILM or DLM i.e. MS ID does not match MS of processing then processing continues to block . Block peeks the WDR queue for the most recent highest confidence entry for this MS whereabouts by searching queue for the MS ID field matching the MS ID of processing and a confidence field greater than or equal to the confidence floor value and a most recent date time stamp field . Thereafter if block determines one was found then processing continues to block otherwise processing continues to block where a Last Whereabouts date Time stamp LWT variable is set to field of the WDR for insert e.g. first MS whereabouts WDR and processing continues to block .

If block determines the WDR for insertion has significantly moved i.e. using a movement tolerance configuration e.g. 3 meters with fields of the WDR for insert and the WDR peeked at block then block sets the LWT Last Whereabouts date Time stamp variable with appropriate semaphore to field of the WDR for insert and processing continues to block otherwise processing continues directly to block thereby keeping the LWT as its last setting . The LWT is to hold the most recent date time stamp of when the MS significantly moved as defined by a movement tolerance. The movement tolerance can be system defined or configured or user configured in by an option for configuration detected at block and then using the Configure Value procedure of like confidence floor value configuration .

Block accesses the DLMV and updates it with a new DLM role if there is not one present for it. This ensures a correct list of DLMV roles are available for configuration by . Preferably by default an unanticipated DLMV role is enabled helps inform the user of its availability . Likewise in another embodiment ILMV roles can be similarly updated in particular if a more granulated list embodiment is maintained to the ILMV or if unanticipated results help to identify another configurable role. By default block should allow unanticipated roles to continue with WDR insertion processing and then block can add the role enable it and a user can decide what to do with it in configuration B .

Thereafter the WDR is inserted to the WDR queue at block block discards any obsolete records from the queue as directed by the caller invoker and processing continues to block . The WDR queue preferably contains a list of historically MS maintained Whereabouts Data Records WDRs as the MS travels. When the MS needs its own location for example from an application access or to help locate an ILM the queue is accessed for returning the WDR with the highest confidence value field in the most recent time field for the MS field . Block preferably discards by using fields and relative to other WDRs. The queue should not be allowed to get too large. This will affect memory or storage utilization at the MS as well as timeliness in accessing a sought queue entry. Block also preferably discards WDRs from queue by moving selected WDRs to LBX History .

As described above queue interfaces assume an implicit semaphore for properly accessing queue . There may be ILMs requesting to be located or local applications of the MS may request to access the MS whereabouts. Executable thread s at the MS can accesses the queue in a thread safe manner for responding to those requests. The MS may also have multiple threads of processing for managing whereabouts information from DLMs ILMs or stationary location services. The more concurrently executable threads available to the MS the better the MS is able to locate itself and respond to others e.g. MSs . There can be many location systems and methods used to keeping a MS informed of its own whereabouts during travel. While the preferred embodiment is to maximize thread availability the obvious minimum requirement is to have at least 1 executable thread available to the MS. As described above in operating system environments without proper queue interfaces queue access blocks are first preceded by an explicit request for a semaphore lock to access queue waits until obtained and then followed by a block for releasing the semaphore lock to another thread for use. Also in the present disclosure it is assumed in blocks which access data accessible to more than 1 concurrent thread e.g. shared memory access to DLMV or ILMV at block that an appropriate semaphore created at block protect synchronous access.

If block determines information e.g. whereabouts should be communicated by service informant code to a supervisory service for example a service then block communicates specified data to the service and processing terminates at block by returning to the invoker caller . If block determines a supervisory service is not to be informed then processing terminates with an appropriate return to the caller at block . Service informant code at block can send information as data that is reliably acknowledged on receipt or as a datagram which most likely but unreliably is received.

Depending on the SUPER variable block may opt to communicate every time a WDR is placed to the queue or when a reasonable amount of time has passed since last communicating to the supervisory service or when a WDR confidence reaches a certain sought value or when any WDR field or fields contain certain sought information or when a reasonably large number of entries exist in WDR queue or for any processing condition encountered by blocks through or for any processing condition encountered by caller processing up to the invocation of processing. Different embodiments will send a single WDR at block a plurality of WDRs or any other data. Various SUPER parameter s embodiments for caller parameters can indicate what when where and how to send certain data. Block may send an email an SMS message or use other means for conveying data. Service informant code may send LBX history statistics and or any other data data queue data data or resources . Service informant code may update data in history statistics or any other data data queue data data and or resources possibly using conditions of this data to determine what is updated. Blocks and may be omitted in some embodiments.

If a single WDR is sent at block as passed to processing then the WDR parameter determined at block is accessed. If a plurality of WDRs is sent at block then block appropriately interfaces in a thread safe manner to queue and sends the WDRs.

Some preferred embodiments do not incorporate blocks through . i.e. block continues to block if confidence ok . Blocks through are for the purpose of implementing maintaining a date time stamp of last MS significant movement using a movement tolerance . Architecture uses as does DLM processing. must perform well for the preferred multithreaded architecture . Block performs a peek and block can be quite timely depending on embodiments used for location field . A movement tolerance incorporated at the MS is not necessary but may be nice to have. Therefore blocks through are optional blocks of processing.

With reference now to depicted is a flowchart for describing a preferred embodiment of an MS whereabouts update event of an antenna in range detected MS for example a DLM when MS location awareness is monitored by the MS. describes relevant processing for MSs to maintain their own whereabouts. Processing begins at block when the MS receives a signal from an antenna or cell tower deserving a response and continues to block where the antenna or cell tower signal is authenticated by the MS as being a legitimate signal for processing. The signal can be received for processing by blocks through as the result of a continuous or pulsed broadcast or beaconing by the antenna or cell tower or as part of usual communication protocol in progress with at least one MS usual data with embedded Communications Key or as a response via antenna to a previous MS signal . The signal is preferably authenticated by a data parsed signature deserving further processing. Block continues to block where the MS sends an outbound request for soliciting an immediate response from the antenna or cell tower service. The request by the MS is appropriately correlated e.g. as described above for a response which additionally facilitates embodiments using TDOA measurements time of communications between the MS and antenna or cell tower to determine how close is the MS in range. Block waits for a response or waits until a reasonable timeout whichever occurs first. There are also multithreaded embodiments to breaking up where block does not wait but rather terminates processing and depends on another thread to correlate the response and then continue processing blocks through like architecture .

Thereafter if block determines the request timed out then processing terminates at block . If block determines the response was received then processing continues to block . Block completes a WDR with appropriate response data received along with data set by the MS. See descriptions. Fields are set to the following upon exit from block 

LOCATION TECHNOLOGY field is preferably set with Client Antenna Range for an antenna detecting the MS and is set to Client Cell Range for a cell tower detecting the MS. The originator indicator is set to DLM.

The longer time it takes between sending a request and getting a response at block the less confidence there is for being located because the MS must be a larger distance from the antenna or cell tower. The less time it takes the more confidence there is for being located because the MS must be a closer distance to the antenna or cell tower. Confidence values are analogously determined as described for . NTP embodiments also apply here. NTP can be used so no bidirectional communications is required for TDOA measurement. In this embodiment the antenna or cell tower sets a NTP date time stamp in the pulse beacon or protocol. Upon receipt the MS instantly knows how long the packet took to be received by comparing the NTP date time stamp in the packet and a MS NTP date time stamp of when it was received i.e. no request response pair required . If location information is also present with the NTP date time stamp in data received at block then block can continue directly to block .

An alternate MS embodiment determines its own direction heading and or speed for WDR completion based on historical records maintained to the WDR queue and or LBX history .

Block continues to block for preparing parameters for WDRREF a reference or pointer to the WDR DELETEQ location queue discard processing and SUPER supervisory notification processing. Thereafter block invokes the procedure processing to insert the WDR to queue . After processing of block processing terminates at block .

In alternative coming within range same as in range in range within range embodiments a unique MS identifier or MS group identifier for authenticating an MS for locating the MS is not necessary. An antenna emitting signals will broadcast in CK of data not only its own location information e.g. location field but also an NTP indicated date time stamp field which the receiving MS also having NTP for time synchronization uses to perform a TDOA measurement upon receipt. This will enable a MS to determine at least how close e.g. radius range radius range radius range or radius range it is located to the location of the antenna by listening for and receiving the broadcast e.g. of . Similarly in another embodiment an NTP synchronized MS emits signals and an NTP synchronized data processing system associated with a receiving antenna can make a TDOA measurement upon signal receipt. In other embodiments more than a single unidirectional signal may be used while still preventing the requirement to recognize the MS to locate it. For example an antenna emitting signals e.g. hotspot WiFi 802.x will contain enough information for a MS to respond with correlation for being located and visa versa. In any case there can be multi directional exchanged signals for determining a TDOA measurement.

TDOA is calculated from the time it takes for a communication to occur from the MS back to the MS via the base tower or alternatively from a base tower back to that base tower via the MS. NTP may also be used for time calculations in a unidirectional broadcast from a base tower to the MS or from the MS to a base tower as described above . AOA is performed through calculations of the angle by which a signal from the MS encounters the antenna. Triangle geometry is then used to calculate a location. The AOA antenna is typically of a phased array type.

See Missing Part Triangulation MPT section below with discussions for for details on heterogeneously locating the MS using both TDOA and AOA i.e. Missing Part Triangulation MPT . Just as high school taught geometry for solving missing parts of a triangle so to does MPT triangulate an MS location. Think of the length of a side of a triangle as a TDOA measurement i.e. length of time translatable to a distance. Think of the AOA of a signal to an antenna as one of the angles of a triangle vertice. Solving with MPT analogously uses geometric and trigonometric formulas to solve the triangulation albeit at fast processing speeds.

Thereafter if the MS is determined to be legitimate and deserving of processing similar to above then block continues to block . If block determines the MS is not participating with the service in which case block did little to process it then processing continues back to block to continue working on behalf of legitimate participating MSs. The controller at block may communicate with other controllers when base stations in other cellular clusters are picking up a signal for example when the MS roams. In any case at block the controller s determines the strongest signal base stations needed for locating the MS at block . The strongest signals that can accomplish whereabouts information of the MS are used. Thereafter block accesses base station location information for base stations determined at block . The base station provides stationary references used to relatively determine the location of the MS. Then block uses the TDOA or AOA or MPT i.e. heterogeneously both AOA and TDOA information together with known base station locations to calculate the MS location.

Thereafter block accesses historical MS location information and block performs housekeeping by pruning location history data for the MS by time number of entries or other criteria. Block then determines a heading direction of the MS based on previous location information. Block may perform Artificial Intelligence AI to determine where the MS may be going by consulting many or all of the location history data. Thereafter block completes a service side WDR block appends the WDR information to location history data and notifies a supervisory service if there is one outside of the service processing of . Processing continues to block where the service communicates the WDR to the located MS.

Thereafter the MS completes its own WDR at block for adding to WDR queue to know its own whereabouts whenever possible and block prepares parameters for invoking WDR insertion processing at block . Parameters are set for WDRREF a reference or pointer to the MS WDR DELETEQ location queue discard processing and SUPER supervisory notification processing e.g. no supervisory notification processing because it was already handled at block or by being in context of the service processing . At block the MS invokes processing already described. After block processing continues back to block . Of course block continues directly to block at the service s since there is no need to wait for MS s processing in blocks through . processing is continuous for every MS in the wireless network 7 days a week 24 hours a day.

LOCATION field is preferably set with The triangulated location of the MS as communicated by the service.

CONFIDENCE field is preferably set with Confidence of triangulation determined by the service which is passed to the MS at block . The confidence value may be set with the same value e.g. 85 regardless of how the MS was triangulated. In other embodiments field will be determined completely or adjusting the value of 85 by the service for TDOA measurements used AOA measurements signal strengths wave spectrum involved and or the abundance of particular MS signals available for processing by blocks through . Higher confidences are assigned for smaller TDOA measurements shorter distances strong signal strengths and numerous additional data points beyond what is necessary to locate the MS. Lower confidences are assigned for larger TDOA measurements weak signal strengths and minimal data points necessary to locate the MS. A reasonable confidence can be assigned using this information as guidelines where 1 is the lowest confidence and 100 is the highest confidence. LOCATION TECHNOLOGY field is preferably set with Server Cell TDOA Server Cell AOA Server Cell MPT Server Antenna TDOA Server Antenna AOA or Server Antenna MPT depending on how the MS was located and what flavor of service was used. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with null not set for indicating that all triangulation data was factored into determining confidence and none is relevant for a single TDOA or AOA measurement in subsequent processing i.e. service did all the work . COMMUNICATIONS REFERENCE INFO field is preferably set with Same as was described for block above. SPEED field is preferably set with Service WDR information at block wherein the service used historical information and artificial intelligence interrogation of MS travels to determine if available. HEADING field is preferably set with Service WDR information at block wherein the service used historical information and artificial intelligence interrogation of MS travels to determine if available. ELEVATION field is preferably set with Elevation altitude if available. APPLICATION FIELDS field is preferably set with Same as was described for block above. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

Thereafter block accesses historical MS location information e.g. WDR queue and or LBX history to prevent redundant information kept at the MS and block performs housekeeping by pruning the LBX history for the MS by time number of entries or other criteria. Block then determines a heading direction of the MS based on previous location information unless already known from block for AOA determination . Block may perform Artificial Intelligence AI to determine where the MS may be going by consulting queue and or history . Thereafter block completes a WDR and block prepares parameters for processing WDRREF a reference or pointer to the MS WDR DELETEQ location queue discard processing and SUPER supervisory notification processing. Block continues to block for invoking processing already described above. After block processing continues back to block . processing is continuous for the MS as long as the MS is enabled. In various multithreaded embodiments many threads at the MS work together for high speed processing at blocks through for concurrently communicating to many stationary references.

CONFIDENCE field is preferably set with The confidence of triangulation as determined by the MS. Confidence may be set with the same value e.g. 80 since MS may be moving during triangulation regardless of how the MS was triangulated. In other embodiments field will be determined completely or adjusting the value of 80 by the MS for TDOA measurements used AOA measurements signal strengths wave spectrum involved and or the abundance of particular service signals available for processing. Higher confidences are assigned for smaller TDOA measurements shorter distances strong signal strengths and numerous additional data points beyond what is necessary to locate the MS. Lower confidences are assigned for larger TDOA measurements weak signal strengths and minimal data points necessary to locate the MS. A reasonable confidence can be assigned using this information as guidelines where 1 is the lowest confidence and 100 is the highest confidence. LOCATION TECHNOLOGY field is preferably set with Client Cell TDOA Client Cell AOA Client Cell MPT Client Antenna TDOA Client Antenna AOA or Client Antenna MPT depending on how the MS located itself. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with Data associated with selected best stationary reference s used by the MS the selection location whereabouts TDOA measurement to it and wave spectrum and or particular communications interface used if reasonable. The TDOA measurement may be converted to a distance using wave spectrum information. Also preferably set herein is data associated with a selected best stationary reference used by the MS may be same or different than for TDOA measurement the selection location AOA measurement to it and heading yaw pitch and roll values or accelerometer readings if reasonable. Values that may be populated here should have already been factored into the confidence value. There may be one or more stationary reference whereabouts with useful measurements maintained here for processing of block . COMMUNICATIONS REFERENCE INFO field is preferably set with Parameters referencing MS internals if desired. SPEED field is preferably set with Speed determined by the MS using historical information queue and or history and artificial intelligence interrogation of MS travels to determine if reasonable. HEADING field is preferably set with Heading determined by the MS using historical information queue and or history and artificial intelligence interrogation of MS travels to determine if reasonable. ELEVATION field is preferably set with Elevation altitude if available. APPLICATION FIELDS field is preferably set with Same as was described for block above. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

In alternative triangulation embodiments a unique MS identifier or MS group identifier for authenticating an MS for locating the MS is not necessary. An antenna emitting signals will broadcast CK of data not only its own location information but also an NTP date time stamp which the receiving MS also having NTP for time synchronization uses to perform TDOA measurements upon receipt. This will enable a MS to determine how close e.g. radius range radius range radius range or radius range it is located to the location of the antenna by listening for and receiving the broadcast e.g. of . Similarly in another embodiment an NTP synchronized MS emits signals and an NTP synchronized data processing system associated with a receiving antenna can determine a TDOA measurement upon signal receipt. In other embodiments more than a single unidirectional signal may be used while still preventing the requirement to recognize the MS to locate it. For example an antenna emitting signals will contain enough information for a MS to respond with correlation for being located. Alternatively an MS emitting signals will contain enough information for a service to respond with correlation for being located. In any case there can be multi directional exchanged signals for determining TDOA. Similarly a service side data processing system can interact with a MS for AOA information without requiring a known identifier of the MS use request response correlation .

CONFIDENCE field is preferably set with Confidence of GPS variety usually high which may be set with the same value e.g. 95 for DGPS 93 for AGPS and 90 for GPS . In other embodiments field will be determined completely or amending the defaulted value by the MS for timing measurements signal strengths and or the abundance of particular signals available for processing similarly to as described above. An MS may not be aware of the variety of GPS in which case straight GPS is assumed. LOCATION TECHNOLOGY field is preferably set with GPS A GPS or DGPS depending on if known flavor of GPS. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with null not set for indicating that data was factored into determining confidence and none is relevant for a single TDOA or AOA measurement in subsequent processing. COMMUNICATIONS REFERENCE INFO field is preferably set with Parameters referencing MS internals if desired. SPEED field is preferably set with Speed determined by the MS using a suitable GPS interface or historical information queue and or history and artificial intelligence interrogation of MS travels to determine if reasonable. HEADING field is preferably set with Heading determined by the MS using a suitable GPS interface or historical information queue and or history and artificial intelligence interrogation of MS travels to determine if reasonable. ELEVATION field is preferably set with Elevation altitude if available. APPLICATION FIELDS field is preferably set with Same as was described for block above. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

Thereafter block accesses historical MS location information performs housekeeping by pruning location history data for the MS by time number of entries or other criteria and determines a heading direction of the MS based on previous location information. Block may perform Artificial Intelligence AI to determine where the MS may be going by consulting many or all of the location history data. Thereafter block completes a service side WDR block appends the WDR information to location history data and notifies a supervisory service if there is one outside of the service processing of . Processing continues to block where the service communicates the WDR to the located MS.

Thereafter the MS completes the WDR at block for adding to WDR queue . Thereafter block prepares parameters passed to processing for WDRREF a reference or pointer to the MS WDR DELETEQ location queue discard processing and SUPER supervisory notification processing e.g. no supervisory notification processing because it was already handled at block or by being in context of the service processing . Block continues to block where the MS invokes processing already described above. After block processing continues back to block . Of course block continues directly to block at the service s since there is no need to wait for MS s processing in blocks through . processing is continuous for every MS in the wireless network 7 days a week 24 hours a day.

LOCATION field is preferably set with The triangulated location of the MS as communicated by the service.

CONFIDENCE field is preferably set with Confidence of triangulation determined by the service which is passed to the MS at block . The confidence value may be set with the same value e.g. 95 normally high for triangulation using densely positioned antennas regardless of how the MS was triangulated. In other embodiments field will be determined completely or adjusting the value of 95 by the service for TDOA measurements used AOA measurements signal strengths wave spectrum involved and or the abundance of particular MS signals available for processing. Higher confidences are assigned for smaller TDOA measurements shorter distances strong signal strengths and numerous additional data points beyond what is necessary to locate the MS. Lower confidences are assigned for larger TDOA measurements weak signal strengths and minimal data points necessary to locate the MS. A reasonable confidence can be assigned using this information as guidelines where 1 is the lowest confidence and 100 is the highest confidence. LOCATION TECHNOLOGY field is preferably set with Server Antenna TDOA Server Antenna AOA or Server Antenna MPT depending on how the MS was located and what flavor of service was used. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with null not set for indicating that all triangulation data was factored into determining confidence and none is relevant for a single TDOA or AOA measurement in subsequent processing i.e. service did all the work . COMMUNICATIONS REFERENCE INFO field is preferably set with Same as was described for block above. SPEED field is preferably set with Service WDR information at block wherein the service used historical information and artificial intelligence interrogation of MS travels to determine if available. HEADING field is preferably set with Service WDR information at block wherein the service used historical information and artificial intelligence interrogation of MS travels to determine if available. ELEVATION field is preferably set with Elevation altitude if available. APPLICATION FIELDS field is preferably set with Same as was described for block above. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

Relevant processing begins at block and continues to block where an MS device is physically logically connected to a network. Thereafter the MS accesses a service at block . Then at block the service accesses historical MS location history and block performs housekeeping by pruning the location history data maintained for the MS by time number of entries or other criteria. Block may perform Artificial Intelligence AI to determine where the MS may be going e.g. using heading based on previous locations by consulting much or all of the location history data. Thereafter service processing at block completes a service side WDR then the service appends WDR information to location history data at block and may notify a supervisory service if there is one outside of the service processing of . Processing continues to block where the service communicates WDR information to the newly physically logically connected MS. There are many embodiments for determining a newly connected MS location using a physical or logical address for example consulting a database which maps locations to network addresses e.g. location to logical ip address location to physical wall jack port etc . Then at block the MS completes its own WDR using some information from block parameters are prepared at block block invokes processing already described above and processing terminates at block . Parameters are set at block for WDRREF a reference or pointer to the MS WDR DELETEQ location queue discard processing and SUPER supervisory notification processing e.g. no supervisory notification processing because it was already handled at block or by being in context of the service processing . Of course block continues directly to block at the service s since there is no need to wait for MS processing in blocks through . processing is available at any appropriate time in accordance with the underlying service.

CONFIDENCE field is preferably set with Confidence determined by the service according to how the MS was connected or may be set with the same value e.g. 100 for physical connect 77 for logical connect e.g. short range wireless regardless of how the MS was located. In other embodiments field will be determined by the service for anticipated physical conduit range wireless logical connect range etc. The resulting confidence value can be adjusted based on other parameters analogously to as described above. LOCATION TECHNOLOGY field is preferably set with Service Physical Connect or Service Logical Connect depending on how the MS connected. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with null not set but if a TDOA measurement can be made e.g. short range logical connect and using methodologies described above then a TDOA measurement a communications signal strength if available and wave spectrum and or particular communications interface used if available. The TDOA measurement may be converted to a distance using wave spectrum information. Possible values populated here should have already been factored into the confidence value. COMMUNICATIONS REFERENCE INFO field is preferably set with Same as was described for block above. SPEED field is preferably set with null not set but can be set with speed required to arrive to the current location from a previously known location assuming same time scale is used. HEADING field is preferably set with null not set but can be set to heading determined when arriving to the current location from a previously known location. ELEVATION field is preferably set with Elevation altitude e.g. of physical connection or place of logical connection detection if available. APPLICATION FIELDS field is preferably set with Same as was described for block above. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

CONFIDENCE field is preferably set with Confidence determined by the service according to how the MS was connected or may be set with the same value e.g. 100 for physical connect 77 for logical connect e.g. short range wireless regardless of how the MS was located. In other embodiments field will be determined by the service for anticipated physical conduit range wireless logical connect range etc. The resulting confidence value can be adjusted based on other parameters analogously to as described above. LOCATION TECHNOLOGY field is preferably set with Client Physical Connect or Client Logical Connect depending on how the MS connected. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with null not set but if a TDOA measurement can be made e.g. short range logical connect and using methodologies described above then a TDOA measurement a communications signal strength if available and wave spectrum and or particular communications interface used if available. The TDOA measurement may be converted to a distance using wave spectrum information. Possible values populated here should have already been factored into the confidence value. COMMUNICATIONS REFERENCE INFO field is preferably set with Same as was described for block above. SPEED field is preferably set with null not set but can be set with speed required to arrive to the current location from a previously known location using assuming same time scale is used. HEADING field is preferably set with null not set but can be set to heading determined when arriving to the current location from a previously known location. ELEVATION field is preferably set with Elevation altitude e.g. of physical connection or place of logical connection detection if available. APPLICATION FIELDS field is preferably set with Same as was described for block above. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

With reference now to image capture device is positioned for monitoring MSs that come into the field of view of device . MSs are preferably distinguishable by appearance e.g. color shape markings labels tags etc or as attached e.g. recognized mount to host or carried e.g. recognized by its recognized user . Such techniques are well known to those skilled in the art. Device is as described above with connectivity to locating service and antenna or cell tower . illustrates that device uses known measurements within its field of view for determining how large and where located are objects that come into the field of view . For example a well placed and recognizable vertical line and horizontal line which are preferably perpendicular to each other have known lengths and positions. The objects which come into the field of view are measured based on the known lengths and positions of the lines and which may be landscape markings e.g. parking lot lines for additional purpose. Field of view may contain many lines and or objects of known dimensions strategically placed or recognized within the field of view to facilitate image processing by service . Building may serve as a reference point having known dimension and position in measuring objects such as a person or DLM . A moving object such as a shopping cart can have known dimensions but not a specific position to facilitate service in locating an MS coming into the field of view . Those skilled in the art recognize that known dimensions and or locations of anticipated objects in field of view have measurements facilitating discovering positions and measurements of new objects that may travel into the field of view . Using techniques with techniques provides additional locating accuracy. A distance may be estimated based on the anticipated sizes of references in the field of view relative size of the recognized MS.

With reference now to image capture device is positioned for monitoring MSs that come into the field of view of device . Device is as described above with connectivity to locating service and antenna or cell tower . MSs are preferably distinguishable by appearance e.g. color shape markings labels tags etc or as attached e.g. recognized mount to host or carried e.g. recognized by its user or as identified by and or methodologies. illustrates that device uses known locations within its field of view for determining how large and where located are objects that come into the field of view . For example building tree and traffic sign have its locations known in field of view by service . Solving locations of objects that move into the field of view is accomplished with graphical triangulation measurements between known object reference locations e.g. building tree and sign and the object to be located. Timely snapshots by device provide an ongoing locating of an MS for example DLM . Line segment distances a b c can be measured using references such as those of . Whereabouts are determined by providing known coordinates to anticipated objects such as building tree and sign . Similarly graphical AOA measurements i.e. graphical angle measurements and graphical MPT measurements can be used in relation to anticipated locations of objects within the field of view . There may be many anticipated known object locations within field of view to further facilitate locating an MS. Being nearby an object may also be enough to locate the MS by using the object s location for the location of the MS. Using techniques with and or techniques provides additional locating accuracy.

The system and methodologies illustrated by are preferably used in optimal combination by locating service to provide a best location of an MS. In some embodiments MS whereabouts is determined as the location of a device by simply being recognized by the device . In other embodiments multiple devices can be strategically placed within a geographic area for being used in combination to a common locating service for providing a most accurate whereabouts of an MS. Multiple field of views from difference angles of different devices enable more precise locating within three dimensional space including precise elevations.

There may be a plurality of MSs in the field of view so communications at block targets each MS recognized. A MS should not rely on the service to have done its job correctly. At a MS block checks the MS ID communicated for validation. If block determines the MS ID is incorrect then processing continues back to block for the particular MS . If block determines the MS ID is correct then processing continues to block where the particular MS completes its WDR received from service . Thereafter MS s prepare parameters at block invoke local processing already described above at block and processing continues for service back to block . Of course block continues directly to block at the service s since there is no need to wait for MS s processing in blocks through . Parameters set at block are WDRREF a reference or pointer to the MS WDR DELETEQ location queue discard processing and SUPER supervisory notification e.g. no supervisory notification processing because it was already handled at block or by being in context of the service processing . No snapshots from device are to be missed at block .

MS ID field is preferably set with Unique MS identifier of the MS after validating at the MS that the service has correctly identified it. This field is used to uniquely distinguish this MS WDRs on queue from other originated WDRs. The service may determine a MS ID from a database lookup using above appearance criteria. Field may also be determined using the transmission methods as described for for example by way of antenna . For example when the MS comes within range of antenna processing commences. Another embodiment prevents recognizing more than one MS within the field of view at any time e.g. a single file entryway in which case the service can solicit a who are you transmission to identify the MS and then send back its whereabouts in which case the MS sets its own MS ID here . DATE TIME STAMP field is preferably set with Same as was described for block above. LOCATION field is preferably set with The location determined for the MS by the service. CONFIDENCE field is preferably set with same value e.g. 76 regardless of how the MS location was determined. In other embodiments field will be determined by the number of distance measurements and or the abundance of particular objects used in the field of view . The resulting confidence value can be adjusted based on other graphical parameters involved analogously to as described above. LOCATION TECHNOLOGY field is preferably set with Server Graphic Patterns Server Graphic Distances Server Graphic Triangulate or a combination field value depending on how the MS was located and what flavor of service was used. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with null not set for indicating that all whereabouts determination data was factored into the confidence and none is relevant for a single TDOA or AOA measurement in subsequent processing i.e. service did all the work . COMMUNICATIONS REFERENCE INFO field is preferably set with Same as was described for block above. SPEED field is preferably set with null not set but can be set with speed required to arrive to the current location from a previously known time at a location e.g. using previous snapshots processed assuming the same time scale is used. HEADING field is preferably set with null not set but can be set to heading determined when arriving to the current location from a previously known location e.g. using previous snapshots processed . ELEVATION field is preferably set with Elevation altitude if available if available. APPLICATION FIELDS field is preferably set with Same as was described for block above. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

In an alternative embodiment MS may be equipped e.g. as part of resources with its own device and field of view for graphically identifying recognizable environmental objects or places to determine its own whereabouts. In this embodiment the MS would have access to anticipated objects locations and dimensions much the same way described for either locally maintained or verifiable with a connected service. Upon a successful recognition of an object place or other graphically perceptible image which can be mapped to a location the MS would complete a WDR similarly to above. The MS may recognize addresses buildings landmarks of other pictorial data. Thus the MS may graphically determine its own location. The MS would then complete a WDR for processing exactly as described for with the exceptions of fields that follow 

LOCATION TECHNOLOGY field is preferably set with Client Graphic Patterns Client Graphic Distances Client Graphic Triangulate or a combination field value depending on how the MS located itself. The originator indicator is set to DLM.

It has been shown that light can be used to triangulate position or location information e.g. U.S. Pat. No. 6 549 288 Migdal et al and U.S. Pat. No. 6 549 289 Ellis . Optical sensors through detect a light source of or illumination of an MS for example DLM . Data is superimposed on the light wave spectrum with specified frequency wavelength and or periodicity or data occurs in patterned breaks in light transmission. Data may contain a unique identifier of the MS so service s attached to sensors through can communicate uniquely to an MS. Mirrors positioned at optical sensors through may be used to determine an AOA of light at the sensor or alternatively TDOA of recognizable light spectrum is used to position an MS. The flowcharts occur analogously for light signals received by sensors through which are connected to service processing of . The only difference is wave spectrum used.

Heterogeneously speaking illustrates having strategically placed sensors through for detecting a wave spectrum and using TDOA AOA or MPT. Those skilled in the art appreciate that a wave is analogously dealt with by regardless of the wave type albeit with different sensor types through and different sensor interface to service s of . Wave signal spectrums for triangulation by analogous processing to include microwaves infrared visible light ultraviolet light X rays gamma rays longwaves magnetic spectrum or any other invisible visible audible or inaudible wave spectrum. Sensors through are appropriately matched according to the requirements. Alternatively a MS may be sensing wave spectrums emitted by transmitters through .

Those skilled in the relevant arts appreciate that the point in all this discussion is all the wave forms provide methods for triangulating whereabouts information of an MS. Different types of wave forms that are available for an MS can be used solely or in conjunction with each other to determine MS whereabouts. MSs may be informed of their location using the identical wave spectrum used for whereabouts determination or may use any other spectrum available for communicating WDR information back to the MS. Alternatively the MS itself can determine WDR information relative applicable sensors transmitters. In any case a WDR is completed analogously to .

Referring now back to block processing continues to block where a supervisory service may be updated with the MS whereabouts if applicable and block communicates the WDR information to the MS. Any available communication method can be used for communicating the WDR information to the MS as described above. Thereafter the MS completes the WDR at block block prepares parameters and block invokes processing already described above. Processing terminates thereafter at block . Parameters set at block are WDRREF a reference or pointer to the MS WDR DELETEQ location queue discard processing and SUPER supervisory notification e.g. no supervisory notification processing because it was already handled at block or by being in context of the service processing . processing is available at any appropriate time for the MS. In an alternate embodiment the MS senses its environment to determine whereabouts.

CONFIDENCE field is preferably set with Should be high confidence e.g. 98 for indisputable contact sensing and is typically set with the same value.

LOCATION TECHNOLOGY field is preferably set with Contact or a specific type of Contact. The originator indicator is set to DLM.

SPEED field is preferably set with null not set but can be set with speed required to arrive to the current location from a previously known time at a location assuming the same time scale is used.

HEADING field is preferably set with null not set but can be set to heading determined when arriving to the current location from a previously known location.

With reference back to block the user interfaces with the MS user interface to manually specify WDR information. The user can specify 

The user can specify a relevant confidence value for the manually entered location however processing at block preferably automatically defaults a confidence value for the data entered. For example a complete address validated at block will have a high confidence. A partial address such as city and state or a zip code will have a low confidence value. The confidence value will reflect how large an area is candidate for where the MS is actually located. To prevent completely relying on the user at block for accurate WDR information validation embodiments may be deployed. Some examples 

After WDR information is specified at block the MS completes the WDR at block block prepares parameters for processing and at block the MS invokes processing already described above before returning back to block . Parameters set at block are WDRREF a reference or pointer to the MS WDR DELETEQ location queue discard processing and SUPER supervisory notification processing. Various embodiments permit override of the confidence floor value by the user or by processing. Block may convert the user specified information into a standardized more usable form in an LN expanse e.g. convert to latitude and longitude if possible truncated precision for more area coverage . WDR fields see are set analogously in light of the many variations already described above.

With reference back to block if it is determined that the MS is equipped with capability e.g. in range or in readiness to locate itself then processing continues to block where the MS locates itself using MS driven capability described by or MS driven alternative embodiments to or any other MS capability for determining its own whereabouts with or without help from other data processing systems or services. Interfacing to locating capability preferably involves a timeout in case there is no or slow response therefore block continues to block where it determined whether or not block timed out prior to determining a location. If block determines a timeout was encountered then block provides the user with an error to the user interface and processing continues back to block . Block preferably requires use acknowledgement prior to continuing to block .

If block determines there was no timeout i.e. whereabouts successfully determined then block interfaces to the locating interface to get WDR information block completes a WDR and blocks and do as described above. If block determines the MS cannot locate itself and needs help then block emits at least one broadcast request to any listening service which can provide the MS its location. Appropriate correlation is used for an anticipated response. Example services listening are service driven capability described by or service side alternative embodiments of or any other service capability for determining MS whereabouts with or without help from the MS or other data processing systems or services. Block then continues to block .

If block determines a timeout was encountered from the service broadcast request then block provides the user with an error to the user interface and processing continues back to block . If block determines there was no timeout i.e. whereabouts successfully determined then block receives WDR information from the locating interface of the responding service block completes a WDR and blocks and do as already described above.

See descriptions. Depending how the MS was located via processing started at block to block a WDR is completed analogous to as described in Figs. above. If the user manually specified whereabouts at block fields are set to the following upon exit from block 

LOCATION field is preferably set with Location entered by the user or converted from entry by the user preferably validated.

CONFIDENCE field is preferably set with User specified confidence value or a system assigned value per a validated manual specification. Confidence should reflect confidence of location precision e.g. validated full address high city and zip code low etc . Manually specified confidences are preferably lower than other location technologies since users may abuse or set incorrectly unless validated. Specifying lower confidence values than technologies above for completely manual WDR specifications i.e. no validation ensures that manual specifications are only used by the MS in absence of other technologies. There are many validation embodiments that can be deployed as described above for a manually entered address wherein the resulting confidence may be based on validation s performed e.g. compare recent history for plausible current address use current latitude and longitude for database lookup to compare with address information entered etc . The system and or user may or may not be able to override the confidence value determined. LOCATION TECHNOLOGY field is preferably set with Manual or Manual Validated . Types of validations may further be elaborated. The originator indicator is set to DLM. LOCATION REFERENCE INFO field is preferably set with null not set . COMMUNICATIONS REFERENCE INFO field is preferably set with null not set . SPEED field is preferably set with null not set . HEADING field is preferably set with null not set . ELEVATION field is preferably set with null not set . APPLICATION FIELDS field is preferably set with Same as was described for block above or as decided by the user. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

The table has DLM location methods for rows and a single column for the MS e.g. DLM . Each location technology can be driven by the client i.e. the MS or a service i.e. the location server s as denoted by a row qualifier C for client or S for service. An MS may be located by many technologies. The table illustrated shows that the MS with unique identifier 0A12 43 EF 985B 012F is able to be heterogeneously located specifically with local MS GPS capability service side cell tower in range detection service side cell tower TDOA service side cell tower MPT combination of TDOA and AOA service side antenna in range detection service side antenna AOA service side antenna TDOA service side antenna MPT service side contact sensory and general service side MPT. The unique identifier in this example is a universal product identifier like Host Bus Adapter HBA World Wide Name WWN identifiers are generated but could be in other form as described above e.g. phone 214 403 4071 . An MS can have any subset of technologies used to locate it or all of the technologies used to locate it at some time during its travels. An MS is heterogeneously located when two or more location technologies are used to locate the MS during MS travels and or when two or more location technologies with incomplete results are used in conjunction with each other to locate the MS during MS travels such as MPT. MPT is a heterogeneous location technology because it uses at least two different methods to accomplish a single location determination. Using combinations of different location technologies can be used for example a TDOA measurement from an in range antenna with a TDOA measurement relative a cell tower e.g. as accomplished in MS processing of using completely different services that have no knowledge of each other. Another combination is to use a synergy of whereabouts data from one technology with whereabouts data from another technology. For example in range detection is used in combination with graphical identification to provide better whereabouts of a MS. In another example a GPS equipped MS travels to an area where GPS does not work well e.g. downtown amidst large and tall buildings . The DLM becomes an ILM and is triangulated relative other MSs. So an MS is heterogeneously located using two or more technologies to determine a single whereabouts or different whereabouts of the MS during travel.

In some embodiments of processing Missing Part Triangulation MPT is used to heterogeneously locate an MS. For a service side embodiment example block begins service processing when TDOA information itself cannot be used to confidently locate the MS or AOA information itself cannot be used to confidently locate the MS however using angles and distances from each in conjunction with each other enables solving whereabouts confidently. See Missing Part Triangulation MPT section below with discussions for for MPT processing of blocks and . Data discovered at block and processed by block depends on the embodiment what stationary reference point locations are known at the time of blocks and processing and which parts are missing for triangulating the MS. Having three 3 sides all TDOA with known stationary vertices location s solves the triangle for locating the MS. Three 3 angles all AOA with known stationary vertices location s solves the triangle for locating the MS. Those skilled in the art appreciate that solving triangulation can make complementary use of different distances time used to determine length in TDOA and angles from AOA for deducing a MS location confidently e.g. MPT . Those skilled in the art recognize that having stationary reference locations facilitates requiring less triangular information for deducing a MS location confidently.

While MPT has been discussed by example flowchart B is not to be interpreted in a limiting sense. Any location technologies for example as shown in can be used in conjunction with each other when not all information required is available in a single location technology to confidently deduce an MS location. Data available from the different location technologies available will be examined on its own merits and optionally used in conjunction to deduce a confident location. For example a TDOA difference between when signal sent and when received measurement from coming within range technology can be used to distinguish how close or how far is an MS in the vicinity. That measurement may be used to more confidently locate the MS using other TDOA measurements from other unrelated coming within range whereabouts information.

With the many DLM examples above it should be clear now to the reader how to set the WDR for DLM invoked processing. There can be other location technologies that will set WDR fields analogously. Locating methodologies of can be used in any combination for example for more timely or accurate locating. Furthermore a MS automatically takes on a role of a DLM or ILM depending on what capability is available at the time regardless of whether or not the MS is equipped for being directly located. As a DLM roams to unsupported areas it can remain a DLM using different DLM technologies and it can become an ILM to depend on other MSs ILMs or DLMs in the vicinity to locate it.

With reference now to ILM has been located relative a plurality of DLMs namely DLM DLM and DLM . ILM is located analogously to ILM as described for except there are different DLMs involved with doing the locating of ILM because of a different location of ILM . illustrate that MSs can be located using other MSs rather than fixed stationary references described for . ILM and ILM are indirectly located using DLMs .

With reference now to ILM is automatically located using the reference locations of ILM ILM and ILM . ILM ILM and ILM can be mobile while providing reference locations for automatically determining the location of ILM . ILM is located analogously to ILM as described for except there are different ILMs involved with doing the locating of ILM because of a different location of ILM . Note that as ILMs are located in the LN expanse the LN expanse expands with additionally located MSs.

With reference now to ILM is automatically located using the reference locations of ILM ILM and ILM . ILM ILM and ILM can be mobile while providing reference locations for automatically determining the location of ILM . ILM is located analogously to ILM as described for except there are different ILMs involved with doing the locating of ILM because of a different location of ILM . illustrate that an MS can be located using all ILMs rather than all DLMs a mixed set of DLMs and ILMs or fixed stationary references . ILMs and are indirectly located using ILMs. Note that in the illustrations the LN expanse has expanded down and to the right from DLMs directly located up and to the left. It should also be noted that locating any MS can be done with at least one other MS. Three are not required as illustrated. It is preferable that triangulation references used surround an MS.

With reference now to an analysis of an LN Expanse will contain at least one DLM region containing a plurality of DLMs and at least one DLM indirectly located region containing at least one ILM that has been located with all DLMs. Depending on the range or scope of an LN Expanse there may be a mixed region containing at least one ILM that has been indirectly located by both an ILM and DLM and there may be an exclusive ILM region containing at least one ILM that has been indirectly located by all ILMs. The further in distance the LN Expanse has expanded from DLM region with a substantial number of MSs the more likely there will an exclusive ILM region . NTP may be available for use in some regions or some subset of a region yet not available for use in others. NTP is preferably used where available to minimize communications between MSs and an MS and service s . An MS has the ability to make use of NTP when available.

With reference now to all MSs depicted know their own locations. The upper left hand portion of the illustration consists of region . As the reader glances more toward the rightmost bottom portion of the illustration there can be regions and regions in the middle of the illustration. At the very rightmost bottom portion of the illustration remaining ILMs fall in region . An ILM is indirectly located relative all DLMs DLMs and ILMs or all ILMs. An Affirmifier in a LN expanse confidently knows its own location and can serve as a reference MS for other MSs. An affirmifier is said to affirmify when in the act of serving as a reference point to other MSs. A Pacifier can contribute to locating other systems but with a low confidence of its own whereabouts. The LN Expanse is a network of located locatable MSs and is preferably expanded by a substantial number of affirmifiers.

Some fields are multi part fields i.e. have sub fields . Whereabouts Data Records WDRs may be fixed length records varying length records or a combination with field s in one form or the other. Some WDR embodiments will use anticipated fixed length record positions for subfields that can contain useful data or a null value e.g. 1 . Other WDR embodiments may use varying length fields depending on the number of sub fields to be populated. Other WDR embodiments will use varying length fields and or sub fields which have tags indicating their presence. Other WDR embodiments will define additional fields to prevent putting more than one accessible data item in one field. In any case processing will have means for knowing whether a value is present or not and for which field or sub field it is present. Absence in data may be indicated with a null indicator 1 or indicated with its lack of being there e.g. varying length record embodiments .

When a WDR is referenced in this disclosure it is referenced in a general sense so that the contextually reasonable subset of the WDR of is used. For example when communicating WDRs sending receiving data or between data processing systems a reasonable subset of WDR is communicated in preferred embodiments as described with flowcharts. When a WDR is maintained to queue preferably most if not all fields are set for a complete record regardless if useful data is found in a particular field e.g. some fields may be null e.g. 1 . Most importantly Whereabouts Data Records WDRs are maintained to queue for maintaining whereabouts of the MS which owns queue . LBX is most effective the more timely and continuous a MS has valid whereabouts locally maintained. WDRs are designed for maintaining whereabouts information independent of any location technology applied. Over time a MS may encounter a plurality of location technologies used to locate it. WDRs maintained to a first MS queue have the following purpose 

A MS may go in and out of DLM or ILM roles as it is mobile. Direct location methods are not always available to the MS as it roams therefore the MS preferably does all of 1 through 5 above. When the WDR contains a MS ID field matching the MS which owns queue that WDR contains the location location field with a specified confidence field at a particular time date time stamp field for that MS. Preferably the MS ID field date time stamp field and confidence field is all that is required for searching from the queue the best possible and most timely MS whereabouts at the time of searching queue . Other embodiments may consult any other fields to facilitate the best possible MS location at the time of searching and or processing queue . The WDR queue also maintains affirmifier WDRs and acceptable confidence pacifier WDRs block which are used to calculate a WDR having matching MS field so the MS knows its whereabouts via indirect location methods. Affirmifier and pacifier WDRs have MS ID field values which do not match the MS owning queue . This distinguishes WDRs of queue for A accessing the current MS location from B the WDRs from other MSs. All WDR fields of affirmifier and pacifier originated WDRs are of importance for determining a best location of the MS which owns queue and in providing LBX functionality.

MS ID field is a unique handle to an MS as previously described. Depending on the installation MS ID field may be a phone physical or logical address name machine identifier serial number encrypted identifier concealable derivative of a MS identifier correlation pseudo MS ID or some other unique handle to the MS. An MS must be able to distinguish its own unique handle from other MS handles in field . For indirect location functionality disclosed herein affirmifier and pacifier WDRs do not need to have a correct originating MS ID field . The MS ID may be null or anything to distinguish WDRs for MS locations. However to accomplish other LBX features and functionality MS Identifiers MS IDs of nearby MSs or unique correlations thereof maintained in queue are to be known for processing by an MS. MS ID field may contain a group identifier of MSs in some embodiments for distinguishing between types of MSs e.g. to be treated the same or targeted with communications as a group as long as the MS containing queue can distinguish its own originated WDRs . A defaulted value may also be set for a do not care setting e.g. null .

Date Time stamp field contains a date time stamp of when the WDR record was completed by an MS for its own whereabouts prior to WDR queue insertion. It is in terms of the date time scale of the MS inserting the local WDR NTP derived or not . Date Time stamp field may also contain a date time stamp of when the WDR record was determined for the whereabouts of an affirmifier or pacifier originating record to help an MS determine its own whereabouts but it should still be in terms of the date time scale of the MS inserting the local WDR NTP derived or not to prevent time conversions when needed and to promote consistent queue searches sorts etc. The date time stamp field should use the best possible granulation of time and may be in synch with other MSs and data processing systems according to NTP. A time zone day light savings time and NTP indicator is preferably maintained as part of field . The NTP indicator e.g. bit is for whether or not the date time stamp is NTP derived e.g. the NTP use setting is checked for setting this bit when completing the WDR for queue insertion . In some embodiments date time stamp field is measured in the same granulation of time units to an atomic clock available to MSs of an LN Expanse . When NTP is used in a LN Expanse identical time server sources are not a requirement provided NTP derived date time stamps have similar accuracy and dependability.

Location field depends on the installation of the present disclosure but can include a latitude and longitude cellular network cell identifier geocentric coordinates geodetic coordinates three dimensional space coordinates area described by GPS coordinates overlay grid region identifier or coordinates GPS descriptors altitude elevation e.g. in lieu of using field MAPSCO reference physical or logical network address including a wildcard e.g. ip addresses 145.32. . particular address polar coordinates or any other two three dimensional location methods means used in identifying the MS location. Data of field is preferably a consistent measure e.g. all latitude and longitude for all location technologies that populate WDR queue . Some embodiments will permit using different measures to location field e.g. latitude and longitude for one address for another polar coordinates for another etc which will be translated to a consistent measure at appropriate processing times.

Confidence field contains a value for the confidence that location field accurately describes the location of the MS when the WDR is originated by the MS for its own whereabouts. Confidence field contains a value for the confidence that location field accurately describes the location of an affirmifier or pacifier that originated the WDR. A confidence value can be set according to known timeliness of processing communications and known mobile variables e.g. MS speed heading yaw pitch roll etc at the time of transmission. Confidence values should be standardized for all location technologies used to determine which location information is of a higher lower confidence when using multiple location technologies as determined by fields and for enabling determination of which data is of a higher priority to use in determining whereabouts. Confidence value ranges depend on the implementation. In a preferred embodiment confidence values range from 1 to 100 as discussed previously for denoting a percentage of confidence. 100 confidence indicates the location field is guaranteed to describe the MS location. 0 confidence indicates the location field is guaranteed to not describe the MS location. Therefore the lowest conceivable value of a queue for field should be 1. Preferably there is a lowest acceptable confidence floor value configured by system administrator or user as used at points of queue entry insertion see block to prevent frivolous data to queue . In most cases WDRs contain a confidence field up to 100. In confidence value preferred embodiments pacifiers know their location with a confidence of less than 75 and affirmifiers know their location with a confidence value 75 or greater. The confidence field is skewed to lower values as the LN expanse is expanded further from region . Confidence values are typically lower when ILMs are used to locate a first set of ILMs i.e. first tier and are then lower when the first set of ILMs are used to locate a second set of ILMs second tier and then lower again when the second set of ILMs are used to locate a third set of ILMs third tier and so on. Often examination of a confidence value in a WDR can indicate whether the MS is a DLM or an ILM far away from DLMs or an MS which has been located using accurate high confidence or inaccurate low confidence locating techniques.

Location Technology field contains the location technology used to determine the location of location field . An MS can be located by many technologies. Location Technology field can contain a value from a row of or any other location technology used to locate a MS. WDRs inserted to queue for MS whereabouts set field to the technology used to locate the MS. WDRs inserted to queue for facilitating a MS in determining whereabouts set field to the technology used to locate the affirmifier or pacifier. Field also contains an originator indicator e.g. bit for whether the originator of the WDR was a DLM or ILM. When received from a service that has not provided confidence this field may be used by a DLM to determine confidence field

Location Reference Info field preferably contains one or more fields useful to locate a MS in processing subsequent of having been inserted to queue . In other embodiments it contains data that contributed to confidence determination. Location Reference Info field may contain information TDOA measurement and or AOA measurement see inserted field for useful to locate a MS in the future when the WDR originated from the MS for its own whereabouts. Field will contain selected triangulation measurements wave spectrum used and or particular communications interfaces signal strength s TDOA information AOA information or any other data useful for location determination. Field can also contain reference whereabouts information to use relative a TDOA or AOA otherwise WDR location field assumed as reference . In one embodiment field contains the number of DLMs and ILMs which contributed to calculating the MS location to break a tie between using WDRs with the same confidence values. In another embodiment a tier of ILMs used to locate the MS is maintained so there is an accounting for the number of ILMs in the LN expanse between the currently located MS and a DLM. In other embodiments MS heading yaw pitch and roll or accelerometer values are maintained therein for example for antenna AOA positioning. When wave spectrum frequencies or other wave characteristics have changed in a transmission used for calculating a TDOA measurement appropriate information may be carried along for example to properly convert a time into a distance. Field should be used to facilitate correct measurements and uses if needed conversions have not already taken place.

Communications reference information field is a multipart record describing the communications session channel and bind criteria between the MS and MSs or service s that helped determine its location. In some embodiments field contains unique MS identifiers protocol used logon access parameters and useful statistics of the MSs which contributed to data of the location field . An MS may use field for WDRs originated from affirmifiers and pacifiers for subsequent LBX processing.

Speed field contains a value for the MS speed when the WDR is originated by the MS for its own whereabouts. Speed field may contain a value for speed of an affirmifier or pacifier when the WDR was originated elsewhere. Speed is maintained in any suitable units.

Heading field contains a value for the MS heading when the WDR is originated by the MS for its own whereabouts. Heading field may contain a value for heading of an affirmifier or pacifier when the WDR was originated elsewhere. Heading values are preferably maintained in degrees up to 360 from due North but is maintained in any suitable directional form.

Elevation field contains a value for the MS elevation or altitude when the WDR is originated by the MS for its own whereabouts. Elevation field may contain a value for elevation altitude of an affirmifier or pacifier when the WDR was originated elsewhere. Elevation or altitude is maintained in any suitable units.

Application fields contains one or more fields for describing application s at the time of completing or originating the WDR . Application fields may include field s for 

Correlation field is optionally present in a WDR when the WDR is in a transmission between systems e.g. wireless communications such as in data or . Field provides means for correlating a response to an earlier request or to correlate a response to an earlier broadcast. Correlation field contains a unique handle. In a LN expanse which globally uses NTP there is no need for correlation in data or . Correlation field may be present in WDRs of queues or . Alternatively a MS ID is used for correlation.

Sent date time stamp field is optionally present in a WDR when the WDR is in transmission between systems e.g. wireless communications such as in data or . Field contains when the WDR was transmitted. A time zone day light savings time and NTP indicator is preferably maintained as part of field . Field is preferably not present in WDRs of queue but can be if TDOA measurement calculation is delayed to a later time . In some embodiments there is no need for field . Whereabouts determined for MSs of an LN Expanse may be reasonably timely facilitating simplicity of setting outbound field to the transmission date time stamp at the sending data processing system rather than when the WDR was originally completed for whereabouts e.g. when substantially the same time anyway . Sent date time field may be present in WDRs of queues or .

Received date time stamp field is preferably present in a WDR when inserted to queue by receiving thread s upon received data or . Field contains when the WDR was received by the MS. A time zone day light savings time and NTP indicator is preferably maintained as part of field . Field is preferably not present in WDRs of queue but can be if TDOA measurement calculation is delayed to a later time . In some embodiments there is no need for field . For example thread s may be listening directly on applicable channel s and can determine when the data is received. In another embodiment thread s process fast enough to determine the date time stamp of when data or is received since minimal time has elapsed between receiving the signal and determining when received. In fact known processing duration between when received and when determined to be received can be used to correctly alter a received date time stamp. Received date time stamp field is preferably added to records placed to queue by receiving thread s feeding queue .

Any fields of WDR which contain an unpredictable number of subordinate fields of data preferably use a tagged data scheme for example an X.409 encoding for a Token Length and Value called a TLV encoding . Therefore a WDR or field therein can be a variable sized record. For example Location Reference info field may contain TTA 8 0.1456 where the Token TTA for Time Till Arrival TDOA measurement between when sent and when received Length 8 for 8 bytes to follow and Value 0.1456 in time units contained within the 8 bytes also SS 4 50 where Token Signal Strength 4 4 for 4 bytes to follow and Value 50 dBu for the signal strength measurement. This allows on the fly parsing of unpredictable but interpretable multipart fields. The TLV encoding also enables on the fly configuration for parsing new subordinate fields to any WDR field in a generic implementation for example in providing parse rules to a Lex and Yacc implementation or providing parse rules to a generic top down recursive TLV encoding parser and processor.

Any field of WDR may be converted a prior to insertion to queue or b after access to queue or c by queue interface processing for standardized processing. Any field of WDR may be converted when sending receiving broadcasting or related processing to ensure a standard format. Other embodiments will store and access values of WDR field s which are already in a standardized format. WDR fields can be in any order and a different order when comparing what is in data transmitted versus data maintained to queue .

An alternate embodiment to WDRs maintained to queue preserves transport fields and or for example for use on queue . This would enable thread s to perform TDOA measurements that are otherwise calculated in advance and kept in field . However queue size should be minimized and the preferred embodiment uses transport fields when appropriate to avoid carrying them along to other processing.

With reference now to a triangulation of MS at location is explained using location whereabouts of MS location whereabouts of MS and location whereabouts of MS. Signal transmission distance from MSlocations are represented by the radiuses with rthe TDOA measurement time difference between when sent and when received between MSand MS with rthe TDOA measurement time difference between when sent and when received between MSand MS with rthe TDOA measurement time difference between when sent and when received between MSand MS . In this example the known locations of MSwhich are used to determine the location of MS allow triangulating the MS whereabouts using the TDOA measurements. In fact less triangular data in the illustration can be necessary for determining a highly confident whereabouts of MS

With reference now to a triangulation of MS at location is explained using location whereabouts of MS location whereabouts of MS and location whereabouts of MS. In some embodiments AOA measurements taken at a positioned antenna of MS at location are used relative the whereabouts whereabouts whereabouts AOA AOA and AOA wherein AOA measurements are detected for incoming signals during known values for MS heading with MS yaw pitch and roll or accelerometer readings . AOA triangulation is well known in the art. Line segment represents the direction of signal arrival to the antenna at whereabouts from MSat whereabouts . Line segment represents the direction of signal arrival to the antenna at whereabouts from MSat whereabouts . Line segment represents the direction of signal arrival to the antenna at whereabouts from MSat whereabouts . In this example the known locations of MSwhich are used to determine the location of MS allow triangulating the MS whereabouts using the AOA measurements. In fact less triangular data in the illustration can be necessary for determining a highly confident whereabouts of MS . Alternative embodiments will use AOA measurements of outbound signals from the MS at whereabouts detected at antennas of whereabouts and or and or .

If block determines NTP is enabled as defaulted or last set by a user i.e. persistent variable then block initializes NTP appropriately and processing continues to block . If block determines NTP was not enabled then processing continues to block . Block embodiments are well known in the art of NTP implementations also see block . Block may cause the starting of thread s associated with NTP. In some embodiments NTP use is assumed in the MS. In other embodiments appropriate NTP use is not available to the MS. Depending on the NTP embodiment thread s may pull time synchronization information or may listen for and receive pushed time information. Resources or other MS local resource provides interface to an MS clock for referencing maintaining and generating date time stamps at the MS. After block processing the MS clock is synchronized to NTP. Because of initialization of the MS in block may rely on a connected service to initially get the startup synchronized NTP date time. MS NTP processing will ensure the NTP enabled disabled variable is dynamically set as is appropriate using semaphore access because an MS may not have continuous clock source access during travel when needed for resynchronization. If the MS does not have access to a clock source when needed the NTP use variable is disabled. When the MS has or again gets access to a needed clock source then the NTP use variable is enabled.

Thereafter block creates shared memory to maintain data shared between processes threads block initializes persistent data to shared memory block initializes any non persistent data to shared memory e.g. some statistics block creates system queues and block creates semaphore s used to ensure synchronous access by concurrent threads to data in shared memory before continuing to block . Shared memory data accesses appropriately utilize semaphore lock windows semaphore s created at block for proper access. In one embodiment block creates a single semaphore for all shared memory accesses but this can deteriorate performance of threads accessing unrelated data. In the preferred embodiment there is a semaphore for each reasonable set of data of shared memory so all threads are fully executing whenever possible. Persistent data is that data which maintains values during no power for example as stored to persistent storage . This may include data including permissions charters statistics service directory data LBX history data resources and or other data. Persistent data preferably includes at least the DLMV see DLM role s list Variable below ILMV see ILM role s list Variable below process variables Max values and see discussions below for the last configured maximum number of threads to run in the respective process process variables PID values and see discussions below for multi purpose of a holding an Operating System Process Identifier i.e. O S PID for a process started and b whether or not the respective process was last enabled i.e. PID 0 or disabled i.e. PID

All queues disclosed herein are understood to have their own internally maintained semaphore for queue accesses so that queue insertion peeking accessing etc uses the internally maintained semaphore to ensure two or more concurrently executing threads do not corrupt or misuse data to any queue. This is consistent with most operating system queue interfaces wherein a thread stays blocked preempted after requesting a queue entry until a queue entry appears in the queue. Also no threads will collide with another thread when inserting peeking or otherwise accessing the same queue. Therefore queues are implicitly semaphore protected. Other embodiments may use an explicit semaphore protected window around queue data accessing in which case those semaphore s are created at block .

Thereafter block checks for any ILM roles currently enabled for the MS for example as determined from persistent storage of an ILM role s list Variable ILMV preferably preconfigured for the MS at first use or configured as last configured by a user of the MS . ILM roles are maintained to the ILM role s list Variable ILMV . The ILMV contains one or more entries for an ILM capability role each entry with a flag indicating whether it is enabled or disabled marked enabled unmarked disabled . If block determines there is at least one ILM role enabled i.e. as marked by associated flag then block artificially sets the corresponding PID variables to a value greater than 0 for indicating the process es are enabled and are to be started by subsequent initialization processing. The PID will be replaced with the correct Process Identifier PID upon exit from block after the process is started. Preferably every MS can have ILM capability. However a user may want to configure ensure a DLM has no ILM capability enabled e.g. or having no list present . In some embodiments by default every MS has an unmarked list of ILM capability maintained to the ILMV for 1 USE DLM REFERENCES and 2 USE ILM REFERENCES. USE DLM REFERENCES when enabled marked in the ILMV indicates to allow the MS of processing to determine its whereabouts relative remote DLMs. USE ILM REFERENCES when enabled marked in the ILMV indicates to allow the MS of processing to determine its whereabouts relative remote ILMs. Having both list items marked indicates to allow determining MS whereabouts relative mixed DLMs and ILMs. An alternative embodiment may include a USE MIXED REFERENCES option for controlling the MS of processing to determine its whereabouts relative mixed DLMs and or ILMs. Alternative embodiments will enforce any subset of these options without exposing user configurations for example on a MS without any means for being directly located.

For any of the ILMV roles of USE DLM REFERENCES USE ILM REFERENCES or both all processes and are preferably started i.e. PID PID PID PID PID and PID are artificially set at block to cause subsequent process startup at block . Characteristics of an anticipated LN expanse e.g. anticipated location technologies of participating MSs MS capabilities etc will start a reasonable subset of those processes with at least process started. Block continues to block . If block determines there are no ILMV role s enabled then block processing continues to block .

Block initializes an enumerated process name array for convenient processing reference of associated process specific variables described in and continues to block where the first member of the set is accessed for subsequent processing. The enumerated set of process names has a prescribed start order for MS architecture . Thereafter if block determines the process identifier i.e. PID such that is in a loop iteration of blocks through is greater than 0 e.g. this first iteration of PID 0 implies it is to be started here also implies process is enabled as used in then block spawns starts the process e.g. of to start execution of subordinate worker thread s e.g. process thread s and saves the real PID Process Identifier to the PID variable e.g. PID returned by the operating system process spawn interface. Block passes as a parameter to the process of which process name to start e.g. and continues to block . If block determines the current process PID variable e.g. PID is not greater than 0 i.e. not to be started also implies is disabled as used in then processing continues to block . Block checks if all process names of the enumerated set pattern of have been processed iterated by blocks through . If block determines that not all process names in the set have been processed iterated then processing continues back to block for handling the next process name in the set. If block determines that all process names of the enumerated set were processed then block checks the DLMV DLM role s list Variable . Blocks through iterate every process name of to make sure that each is started in accordance with non zero PID variable values at initialization.

Block checks for any DLM roles currently enabled for the MS for example as determined from persistent storage of a DLM role s list Variable DLMV preferably preconfigured for the MS at first use if the MS contains DLM capability . DLM capability roles whether on board at the MS or determined during MS travels see block is maintained to the DLM role s list Variable DLMV . The DLMV contains one or more entries for a DLM capability role each role entry with a flag indicating whether it is enabled or disabled marked enabled unmarked disabled . If block determines there is at least one DLM role enabled i.e. as marked by associated flag then block initializes enabled role s appropriately and processing continues to block . Block may cause the starting of thread s associated with enabled DLM role s for DLM processing above e.g. . Block may invoke API s enable flag s or initialize as is appropriate for DLM processing described above. Such initializations are well known in the art of prior art DLM capabilities described above. If block determines there are no DLM roles to initialize at the MS then processing continues to block . Any of the technologies are eligible in the DLMV as determined to be present at the MS and or as determined by historical contents of the WDR queue e.g. location technology field with MS ID field for this MS and or determined by LBX history . Application Programming Interfaces APIs may also be used to determine MS DLM capability role s for entry s to the DLMV.

Block completes LBX character initialization and initialization processing terminates thereafter at block . Depending on what threads were started as part of block Block may startup the preferred number of listen receive threads for feeding queue and the preferred number of send threads for sending data inserted to queue in particular when transmitting new data and receiving new data or . The number of threads started should be optimal for parallel processing across applicable channel s . Upon encounter of block the MS is appropriately operational and a user at the MS of processing will have the ability to use the MS and applicable user interfaces thereof.

With reference now to depicted is a flowchart for describing a preferred embodiment of a process for starting a specified number of threads in a specified thread pool. is in itself an O S process has a process identifier PID after being started will contain at least two threads of processing after being started and is generic in being able to take on the identity of any process name passed to it e.g. with a parameter e.g. from block . represents the parent thread of a process. The process is generic for executing any of processes i.e. and with the prescribed number of worker threads using the Max configuration i.e. Max Max Max Max Max and Max . will stay running until it first all of its worker thread s is terminated. consists of an O S Process with at least a parent thread main thread and one worker thread or number of worker threads for processing as determined by Max . The parent thread has purpose to stay running while all worker threads are running and to own intelligence for starting worker threads and terminating the process when all worker threads are terminated. The worker threads are started subordinate to the process at block using an O S start thread interface.

A i.e. and process starts at block and continues to block where the parameter passed for which process name to start i.e. take on identity of is determined e.g. . Thereafter block creates a RAM semaphore i.e. operating system term for a well performing Random Access Memory RAM semaphore with scope only within the process i.e. to all threads of the process . The local semaphore name preferably uses the process name prefix e.g. Sem and is used to synchronize threads within the process. RAM semaphores perform significantly better than global system semaphores. Alternate embodiments will have process semaphore s created at block in advance. Thereafter block initializes a thread counter e.g. Ct to 0 for counting the number of worker threads actually started within the process e.g. block initializes a loop variable J to 0 and block starts a worker thread the first one upon first encounter of block for a process in this process e.g. process starts worker thread . . . process starts worker thread see architecture description below .

Thereafter block increments the loop variable by 1 and block checks if all prescribed worker threads have been started. Block accesses the Max e.g. Max variable from shared memory using a semaphore for determining the maximum number of threads to start in the process worker thread pool. If block determines all worker threads have been started then processing continues to block . If block determines that not all worker threads have been started for the process of then processing continues back to block for starting the next worker thread. Blocks through ensure the Max e.g. Max number of worker threads are started within the process of .

Block waits until all worker threads of blocks through have been started as indicated by the worker threads themselves. Block waits until the process Ct variable has been updated to the prescribed Max value by the started worker threads thereby indicating they are all up and running. When all worker threads are started e.g. Ct Max thereafter block waits perhaps a very long time until the worker thread count e.g. Ct has been reduced back down to 0 for indicating that all worker threads have been terminated for example when the user gracefully powers off the MS. Block continues to block when all worker threads have been terminated. Block sets the shared memory variable for the process e.g. PID to 0 using a semaphore for indicating that the e.g. process is disabled and no longer running. Thereafter the process terminates at block . Waiting at blocks and are accomplished in a variety of well known methods 

Starting threads of processing in has been presented from a software perspective but there are hardware firmware thread embodiments which may be started appropriately to accomplish the same functionality. If the MS operating system does not have an interface for returning the PID at block then can have a block e.g. used to determine its own PID for setting the PID variable.

In another embodiment data contains a Communications Key CK because data is new transmitted data in accordance with the present disclosure. Data purpose is for carrying CK information for being detected parsed and processed when received by another MS or other data processing system in the vicinity of the MS e.g. DLM as determined by the maximum range of transmission .

With reference now to a MS for example an ILM sends broadcasts data such as a data in a manner well known to those skilled in the art. Data and CK are as described above for . Data or CK can be detected parsed and processed when received by another MS or other data processing system in the vicinity of the MS e.g. ILM as determined by the maximum range of transmission . Transmission from the MS radiate out from it in all directions in a manner consistent with the wave spectrum used and as described above for .

With reference now to a service or set of services sends broadcasts data such as a data packet in a manner well known to those skilled in the art for example to service other character processing. When a Communications Key CK is embedded within data data is considered usual communications data e.g. protocol voice or any other data over conventional forward channel reverse channel voice data channel data transmission channel or any other prior art use channel which has been altered to contain CK . Data contains a CK which can be detected parsed and processed when received by an MS or other data processing system in the vicinity of the service s as determined by the maximum range of transmission . CK permits piggy backing on current transmissions to accomplish new functionality as disclosed herein. Transmissions radiate out in all directions in a manner consistent with the wave spectrum used and data carried thereon may or may not be encrypted e.g. encrypted WDR information . The radius represents a first range of signal reception from the service e.g. antenna thereof perhaps by a MS not shown . The radius represents a second range of signal reception from the service e.g. antenna thereof perhaps by a MS not shown . The radius represents a third range of signal reception from the service e.g. antenna thereof perhaps by a MS not shown . The radius represents a last and maximum range of signal reception from the service e.g. antenna thereof perhaps by a MS not shown . The time of transmission from service to radius is less than times of transmission from service to radiuses or . The time of transmission from service to radius is less than times of transmission from service to radiuses or . The time of transmission from service to radius is less than time of transmission from service to radius . In another embodiment data contains a Communications Key CK because data is new transmitted data in accordance with the present disclosure. Data purpose is for carrying CK information for being detected parsed and processed when received by another MS or data processing system in the vicinity of the service s as determined by the maximum range of transmission.

In some embodiments data and are prior art wireless data transmission packets with the exception of embedding a detectable CK and or CK respectively. Usual data communications of MSs are altered to additionally contain the CK so data processing systems in the vicinity can detect parse and process the CK. Appropriate send and or broadcast channel processing is used. In other embodiments data and are new broadcast wireless data transmission packets for containing CK and CK respectively. A MS may use send queue for sending broadcasting packets to data processing systems in the vicinity and may use the receive queue for receiving packets from other data processing systems in the vicinity. Contents of CKs Communications Keys depend on which LBX features are in use and the functionality intended.

In the case of piggybacking on usual communications receive queue insertion processing simply listens for the usual data and when detecting CK presence inserts CK information appropriately to queue for subsequent processing. Also in the case of piggybacking on usual communications send queue retrieval processing simply retrieves CK information from the queue and embeds it in an outgoing data at first opportunity. In the case of new data communications receive queue insertion processing simply listens for the new data containing CK information and inserts CK information appropriately to queue for subsequent processing. Also in the case of new data communications send queue retrieval processing simply retrieves CK information from the queue and transmits CK information as new data.

If block determines the user selected to maintain the WDR queue then the user maintains WDRs at block and processing continues back to block . Block processing is described by . Blocks and are understood to be delimited by appropriate semaphore control to avoid multi threaded access problems. If block determines the user did not select to maintain the WDR queue then processing continues to block . If block determines the user selected to configure the confidence floor value then block prepares parameters for invoking a Configure Value procedure parameters for reference address of value to configure and validity criteria of value to configure and the Configure Value procedure of is invoked at block with the two 2 parameters. Thereafter processing continues back to block . Blocks and are understood to be delimited by appropriate semaphore control when modifying the confidence floor value since other threads can access the floor value.

The confidence floor value is the minimum acceptable confidence value of any field for example as checked by block . No WDR with a field less than the confidence floor value should be used to describe MS whereabouts. In an alternative embodiment the confidence floor value is enforced as the same value across an LN expanse with no user control to modify it. One embodiment of does not permit user control over a minimum acceptable confidence floor value. Various embodiments will default the floor value. Block enforces an appropriate value in accordance with the confidence value range implemented e.g. value from 1 to 100 . Since the confidence of whereabouts is likely dependent on applications in use at the MS the preferred embodiment is to permit user configuration of the acceptable whereabouts confidence for the MS. A new confidence floor value can be put to use at next thread s startup or can be used instantly with the modification made depending on the embodiment. The confidence floor value can be used to filter out WDRs prior to inserting to queue filter out WDRs when retrieving from queue filter out WDR information when listening on channel s prior to inserting to queue and or used in accessing queue for any reason depending on embodiments . While confidence is validated on both inserts and queries retrievals peeks one or the other validation is fine preferably on inserts . It is preferred that executable code incorporate checks where applicable since the confidence floor value can be changed after queue is in use. Also various present disclosure embodiments may maintain all confidences to queue or a particular set of acceptable confidences.

If block determines the user did not select to configure the confidence floor value then processing continues to block . If block determines the user selected to configure the Whereabouts Timeliness Variable WTV then block prepares parameters for invoking the Configure Value procedure parameters for reference address of value to configure and validity criteria of value to configure and the Configure Value procedure of is invoked at block with the two 2 parameters. Thereafter processing continues back to block . Blocks and are understood to be delimited by appropriate semaphore control when modifying the WTV since other threads can access the WTV.

A critical configuration for MS whereabouts processing is whereabouts timeliness. Whereabouts timeliness is how often how timely an MS should have accurate whereabouts. Whereabouts timeliness is dependent on how often the MS is updated with whereabouts information what technologies are available or are in the vicinity how capable the MS is of maintaining whereabouts processing speed s transmission speed s known MS or LN expanse design constraints and perhaps other factors. In some embodiments whereabouts timeliness is as soon as possible. That is MS whereabouts is updated whenever possible as often as possible. In fact the present disclosure provides an excellent system and methodology to accomplish that by leveraging location technologies whenever and wherever possible. However there should be balance when considering less capable processing of a MS to prevent hogging CPU cycles from other applications at the MS. In other embodiments a hard coded or preconfigured time interval is used for keeping an MS informed of its whereabouts in a timely manner. For example the MS should know its own whereabouts at least every second or at least every 5 seconds or at least every minute etc. Whereabouts timeliness is critical depending on the applications in use at the MS. For example if MS whereabouts is updated once at the MS every 5 minutes during high speeds of travel when using navigation the user has a high risk of missing a turn during travel in downtown cities where timely decisions for turns are required. On the other hand if MS whereabouts is updated every 5 seconds and an application only requires an update accuracy to once per minute then the MS may be excessively processing.

In some embodiments there is a Whereabouts Timeliness Variable WTV configured at the MS blocks . Whether it is user configured system configured or preset in a system the WTV is used to 

If block determines the user did not select to configure the WTV then processing continues to block . If block determines the user selected to configure the maximum number of threads in a process see Max variable in discussions then block interfaces with the user until a valid max variable is selected and processing continues to block . If block determines the process is already running i.e. PID 0 implies it is enabled then an error is provided to the user at block and processing continues back to block . Preferably block does not continue back to block until the user acknowledges the error e.g. with a user action . If block determines the user selected process process process process process process or process is not already running i.e. PID 0 implies it is disabled then block prepares parameters for invoking the Configure Value procedure parameters for reference address of Max value to configure and validity criteria of value to configure and the Configure Value procedure of is invoked at block with the two 2 parameters. Thereafter processing continues back to block . Blocks and are understood to be delimited by appropriate semaphore control when modifying the Max value since other threads can access it. The Max value should not be modified while the process is running because the number of threads to terminate may be changed prior to terminating. An alternate embodiment of modifying a process number of threads will dynamically modify the number of threads in anticipation of required processing.

If block determines the user did not select to configure a process thread maximum Max then block checks if the user selected to toggle disable or enable a particular process i.e. a process of . If block determines the user did select to toggle enabling disabling a particular process then block interfaces with the user until a valid process name is selected and processing continues to block . If block determines the process is already running i.e. PID 0 implies it is enabled then block prepares parameters just as does block . Thereafter block invokes processing just as does block . Processing then continues back to block . If block determines the process is not running i.e. PID 0 implies it is disabled then block invokes processing just as does block . Processing then continues back to block . Block does not continue back to block until the process is completely terminated. Blocks and are understood to be delimited by appropriate semaphore control.

Preferred embodiments of blocks and use convenient names of processes being started or terminated rather than convenient brief process names such as or used in flowcharts. In some embodiments the long readable name is used such as whereabouts broadcast process whereabouts collection process whereabouts supervisor process timing determination process WDR request process and whereabouts determination process . For example the user may know that the whereabouts supervisor process enabled disabled indicates whether or not to have whereabouts timeliness monitored in real time. Enabling the whereabouts supervisor process enables monitoring for the WTV in real time and disabling the whereabouts supervisor process disables monitoring the WTV in real time.

In another embodiment of blocks and a completely new name or description may be provided to any of the processes to facilitate user interface usability. For example a new name Peer Location Source Variable PLSV can be associated to the whereabouts broadcast process and or . PLSV may be easier to remember. If the PLSV was toggled to disabled the whereabouts broadcast process and or terminates. If the PLSV was toggled to enabled the whereabouts broadcast process and or is started. It may be easier to remember that the PLSV enables disables whether or not to allow this MS to be a location source for other MSs in an LN expanse.

In other embodiments a useful name e.g. PLSV represents starting and terminating any subset of processes a plurality e.g. and for simplicity. In yet other embodiments B can be used to start or terminate worker thread s in any process for example to throttle up more worker threads in a process or to throttle down for less worker threads in a process perhaps modifying thread instances to accommodate the number of channels for communications or for the desired performance. There are many embodiments for fine tuning the architecture for optimal peer to peer interaction. In yet other embodiments toggling may not be used. There may be individual options available at block for setting any data of this disclosure. Similarly the Max variables may be modified via individual user friendly names and or as a group of Max variables.

Referring back to block if it is determined the user did not select to toggle for enabling disabling process es then processing continues to block . If block determines the user selected to exit B configuration processing then block terminates the user interface appropriately and processing terminates at block . If block determines the user did not select to exit the user interface then processing continues to block of by way of off page connector .

With reference now to depicted is a continued portion flowchart of for describing a preferred embodiment of MS LBX configuration processing. If block determines the user selected to configure the Source Periodicity Time Period SPTP value then block prepares parameters for invoking the Configure Value procedure parameters for reference address of value to configure and validity criteria of value to configure and the Configure Value procedure of is invoked at block with the two 2 parameters. Thereafter processing continues back to block by way of off page connector . Blocks and are understood to be delimited by appropriate semaphore control when modifying the SPTP value since other threads can access it. The SPTP configures the time period between broadcasts by thread s for example 5 seconds. Some embodiments do not permit configuration of the SPTP.

If block determines the user did not select to configure the SPTP value then processing continues to block . If block determines the user selected to configure service propagation then the user configures service propagation at block and processing continues back to block by way of off page connector . If block determines the user did not select to configure service propagation then processing continues to block .

If block determines the user selected to configure permissions then the user configures permissions at block and processing continues back to block by way of off page connector . If block determines the user did not select to configure permissions then processing continues to block . If block determines the user selected to configure charters then the user configures charters at block and processing continues back to block by way of off page connector . If block determines the user did not select to configure charters then processing continues to block . If block determines the user selected to configure statistics then the user configures statistics at block and processing continues back to block by way of off page connector . If block determines the user did not select to configure statistics then processing continues to block . If block determines the user selected to configure service informant code then the user configures code at block and processing continues back to block by way of off page connector . If block determines the user did not select to configure code then processing continues to block . If block determines the user selected to maintain LBX history then the user maintains LBX history at block and processing continues back to block by way of off page connector . If block determines the user did not select to maintain LBX history then processing continues to block .

Block handles other user interface actions leaving block and processing continues back to block by way of off page connector .

Details of blocks and perhaps more detail to block are described with other flowcharts. Appropriate semaphores are requested at the beginning of block processing and released at the end of block processing for thread safe access to applicable data at risk of being accessed by another thread of processing at the same time of configuration. In some embodiments a user administrator with secure privileges to the MS has ability to perform any subset of configurations of processing while a general user may not. Any subset of configuration may appear in alternative embodiments with or without authenticated administrator access to perform configuration.

Block determines if there were any changes to the DLMV from processing by comparing the DLMV after block with the DLMV saved at block . If there were changes via processing such as a role which was enabled prior to block which is now disabled or such as a role which was disabled prior to block which is now enabled then block continues to block which handles the DLMV changes appropriately. Block continues to block which terminates processing. If block determines there were no changes via block then processing terminates at block .

Block enables newly enabled role s as does block described for . Block disables newly disabled role s as does block described for .

Block determines if there were any changes to the ILMV from processing by comparing the ILMV after block with the ILMV saved at block . If there were changes via processing such as a role which was enabled prior to block which is now disabled or such as a role which was disabled prior to block which is now enabled then block continues to block which handles the ILMV changes appropriately. Block continues to block which terminates processing. If block determines there were no changes via block then processing terminates at block .

Block enables newly enabled role s as does blocks through described for . Block disables newly disabled role s as does blocks through described for .

If block determines the user did not respond for disabling NTP then block checks for a toggle to being enabled. If block determines the user wanted to enable NTP use then block accesses known NTP server address es e.g. ip addresses preconfigured to the MS or set with another user interface at the MS and pings each one if necessary at block with a timeout. As soon as one NTP server is determined to be reachable block continues to block . If no NTP server was reachable then the timeout will have expired for each one tried at block for continuing to block . Block determines if at least one NTP server was reachable at block . If block determines no NTP server was reachable then an error is presented to the user at block and processing continues back to block . Preferably the error presented at block requires the user to acknowledge the error before block continues to block . If block determines that at least one NTP server was reachable then block initializes NTP use appropriately block sets the NTP use setting to enabled and saves and processing continues back to block . Block enables NTP as does block .

Referring back to block if it is determined the user did not want to enable NTP use then processing continues to block where it is checked if the user wanted to exit processing. If block determines the user did not select to exit processing then processing continues to block where other user interface actions leaving block are appropriately handled and then processing continues back to block . If block determines the user did select to exit processing then processing terminates at block .

There are many embodiments for maintaining WDRs of queue . In some embodiments i.e. block processing is only provided for debug of an MS. In a single instance WDR embodiment block presents the one and only WDR which is used to keep current MS whereabouts whenever possible. Other embodiments incorporate any subset of processing.

Block continues to block where the current value passed is presented to the user e.g. confidence floor value and then to block for awaiting user action. When a user action is detected at block block checks if the user selected to modify the value in which case block interfaces with the user for a validated value using the validity criteria parameter before continuing back to block . Validity criteria may take the form of a value range value type set of allowable values or any other criteria for what makes the value a valid one.

If block determines the user did not select to modify the value then block checks if the user wanted to exit processing. If block determines the user did not select to exit processing then processing continues to block where other user interface actions leaving block are appropriately handled and then processing continues back to block . If block determines the user did select to exit processing then processing appropriately returns to the caller at block .

A process is a slave to queue process when its worker thread s are driven by feeding from a queue of architecture . A slave to queue process stays blocked O S terminology blocked preempted on a queue entry retrieval interface until the sought queue item is inserted to the queue. The queue entry retrieval interface becomes cleared O S terminology cleared clear to run when the sought queue entry is retrieved from the queue by a thread. These terms blocked and cleared are analogous to a semaphore causing a thread to be blocked and a thread to be cleared as is well known in the art. Queues have semaphore control to ensure no more than one thread becomes clear at a time for a single queue entry retrieved as done in an O S . One thread sees a particular queue entry but many threads can feed off the same queue to do the same work concurrently. Slave to queue type of processes are and . A slave to queue process is properly terminated by inserting a special termination queue entry for each worker thread to terminate itself after queue entry retrieval.

A process is a slave to timer process when its worker thread s are driven by a timer for peeking a queue of architecture . A timer provides the period of time for a worker thread to sleep during a looped iteration of checking a queue for a sought entry without removing the entry from the queue . Slave to timer threads periodically peek a queue and based on what is found will process appropriately. A queue peek does not alter the peeked queue. The queue peek interface is semaphore protected for preventing peeking at an un opportune time e.g. while thread inserting or retrieving from queue . Queue interfaces ensure one thread is acting on a queue with a queue interface at any particular time. Slave to timer type of processes are and . A slave to timer process is properly terminated by inserting a special termination queue entry for each worker thread to terminate itself by queue entry peek.

Block knows the type of process for preparing the process type parameter for invocation of at block . The type of process has slightly different termination requirements because of the worker thread s processing type. Alternate embodiments of slave to timer processes will make them slave to queue processes by simply feeding off Thread Request TR queue for driving a worker thread when to execute and when to terminate . New timer s would insert timely queue entries to queue and processes and would retrieve from the queue record . The queue entries would become available to queue when it is time for a particular worker thread to execute. Worker threads of processes and could retrieve and stay blocked on queue until an entry was inserted by a timer for enabling a worker thread field set to or . TR queue is useful for starting any threads of architecture in a slave to queue manner. This may be a cleaner architecture for all thread pools to operate the same way slave to queue . Nevertheless the two thread pool methods are implemented.

Receive Rx queue is for receiving CK or CK data e.g. WDR or WDR requests for example from wireless transmissions. Queue will receive at least WDR information destined for threads and WDR requests records destined for threads . At least one thread not shown is responsible for listening on appropriate channel s and immediately depositing appropriate records to queue so that they can be processed by architecture . Preferably there is a plurality pool of threads for feeding queue based on channel s being listened on and data or anticipated for being received. Alternative embodiments of thread s may themselves directly be listening on appropriate channels and immediately processing packets identified in lieu of a queue . Alternative embodiments of thread s may themselves directly be listening on appropriate channels and immediately processing packets identified in lieu of a queue . Queue is preferred to isolate channel s e.g. frequency s and transmission reception processing in well known modular e.g. Radio Frequency RF componentry while providing a high performance queue interface to other asynchronous threads of architecture e.g. thread s of process . Wave spectrums via particular communications interface are appropriately processed for feeding queue . As soon as a record is received by an MS it is assumed ready for processing at queue . All queue accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. Queue entries inserted to queue may have arrived on different channel s and in such embodiments a channel qualifier may further direct queue entries from queue to a particular thread or e.g. thread s dedicated to channel s . In other embodiments receive processing feeds queue independent of any particular channel s monitored or received on the preferred embodiment described . Regardless of how data is received and then immediately placed on queue a received date time stamp e.g. fields or is added to the applicable record for communicating the received date time stamp to a thread e.g. thread s or of when the data was received. Therefore the queue insert interface tells the waiting thread s when the data was actually received. This ensures a most accurate received date time stamp as close to receive processing as possible e.g. enabling most accurate TDOA measurements . An alternate embodiment could determine applicable received date time stamps in thread s or thread s . Other data placed into received WDRs are wave spectrum and or particular communications interface of the channel received on and heading yaw pitch roll or accelerometer readings with AOA measurements signal strength and other field eligible data of the receiving MS. Depending on alternative embodiments queue may be viewed metaphorically for providing convenient grounds of explanation.

Send Tx queue is for sending communicating CK data for example for wireless transmissions. At least one thread not shown is responsible for immediately transmitting e.g. wirelessly anything deposited to queue . Preferably there is a plurality pool of threads for feeding off of queue based on channel s being transmitted on and data anticipated for being sent. Alternative embodiments of thread s of processes and may themselves directly transmit send broadcast on appropriate channels anything deposited to queue in lieu of a queue . Queue is preferred to isolate channel s e.g. frequency s and transmission processing in well known modular e.g. RF componentry while providing a high performance queue interface to other asynchronous threads of architecture e.g. thread s . Wave spectrums and or particular communications interface are appropriately processed for sending from queue . All queue accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. As soon as a record is inserted to queue it is assumed sent immediately. Preferably fields sent depend on fields set. Queue entries inserted to queue may contain specification for which channel s to send on in some embodiments. In other embodiments send processing feeding from queue has intelligence for which channel s to send on the preferred embodiment described . Depending on alternative embodiments queue may be viewed metaphorically for providing convenient grounds of explanation.

When interfacing to queue the term broadcast refers to sending outgoing data in a manner for reaching as many MSs as possible e.g. use all participating communications interfaces whereas the term send refers to targeting a particular MS or group of MSs.

WDR queue preferably contains at least one WDR at any point in time for at least describing whereabouts of the MS of architecture . Queue accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. A single instance of data embodiment of queue may require an explicit semaphore control for access. In a WDR plurality maintained to queue appropriate queue interfaces are again provided to ensure synchronous thread access e.g. implicit semaphore control . Regardless there is still a need for a queue to maintain a plurality of WDRs from remote MSs. The preferred embodiment of all queue interfaces uses queue interface maintained semaphore s invisible to code making use of queue e.g. API interfaces. Depending on alternative embodiments queue may be viewed metaphorically for providing convenient grounds of explanation.

Thread Request TR queue is for requesting processing by either a timing determination worker thread of process i.e. thread or whereabouts determination worker thread of process i.e. thread . When requesting processing by a thread TR queue has requests retrieved via processing after insertion processing from a thread to initiate TDOA measurement. When requesting processing by a thread TR queue has requests retrieved via processing after insertion processing or from a thread or so that thread performs whereabouts determination of the MS of architecture . Requests of queue comprise records . Preferably there is a plurality pool of threads for feeding queue i.e. feeding from queue and for feeding a plurality each of threads and from queue . All queue accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. Depending on alternative embodiments queue may be viewed metaphorically for providing convenient grounds of explanation.

With reference now to depicted is an illustration for describing a preferred embodiment of a thread request queue record as maintained to Thread Request TR queue . TR queue is not required when a LN expanse globally uses NTP as found in thread processing described for architecture however it may be required at a MS which does not have NTP or a MS which interacts with another data processing system e.g. MS that does not have NTP. Therefore TR queue record i.e. queue entry may or may not be required. This is the reason does not depict queue . When NTP is in use globally in LN expanse TDOA measurements can be made using a single unidirectional data or packet containing a sent date time stamp of when the data was sent . Upon receipt that sent date time stamp received is compared with the date time of receipt to determine the difference. The difference is a TDOA measurement. Knowing transmission speeds with a TDOA measurement allows calculating a distance. In this NTP scenario no thread s are required.

Threads and or DLM processing may always insert the MS whereabouts without requirement for thread s by incorporating thread logic into thread or by directly starting without queue a thread from a thread . Therefore threads may not be required. If threads are not required queue may not be required by incorporating thread logic into thread or by directly starting without queue a thread from a thread . Therefore queue may not be required and threads may not be required.

Records i.e. queue entries contain a request type field and data field . Request type field simply routes the queue entry to destined thread s e.g. thread s or thread s . A thread remains blocked on queue until a record is inserted which has a field containing the value . A thread remains blocked on queue until a record is inserted which has a field containing the value . Data field is set to zero 0 when type field contains i.e. not relevant . Data field contains an MS ID field value and possibly a targeted communications interface or wave spectrum if one to one when type field contains . Field will contain information for appropriately targeting the MS ID with data e.g. communications interface to use if MS has multiple of them . An MS with only one communications interface can store only a MS ID in field

Records are used to cause appropriate processing by threads e.g. or as invoked when needed e.g. by thread s . Process is a slave to queue type of process and there are no queue entries which will not get timely processed by a thread . No interim pruning is necessary to queue .

With reference now back to Correlation Response CR queue is for receiving correlation data for correlating requests transmitted in data with responses received in data or . Records are inserted to queue via processing from thread s so that thread s after processing correlate data or with requests sent by thread s e.g. over interface for the purpose of calculating a TDOA measurement. Additionally records are inserted to queue via processing from thread s so that thread s after processing correlate data or with requests sent by thread s e.g. over interface for the purpose of calculating a TDOA measurement. Preferably there is a plurality pool of threads for feeding queue and for feeding from queue feeding from queue with thread s . All queue accesses are assumed to have appropriate semaphore control to ensure synchronous access by any thread at any particular time to prevent data corruption and misuse. Depending on alternative embodiments queue may be viewed metaphorically for providing convenient grounds of explanation.

With reference now to depicted is an illustration for describing a preferred embodiment of a correlation response queue record as maintained to Correlation Response CR queue . CR queue is not required when a LN expanse globally uses NTP as found in thread processing described for architecture however it may be required at a MS which does not have NTP or a MS which interacts with another data processing system e.g. MS that does not have NTP. Therefore CR record i.e. queue entry may or may not be required. This is the reason does not depict queue . The purpose of CR queue is to enable calculation of TDOA measurements using correlation data to match a request with a response. When NTP is used globally in the LN expanse no such correlations between a request and response is required as described above. In the NTP scenario thread s can deduce TDOA measurements directly from responses see and there is no requirement for threads .

TDOA measurements are best taken using date time stamps as close to the processing points of sending and receiving as possible otherwise critical regions of code may be required for enabling process time adjustments to the measurements when processing is further out from said points. This is the reason MS receive processing provides received date time stamps with data inserted to queue field or . In a preferred embodiment send queue processing inserts to queue so the date time stamp field for when sent is as close to just prior to having been sent as possible. However there is still the requirement for processing time spent inserting to queue prior to sending anyway. Anticipated processing speeds of architecture allow reasonably moving sent date time stamp setting just a little further out from actually sending to keep modular send processing isolated. A preferred embodiment as presented assumes the send queue interface minimizes processing instructions from when data is placed onto queue and when it is actually sent so that the sending thread s and insert to queue with a reasonably accurate sent date stamp field . This ensures a most accurate sent date time stamp e.g. enabling most accurate TDOA measurements . An alternate embodiment makes appropriate adjustments for more accurate time to consider processing instructions up to the point of sending after queue insertion.

Records i.e. queue entries contain a date time stamp field and a correlation data field . Date time stamp field contains a date time stamp of when a request data was sent as set by the thread inserting the queue entry . Correlation data field contains unique correlation data e.g. MS id with suffix of unique number used to provide correlation for matching sent requests data with received responses data or regardless of the particular communications interface s used e.g. different wave spectrums supported by MS . Upon a correlation match a TDOA measurement is calculated using the time difference between field and a date time stamp of when the response was received e.g. field . A thread accesses queue for a record using correlation field to match when data or contains correlation data for matching. A thread then uses the field to calculate a TDOA measurement. Process is not a slave to queue but is to queue . A thread peeks queue for a matching entry when appropriate. Queue may contain obsolete queue entries until pruning is performed. Some WDR requests may be broadcasts therefore records may be used for correlating a plurality of responses. In another record embodiment an additional field is provided for specification of which communication interface s and or channel s to listen on for a response.

With reference now back to any reasonable subset of architecture processing may be incorporated in a MS. For example in one minimal subset embodiment a DLM which has excellent direct locating means only needs a single instance WDR queue and a single thread for broadcasting whereabouts data to facilitate whereabouts determination by other MSs. In a near superset embodiment process processing may be incorporated completely into process thereby eliminating processing by having threads feed from queue for WDR requests as well as WDR information. In another subset embodiment process may only send requests to queue for responses or may only start a thread for determining whereabouts of the MS. There are many viable subset embodiments depending on the MS being a DLM or ILM capabilities of the MS LN expanse deployment design choices etc. A reference to accompanies thread flowcharts . The user preferably an administrator type e.g. for lbxPhone debug selectively configures whether or not to start or terminate a process thread pool and perhaps the number of threads to start in the pool see . Starting a process and threads and terminating processes and threads is shown in flowcharts A and B. There are other embodiments for properly starting and terminating threads without departing from the spirit and scope of this disclosure.

LBX of data may also be viewed as LBX of objects for example a WDR WDR request TDOA request AOA request charters permissions data record s or any other data may be viewed as an object. An subset of an object or data may also be viewed as an object.

In an alternative embodiment having multiple transmission channels visible to process there can be a worker thread per channel to handle broadcasting on multiple channels. If thread s block do not transmit directly over the channel themselves this embodiment would provide means for communicating the channel for broadcast to send processing when interfacing to queue e.g. incorporate a channel qualifier field with WDR inserted to queue . This embodiment could allow specification of at least one 1 worker thread per channel however multiple worker threads configurable for process as appropriated for the number of channels configurable for broadcast.

Processing begins at block continues to block where the process worker thread count Ct is accessed and incremented by 1 using appropriate semaphore access e.g. Sem and continues to block for peeking WDR queue for a special termination request entry. Block may also check the Ct value and signal the process parent thread that all worker threads are running when Ct reaches Max. Thereafter if block determines that a worker thread termination request was not found in queue processing continues to block . Block peeks the WDR queue using interface for the most recent highest confidence entry for this MS whereabouts by searching queue for the MS ID field matching the MS ID of processing and a confidence field greater than or equal to the confidence floor value and a most recent NTP enabled date time stamp field within a prescribed trailing period of time e.g. preferably less than or equal to 2 seconds . For example block peeks the queue i.e. makes a copy for use if an entry found for subsequent processing but does not remove the entry from queue for a WDR of this MS i.e. MS of processing which has the greatest confidence over 75 and has been most recently inserted to queue with an NTP date time stamp in the last 2 seconds. Date time stamps for MS whereabouts which are not NTP derived have little use in the overall palette of process choices of architecture because receiving data processing systems e.g. MSs will have no means of determining an accurate TDOA measurement in the unidirectional transmission from an NTP disabled MS. A receiving data processing system will still require a bidirectional correlated exchange with the MS of processing to determine an accurate TDOA measurement in its own time scale which is accomplished with thread s pulling WDR information anyway . An alternate embodiment to block will not use the NTP indicator as a search criteria so that receiving data processing systems can receive to a thread and then continue for appropriate correlation processing or can at least maintain whereabouts to queue to know who is nearby.

Thread is of less value to the LN expanse when it broadcasts outdated invalid whereabouts of the MS to facilitate locating other MSs. In an alternate embodiment a movement tolerance e.g. user configured or system set e.g. 3 meters is incorporated at the MS or at service s used to locate the MS for knowing when the MS has significantly moved e.g. more than 3 meters and how long it has been e.g. 45 seconds since last significantly moving. In this embodiment the MS is aware of the period of time since last significantly moving and the search time criteria is set using the amount of time since the MS significantly moved whichever is greater . This way a large number of perhaps more confident candidates WDRs are searched in the time period when the MS has not significantly moved. Optional blocks through may have been incorporated to for movement tolerance processing just described in which case the LWT is compared to the current date time of block processing to adjust block search time criteria for the correct trailing period. In any case a WDR is sought at block which will help other MSs in the LN expanse locate themselves and to let other MSs know who is nearby.

Thereafter if block determines a useful WDR was found then block prepares the WDR for send processing block broadcasts the WDR information using send interface by inserting to queue so that send processing broadcasts data e.g. on all available communications interface s for example as far as radius and processing continues to block . The broadcast is for reception by data processing systems e.g. MSs in the vicinity. At least fields and are broadcast. See descriptions. Fields are set to the following upon exit from block 

MS ID field is preferably set with Field from queue or transformed if not already into a pseudo MS ID possibly for future correlation if desired. This field may also be set to null not set because it is not required when the NTP indicator of field is enabled and the broadcast is sent with an NTP enabled field DATE TIME STAMP field is preferably set with Field from queue . LOCATION field is preferably set with Field from queue . CONFIDENCE field is preferably set with Field from queue . LOCATION TECHNOLOGY field is preferably set with Field from queue . LOCATION REFERENCE INFO field is preferably set with null not set . Null indicates to send processing feeding from queue to use all available comm. interfaces i.e. Broadcast . Specifying a comm. interface targets the specified interface i.e. send . COMMUNICATIONS REFERENCE INFO field is preferably set with null not set . If MS ID or pseudo MS ID is sent this is all that is required to target this MS. SPEED field is preferably set with Field from queue . HEADING field is preferably set with Field from queue . ELEVATION field is preferably set with Field from queue . APPLICATION FIELDS field is preferably set with Field from queue . An alternate embodiment will add alter or discard data with or without date time stamps here at the time of block processing. CORRELATION FIELD is preferably set with null not set . SENT DATE TIME STAMP field is preferably set with Sent date time stamp as close in processing the broadcast of block as possible. RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. N A for sending .

Block causes thread to sleep according to the SPTP setting e.g. a few seconds . When the sleep time has elapsed processing continues back to block for another loop iteration of blocks through . Referring back to block if a useful WDR was not found e.g. candidates too old then processing continues to block . Referring back to block if a worker thread termination request entry was found at queue then block decrements the worker thread count by 1 using appropriate semaphore access e.g. Sem and thread processing terminates at block . Block may also check the Ct value and signal the process parent thread that all worker threads are terminated when Ct equals zero 0 .

Block causes broadcasting data containing CK wherein CK contains WDR information prepared as described above for block . Alternative embodiments of block may not search a specified confidence value and broadcast the best entry available anyway so that listeners in the vicinity will decide what to do with it. A semaphore protected data access instead of a queue peek may be used in embodiments where there is always one WDR current entry maintained for the MS.

In the embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place WDR information as CK embedded in usual data at the next opportune time of sending usual data . If an opportune time is not timely send processing should discard the send request of block to avoid broadcasting outdated whereabouts information unless using a movement tolerance and time since last significant movement . As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends repeated timely pulsed broadcasts of new data per SPTP for MSs in the vicinity of the first MS to receive. In any case appropriate implementation should ensure field is as accurate as possible for when data is actually sent.

An alternate embodiment to architecture for elimination of process incorporates a trigger implementation for broadcasting MS whereabouts at the best possible time i.e. when the MS whereabouts is inserted to queue . As soon as a new preferably NTP enabled WDR candidate becomes available it can be broadcast at a new block of . e.g. new block continued to from block and then continuing to block . Fields are set as described above for . Preferably the new block starts an asynchronous thread consisting of blocks and so that processing performance is not impacted. In a further embodiment block can be further enhanced using the SPTP value to make sure that too many broadcasts are not made. The SPTP Source Periodicity Time Period could be observed for getting as close as possible to broadcasting whereabouts in accordance with SPTP e.g. worst case there are not enough broadcasts .

In an alternative embodiment having multiple receiving transmission channels visible to process e.g. thread s receiving directly there can be a worker thread per channel to handle receiving on multiple channels simultaneously. If thread s do not receive directly from the channel the preferred embodiment of FIG. would not need to convey channel information to thread s waiting on queue anyway. Embodiments could allow specification configuration of many thread s per channel.

Processing begins at block continues to block where the process worker thread count Ct is accessed and incremented by 1 using appropriate semaphore access e.g. Sem and continues to block for interim housekeeping of pruning the WDR queue by invoking a Prune Queues procedure of . Block may also check the Ct value and signal the process parent thread that all worker threads are running when Ct reaches Max. Block may not be required since block can cause queue pruning block .

Thereafter block retrieves from queue a WDR using interface perhaps a special termination request entry or a WDR received in data CK or data CK and only continues to block when a WDR has been retrieved. Block stays blocked on retrieving from queue until any WDR is retrieved. If block determines that a special WDR indicating to terminate was not found in queue processing continues to block . Block adjusts date time stamp field if necessary depending on NTP use in the LN expanse and adjusts the confidence field accordingly. In a preferred embodiment fields and for the WDR in process is set as follows for certain conditions 

If at block the WDR confidence field is not greater than the confidence floor value then processing continues back to block . If block determines that the WDR field is satisfactory then block initializes a TDOA FINAL variable to False and block checks if the WDR from block contains correlation field .

If block determines the WDR does not contain correlation then block accesses the ILMV block determines the source ILM or DLM of the WDR using the originator indicator of field and block checks suitability for collection of the WDR. While processes running are generally reflective of the ILMV roles configured it is possible that the more descriptive nature of ILMV role s not be one to one in relationship to processes in particular depending on the subset of architecture in use. Block is redundant anyway because of block . If block determines the ILMV role is disabled for collecting this WDR then processing continues back to block . If block determines the ILMV role is enabled for collecting this WDR then processing continues to block .

If block determines both the first sending and second receiving MS are NTP enabled i.e. Fields and are NTP indicated OR if TDOA FINAL is set to True as arrived to via block then block completes the WDR for queue insertion block prepares parameters for processing and block invokes processing interface . Parameters set at block are WDRREF a reference or pointer to the WDR completed at block DELETEQ location queue discard processing and SUPER supervisory notification processing. Block calculates a TDOA measurement whenever possible and inserts to field . See descriptions. Fields are set to the following upon exit from block 

CONFIDENCE field is preferably set with Confidence at equal to or less than field received from queue see preferred embodiment for block .

LOCATION REFERENCE INFO field is preferably set with All available measurements from receive processing e.g. AOA heading yaw pitch roll signal strength wave spectrum particular communications interface etc and TDOA measurement s as determined in blocks and . COMMUNICATIONS REFERENCE INFO field is preferably set with Field from queue . SPEED field is preferably set with Field from queue . HEADING field is preferably set with Field from queue . ELEVATION field is preferably set with Field from queue . APPLICATION FIELDS field is preferably set with Field from queue . An alternate embodiment will add alter or discard data with or without date time stamps here at the time of block processing. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . Was used by processing. SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . Was used by processing. RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . Was used by processing.

Block continues to block where a record is built i.e. field and field is set to null e.g. 1 and then block inserts the record to TR queue using interface so that a thread will perform processing. Blocks and may be replaced with an alternative embodiment for starting a thread . Block continues back to block .

Referring now back to block if it is determined that a TDOA measurement cannot be made i.e. field or not NTP indicated OR if TDOA FINAL is set to False then block checks if the WDR contains a MS ID or pseudo MS ID . If block determines there is none then processing continues back to block because there is no way to distinguish one MS from another with respect to the WDR retrieved at block for directing bidirectional correlation. An alternate embodiment will use a provided correlation field received at block instead of a field for knowing how to target the originating MS for TDOA measurement processing initiated by a thread . If block determines there is a usable MS ID or correlation field then block builds a record field field the MS ID or pseudo MS ID or correlation and particular communications interface from field if available of the WDR of block and block inserts the record to queue interface for starting a thread . Block continues back to block . An alternate embodiment causes block to continue directly to block no block for a No condition from block . Regardless of whether the originating MS ID can be targeted a correlation in lieu of an MS ID may be used when the MS responds with a broadcast. The WDR request made by thread can be a broadcast rather than a targeted request. Thread s can handle sending targeted WDR requests to a known MS ID and broadcast WDR requests.

Referring back to block if it is determined the WDR does contain correlation field block peeks the CR queue using interface for a record containing a match i.e. field matched to field . Thereafter if block determines no correlation was found on queue e.g. response took too long and entry was pruned then processing continues to block already described. If block determines the correlation entry was found i.e. thread received a response from an earlier request e.g. from a thread or then block uses date time stamp field from block with field e.g. from block to calculate a TDOA measurement in time scale of the MS of processing and sets field appropriately in the WDR. Note that correlation field is valid across all available MS communications interfaces e.g. all supported active wave spectrums . The TDOA measurement considers duration of time between the earlier sent date time of record and the later time of received date time field . The TDOA measurement may further be altered at block processing time to a distance knowing the velocity of the wave spectrum used as received to queue . Block continues to block where the TDOA FINAL variable is set to True then to block for processing already described.

Referring back to block if a WDR for a worker thread termination request was found at queue then block decrements the worker thread count by 1 using appropriate semaphore access e.g. Sem and thread processing terminates at block . Block may also check the Ct value and signal the process parent thread that all worker threads are terminated when Ct equals zero 0 .

In the embodiment wherein usual MS communications data of the MS is altered to contain CK or for listening MSs in the vicinity receive processing feeding queue will place WDR information to queue as CK or is detected for being present in usual communication data or . As normal communications are conducted transmitted data or contains new data CK or to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK or . Otherwise when LN Expanse deployments have not introduced CK or to usual data or communicated on a receivable signal by MSs in the vicinity receives new data or sent. In any case field should be as accurate as possible for when data or was actually received. Critical regions of code and or anticipated execution timing may be used to affect a best setting of field

So is responsible for maintaining whereabouts of others to queue with data useful for triangulating itself.

In an alternative embodiment having multiple transmission channels visible to process there can be a worker thread per channel to handle broadcasting on multiple channels. If thread s block do not transmit directly over the channel this embodiment would provide means for communicating the channel for broadcast to send processing when interfacing to queue e.g. incorporate a channel qualifier field with WDR request inserted to queue . This embodiment could allow specification of one 1 thread per channel however multiple worker threads configurable for process as determined by the number of channels configurable for broadcast.

Processing begins at block continues to block where the process worker thread count Ct is accessed and incremented by 1 using appropriate semaphore access e.g. Sem and continues to block for interim housekeeping of pruning the CR queue by invoking a Prune Queues procedure of . Block may also check the Ct value and signal the process parent thread that all worker threads are running when Ct reaches Max. Block continues to block for peeking WDR queue using interface for a special termination request entry. Thereafter if block determines that a worker thread termination request was not found in queue processing continues to block . Block peeks the WDR queue using interface for the most recent highest confidence entry for this MS whereabouts by searching queue for the MS ID field matching the MS ID of processing and a confidence field greater than or equal to the confidence floor value and a most recent date time stamp field within a prescribed trailing period of time of block search processing using a function of the WTV i.e. f WTV short hand for function of WTV for the period. For example block peeks the queue i.e. makes a copy for use if an entry found for subsequent processing but does not remove the entry from queue for a WDR of the first MS which has the greatest confidence over 75 and has been most recently inserted to queue in the last 3 seconds. Since the MS whereabouts accuracy may be dependent on timeliness of the WTV it is recommended that the f WTV be some value less than or equal to WTV but preferably not greater than the WTV. Thread is of less value to the MS when not making sure in a timely manner the MS is maintaining timely whereabouts for itself. In an alternate embodiment a movement tolerance e.g. user configured or system set e.g. 3 meters is incorporated at the MS or at service s used to locate the MS for knowing when the MS has significantly moved e.g. more than 3 meters and how long it has been e.g. 45 seconds since last significantly moving. In this embodiment the MS is aware of the period of time since last significantly moving and the f WTV is set using the amount of time since the MS significantly moved i.e. f WTV as described above or the amount of time since significantly moving whichever is greater . This way a large number of perhaps more confident candidates WDRs are searched in the time period when the MS has not significantly moved. Optional blocks through may have been incorporated to for movement tolerance processing just described in which case the LWT is compared to the current date time to adjust the WTV for the correct trailing period. In any case a WDR is sought at block which will verify whether or not MS whereabouts are current.

Thereafter if block determines a satisfactory WDR was found then processing continues to block . Block causes thread to sleep according to a f WTV preferably a value less than or equal to the WTV e.g. 95 of WTV . When the sleep time has elapsed processing continues back to block for another loop iteration of blocks through .

If block determines a current WDR was not found then block builds a WDR request e.g. containing record with field for the MS of processing MS ID or pseudo MS ID so receiving MSs in the LN expanse know who to respond to and field with appropriate correlation for response block builds a record using correlation generated for the request at block block inserts the record to queue using interface and block broadcasts the WDR request record for responses. Absence of field indicates to send processing feeding from queue to broadcast on all available comm. interfaces .

With reference now to depicted is an illustration for describing a preferred embodiment of a WDR request record as communicated to queue or . When a LN expanse globally uses NTP as found in thread processing described for architecture a WDR request record may or may not be required. TDOA calculations can be made using a single unidirectional data or packet containing a sent date time stamp of when the data was sent as described above.

Records contain a MS ID field and correlation field . MS ID field contains an MS ID e.g. a value of field . An alternate embodiment will contain a pseudo MS ID for correlation perhaps made by a derivative of the MS ID with a unique suffix portion so that receiving MSs can directly address the MS sending the request without actually knowing the MS ID i.e. they know the pseudo MS ID which enables the MS to recognize originated transmissions . Correlation data field contains unique correlation data e.g. MS id with suffix of unique number used to provide correlation for matching sent requests data with received WDR responses data or . Upon a correlation match a TDOA measurement is calculated using the time difference between field and a date time stamp of when the response was received e.g. field . Received date time stamp field is added by receive processing feeding queue when an MS received the request from another MS. Comm interface field is added by receive processing inserting to queue for how to respond and target the originator. Many MSs do not have choices of communications interfaces so field may not be required. If available it is used otherwise a response can be a broadcast. Field may contain a wave spectrum identifier for uniquely identifying how to respond e.g. one to one with communications interface or any other value for indicating how to send given how the request was received.

With reference back to block builds a request that receiving MSs will know is for soliciting a response with WDR information. Block generates correlation for field to be returned in responses to the WDR request broadcast at block . Block also sets field to when the request was sent. Preferably field is set as close to the broadcast as possible. In an alternative embodiment broadcast processing feeding from queue makes the record and inserts it to queue with a most accurate time of when the request was actually sent. Fields are to be as accurate as possible. Block broadcasts the WDR request data using send interface by inserting to queue so that send processing broadcasts data for example as far as radius . Broadcasting preferably uses all available communications interface s e.g. all available wave spectrums . Therefore the comm interface field is not set which implies to send processing to do a broadcast .

Block continues to block where a record is built i.e. field and field is set to null e.g. 1 and then block inserts the record to TR queue using interface so that a thread will perform processing. Blocks and may be replaced with an alternative embodiment for starting a thread . Block continues back to block .

Referring back to block if a worker thread termination request entry was found at queue then block decrements the worker thread count by 1 using appropriate semaphore access e.g. Sem and thread processing terminates at block . Block may also check the Ct value and signal the process parent thread that all worker threads are terminated when Ct equals zero 0 .

In the embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place the request as CK embedded in usual data at the next opportune time of sending usual data . This may require the alternative embodiment of adding the entry to queue being part of send processing. As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends new WDR request data .

Processing begins at block continues to block where the process worker thread count Ct is accessed and incremented by 1 using appropriate semaphore access e.g. Sem and continues to block for interim housekeeping of pruning the CR queue by invoking a Prune Queues procedure of . Block may also check the Ct value and signal the process parent thread that all worker threads are running when Ct reaches Max.

Thereafter block retrieves from queue a record using interface perhaps a special termination request entry or a record received from thread s and only continues to block when a record containing field set to has been retrieved. Block stays blocked on retrieving from queue until a record with field is retrieved. If block determines a special entry indicating to terminate was not found in queue processing continues to block .

If at block the record does not contain a MS ID or pseudo MS ID in field processing continues to block for building a WDR request record to be broadcast and then to block . Broadcasting preferably uses all available communications interface s e.g. all available wave spectrums . If block determines the field is a valid MS ID not null block builds a WDR request targeted for the MS ID and processing continues to block . A targeted request is built for targeting the MS ID and communications interface if available from field . Send processing is told which communications interface to use if available e.g. MS has multiple otherwise send processing will target each available interface. In the unlikely case a MS ID is present in field without the communications interface applicable then all communications interfaces are used with the targeted MS ID. In MS embodiments with multiple communications interfaces then is to contain the applicable communication interface for sending. Block generates appropriate correlation for a field e.g. to be compared with a response WDR at block block sets field to the current MS date time stamp block inserts the record to queue using interface and block sends broadcasts using interface a WDR request record . Thereafter processing continues back to block for another loop iteration. An alternative embodiment will only target a WDR request to a known MS ID. For example block would continue back to block if no MS ID is found null otherwise it will continue to block i.e. no use for block .

Block sets field to correlation to be returned in responses to the WDR request sent broadcast at block . Block sets field to when the request is sent. Preferably field is set as close as possible to when a send occurred. In an alternative embodiment send processing feeding from queue makes the record and inserts it to queue with a most accurate time of when the request was actually sent. Fields are to be as accurate as possible. Block sends broadcasts the WDR request data using send interface by inserting to queue a record the targeted MS ID or pseudo MS ID OR null if arrived to from block field correlation generated at block so that send processing sends data for example as far as radius . A null MS ID may be responded to by all MSs in the vicinity. A non null MS ID is to be responded to by a particular MS. Presence of field indicates to send processing feeding from queue to target the MS ID over the specified comm. interface e.g. when MS has a plurality of comm. interfaces e.g. cellular WiFi Bluetooth etc i.e. MS supports multiple classes of wave spectrum .

Referring back to block if a worker thread termination request was found at queue then block decrements the worker thread count by 1 using appropriate semaphore access e.g. Sem and thread processing terminates at block . Block may also check the Ct value and signal the process parent thread that all worker threads are terminated when Ct equals zero 0 .

In the embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place the WDR request as CK embedded in usual data at the next opportune time of sending usual data . As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . This may require the alternative embodiment of adding the entry to queue being part of send processing. Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends broadcasts new WDR request data .

An alternate embodiment to block can wait for a response with a reasonable timeout thereby eliminating the need for blocks through which is used to correlate the subsequent response to thread with the request sent at block . However this will cause a potentially unpredictable number of simultaneously executing thread s when many MSs are in the vicinity.

Thread s are useful when one or both parties to WDR transmission sending and receiving MS do not have NTP enabled. TDOA measurements are taken to triangulate the MS relative other MSs in real time.

In an alternative embodiment having multiple receiving transmission channels visible to process there can be a worker thread per channel to handle receiving on multiple channels simultaneously. If thread s do not receive directly from the channel the preferred embodiment of would not need to convey channel information to thread s waiting on queue anyway. Embodiments could allow specification configuration of many thread s per channel.

Processing begins at block continues to block where the process worker thread count Ct is accessed and incremented by 1 using appropriate semaphore access e.g. Sem and continues to block for retrieving from queue a record using interface perhaps a special termination request entry and only continues to block when a record is retrieved. Block stays blocked on retrieving from queue until any record is retrieved. If block determines a special entry indicating to terminate was not found in queue processing continues to block . There are various embodiments for thread s and thread s to feed off a queue for different record types for example separate queues A and B or a thread target field with either record found at queue e.g. like field . In another embodiment thread s are modified with logic of thread s to handle all records described for a queue since thread s are listening for queue data anyway.

Block peeks the WDR queue using interface for the most recent highest confidence entry for this MS whereabouts by searching queue for the MS ID field matching the MS ID of processing and a confidence field greater than or equal to the confidence floor value and a most recent date time stamp field within a prescribed trailing period of time of block search processing e.g. 2 seconds . For example block peeks the queue i.e. makes a copy for use if an entry found for subsequent processing but does not remove the entry from queue for a WDR of the MS of processing which has the greatest confidence over 75 and has been most recently inserted to queue in the last 2 seconds. It is recommended that the trailing period of time used by block be never greater than a few seconds. Thread is of less value to the LN expanse when it responds with outdated invalid whereabouts of the MS to facilitate locating other MSs. In an alternate embodiment a movement tolerance e.g. user configured or system set e.g. 3 meters is incorporated at the MS or at service s used to locate the MS for knowing when the MS has significantly moved e.g. more than 3 meters and how long it has been e.g. 45 seconds since last significantly moving. In this embodiment the MS is aware of the period of time since last significantly moving and the trailing period of time used by block is set using the amount of time since the MS significantly moved or the amount of time since significantly moving whichever is greater. This way a large number of perhaps more confident candidate WDRs are searched in the time period when the MS has not significantly moved. Optional blocks through may have been incorporated to for movement tolerance processing just described in which case the LWT is compared to the current date time to adjust the trailing period of time used by block for the correct trailing period. In any case a WDR is sought at block to satisfy a request helping another MS in the LN expanse locate itself.

Thereafter if block determines a useful WDR was not found then processing continues back to block for another loop iteration of processing an inbound WDR request. If block determines a useful WDR was found then block prepares the WDR for send processing with correlation field set from correlation field retrieved at block and block sends broadcasts per field the WDR information using send interface by inserting to queue so that send processing transmits data for example as far as radius and processing continues back to block . At least fields and are sent broadcast. See descriptions. Fields are set to the following upon exit from block 

LOCATION REFERENCE INFO field is preferably set with null not set for Broadcast by send processing otherwise set to field for Send by send processing.

APPLICATION FIELDS field is preferably set with Field from queue . An alternate embodiment will add alter or discard data with or without date time stamps here at the time of block processing.

SENT DATE TIME STAMP field is preferably set with Sent date time stamp as close in processing the send broadcast of block as possible.

Embodiments may rely completely on the correlation field with no need for field . Referring back to block if a worker thread termination request was found at queue then block decrements the worker thread count by 1 using appropriate semaphore access e.g. Sem and thread processing terminates at block . Block may also check the Ct value and signal the process parent thread that all worker threads are terminated when Ct equals zero 0 .

Block causes sending broadcasting data containing CK depending on the type of MS wherein CK contains WDR information prepared as described above for block . Alternative embodiments of block may not search a specified confidence value and broadcast the best entry available anyway so that listeners in the vicinity will decide what to do with it. A semaphore protected data access instead of a queue peek may be used in embodiments where there is always one WDR current entry maintained for the MS.

In the embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place WDR information as CK embedded in usual data at the next opportune time of sending usual data . If an opportune time is not timely send processing should discard the send request of block to avoid broadcasting outdated whereabouts information unless using a movement tolerance and time since last significant movement . As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends broadcasts new WDR response data . In any case field should be as accurate as possible for when data is actually sent. Critical regions of code i.e. prevent thread preemption and or anticipated execution timing may be used to affect a best setting of field

In an alternate embodiment records contain a sent date time stamp field of when the request was sent by a remote MS and the received date time stamp field is processed at the MS in processing. This would enable block to calculate a TDOA measurement for returning in field of the WDR sent broadcast at block .

Processing begins at block continues to block where the process worker thread count Ct is accessed and incremented by 1 using appropriate semaphore access e.g. Sem and continues to block for interim housekeeping of pruning the WDR queue by invoking a Prune Queues procedure of . Block may also check the Ct value and signal the process parent thread that all worker threads are running when Ct reaches Max. Block may not be necessary since pruning may be accomplished at block when invoking block .

Thereafter block retrieves from queue a record using interface perhaps a special termination request entry or a record received from thread s and only continues to block when a record containing field set to has been retrieved. Block stays blocked on retrieving from queue until a record with field is retrieved. If block determines a special entry indicating to terminate was not found in queue processing continues to block .

Block peeks the WDR queue using interface for the most recent highest confidence entry for this MS whereabouts by searching queue for the MS ID field matching the MS ID of processing and a confidence field greater than or equal to the confidence floor value and a most recent date time stamp field within a prescribed trailing period of time of block search processing using a f WTV for the period. For example block peeks the queue i.e. makes a copy for use if an entry found for subsequent processing but does not remove the entry from queue for a WDR of the MS of processing which has the greatest confidence over 75 and has been most recently inserted to queue in the last 2 seconds. Since MS whereabouts accuracy may be dependent on timeliness of the WTV it is recommended that the f WTV be some value less than or equal to WTV. In an alternate embodiment a movement tolerance e.g. user configured or system set e.g. 3 meters is incorporated at the MS or at service s used to locate the MS for knowing when the MS has significantly moved e.g. more than 3 meters and how long it has been e.g. 45 seconds since last significantly moving. In this embodiment the MS is aware of the period of time since last significantly moving and the f WTV is set using the amount of time since the MS significantly moved i.e. f WTV as described above or the amount of time since significantly moving whichever is greater . This way a large number of perhaps more confident candidate WDRs are searched in the time period when the MS has not significantly moved. Optional blocks through may have been incorporated to for movement tolerance processing just described in which case the LWT is compared to the current date time to adjust the WTV for the correct trailing period.

Thereafter if block determines a timely whereabouts for this MS already exists to queue current WDR found then processing continues back to block for another loop iteration of processing. If determines a satisfactory WDR does not already exist in queue then block determines a new highest confidence WDR for this MS processing using queue .

Thereafter if block determines a WDR was not created BESTWDR variable null for the MS of processing by block then processing continues back to block . If block determines a WDR was created BESTWDR WDR created by for the MS of processing by block then processing continues to block for preparing parameters and processing is invoked with the new WDR at block for interface before continuing back to block . Parameters set at block are WDRREF a reference or pointer to the WDR completed at block DELETEQ location queue discard processing and SUPER supervisory notification processing.

Referring back to block if a worker thread termination request was found at queue then block decrements the worker thread count by 1 using appropriate semaphore access e.g. Sem and thread processing terminates at block . Block may also check the Ct value and signal the process parent thread that all worker threads are terminated when Ct equals zero 0 .

Alternate embodiments to will have a pool of thread s per location technology WDR field for specific WDR field s selective processing. processing is shown to be generic with handling all WDRs at block .

Thereafter block peeks the WDR queue using interface for most recent WDRs by searching queue for confidence field greater than or equal to the confidence floor value and a most recent date time stamp field within a prescribed trailing period of time of block search processing using a f WTV for the period. For example block peeks the queue i.e. makes a copy of all WDRs to a result list for use if any found for subsequent processing but does not remove the entry s from queue for all WDRs which have confidence over 75 and has been most recently inserted to queue in the last 2 seconds. It is recommended that the f WTV used here be some value less than or equal to the WTV want to be ahead of curve so may use a percentage e.g. 90 but preferably not greater than a couple few seconds depends on MS MS applications MS environment whereabouts determination related variables etc .

In an alternative embodiment thread s coordinate with each other to know successes failures or progress of their sister threads for automatically adjusting the trailing f WTV period of time appropriately. See Alternative IPC Embodiments below.

Thread is of less value to the MS when whereabouts are calculated using stale WDRs or when not enough useful WDRs are considered. In an alternate embodiment a movement tolerance e.g. user configured or system set e.g. 3 meters is incorporated at the MS or at service s used to locate the MS for knowing when the MS has significantly moved e.g. more than 3 meters and how long it has been e.g. 45 seconds since last significantly moving. In this embodiment the MS is aware of the period of time since last significantly moving and the f WTV is set using the amount of time since the MS significantly moved i.e. f WTV as described above or the amount of time since significantly moving whichever is greater . This way a large number of perhaps more confident candidates WDRs are searched in the time period when the MS has not significantly moved. Optional blocks through may have been incorporated to for movement tolerance processing just described in which case the LWT is compared to the current date time to adjust the WTV for the correct trailing period. In any case all useful WDRs are sought at block and placed into a list upon exit from block .

Thereafter block sets THIS MS list and REMOTE MS list sort keys to be used at blocks and . Blocks through will prioritize WDRs found at block depending on the sort keys made at block . A number of variables may be used to determine the best sort keys such as the time period used to peek at block and or the number of entries in the WDR list returned by block and or other variables. When the time period of search is small e.g. less than a couple seconds lists THIS MS and REMOTE MS should be prioritized primarily by confidence fields since any WDRs are valuable for determining whereabouts. This is the preferred embodiment.

When the time period is great careful measure must be taken to ensure stale WDRs are not used e.g. few seconds and not considering movement tolerance . Depending on decision embodiments there will be preferred priority order sort keys created at exit from block for example key1 key2 key3 implies that key1 is a primary key key2 is a second order key and key3 is a third order key. A key such as field field field signal strength would sort WDRs first by using date time stamp fields then by confidence value fields sorted within matching date time stamp WDRs then by signal strength field sub field values sorted within matching WDR confidences no signal strength present lowest priority . Another sort key may be field field for sorting WDRs first by using confidence values then by date time stamps sorted within matching WDR confidences . The same or different sort keys can be used for lists THIS MS and REMOTE MS. Any WDR data fields or subfields can be sorted with a key and sort keys can be of N order dimension such that key1 key2 . . . keyN . Whatever sort keys are used block will have to consider confidence versus being stale relative to the WTV. In the preferred embodiment the REMOTE MS and THIS MS lists are set with the same sort keys of field field i.e. peek time period used at block is less than 2 seconds so that confidence is primary.

Thereafter block gets the first if any WDR in the list returned at block also processes next WDR in list when encountered again in loop of blocks through and block checks if all WDRs have already been processed. If block finds that all WDRs have not been processed then block checks the WDR origination. If block determines the WDR is one that originated from a remote MS i.e. MS ID does not match the MS of processing then block inserts the WDR into the REMOTE MS list using the desired sort key confidence primary time secondary from block and processing continues to block for another loop iteration. If block determines the WDR is one that originated from this MS MS ID field matches the MS of processing e.g. this MS being a DLM at the time of WDR creation this MS ID field or this MS being an ILM at the time of WDR creation previous processing of then processing continues to block to determine how to process the WDR which was inserted by this MS for its own whereabouts.

Block accesses field for data found there e.g. may have inserted useful TDOA measurements even though DLM processing occurred or may have inserted useful TDOA and or AOA measurements with reference station s whereabouts or receive processing may have inserted AOA and related measurements . Thereafter if block determines presence of TDOA and or AOA data block checks if reference whereabouts e.g. selected stationary reference location s is also stored in field . If block determines whereabouts information is also stored to field then block makes new WDR s from the whereabouts information containing at least the WDR Core and field containing the AOA and or TDOA information as though it were from a remote DLM or ILM. Block also performs the expected result of inserting the WDR of loop processing into the THIS MS list using the desired sort key from block . Processing then continues to block where the newly made WDR s is inserted into the REMOTE MS list using the desired sort key confidence primary time secondary from block . Block continues back to block .

Block through show that DLM stationary references may contribute to determining whereabouts of the MS of processing by making such references appear to processing like remote MSs with known whereabouts. Any DLM location technology processing discussed above can facilitate whereabouts processing when reference whereabouts can be maintained to field along with relative AOA TDOA MPT confidence and or other useful information for locating the MS. Various embodiments will populate field wherever possible with any useful locating fields see data discussed for field with discussions above for carrying plenty of information to facilitate processing.

Referring back to block if it is determined that whereabouts information was not present with the AOA and or TDOA information of field then processing continues to block for inserting into the REMOTE MS list appropriately with sort key from block the currently looped WDR from block . In range location technology associates the MS with the antenna or cell tower location so that field already contains the antenna or cell tower whereabouts and the TDOA information was stored to determine how close the MS was to the antenna or cell tower at the time. The WDR will be more useful in the REMOTE MS list then if added to the THIS MS list see loop of blocks through . Referring back to block if it is determined that no AOA and or TDOA information was in field then processing continues to block for inserting the WDR into the THIS MS list appropriately with sort key confidence primary time secondary from block .

Block handles WDRs that originated from the MS of this MS such as described in or results from previous processing. Block maintains remote DLMs and or ILMs their whereabouts to the REMOTE MS list in hope WDRs contain useful field information for determining the whereabouts of the MS of processing. Block handles WDRs that originated from the MS of processing this MS but also processes fields from stationary references used e.g. by this MS which can be helpful as though the WDR was originated by a remote ILM or DLM. Thus block causes inserting to both lists THIS MS and REMOTE MS when the WDR contains useful information for both. Blocks and cause the iterative loop of blocks through to perform ADLT using DLMs and or ILMs. Alternate embodiments of blocks through may use peek methodologies to sort from queue for the REMOTE MS and THIS MS lists.

Referring back to block if it is determined that all WDRs in the list from block have been processed then block initializes a DISTANCE list and ANGLE list each to null block sets a loop iteration pointer to the first entry of the prioritized REMOTE MS list e.g. first entry higher priority then last entry in accordance with sort key used and block starts the loop for working with ordered WDRs of the REMOTE MS list. Exit from block to block occurs when the REMOTE MS and THIS MS lists are in the desired priority order for subsequent processing. Block gets the next or first REMOTE MS list entry for processing before continuing to block . If block determines all WDRs have not yet been processed from the REMOTE MS list then processing continues to block .

Blocks and direct collection of all useful ILM triangulation measurements for TDOA AOA and or MPT triangulation of this MS relative known whereabouts e.g. other MSs . It is interesting to note that TDOA and AOA measurements field may have been made from different communications interfaces e.g. different wave spectrums depending on interfaces the MS has available i.e. all can participate . For example a MS with blue tooth WiFi and cellular phone connectivity different class wave spectrums supported can be triangulated using the best available information i.e. heterogeneous location technique . Examination of fields in can show wave spectrums and or particular communications interfaces inserted by receive processing for what the MS supports. If block determines an AOA measurement is present field sub field then block appends the WDR to the ANGLE list and processing continues to block . If block determines an AOA measurement is not present then processing continues to block . If block determines a TDOA measurement is present field sub field then block appends the WDR to the DISTANCE list and processing continues to block . Block uses WDRs for providing at least an in range whereabouts of this MS by inserting to the THIS MS list in sorted confidence priority order e.g. highest confidence first in list lowest confidence at end of list . Block continues to block . Block may cause duplicate WDR s inserted to the THIS MS list but this will have no negative effect on selected outcome.

Block compares the ANGLE and DISTANCE lists constructed thus far from loop processing blocks through with minimum triangulation requirements e.g. see Missing Part Triangulation MPT above . Three 3 sides three 3 angles and a side and other known triangular solution guides will also be compared. Thereafter if block determines there is still not enough data to triangulate whereabouts of this MS then processing continues back to block for the next REMOTE MS list entry otherwise block maximizes diversity of WDRs to use for triangulating. Thereafter block uses the diversified DISTANCE and ANGLE lists to perform triangulation of this MS block inserts the newly determined WDR into the THIS MS list in sort key order and continues back to block . Block will use heterogeneous MPT TDOA and or AOA triangulation on ANGLE and DISTANCE lists for determining whereabouts.

Block preferably keeps track of or checks THIS MS for what it has thus far determined whereabouts for in this thread processing to prevent inserting the same WDR to THIS MS using the same REMOTE MS data. Repeated iterations of blocks through will see the same data from previous iterations and will use the best of breed data in conjunction with each other at each iteration in current thread context . While inserting duplicates to THIS MS at block does not cause failure it may be avoided for performance reasons. Duplicate insertions are preferably avoided at block for performance reasons as well but they are again not harmful. Block preferably keeps track of previous diversity order in this thread processing to promote using new ANGLE and DISTANCE data in whereabouts determination at block since each iteration is a superset of a previous iteration in current thread context . Block promotes using WDRs from different MSs different MS IDs and from MSs located at significantly different whereabouts e.g. to maximize surrounded ness preferably around the MS of processing. Block preferably uses sorted diversity pointer lists so as to not affect actual ANGLE and DISTANCE list order. The sorted pointer lists provide pointers to entries in the ANGLE and DISTANCE lists for a unique sorted order governing optimal processing at block to maximize unique MSs and surrounded ness without affecting the lists themselves like a SQL database index . Different embodiments of blocks through should minimize inserting duplicate WDRs for performance reasons to THIS MS which were determined using identical REMOTE MS list data. Block causes using ADLT at blocks through which uses the best of breed whereabouts either as originated by this MS maintained in THIS MS list up to the thread processing point of block or as originated by remote MSs DLMs and or ILMs processed by blocks through the start of block .

Referring back to block if it is determined that all WDRs in the REMOTE MS list have been processed then block sets the BESTWDR reference to the head of THIS MS i.e. BESTWDR references first WDR in THIS MS list which is so far the best candidate WDR highest confidence for this MS whereabouts or null if the list is empty . It is possible that there are other WDRs with matching confidence adjacent to the highest confidence entry in the THIS MS list. Block continues to block for comparing matching confidence WDRs and if there are matches then breaking a tie between WDRs with matching confidence by consulting any other WDR field s e.g. field signal strength or location technology field etc . If there is still a tie between a plurality of WDRs then block may average whereabouts to the BESTWDR WDR using the matching WDRs. Thereafter processing continues to block where the BESTWDR is completed and processing terminates at block . Block also frees resources if any allocated by processing e.g. lists . Blocks through result in setting BESTWDR to the highest priority WDR i.e. the best possible whereabouts determined . It is possible that processing causes a duplicate WDR inserted to queue at block for this MS whereabouts determination but that is no issue except for impacting performance to queue . An alternate embodiment to queue may define a unique index for erring out when inserting a duplicate to prevent frivolous duplicate entries or block will incorporate processing to eliminate the chance of inserting a WDR of less use than what is already contained at queue . Therefore block may include processing for ensuring a duplicate will not be inserted e.g. null the BESTWDR reference prior to returning to at block .

Averaging whereabouts at block occurs only when there are WDRs at the head of the list with a matching highest confidence value and still tie in other WDR fields consulted yet whereabouts information is different. In this case all matching highest confidence whereabouts are averaged to the BESTWDR to come up with whereabouts in light of all matching WDRs. Block performs ADLT when finalizing a single whereabouts WDR using any of the whereabouts found in THIS MS which may contain at this point DLM whereabouts originated by this MS and or whereabouts originated by remote DLMs and or ILMs . Block must be cognizant of sort keys used at blocks and in case confidence is not the primary key time may be primary .

If no WDRs were found at block or no THIS MS list WDRs were found at blocks and and no REMOTE MS list entries were found at block or no THIS MS list WDRs were found at blocks and and no REMOTE MS list entries were found useful at blocks and or then block may be setting BESTWDR to a null reference i.e. none in list in which case block does nothing. Hopefully at least one good WDR is determined for MS whereabouts and a new WDR is inserted for this MS to queue otherwise a null BESTWDR reference will be returned checked at block . See descriptions. If BESTWDR is not null then fields are set to the following upon exit from block 

LOCATION TECHNOLOGY field is preferably set with ILM TDOA Triangulation ILM AOA Triangulation ILM MPT Triangulation or ILM in range as determined by the WDRs inserted to MS LIST at blocks and . The originator indicator is set to ILM. LOCATION REFERENCE INFO field is preferably set with null not set but may be set with contributing data for analysis of queue provided it is marked for being overlooked by future processing of blocks and e.g. for debug purpose . COMMUNICATIONS REFERENCE INFO field is preferably set with null not set . SPEED field is preferably set with Block may compare prioritized entries and their order of time field in THIS MS list for properly setting this field if possible. HEADING field is preferably set with null not set . Block may compare prioritized entries and their order of time field in THIS MS list for properly setting this field if possible. ELEVATION field is preferably set with Field of BESTWDR may be averaged if WDR tie s if available. APPLICATION FIELDS field is preferably set with Field s from BESTWDR or tie s thereof from THIS MS. An alternate embodiment will add alter or discard data with or without date time stamps here at the time of block processing. CORRELATION FIELD is preferably set with Not Applicable i.e. not maintained to queue . SENT DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue . RECEIVED DATE TIME STAMP field is preferably set with Not Applicable i.e. not maintained to queue .

Block determines whereabouts using preferred guidelines such as whereabouts determined never results in a confidence value exceeding any confidence value used to determine whereabouts. Some embodiments will use the mean average of confidence values used some will use the highest and some the lowest of the WDRs used. Preferred embodiments tend to properly skew confidence values to lower values as the LN Expanse grows away from region . Blocks through may consult any of the WDR fields e.g. field sub fields yaw pitch roll speed heading etc to deduce the most useful WDR inputs for determining an optimal WDR for this MS whereabouts.

Thread s are started for every WDR collected from remote MSs. Therefore it is possible that identical new WDRs are inserted to queue using the same WDR information at blocks of simultaneously executing threads but this will not cause a problem since at least one will be found when needed and duplicates will be pruned together when appropriate. Alternative embodiments provide IPC Interprocess Communications Processing coordination between threads for higher performance processing for example 

The current design for queue does not require to prune it. Alternative embodiments may add additional queues for similar processing. Alternate embodiments may use like processing to prune queues or any other queue under certain system circumstances. Parameters received at block may also include how to prune the queue for example when using different constraints for what indicates entry s for discard.

Blocks through handle termination of all processes threads associated with the ILMV roles so there is no explicit ILMV check required. Block initializes an enumerated process name array for convenient processing reference of associated process specific variables described in and continues to block where the first member of the set is accessed for subsequent processing. The enumerated set of process names has a prescribed termination order for MS architecture . Thereafter if block determines the process identifier i.e. PID such that is in a loop iteration of blocks through is greater than 0 e.g. this first iteration of PID 0 implies it is to be terminated here also implies process is enabled as used in then block prepares parameters for invocation and block invokes calls the procedure of to terminate the process of this current loop iteration . Block prepares the second parameter in accordance with the type of process. If the process is one that is slave to a queue for dictating its processing i.e. blocked on queue until queue entry present then the second parameter process type is set to 0 directing processing to insert a special termination queue entry to be seen by worker thread s for terminating . If the process is one that is slave to a timer for dictating its processing i.e. sleeps until it is time to process then the second parameter process type is set to the associated PID value directing to use in killing terminating the PID in case the worker thread s are currently sleeping . Block passes the process name and process type as parameters to processing. Upon return from block continues to block . If block determines that the process is not enabled then processing continues to block . Upon return from processing the process is terminated and the associated PID variable already set to 0 see blocks and .

Block checks if all process names of the enumerated set have been processed iterated by blocks through . If block determines that not all process names in the set have been processed iterated then processing continues back to block for handling the next process name in the set. If block determines that all process names of the enumerated set were processed then block continues to block .

Block destroys semaphore s created at block . Thereafter block destroys queue s created at block may have to remove all entries first in some embodiments block saves persistent variables to persistent storage for example to persistent storage block destroys shared memory created at block and block checks the NTP use variable saved prior to destroying shared memory at block .

If block determines NTP is enabled then block terminates NTP appropriately also see block and processing continues to block . If block determines NTP was not enabled then processing continues to block . Block embodiments are well known in the art of NTP implementations. Block may cause terminating of thread s associated with NTP use.

Block completes LBX character termination then block completes other character termination processing and processing terminates thereafter at block . Depending on what threads were started at block block may terminate the listen receive threads for feeding queue and the send threads for sending data inserted to queue . Depending on what threads were started at block block may terminate the listen receive threads for feeding queue and the send threads for sending data inserted to queue i.e. other character threads altered to cause embedded CK processing . Upon encounter of block the MS is appropriately terminated for reasons at set forth above for invoking .

With reference now to depicted is a flowchart for describing a preferred embodiment of a procedure for terminating a process started by . When invoked by a caller the procedure starts at block and continues to block where parameters passed are determined. There are two parameters the process name to terminate and the type of process to terminate. The type of process is set to 0 for a process which has worker threads which are a slave to a queue. The type of process is set to a valid O S PID when the process worker threads are slave to a timer.

Thereafter if block determines the process type is 0 then block initializes a loop variable J to 0 and block inserts a special termination request queue entry to the appropriate queue for the process worker thread to terminate. See discussions for the queue inserted for which process name.

Thereafter block increments the loop variable by 1 and block checks if all process prescribed worker threads have been terminated. Block accesses the Max e.g. Max variable from shared memory using a semaphore for determining the maximum number of threads to terminate in the process worker thread pool. If block determines all worker threads have been terminated processing continues to block for waiting until the PID variable is set to disabled e.g. set to 0 by block and then to block which causes return to the caller. Block uses a preferred choice of waiting described for blocks and . The process e.g. will have its PID e.g. PID variable set at 0 block when the process terminates. In some embodiments the waiting methodology used at block may use the PID variable or may be signaled by the last terminating worker thread or by block .

If block determines that not all worker threads have been terminated yet then processing continues back to block to insert another special termination request queue entry to the appropriate queue for the next process worker thread to terminate. Blocks through insert the proper number of termination queue entries to the same queue so that all of the process worker threads terminate.

Referring back to block if it is determined the process type is not 0 i.e. is a valid O S PID then block inserts a special WDR queue entry enabling a queue peek for worker thread termination. The reader will notice that the process termination order of block ensures processes which were slaves to the WDR queue have already been terminated. This allows processes which are slaves to a timer to see the special termination queue entry inserted at block since no threads which are slaves to queue will remove it from queue . Thereafter block waits until the process name parameter worker threads have been terminated using a preferred choice of waiting described for blocks and . The process e.g. will have its PID e.g. PID variable set at 0 block when the process terminates. In some embodiments the waiting methodology used at block may use the PID variable or may be signaled by the last terminating worker thread or by block . Block also preferably waits for a reasonable timeout period in anticipation of known sleep time of the process being terminated for cases where anticipated sleep times are excessive and the user should not have to wait for lengthy termination processing. If the timeout occurs before the process is indicated to be terminated then block will continue to block . Block also continues to block when the process has successfully terminated.

If block determines the process did terminate the caller is returned to at block i.e. PID already set to disabled 0 . If block determines the process termination timed out then block forces an appropriate O S kill to the PID thereby forcing process termination and block sets the PID variable for disabled i.e. process was terminated . Thereafter block causes return to the caller.

There are many embodiments for setting certain queue entry field s identifying a special queue termination entry inserted at blocks and . Some suggestions In the case of terminating thread s queue insertion of a WDR preferably sets the MS ID field with a value that will never appear in any other case except a termination request e.g. 100 . In the case of terminating thread s and queue insertion of a WDR preferably sets the MS ID field with a value that will never appear in any other case except a termination request e.g. 100 . In the case of terminating thread s queue insertion of a WDR request preferably sets the MS ID field with a value that will never appear in any other case except a termination request e.g. 100 . In the case of terminating thread s queue insertion of a thread request queue record preferably sets field with a value that will never appear in any other case except a termination request e.g. 100 . Of course any available field s can be used to indicate termination to particular thread s .

Terminating threads of processing in has been presented from a software perspective but there are hardware firmware thread embodiments which may be terminated appropriately to accomplish the same functionality. If the MS operating system does not have an interface for killing the PID at block then blocks through can be eliminated for relying on a invocation timeout incorporated for block to appropriately rob power from remaining thread s of processing.

An ILM has many methods and systems for knowing its own location. LBX depends on MSs maintaining their own whereabouts. No service is required to maintain the whereabouts of MSs in order to accomplish novel functionality.

Armed with its own whereabouts as well as whereabouts of others and others nearby a MS uses charters for governing many of the peer to peer interactions. A user is preferably unaware of specificities of the layer s providing WDR interoperability and communications. Permissions and charters surface desired functionality to the MS user s without fully revealing the depth of features that could be made available. Permissions provide authentication for novel features and functionality and to which context to apply the charters. However some permissions can provide action s features and functionality by themselves without a charter. It is preferred that LBX features and functionality be provided in the most elegant manner across heterogeneous MSs.

User configured permissions are maintained at a MS and their relevance applicability to WDRs that are being processed is determined. WDR processing events are recognized through being placed in strategic LBX processing paths of WDRs. For example permissions govern processing of newly processed WDRs at a MS regardless of where the WDR originated. A permission can provide at least one privilege and may provide a plurality of privileges. A permission is granted from a grantor identity to a grantee identity. Depending on what permissions are determined relevant to i.e. applicable to a WDR being processed e.g. by accessing at least one field in the WDR an action or plurality of actions which are associated with the permission can automatically occur. Actions may be as simple as modifying a setting which is monitored used by an LBX application or as complex as causing many executable application actions for processing. User configured charters are maintained at a MS and their relevance applicability to WDRs that are being processed is determined preferably in context of the same recognized events i.e. strategic processing paths which are used for determining relevance of permissions to WDRs. A charter consists of a conditional expression and can have an action or plurality of actions which are associated with the expression. Upon evaluating the expression to an actionable condition e.g. evaluates to a Boolean true result the associated action s are invoked. Charters can be created for a MS by a user of that MS or by a user of another MS. Charters are granted similarly to permissions in using a grantor and grantee identity therefore granting a charter is equivalent to granting a permission to execute the charter.

While some embodiments will provide disclosed features as one at a time implementations a comprehensive architecture is disclosed for providing a platform that will survive LBX maturity. depict a preferred embodiment BNF Backus Naur Form grammar for permissions and charters . A BNF grammar is an elegant method for describing the many applicable derived subset embodiments of syntax and semantics in carrying out processing behavior. The BNF grammar of specifically describes 

Preferably when a variable is set to another variable e.g. a b an instantiation of the variable i.e. a equals the variable b not b s value i.e. a b s value . If the variable b is set to a variable c e.g. b c in the example and the variable a is set to the variable b as already described past or future prior to instantiation and c was set i.e. c 2 to the value 2 past or future prior to instantiation then the preferred embodiment requires three 3 instantiations of variable a to get to the value assigned to variable c e.g. a 2 . Instantiation of variable a e.g. a preferably corresponds to a level of peeling back through the hierarchy of variable assignments if one exists. Alternative embodiments will allow a single instantiation of a variable to get through any number of indirect variable assignments for the first encountered value in the indirect chain value e.g. a 2 at the time of instantiation. Either semantic may have useful features from a programming standpoint. Over instantiating e.g. c error should cause an error. An assigned value is the leaf node in peeling back with instantiations.

The BNF Grammar null is an atomic element for no value. In a syntactic embodiment a null value may be a special null character e.g. . The History construct is preferably used to track when certain constructs were created and last modified. An alternative embodiment will track all construct changes to LBX history for later human or automated processing audit.

Grammar system type is an atomic element atomic elements are not constructs which elaborate to other things atomic elements are shown delimited in double quotes generalized for the type of MS e.g. PDA cell phone laptop etc . Other embodiments will provide more detail to the type of MS e.g. iPhone Blackberry Pearl Nextel i845 Nokia 741 etc . ID is an identity construct of the present disclosure for identifying a MS a user a group or any other entity for which to associate data and or processing. IDType provides the type of ID to support a heterogeneous identifying grammar. An identity i.e. ID IDType can be directly associated to a MS e.g. MS ID or may be indirectly associated to a MS e.g. user ID or group ID of the MS . Indirect identity embodiments may assume an appropriate lookup for mapping between identities is performed to get one identity by looking up another identity. There may be multiple identities for a MS. Identities by definition provide a collective handle to data. For example an email sender or recipient is an example of an identity logical handle which can be associated to a user identity and or MS identity and or group identity. A sender source recipient and system parameter in some atomic commands presented below is any of the variety of types of identities.

Address elements of ip address and SNA address are examples of logical addresses but are mentioned specifically anyway. ID IDType and Address construct atomic elements as elaborated on Right Hand Side RHS are self explanatory. The TimeSpec construct is one of various kinds of date time stamp or date time period atomic elements. In a syntactic embodiment date time stamps are specified with prefixed character s and a time format such as xYYYYMMDDHHMMSS.12 . . . J J places to right of decimal point such that 1 is the one tenth 1 10 second place two the one hundredth 1 100 second place etc . The first character s i.e. x clarify the date time stamp information.

There are two 2 main types of permissions privileges semantic privileges which on their own enable LBX features and functionality and grammar specification privileges which enable BNF grammar specifications. Semantic privileges are named anticipated by applications and have a semantic meaning to an application. Semantic privileges are variables to applications whereby values at the time of an application checking the variable s determine how the application will behave. Semantic privileges can also have implicit associated action s . Grammar specification privileges are named anticipated by charter parser implementation and indicate what is and what is not permitted when specifying a charter. Grammar specification privileges are variables to charter parsing whereby values at the time of charter parse logic checking the variable s determine whether or not the charter is valid i.e. privileged for execution. Impersonation is not directly defined in the BNF grammar of charters and is therefore considered a semantic privilege.

The MS relevance descriptor atomic element is preferably a binary bit mask accommodating all anticipated MS types see system type . Each system type is represented by a bit mask bit position wherein a bit set to 1 indicates the MS type does participate with the privilege assigned and a bit set to 0 indicates the MS type does not participate with the privilege assigned. This is useful when MSs do not have equivalent capabilities thereby limiting interoperability for a particular feature governed by a privilege. When the optional MSRelevance construct is not specified with a privilege the preferred default is assumed relevance for all MSs i.e. all bits set to 1 . An alternate embodiment will make the default relevant for no MSs i.e. all bits set to 0 . Privilege codes i.e. syntactical constants equated to an atomic privilege for assignment description are preferably long lived and never changing so that as new LBX privileges are introduced i.e. new privileges supported the old ones retain their values and assigned function and operate properly with new software releases i.e. backwards compatible . Thus new constants e.g. lbxall privilege for allowing all LBX interoperable features for atomic privilege for assignment should be chosen carefully.

Grants are used to organize privileges in desired categories and or sub categories e.g. organization name team name person name etc and then privileges for that particular grant name . A grant can be used like a folder. Grants provide an hierarchy of tree branch nodes while privileges are leaf nodes of the grant privilege tree. There are many types of privileges. Many are categorized for configuring charter conditions and charter actions and some can be subsets of others for example to have an overall category of privileges as well as many subordinate privileges within that category. This facilitates enabling disabling an entire set with a single configuration or enabling disabling certain privileges within the set. This also prevents forcing a user to define Grants to define privilege categories. BNF grammar does not clarify the Privilege construct with a parameter for further interpretation however some embodiments will incorporate an optional Parameters specification 

While the Grantor construct translates to the owner of the permission configuration according to grammar impersonation permits a user to take on the identity of a Grantor for making a configuration. For example a group by its very nature is a form of impersonation when a single user of the group grants permissions from the group to another identity. A user may also impersonate another user if has the privilege to do so for making configurations. In an alternative embodiment grammar may include means for identifying the owner of the permission s granted. Group constructs provide means for collections of ID constructs for example for teams departments family whatever is selected for grouping by a name atomic element group name . The impersonation privilege should be delegated very carefully in the preferred embodiment since the BNF grammar does not carry owner information except through a History construct use.

The Grantor of a privilege is the identity wanting to convey a privilege to another identity the Grantee . The Grantee is the identity becoming privileged by administration of another identity the Grantor . There are various embodiments for maintaining privileges some embodiments having the side affect of increasing or decreasing the palette of available privileges for assignment. Privilege Permission embodiments include 

It is important to note the context of terminology use Grantor and Grantee appears in since they are similarly used in context of charters versus permissions. In both cases there is an acceptance authentication configuration granted by a Grantor to a Grantee. A permission Grantor grants a privilege to a Grantee. A charter Grantor grants a privilege to enable a Grantee s charters may be at the mercy of privileges in the preferred embodiment . The Grantee construct in charters translates to the owner creator maintainer identity of the charter configuration according to grammar and and the Grantor construct translates to an identity the Grantee has created the charter for but does not necessarily have the privilege to do so or does not necessarily have the privilege for any subset of processing of the charter. Privileges preferably govern whether charters are in effect and how they are in effect. An alternative embodiment will activate make in effect a charter by granting it from one identity to another as shown in grammar . A charter consists of a conditional expression and can have an action or plurality of actions which are associated with the conditional expression. Upon evaluating the expression to an actionable condition e.g. evaluates to a Boolean true result the associated action s are invoked.

Impersonation permits a user to take on the identity of a Grantee for making a configuration. For example a group by its very nature is a form of impersonation when a single user of the group administrates charters for the group. A user may also impersonate another user if has the privilege to do so for making configurations. In an alternative embodiment grammar and may include means for identifying the owner of the charters administrated. The impersonation privilege should be delegated very carefully in the preferred embodiment since the BNF grammar does not carry owner information except through a History construct use.

The Grantee of a charter is the identity e.g. creates and owns the charter wanting to have its charters processed for another identity the Grantor . The Grantor is the identity targeted for processing the administrated charter s created by the Grantee. The terminology Grantor and Grantee will become reversed to match privilege assignments in an embodiment which grants charters like privileges. There are various embodiments for maintaining charters some embodiments having the side affect of increasing or decreasing the palette of available charter processing deployed. Charter embodiments include 

WDRTerm provides means for setting up conditions on any WDR field or subfield that is detected for WDR s 

AppTerm provides means for setting up conditions on data of any application of an MS for example to trigger an action based on a particular active call during whereabouts processing. A few AppTerm examples are any of the following 

Grammar completes definition of grammar rules for charters. The Invocation construct elaborates to any of a variety of executables with or without parameters including Dynamic Link Library DLL interfaces e.g. function post compile linked interfaces e.g. function scripts batch files command files or any other executable. The invoked interface should return a value preferably a Boolean true or false otherwise one will preferably be determined or defaulted for it. The Op construct contains atomic elements called atomic operators for certain operators used for terms to specify conditions. In syntactical embodiments each atomic operator may be clarified with a not modifier i.e. . For example equal to is and not equal to is . Those skilled in the art recognize which atomic operator is contextually appropriate for which applicable terms see BNF grammar . There are many reasonable syntactical embodiments for atomic operators with at least 

Resolving of conditions using atomic operators involves evaluating conditions BNF grammar constructs and additionally accessing similar data of LBX history in some preferred embodiments. Atomic operator validation errors should result when inappropriately used.

In one embodiment of profiles maintained at MSs a LBX singles dating application maintains a MS profile for user s interests tastes likes dislikes etc. The ProfileMatch operators enable comparing user profiles under a variety of conditions for example to cause an action of alerting a user that a person of interest is nearby. See for other profile information.

Atomic operators are context sensitive and take on their meaning in context to terms i.e. BNF Grammar Term they are used with. An alternate embodiment incorporates new appropriate atomic operators for use as CondOp operators provided the result of the condition is a Boolean e.g. term term results in a true or false . Also while a syntactical form of parenthesis is not explicitly shown in the BNF grammar the Conditions constructs explicitly defines how to make complex expressions with multiple conditions. Using parenthesis is one preferred syntactical embodiment for carrying out the Conditions construct. The intention of the BNF grammar is to end up with any reasonable conditional expression for evaluating to a Boolean True or False. Complex expression embodiments involving any conceivable operators terms order of evaluation e.g. as syntactically represented with parentheses and other arithmetic similarities are certainly within the spirit and scope of this disclosure.

BNF grammar terms are to cover expressions containing conditions involving WDR fields WDRTerm situational locations geofences i.e. a geographic boundary identifying an area or space two dimensional and three dimensional areas two dimensional and three dimensional space point in an area point in space movement amounts movement distances movement activity MS IDs MS group IDs current mobile locations past mobile locations future mobile locations nearness distantness newly near newly afar activities at locations past present future applications and context thereof in use at locations past present future etc. There are many various embodiments for specific supported operators used to provide interpretation to the terms. Certain operators terms and processing is presented for explanation and is in no way meant to limit the many other expression BNF Grammar Expression embodiments carrying the spirit of the disclosure.

The Command construct elaborates to atomic commands. The atomic command atomic element is a list of supported commands such as those found in the column headings of table see discussions for . There are many commands some popular commands being shown. The Operand construct elaborates to atomic operands. The atomic operand atomic element is a list of supported operands data processing system objects such as those found in the row headings of table see discussions for . There are many operands some popular operands being shown. For each command and operand combination there may be anticipated parameters. The command and operand pair indicates how to interpret and process the parameters.

The constructs of Parameter WDRTerm AppTerm Value and Data are appropriately interpreted within context of their usage. An optional time specification is made available when specifying charters i.e. when charter is in effect expressions i.e. a plurality of conditions e.g. with Conditions within Expressions construct a particular condition e.g. with Condition elaborations within Condition construct and actions e.g. with Action elaborations within Action construct . One embodiment supports multiple Host specifications for a particular action. Some embodiments allow an Invocation to include invocations as parameters in a recursive manner so as to bubble up a resulting Boolean e.g. fcn1 2 fcn2 p1 x 45 10 such that fcn2 may also have invocations for parameters. The conventional inside out evaluation order is implemented. Other embodiments support various types of invocations which contribute to the overall invocation result returned.

In alternate embodiments an action can return a return code for example to convey success failure or some other value s back to the point of performing the action. Such embodiments may support nesting of returned values in BNF grammar Parameters so as to affect the overall processing of actions. For example action1 parameter s . . . action2 . . . parameters . . . . . . parameter s and action2 may include returning value s from its parameters which are actions .

Wildcarding is of value for broader specifications in a single specification. Wildcards may be used for BNF grammar specification wherever possible to broaden the scope of a particular specification e.g. Condition TimeSpec etc .

An atomic command is an enumeration shown in column headings i.e. . . . etc with an implied command meaning. shows what meaning is provided to some of the atomic command enumerations shown also see . A plurality of commands can map to a single command meaning. This supports different words phrases e.g. spoken in a voice command interface to produce the same resulting command so that different people specify commands with terminology language or written form they prefer. An atomic operand is an enumeration shown in row headings i.e. . . . etc with an implied operand meaning. shows what meaning is provided to some of the atomic operand enumerations shown also see . A plurality of operands can map to a single operand meaning. This supports different words phrases e.g. spoken in a voice command interface to produce the same resulting operand so that different people specify operands with terminology language or written form they prefer. Operands are also referred to as data processing system objects because they are common objects associated with data processing systems. demonstrate anticipated parameters for each combination of a command with an operand. There are potentially hundreds or more of commands and operands. This disclosure would be extremely large to cover all the different commands operands and parameters that may be reasonable. Only some examples with a small number of parameters are demonstrated in to facilitate discussions. There can be a large number of parameters for a command and operand pair. Each parameter as shown by the BNF grammar may be in many forms. In one preferred embodiment not shown in BNF grammar the Parameter construct of may also elaborate to a ParameterExpression which is any valid arithmetic expression that elaborates to one of the Parameter constructs RHS shown in the BNF Grammar. This allows specifying expressions which can be evaluated at run time for dynamically evaluating to a parameter for processing.

The combination of a command with an operand and its set of associated parameters form an action in the present disclosure relative the BNF grammar discussed above. Some of the command operand combinations overlap or intersect in functionality and or parameters. In general if parameters are not found null specified for an anticipated parameter position a default is assumed e.g. parameters of 5 7 indicates three 3 parameters of 5 use default or ignore and 7 . Operands and parameters are preferably determined at executable code run time when referenced accessed so that the underlying values may dynamically change as needed at executable code run time in the same references. For example a variable set with constructs which elaborates to a command operand and parameters can be instantiated in different contexts for completely different results. Also a programming language enhanced with new syntax e.g. as described in may include a loop for processing a single construct which causes completely different results at each loop iteration. The operand or parameter specification itself may be for a static value or dynamic value as determined by the reference used. An alternate embodiment elaborates values like a preprocessed macro ahead of time prior to processing for static command operand and parameter values. Combinations described by are discussed with flowcharts. In another embodiment substitution like parameter substitution discussed above for can be used for replacing parameters at the time of invocation. In any case Parameters can contain values which are static or dynamically changing up to the time of reference.

Parameters of atomic command processing will evaluate resolve elaborate to an appropriate data type and form for processing which is described by the B matrices below e.g. is the matrix for describing atomic send command processing . The B descriptions provide the guide for the data types and forms supportable for the parameters. For example an email body parameter may be a string a file containing text a variable which resolves to a string or file etc. The BNF grammar is intended to be fully exploited in the many possible embodiments used for each parameter.

In the preferred embodiment Parameters are contextually determined upon the MS recognizing user directives depending on the context in use at the time. In another embodiment Parameters will also have directive mappings for being interpreted for MS processing analogously to .

The preferred embodiment of a WDRTerm is a system well known WDR field subfield variable name with two 2 leading underscore characters e.g. source code references of  confidence refers to a confidence value of a WDR confidence field  msyaw refers to a yaw value of a WDR location reference field MS yaw subfield . Some useful examples using a WDRTerm include 

An atomic term is another special type of user specifiable programmatic variable reference for expressions conditions to cause certain actions. The preferred embodiment of an atomic term is a system well known variable name with a leading backslash escape character e.g. source code references of loc my refers to the most recent MS location timestamp refers to the current MS system date time in a date time stamp format . There can be atomic terms to facilitate expression condition specifications some of which were described above.

Source code header information is well understood by those skilled in the relevant art in light of the BNF grammar disclosed. The example does make certain assumptions which are easily altered depending on specificities of a derivative form or subset of the grammar of . Assumptions are easily modified for good implementations through modification of isolated constants in the header file 

The TIMESPEC structure of preferably utilizes a well performing Julian date time format. Julian date time formats allows using unambiguous floating point numbers for date time stamps. This provides maximum performance for storage database queries and data manipulation. Open ended periods of time use an unspecified start or end data time stamp as appropriate i.e. DT NOENDSPEC or DT NOSTARTSPEC . A known implemented minimal time granulation used in Julian date time stamps can be decrement or incremented by one 1 as appropriate to provide a non inclusive date time stamp period delimiter in a range specification e.g. date time stamp .

The VAR structure provides a pointer to a datastream which can be typecast if applicable in embodiments which elaborate the variable prior to being instantiated or referenced or later processed. Variables are preferably not elaborated evaluated until instantiated or referenced. For example the variable assigned value s which are parsed from an encoding remains unprocessed e.g. stays in X.409 datastream encoded form until instantiated. Enough space is dynamically allocated for the value s e.g. per length of variable s value s e.g. X.409 encoding form the variable s value e.g. X.409 encoding is copied to the allocated space and the v.value pointer is set to the start of the allocated space. The v.value pointer will be used later when the variable is instantiated to then parse and process the variable value s when at the context they are instantiated .

An alternate embodiment to the PERMISSION structure of may not require the grantor fields e.g. grantor gortype since the data processing system owning the data may only maintain permissions for the grantor e.g. the MS user . An alternate embodiment to the CHARTER structure of may not require the grantee fields e.g. grantee geetype or the grantor fields e.g. grantor gortype since the data processing system owning the data may only maintain charters for that user at his MS. Another embodiment to the CHARTER structure of may not require the grantor fields e.g. grantor gortype since the data processing system owning the data may be self explanatory for the Grantor identity e.g. charters used at MS of Grantor .

In one embodiment data can be maintained to data records of and such that it is marked as enabled or disabled e.g. additional column in SQL table for enabled disabled . In another embodiment a record is configured in disabled form and then subsequently enabled for example with a user interface. Any subset of data records may be enabled or disabled as a related set. Privileges may be configured for which subsets can be enabled or disabled by a user. In another embodiment privileges themselves enable or disable a data record a subset of data records a subset of data record types or a subset of data of data records.

Data records were derived from the BNF grammar of . Other data record embodiments may exist. In a preferred embodiment data records of are maintained to persistent storage of the MS. A MS used for the first time should be loaded with a default set of data e.g. starter templates containing defaulted data preloaded to the data records for user convenience. Loading may occur from local storage or from remotely loading for example over a communications channel when first initializing the MS e.g. enhanced block for additionally ensuring the data records are initialized in particular for the first startup of an MS . Owner fields e.g. field for preloaded data are preferably set to a system identity for access and use by all users. Preferably a user cannot delete any of the system preloaded data. While the data records themselves are enough to operate permissions and charters at the MS after startup a better performing internalization may be preferred. For example block can be enhanced for additionally using data records to internalize to a non persistent well performing form such as compiled C encoding of also see and block can be enhanced for additionally using the internalized data to write out to data records maintained in persistent storage. Any compiled interpreted programming source code may be used without departing from the spirit and scope of the disclosure. also see are an example but may provide an internalized form for processing. In any case many examples are provided for encoding permissions and charters . Continuing with the data record examples for example a persistent storage form of data records in a MS local SQL database e.g. a data record corresponds to a particular SQL table and data record fields correspond to the SQL table columns flowcharts through B are provided for configuration of permissions and charters . Data records are to be maintained in a suitable MS performance conscious form may not be an SQL database . An s is added as a suffix to disclosed acronyms e.g. GDR to reference a plural version of the acronym e.g. GDRs Granting Data Records .

It is anticipated that management of permissions and charters be as simple and as lean as possible on an MS. Therefore a reasonably small subset of the grammar is preferably implemented. While demonstrate a significantly large derivative of the BNF grammar the reader should appreciate that this is to cover all bases of consideration and is not necessarily a derivative to be incorporated on a MS of limited processing capability and resources. A preferred embodiment is discussed but much smaller derivatives are even more preferred on many MSs. Appropriate semaphore lock windows are assumed incorporated when multiple asynchronous threads can access the same data concurrently.

In an alternate embodiment where the MS maintains GDRs GRTDRs GADRs PDRs and GRPDRs and their associated data records DDRs HDRs and TDRs at the MS where they were configured may not provide blocks through . The MS may be aware of its user permissions and need not share the data i.e. self contained . In some embodiments options through cause access to locally maintained data for others other users MSs etc or cause remote access to data when needed e.g. from the remote MSs . In the embodiment where no data is maintained locally for others blocks through may not be necessary. The preferred embodiment is to locally maintain permissions data for the MS user and others e.g. MS users which are relevant to provide the richest set of permissions governing MS processing at the MS.

Block accesses all GDRs e.g. all rows from a GDR SQL table for the user of matching field to Permission and the owner information of the GDRs e.g. user information matches field to the user and to groups the user is a member of e.g. group information matches field e.g. owner type group owner id a group ID field from block . The GDRs are additionally joined e.g. SQL join with DDRs and TDRs e.g. fields and Permission and by matching ID fields and with field . Description field may provide a useful description last saved by the user for the permission entry. Block may also retrieve system predefined data records for use and or management. Thereafter each joined entry returned at block is associated at block with the corresponding data IDs at least fields and for easy unique record accesses when the user acts on the data. Block also initializes a list cursor to point to the first list entry to be presented to the user. Thereafter block sets user interface indication for where the list cursor is currently set e.g. set to highlight the entry and any list scrolling settings are set the list is initially not set for being scrolled on first processing encounter to block from block . Block continues to block where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter block waits for user action to the presented list of permissions data and will continue to block when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format such that an entry contains fields for DDR description GDR owner information grantor information and grantee information GRPDR owner information and group name if applicable and TDR time spec information. Alternate embodiments will present less information or more information e.g. GRTDR s and or PDR s via GADR s joining fields e.g. .

If block determines the user selected to set the list cursor to a different entry then block sets the list cursor accordingly and processing continues back to block . Block always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block determines the user did not select to set the list cursor then processing continues to block . If block determines the user selected to add a permission then block accesses a maximum number of permissions allowed perhaps multiple maximum values accessed and block checks the maximum s with the number of current permissions defined. There are many embodiments for what deems a maximum for this user for a group for this MS etc . If block determines a maximum number of permissions allowed already exists then block provides an error to the user and processing continues back to block . Block preferably requires the user to acknowledge the error before continuing back to block . If block determines a maximum was not exceeded then block interfaces with the user for entering validated permission data and block adds the data record s appropriately updates the list with the new entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . If block determines the user did not want to add a permission processing continues to block . Block will add a GDR DDR HDR to set creator information and TDR . The DDR and TDR are optionally added by the user but the DDR may be strongly suggested if not enforced on the add . This will provide a permission record assigning all privileges from the grantor to the grantee. Additionally blocks may support adding new GADR s for assigning certain grants and or privileges which are validated to exist prior to adding data at block .

If block determines the user selected to delete a permission then block deletes the data record currently pointed to by the list cursor modifies the list for the discarded entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . Block will use the granting ID field associated with the entry at block to delete the permission. Associated GADR s DDR HDR and TDR is also deleted e.g. preferably with a cascade delete in a SQL embodiment . If block determines the user did not select to delete a permission then processing continues to block of by way of off page connector .

With reference now to if block determines the user selected to modify a permission then block interfaces with the user to modify permission data of the entry pointed to by the list cursor. The user may change information of the GDR and any associated records e.g. DDR TDR and GADR s . The user may also add the associated records at block . Block waits for a user action indicating completion. Block will continue to block when the complete action is detected at block . If block determines the user exited then processing continues back to block by way of off page connector . If block determines the user selected to save changes made at block then block updates the data and the list is appropriately updated before continuing back to block . Block may update the GDR and or any associated records e.g. GADR s DDR and or TDR using the permission id field associated to the entry at block . Block will update an associated HDR as well. Block may add new GADR s a DDR and or TDR as part of the permission change. If block determines the user did not select to modify a permission then processing continues to block .

If block determines the user selected to get more details of the permission e.g. show all joinable data to the GDR that is not already presented with the entry then block gets additional details may involve database queries in an SQL embodiment for the permission pointed to by the list cursor and block appropriately presents the information to the user. Block then waits for a user action that the user is complete reviewing details in which case processing continues back to block . If block determines the user did not select to get more detail then processing continues to block .

If block determines the user selected to internalize permissions data thus far being maintained then block internalizes e.g. as a compiler would all applicable data records for well performing use by the MS and block saves the internalized form for example to MS high speed non persistent memory. In one embodiment blocks and internalize permission data to applicable C structures of also see . In various embodiments block maintains statistics for exactly what was internalized and updates any running totals or averages maintained for a plurality of internalizations up to this point or over certain time periods. Statistics such as number of active constructs number of user construct edits of particular types amount of associated storage used freed changed etc with perhaps a graphical user interface to graph changes over time number of privilege types specified number of charters affected by permissions and other permission dependent statistics. In other embodiments statistical data is initialized at internalization time to prepare for subsequent gathering of useful statistics during permission processing. In embodiments where a tense qualifier is specified for TimeSpec information saving the internalized form at block causes all past and current tense configurations to become effective for being processed.

Bock then continues back to block . If block determines the user did not select to internalize permission configurations then processing continues to block . Alternate embodiments of processing permissions in the present disclosure will rely upon the data records entirely rather than requiring the user to redundantly internalize from persistent storage to non persistent storage for use. Persistent storage may be of reasonably fast performance to not require an internalized version of permission . Different embodiments may completely overwrite the internalized form or update the current internalized form with any changes.

If block determines the user selected to exit block processing then block cleans up processing thus far accomplished e.g. issue a stop using database command and block completes block processing. If block determines the user did not select to exit then processing continues to block where all other user actions detected at block are appropriately handled and processing continues back to block by way off off page connector .

Block accesses all GRTDRs e.g. all rows from a GRTDR SQL table for the user of matching the owner information of the GRTDRs e.g. user information matches field to the user and to groups the user is a member of e.g. group information matches field e.g. owner type group owner id group ID field from block . The GRTDRs are additionally joined e.g. SQL join with DDRs and TDRs e.g. fields and Grant and by matching ID fields and with field . Description field can provide a useful description last saved by the user for the grant data however the grant name itself is preferably self documenting. Block may also retrieve system predefined data records for use and or management. Block will also retrieve grants within grants to present the entire tree structure for a grant entry. Block retrieves all GRTDRs joined to other GRTDRs through GADRs which will provide the grant tree structure hierarchy. Grants can be descendant to other grants in a grant hierarchy. Descendant type field set to Grant and descendant ID field for a particular grant will be a descending grant to an ascending grant of ascendant type field set to Grant and ascendant ID field . Therefore each list entry is a grant entry that may be any node of a grant hierarchy tree. There may be grant information redundantly presented for example when a grant is subordinate to more than one grant but this helps the user know a grant tree structure if one has been configured. A visually presented embodiment may take the following form wherein a particular Grantappears in the appropriate hierarchy form.

If block determines the user selected to set the list cursor to a different grant reference then block sets the list cursor accordingly and processing continues back to block . Block always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block determines the user did not select to set the list cursor then processing continues to block . If block determines the user selected to add a grant then block accesses a maximum number of grants allowed perhaps multiple maximum values accessed and block checks the maximum s with the number of current grants defined. There are many embodiments for what deems a maximum for this user for a group for this MS etc . If block determines a maximum number of grants allowed already exists then block provides an error to the user and processing continues back to block . Block preferably requires the user to acknowledge the error before continuing back to block . If block determines a maximum was not exceeded then block interfaces with the user for entering validated grant data and block adds the data record appropriately updates the list with the new entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . If block determines the user did not want to add a grant processing continues to block . Block will add a GRTDR DDR HDR to set creator information and TDR . The DDR and TDR are optionally added by the user. Additionally at block the user may add new GADR s for assigning certain grants to the added grant and or privileges to the grant which are validated to exist prior to adding data at block .

If block determines the user selected to modify a grant then block interfaces with the user to modify grant data of the entry pointed to by the list cursor. The user may change information of the GRTDR and any associated records e.g. DDR TDR and GADR s . The user may also add the associated records at block . Block waits for a user action indicating completion. Block will continue to block when the action is detected at block . If block determines the user exited then processing continues back to block . If block determines the user selected to save changes made at block then block updates the data and the list is appropriately updated before continuing back to block . Block may update the GRTDR and or any associated records e.g. GADR s DDR and or TDR using the grant id field associated to the grant item at block . Block will update an associated HDR as well. Block may add new GADR s a DDR and or TDR as part of the grant change. If block determines the user did not select to modify a grant then processing continues to block by way of off page connector .

With reference now to if block determines the user selected to get more details of the grant e.g. show all joinable data to the GRTDR that is not already presented with the entry then block gets additional details may involve database queries in an SQL embodiment for the grant pointed to by the list cursor and block appropriately presents the information to the user. Block then waits for a user action that the user is complete reviewing details in which case processing continues back to block by way of off page connector . If block determines the user did not select to get more detail then processing continues to block .

If block determines the user selected to delete a grant then block determines any data records e.g. GADR s that reference the grant data record to be deleted. Preferably no ascending data records e.g. GRTDRs are joinable to the grant data record being deleted otherwise the user may improperly delete a grant from a configured permission or other grant. In the case of descending grants all may be cascaded deleted in one embodiment provided no ascending grants exist for any of the grants to be deleted. The user should remove ascending references to a grant for deletion first. Block continues to block . If block determines there was at least one reference block provides an appropriate error with the reference s found so the user can subsequently reconcile. Block preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block then processing continues to block for deleting the data record currently pointed to by the list cursor along with any other related records that can be deleted. Block also modifies the list for the discarded entry s and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . Block will use the grant ID field associated with the entry at block to delete a grant. Associated records e.g. DDR HDR and TDR are also deleted e.g. preferably with a cascade delete in a SQL embodiment . If block determines the user did not select to delete a grant then processing continues to block .

If block determines the user selected to exit block processing then block cleans up processing thus far accomplished e.g. issue a stop using database command and block completes block processing. If block determines the user did not select to exit then processing continues to block where all other user actions detected at block are appropriately handled and processing continues back to block by way off off page connector .

Block accesses all GRPDRs e.g. all rows from a GRPDR SQL table for the user of matching the owner information of the GRPDRs e.g. user information matches field to the user and to groups the user is a member of e.g. group information matches field e.g. owner type group owner id group ID field from block . The GRPDRs are additionally joined e.g. SQL join with DDRs and TDRs e.g. fields and Group and by matching ID fields and with field . Description field can provide a useful description last saved by the user for the group data however the group name itself is preferably self documenting. Block may also retrieve system predefined data records for use and or management. Block will also retrieve groups within groups to present the entire tree structure for a group entry. Block retrieves all GRPDRs joined to other GRPDRs through GADRs which will provide the group tree structure hierarchy. Groups can be descendant to other groups in a group hierarchy. Descendant type field set to Group and descendant ID field for a particular group will be a descending group to an ascending group of ascendant type field set to Group and ascendant ID field . Therefore each list entry is a group entry that may be any node of a group hierarchy tree. There may be group information redundantly presented for example when a group is subordinate to more than one group but this helps the user know a group tree structure if one has been configured. A visually presented embodiment may take the following form wherein a particular Groupappears in the appropriate hierarchy form.

If block determines the user selected to set the list cursor to a different group entry then block sets the list cursor accordingly and processing continues back to block . Block always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block determines the user did not select to set the list cursor then processing continues to block . If block determines the user selected to add a group then block accesses a maximum number of groups allowed perhaps multiple maximum values accessed and block checks the maximum s with the number of current groups defined. There are many embodiments for what deems a maximum for this user for a group for this MS etc . If block determines a maximum number of groups allowed already exists then block provides an error to the user and processing continues back to block . Block preferably requires the user to acknowledge the error before continuing back to block . If block determines a maximum was not exceeded then block interfaces with the user for entering validated group data and block adds the data record appropriately updates the list with the new entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . If block determines the user did not want to add a group processing continues to block . Block will add a GRTDR DDR HDR to set creator information and TDR . The DDR and TDR are optionally added by the user. Additionally at block the user may add new GADR s for assigning certain groups to the added group and or identities to the group which are validated to exist prior to adding data at block .

If block determines the user selected to modify a group then block interfaces with the user to modify group data of the entry pointed to by the list cursor. The user may change information of the GRPDR and any associated records e.g. DDR TDR and GADR s . The user may also add the associated records at block . Block waits for a user action indicating completion. Block will continue to block when the complete action is detected at block . If block determines the user exited then processing continues back to block . If block determines the user selected to save changes made at block then block updates the data and the list is appropriately updated before continuing back to block . Block may update the GRPDR and or any associated GADR s DDR and or TDR using the group id field associated to the group item at block . Block will update an associated HDR as well. Blocks may support adding new GADR s a DDR and or TDR as part of the group change. If block determines the user did not select to modify a group then processing continues to block by way of off page connector .

With reference now to if block determines the user selected to get more details of the group e.g. show all joinable data to the GRPDR that is not already presented with the entry then block gets additional details may involve database queries in an SQL embodiment for the group pointed to by the list cursor and block appropriately presents the information to the user. Block then waits for a user action that the user is complete reviewing details in which case processing continues back to block by way of off page connector . If block determines the user did not select to get more detail then processing continues to block .

If block determines the user selected to delete a group then block determines any data records e.g. GADR s that reference the group data record to be deleted. Preferably no ascending data records e.g. GRPDRs are joinable to the group data record being deleted otherwise the user may improperly delete a group from a configured permission or other group. In the case of descending groups all may be cascaded deleted in one embodiment provided no ascending groups exist for any of the groups to be deleted. The user should remove ascending references to a group for deletion first. Block continues to block . If block determines there was at least one reference block provides an appropriate error with the reference s found so the user can subsequently reconcile. Block preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block then processing continues to block for deleting the data record currently pointed to by the list cursor along with any other related records that can be deleted. Block also modifies the list for the discarded entry s and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . Block will use the group ID field associated with the entry at block to delete the group. Associated records e.g. DDR HDR and TDR are also deleted e.g. preferably with a cascade delete in a SQL embodiment . If block determines the user did not select to delete a group then processing continues to block .

If block determines the user selected to exit block processing then block cleans up processing thus far accomplished e.g. issue a stop using database command and block completes block processing. If block determines the user did not select to exit then processing continues to block where all other user actions detected at block are appropriately handled and processing continues back to block by way off off page connector .

In an alternative embodiment block appropriately accesses privileges granted from the owner criteria to the user of to ensure the user has a privilege to browse the data records per object type parameter of the specified owner. Block will provide an error when there is no privilege and will continue to block when there is a privilege. Block may also provide a user exit option for continuing to block for cases the user cannot successfully specify owner criteria. In similar embodiments there may be a separate privilege required for each object type a user may browse.

Block gets e.g. SQL selects data according to the object type parameter e.g. GRPDR s GDR s GRTDR s CDR s ADR s or PARMDR s along with any available associated joinable data e.g. DDR s HDR s TDR s and data records via GADR s if applicable per object type passed . There are various embodiments to block in accessing data locally maintained data for the owner criteria specified at block communicating with a remote MS for accessing the MS of the owner criteria to synchronously pull the data or sending a request to a remote MS over an interface like interface for then asynchronously receiving by an interface like interface for processing. One preferred embodiment is to locally maintain relevant data. In privilege enforced embodiments appropriate privileges are determined before allowing access to the other s data.

Thereafter if block determines there were no data records according to the object type passed by the caller for the owner criteria specified at block then block provides an error to the user and processing continues to block . Block performs cleanup of processing thus far accomplished e.g. perform a stop using database command and then continues to block for returning to the caller of processing. Block preferably requires the user to acknowledge the error before continuing to block .

If block determines at least one data record of object type was found then block presents a browse able scrollable list of entries to the user i.e. similar to lists discussed for presentation by B B B B B or B per object typed passed and block waits for a user action in response to presenting the list. When a user action is detected at block processing continues to block . If block determines the user selected to specify new owner criteria e.g. for comparison to field or per object type passed for browse then processing continues back to block for new specification and applicable processing already discussed for blocks thereafter. If block determines the user did not select to specify new owner criteria processing continues to block .

If block determines the user selected to get more detail of a selected list entry then processing continues to block for getting data details of the selected entry and block presents the details to the user and waits for user action. Detail presentation is similar to getting detail processing discussed for presentation by B B B B B or B per object typed passed. Block continues to block upon a user action complete clone .

If block determines the user action from block was to exit browse processing continues to block . If block determines the user action from block was to clone the data e.g. to make a copy for user s own use processing continues to block for accessing permissions. Thereafter if block determines the user does not have permission to clone processing continues to block for reporting an error preferably requiring the user to acknowledge before leaving block processing and then back to block . If block determines the user does have permission to clone processing continues to block where the data item browsed is appropriately duplicated with defaulted fields as though the user of processing had created new data himself. Processing then continues back to block . If block determines the user did not select to get more detail on a selected item then processing continues to block .

If block determines the user selected to exit browse processing then processing continues to block already described. If block determines the user did not select to exit then processing continues to block where all other user actions detected at block are appropriately handled and processing continues back to block .

In an alternate embodiment will support cloning multiple entries in one action so that a first user conveniently makes use of a second user s data like starter template s for the first user to create configure new data without entering it from scratch in the other interfaces disclosed. Another embodiment will enforce unique privileges for which data can be cloned by which user s .

In one embodiment the second set of configurations is further governed by individual privileges each send type and or privileges per a source identity. For example while configurations of the second set may be enabled the MS will only accept data in a form from a source in accordance with a privilege which is enabled set for the source identity . Privilege examples may also each have associated time specification include 

In some embodiments charter data that is received may be received by a MS in a deactivated form whereby the user of the receiving MS must activate the charters for use e.g. define a new charter enabled field for indicating whether or not the charter is active Y Yes N No . New field may also be used by the charter originator for disabling or enabling for a variety of reasons. This permits a user to examine charters and perhaps put them to a test prior to putting them into use. Other embodiments support activating charters received and or originated one at a time as selected sets by user specified criteria any charter characteristic s all or none by certain originating user s by certain originating MS s or any other desirable criteria. Of course privileges are defined for enabling accepting privileges or charters from a MS but many privileges can be defined for accepting privileges or charters with certain desired characteristics from a MS.

In any case see detailed explanations of as well as supporting exemplifications shown in respectively. Processing begins at block continues to block where the caller parameter passed to processing is determined i.e. OBJ TYPE and processing continues to block for interfacing with the user to specify targets to send data to in context of the object type parameter specified for sending PERMISSION INFO or CHARTER INFO . An alternate embodiment will consult a configuration of data for validated target information. Depending on the present disclosure embodiment a user may specify any reasonable supported ID IDType combination of the BNF grammar ID construct see as valid targets. Validation will validate at least syntax of the specification. In another embodiment block will access and enforce known permissions for validating which target s e.g. grantor s can be specified. Various embodiments will also support wildcarding the specifications for a group of ID targets e.g. department for all department groups . Additional target information is to be specified when required for sending for example if email or SMS message is to be used as a send method i.e. applicable destination recipient addresses to be specified . An alternate embodiment to block accesses mapped delivery addresses from a database or table referred to as a Recipient Address Book RAB associating a recipient address to a target identity thereby alleviating the user from manual specification and perhaps allowing the user to save to the RAB for any new useful RAB data. In another embodiment block discussed below accesses the RAB for a recipient address for the target when preparing the data for sending.

Upon validation at block processing continues to block . It is possible the user was unsuccessful in specifying targets or wanted to exit block processing. If block determines the user did not specify at least one validated target equivalent to selecting to exit processing then processing continues to block where processing returns to the caller. If block determines there is at least one target specified then block accesses LBX history to determine if any of the targets have been sent the specific data already. Thereafter if block determines the most recently updated data for a target has already been sent then block presents an informative error to the user preferably requiring user action. Block continues to block when the user performs the action. If block determines the user selected to ignore the error then processing continues to block otherwise processing continues back to block for updating target specifications.

Block interfaces with the user to specify a delivery method. Preferably there are defaulted setting s based on the last time the user encountered block . Any of the second set of options described with can be made. Thereafter block logs to LBX history the forthcoming send attempt and gets the next target from block specifications before continuing to block . If block determines that all targets have not been processed then block determines applicable OBJ TYPE data for the target e.g. check LBX history for any new data that was not previously successfully sent and block gets e.g. preferably new data or all depending on embodiment the applicable target s OBJ TYPE data permissions or charters before continuing to block . Block formats the data for sending in accordance with the specified delivery method along with necessary packet information e.g. source identity wrapper data etc of this loop iteration from block and block sends the data appropriately. For a broadcast send block broadcasts the information using a send interface like interface by inserting to queue so that send processing broadcasts data e.g. on all available communications interface s for example as far as radius and processing continues to block . The broadcast is for reception by data processing systems e.g. MSs in the vicinity see as further explained in detail by which includes potentially any distance . For a targeted send block formats the data intended for recognition by the receiving target. Block causes sending broadcasting data containing CK depending on the type of MS wherein CK contains information appropriately. In a send email embodiment confirmation of delivery status may be used to confirm delivery with an email interface API to check the COD Confirmation of Delivery status or the sending of the email also SMS message is assumed to have been delivered in one preferred embodiment.

In an embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place information as CK embedded in usual data at the next opportune time of sending usual data . This embodiment will replace synchronous sending success validation of blocks through and multiple delivery methods of and subsequent loop processing with status asynchronously updated by the receiving MS s for a single type of delivery method selected at block . An alternate embodiment will attempt the multiple send types in an appropriate asynchronous thread of processing depending on success of a previous attempt. As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends broadcasts new data .

For sending an email SMS message or other application delivery method block will use the additional target information recipient address specified via block for properly sending. Thereafter block waits for a synchronous acknowledgement if applicable before either receiving one or timing out. If a broadcast was made one 1 acknowledgement may be all that is necessary for validation or all anticipated targets can be accounted for before deeming a successful ack. An email SMS message or other application send may be assumed reliable and that an ack was received. Thereafter if block determines an applicable ack was received i.e. data successfully sent received or none was anticipated i.e. assume got it then processing continues back to block for processing any next target s . If block determines an anticipated ack was not received then block logs the situation to LBX history and the next specified delivery method is accessed. Thereafter if block determines all delivery methods have already been processed for the current target then processing continues to block for logging the overall status and providing an error to the user. Block may require a user acknowledgement before continuing back to block . If block determines there is another specified delivery method for sending then processing continues back to block for sending using the next method.

Referring back to block if all targets are determined to have been processed then block maintains processing results to LBX history and the caller is returned to at block . In an alternate embodiment to processing a trigger implementation is used for sending broadcasting data at the best possible time e.g. when new modified permissions or charters information is made for a target as soon as possible as soon as a target is detected to be nearby or in the vicinity vicinity is expanded as explained by or as soon as the user is notified to send e.g. in response to a modification and then acknowledges to send. See for explanation of communicating data from a first MS to a second MS over greater distances. In another embodiment background thread s timely poll e.g. per user or system configurations the permissions and or charters data to determine which data should be sent how to send it who to send it to what applicable permissions are appropriate and when the best time is to send it. A time interval or schedule for sending data to others on a continual interim basis may also be configured. This may be particularly useful as a user starts using a MS for the first time and anticipates making many configuration changes. The user may start or terminate polling threads as part of B processing so that is relied on to make sure permissions and or charters are communicated as needed. Appropriate blocks of B will also interface to statistics for reporting successes failures and status of B processing.

In sum provide a LBX peer to peer method for ensuring permissions and charters are appropriately maintained at MSs wherein sends in a peer to peer fashion and receives in a peer to peer to fashion. Thus permissions and charters are sent from a first MS to a second MS for configuring maintaining enforcing and or processing permissions and charters at an MS. There is no intermediary service required for permissions and charters for LBX interoperability. demonstrates a preferred push model. A pull model may be alternatively implemented. An alternative embodiment may make a request to a MS for its permissions and or charters and then populate its local image of the data after receiving the response. Privileges would be appropriately validated at the sending MS s and or receiving MS s in order to ensure appropriate data is sent received to from the requesting MS.

In an alternative embodiment having multiple receiving transmission channels visible to the RxCD process there can be a RxCD worker thread per channel to handle receiving on multiple channels simultaneously. If RxCD thread s do not receive directly from the channel the preferred embodiment of would not need to convey channel information to RxCD thread s waiting on queue anyway. Embodiments could allow specification configuration of many RxCD thread s per channel.

A RxCD thread processing begins at block upon the MS receiving permission data and or charter data continues to block where the process worker thread count RxCD Ct is accessed and incremented by 1 using appropriate semaphore access e.g. RxCD Sem and continues to block for retrieving from queue sent data using interface like interface perhaps a special termination request entry and only continues to block when a record of data permission charter data or termination record is retrieved. In one embodiment receive processing deposits X.409 encoding data as record s to queue and may break up a datastream into individual records of data from an overall received or ongoing datastream. In another embodiment XML is received and deposited to queue or some other suitable syntax is received as derived from the BNF grammar. In another embodiment receive processing receives data in one format and deposits a more suitable format for processing. Receive processing embodiments may deposit piece meal records of data as sent piece meal records broken up from data received full charter or permission datastreams and or subsets thereof to queue for processing by .

Block stays blocked on retrieving from queue until any record is retrieved in which case processing continues to block . If block determines a special entry indicating to terminate was not found in queue processing continues to block . There are various embodiments for RxCD thread s thread s and thread s to feed off a queue for different record types for example separate queues A B and C or a thread target field with different record types found at queue e.g. like field . In another embodiment there are separate queues C and D for separate processing of incoming charter and permission data. In another embodiment thread s are modified with logic of RxCD thread s to handle permission and or charter data records since thread s are listening for queue data anyway. In another embodiment there are segregated RxCD threads RxCD P and RxCD C for separate permission and charter data processing.

Block validates incoming data for this targeted MS before continuing to block . A preferred embodiment of receive processing already validated the data is intended for this MS by having listened specifically for the data or by having already validated it is at the intended MS destination e.g. block can continue directly to block no block and block required . If block determines the data is valid for processing then block accesses the data source identity information e.g. owner information sending MS information grantor grantee information etc as appropriate for an embodiment block accesses acceptable delivery methods and or permissions privileges for the source identity to check if the data is eligible for being received and block checks the result. Depending on an embodiment block may enforce an all or none privilege for accepting the privilege or charter data or may enforce specific privileges from the receiving MS MS user to the sending MS MS user for exactly which privileges or charters are acceptable to be received and locally maintained.

If block determines the delivery is acceptable and perhaps privileged or privileged per source then block appropriately updates the MS locally with the data depending on embodiment of block may remove from existing data at the MS as well as per privilege s block completes an acknowledgment and block sends broadcasts the acknowledgement ack before continuing back to block for more data. Block sends broadcasts the ack using a send interface like interface by inserting to queue so that send processing transmits data for example as far as radius . Embodiments will use the different correlation methods already discussed above to associate an ack with a send.

If block determines the data is not acceptable then processing continues directly back to block . For security reasons it is best not to respond with an error. It is best to ignore the data entirely. In another embodiment an error may be returned to the sender for appropriate error processing and reporting. Referring back to block if it is determined that the data is not valid then processing continues back to block .

Referring back to block if a worker thread termination request was found at queue then block decrements the RxCD worker thread count by 1 using appropriate semaphore access e.g. RxCD Sem and RxCD thread processing terminates at block . Block may also check the RxCD Ct value and signal the RxCD process parent thread that all worker threads are terminated when RxCD Ct equals zero 0 .

Block causes sending broadcasting data containing CK depending on the type of MS wherein CK contains ack information prepared. In the embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place ack information as CK embedded in usual data at the next opportune time of sending usual data . As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends broadcasts new ack data .

In an alternate embodiment permission and or charter data records contain a sent date time stamp field of when the data was sent by a remote MS and a received date time stamp field like field is processed at the MS in processing. This would enable calculating a TDOA measurement while receiving data e.g. permissions and or charter data that can then be used for location determination processing as described above.

For other acceptable receive processing methods are well known to those skilled in the art for hooking customized processing into application processing of sought data received. For example in an email application a callback function API is preferably made available to the present disclosure so that every time an applicable received email distribution is received with specified criteria e.g. certain subject certain attached file name certain source or any other identifiable email attribute s provided by present disclosure processing to API sent by block the callback function provided by present disclosure processing to the appropriate API is invoked for custom processing. In this example the present disclosure invokes the callback API for providing the callback function to be invoked and the email criteria for triggering invocation of the callback function for processing of permissions or charter data. For example a unique subject field indicates to the email application that the email item should be directed by the email application to the callback function for processing. The present disclosure callback function then parses permissions and or charter information from the email item and updates local permissions and or charters . Data received in the email item may be textual syntax derived from the BNF grammar in an email body or attached file form XML syntax derived from the BNF grammar in email body or attached file form an X.409 binary encoding in attached file form or other appropriate format received with the email item e.g. new Document Interchange Architecture DIA attribute data etc . A process return status is preferably returned by the callback function for example for appropriate email confirmation of delivery processing.

In another embodiment the present disclosure provides at least one thread of processing for polling a known API or email repository for sought criteria e.g. attributes which identifies the email item as destined for present disclosure processing. Once the email item s are found they are similarly parsed and processed for updating permissions and or charters .

Thus there are well known methods for processing data in context of this disclosure for receiving permissions and or charters from an originating MS to a receiving MS for example when using email. Similarly callback function or polling SMS messages can be used to communicate data and or from one MS to another MS albeit at smaller data exchange sizes. The sending MS may break up larger portions of data which can be sent as parse able text e.g. source syntax XML etc. derived from the BNF grammar to the receiving MS. It may take multiple SMS messages to communicate the data in its entirety.

Regardless of the type of receiving application those skilled in the art recognize many clever methods for receiving data in context of a MS application which communicates in a peer to peer fashion with another MS e.g. callback function s API interfaces in an appropriate loop which can remain blocked until sought data is received for processing polling known storage destinations of data received or other applicable processing .

Permission data and charter data may be manually copied from one MS to another over any appropriate communications connection between the MSs. Permission data and charter data may also be manually copied from one MS to another MS using available file management system operations move or copy file data processing . For example a special directory can be defined which upon deposit of a file to it processing parses it validates it and uses it to update permissions and or charters . Errors found may also be reported to the user but preferably there are automated processes that create maintain the file data to prevent errors in processing. Any of a variety of communications wave forms can be used depending on MS capability.

In an alternate embodiment where the MS maintains GDRs GADRs CDRs ADRS PARMDRs and GRPDRs and their associated data records DDRs HDRs and TDRs at the MS where they were configured may not provide blocks through . The MS may be aware of its user charters and need not share the data i.e. self contained . In some embodiments options through cause access to locally maintained data for others other users MSs etc or cause remote access to data when needed e.g. from the remote MSs . In the embodiment where no data is maintained locally for others blocks through may not be necessary. In sum the preferred embodiment is to locally maintain charters data for the MS user and others e.g. MS users which are relevant to provide the richest set of charters governing MS processing at the MS.

Block accesses all CDRs e.g. all rows from a CDR SQL table for the user of e.g. user information matches field and for the groups the user is a member of e.g. group information matches field e.g. owner type group owner id a group ID field from block . The CDRs are additionally joined e.g. SQL join with GDRs DDRs and TDRs e.g. fields and Charter and by matching ID fields and with field . Description field can provide a useful description last saved by the user for the charter entry. Block may also retrieve system predefined data records for use and or management. Thereafter each joined entry returned at block is associated at block with the corresponding data IDs at least fields and for easy unique record accesses when the user acts on the data. Block also initializes a list cursor to point to the first list entry to be presented to the user. Thereafter block sets user interface indication for where the list cursor is currently set e.g. set to highlight the entry and any list scrolling settings are set the list is initially not set for being scrolled on first processing encounter to block from block . Block continues to block where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter block waits for user action to the presented list of charters data and will continue to block when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format such that an entry contains fields for DDR description GDR owner information grantor information and grantee information GRPDR owner information and group name if applicable CDR information and TDR time spec information. Alternate embodiments will present less information or more information e.g. join to ADR and or PARMDR information .

If block determines the user selected to set the list cursor to a different entry then block sets the list cursor accordingly and processing continues back to block . Block always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block determines the user did not select to set the list cursor then processing continues to block . If block determines the user selected to add a charter then block accesses a maximum number of charters allowed perhaps multiple maximum values accessed and block checks the maximum s with the number of current charters defined. There are many embodiments for what deems a maximum for this user for a group for this MS etc . If block determines a maximum number of charters allowed already exists then block provides an error to the user and processing continues back to block . Block preferably requires the user to acknowledge the error before continuing back to block . If block determines a maximum was not exceeded then block interfaces with the user for entering validated charter data and block adds the data record s appropriately updates the list with the new entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . If block determines the user did not want to add a charter processing continues to block . Block will add a CDR GDR DDR HDR to set creator information and TDR. The DDR and TDR are optionally added by the user but the DDR may be strongly suggested if not enforced on the add . This will provide a charter record. Additionally block may add new ADR s and or PARMDR s which are validated to exist prior to adding data at block . In one embodiment a GDR associated to the CDR is not added for indicating the user wants his charter made available to all other user MSs which are willing to accept it.

If block determines the user selected to delete a charter then block deletes the data record currently pointed to by the list cursor modifies the list for the discarded entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . Block will use the Charter ID field associated with the entry at block to delete the charter. Associated CDR ADR s PARMDR s DDR HDR and TDR is also deleted e.g. preferably with a cascade delete in a SQL embodiment . If block determines the user did not select to delete a charter then processing continues to block of by way of off page connector .

With reference now to if block determines the user selected to modify a charter then block interfaces with the user to modify charter data of the entry pointed to by the list cursor. The user may change information of the GDR CDR ADR and or PARMDR and any associated records e.g. DDR and TDR . The user may also add applicable records at block . Block waits for a user action indicating completion. Block will continue to block when the complete action is detected. If block determines the user exited then processing continues back to block by way of off page connector . If block determines the user selected to save changes made at block then block updates the data and the list is appropriately updated before continuing back to block . Block may update the GDR CDR ADR PARMDR and or any associated records e.g. DDR and or TDR using the charter id field associated to the entry at block . Block will update an associated HDR as well. Block may add new CDR ADR s PARMDR s a DDR and or TDR as part of the charter change. If block determines the user did not select to modify a charter then processing continues to block .

If block determines the user selected to get more details of the charter e.g. show all joinable data to the GDR or CDR that is not already presented with the entry then block gets additional details may involve database queries in an SQL embodiment for the charter pointed to by the list cursor and block appropriately presents the information to the user. Block then waits for a user action that the user is complete reviewing details in which case processing continues back to block . If block determines the user did not select to get more detail then processing continues to block .

If block determines the user selected to internalize charters data thus far being maintained then block internalizes e.g. as a compiler would all applicable data records for well performing use by the MS and block saves the internalized form for example to MS high speed non persistent memory. In one embodiment blocks and internalize charter data to applicable C structures of also see . In various embodiments block maintains statistics for exactly what was internalized and updates any running totals or averages maintained for a plurality of internalizations up to this point or over certain time periods. Statistics such as number of active constructs number of user construct edits of particular types amount of associated storage used freed changed etc with perhaps a graphical user interface to graph changes over time number of charter expressions actions term types etc specified number of charters affected and unaffected by permissions and other charter dependent statistics. In other embodiments statistical data is initialized at internalization time to prepare for subsequent gathering of useful statistics during charter processing. In embodiments where a tense qualifier is specified for TimeSpec information saving the internalized form at block causes all past and current tense configurations to become effective for being processed.

Block then continues back to block . If block determines the user did not select to internalize charter configurations then processing continues to block . Alternate embodiments of processing charters in the present disclosure will rely upon the data records entirely rather than requiring the user to redundantly internalize from persistent storage to non persistent storage for use. Persistent storage may be of reasonably fast performance to not require an internalized version of charters . Different embodiments may completely overwrite the internalized form or update the current internalized form with any changes.

If block determines the user selected to exit block processing then block cleans up processing thus far accomplished e.g. issue a stop using database command and block completes block processing. If block determines the user did not select to exit then processing continues to block where all other user actions detected at block are appropriately handled and processing continues back to block by way off off page connector .

Block accesses all ADRs e.g. all rows from a ADR SQL table for the user of matching the owner information of the ADRs e.g. user information matches field to the user and to groups the user is a member of e.g. group information matches field e.g. owner type group owner id group ID field from block . The ADRs are additionally joined e.g. SQL join with DDRs and TDRs e.g. fields and Action and by matching ID fields and with field . Description field can provide a useful description last saved by the user for the action data. Block may also retrieve system predefined data records for use and or management. Thereafter each joined entry returned at block is associated at block with the corresponding data IDs at least fields and for easy unique record accesses when the user acts on the data. Block also initializes a list cursor to point to the first action item to be presented to the user in the list. Thereafter block sets user interface indication for where the list cursor is currently set e.g. set to highlight the entry and any list scrolling settings are set the list is initially not set for being scrolled on first processing encounter to block from block . Block continues to block where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter block waits for user action to the presented list of action data and will continue to block when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format reference able by the list cursor. An action entry presented preferably contains ADR fields including owner information GRPDR owner information and group name if applicable TDR time spec information and DDR information. Alternate embodiments will present less information or more information e.g. join ADR s to PARMDR s via field s .

If block determines the user selected to set the list cursor to a different action entry then block sets the list cursor accordingly and processing continues back to block . Block always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block determines the user did not select to set the list cursor then processing continues to block . If block determines the user selected to add an action then block accesses a maximum number of actions allowed perhaps multiple maximum values accessed and block checks the maximum s with the number of current actions defined. There are many embodiments for what deems a maximum for this user for a group for this MS etc . If block determines a maximum number of actions allowed already exists then block provides an error to the user and processing continues back to block . Block preferably requires the user to acknowledge the error before continuing back to block . If block determines a maximum was not exceeded then block interfaces with the user for entering validated action data and block adds the data record appropriately updates the list with the new entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . If block determines the user did not want to add an action processing continues to block . Block will add an ADR HDR to set creator information and TDR . The DDR and TDR are optionally added by the user. Additionally at block the user may add new PARMDR s for the action.

If block determines the user selected to modify an action then block interfaces with the user to modify action data of the entry pointed to by the list cursor. The user may change information of the ADR and any associated records e.g. DDR TDR . The user may also add the associated records at block . Block waits for a user action indicating completion. Block will continue to block when the action is detected at block . If block determines the user exited then processing continues back to block . If block determines the user selected to save changes made at block then block updates the data and the list is appropriately updated before continuing back to block . Block may update the ADR and or any associated records e.g. DDR and or TDR using the action id field associated to the action item at block . Block will update an associated HDR as well. Block may add a new a DDR and or TDR as part of the action change. If block determines the user did not select to modify an action then processing continues to block by way of off page connector .

With reference now to if block determines the user selected to get more details of the action e.g. show all joinable data to the ADR that is not already presented with the entry then block gets additional details may involve database queries in an SQL embodiment for the action pointed to by the list cursor and block appropriately presents the information to the user. Block then waits for a user action that the user is complete reviewing details in which case processing continues back to block by way of off page connector . If block determines the user did not select to get more detail then processing continues to block .

If block determines the user selected to delete an action then block determines any data records e.g. CDR s that reference the action data record to be deleted. Preferably no referencing data records e.g. CDRs are joinable e.g. field to the action data record being deleted otherwise the user may improperly delete an action from a configured charter. The user should remove ascending references to an action for deletion first. Block continues to block . If block determines there was at least one CDR reference block provides an appropriate error with the reference s found so the user can subsequently reconcile. Block preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block then processing continues to block for deleting the data record currently pointed to by the list cursor. Block also modifies the list for the discarded entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . Block will use the action ID field associated with the entry at block to delete an action. Associated records e.g. DDR HDR and TDR are also deleted e.g. preferably with a cascade delete in a SQL embodiment . If block determines the user did not select to delete an action then processing continues to block .

If block determines the user selected to exit block processing then block cleans up processing thus far accomplished e.g. issue a stop using database command and block completes block processing. If block determines the user did not select to exit then processing continues to block where all other user actions detected at block are appropriately handled and processing continues back to block by way off off page connector .

Block accesses all PARMDRs e.g. all rows from a PARMDR SQL table for the user of matching the owner information of the PARMDRs e.g. user information matches field to the user and to groups the user is a member of e.g. group information matches field e.g. owner type group owner id group ID field from block . The PARMDRs are additionally joined e.g. SQL join with DDRs e.g. field Parameter and by matching ID field with field . Description field can provide a useful description last saved by the user for the parameter data. Block may also retrieve system predefined data records for use and or management. Thereafter each joined entry returned at block is associated at block with the corresponding data IDs at least fields and for easy unique record accesses when the user acts on the data. Block also initializes a list cursor to point to the first parameter entry to be presented to the user in the list. Thereafter block sets user interface indication for where the list cursor is currently set e.g. set to highlight the entry and any list scrolling settings are set the list is initially not set for being scrolled on first processing encounter to block from block . Block continues to block where the entry list is presented to the user in accordance with the list cursor and list scroll settings managed for presentation at block . Thereafter block waits for user action to the presented list of parameter data and will continue to block when a user action has been detected. Presentation of the scrollable list preferably presents in an entry format reference able by the list cursor. A parameter entry presented preferably contains fields for PARMDR field GRPDR owner information owning GRPDR owner information and group name if applicable and DDR information. Alternate embodiments will present less information or more information e.g. commands and operands parameters may be used with parameter descriptions etc .

If block determines the user selected to set the list cursor to a different parameter entry then block sets the list cursor accordingly and processing continues back to block . Block always sets for indicating where the list cursor is currently pointed and sets for appropriately scrolling the list if necessary when subsequently presenting the list at block . If block determines the user did not select to set the list cursor then processing continues to block . If block determines the user selected to add a parameter then block accesses a maximum number of parameter entries allowed perhaps multiple maximum values accessed and block checks the maximum s with the number of current parameter entries defined. There are many embodiments for what deems a maximum for this user for a group for this MS etc . If block determines a maximum number of parameter entries allowed already exists then block provides an error to the user and processing continues back to block . Block preferably requires the user to acknowledge the error before continuing back to block . If block determines a maximum was not exceeded then block interfaces with the user for entering validated parameter data and block adds the data record appropriately updates the list with the new entry and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . If block determines the user did not want to add a parameter entry processing continues to block . Block will add a PARMDR DDR and HDR to set creator information . The DDR is optionally added by the user.

If block determines the user selected to modify a parameter entry then block interfaces with the user to modify parameter data of the entry pointed to by the list cursor. The user may change information of the PARMDR and any associated records e.g. DDR . The user may also add the associated records at block . Block waits for a user action indicating completion. Block will continue to block when the complete action is detected at block . If block determines the user exited then processing continues back to block . If block determines the user selected to save changes made at block then block updates the data and the list is appropriately updated before continuing back to block . Block may update the PARMDR and or any associated DDR using the parameter id field associated to the parameter entry at block . Block will update an associated HDR as well. Block may add a new DDR as part of the parameter entry change. If block determines the user did not select to modify a parameter then processing continues to block by way of off page connector .

With reference now to if block determines the user selected to get more details of the parameter entry then block gets additional details may involve database queries in an SQL embodiment for the parameter entry pointed to by the list cursor and block appropriately presents the information to the user. Block then waits for a user action that the user is complete reviewing details in which case processing continues back to block by way of off page connector . If block determines the user did not select to get more detail then processing continues to block .

If block determines the user selected to delete a parameter entry then block determines any data records e.g. ADR s that reference the parameter data record to be deleted. Preferably no referencing data records e.g. ADRs are joinable e.g. field to the parameter data record being deleted otherwise the user may improperly delete a parameter from a configured action. The user should remove references to a parameter entry for deletion first. Block continues to block . If block determines there was at least one reference block provides an appropriate error with the reference s found so the user can subsequently reconcile. Block preferably requires the user to acknowledge the error before continuing back to block . If no references were found as determined by block then processing continues to block for deleting the data record currently pointed to by the list cursor along with any other related records that can be deleted. Block also modifies the list for the discarded entry s and sets the list cursor appropriately for the next list presentation refresh before continuing back to block . Block will use the parameter ID field associated with the entry at block to delete the parameter entry. Associated records e.g. DDR and HDR are also deleted e.g. preferably with a cascade delete in a SQL embodiment . If block determines the user did not select to delete a parameter entry then processing continues to block .

If block determines the user selected to exit block processing then block cleans up processing thus far accomplished e.g. issue a stop using database command and block completes block processing. If block determines the user did not select to exit then processing continues to block where all other user actions detected at block are appropriately handled and processing continues back to block by way off off page connector .

Table depicts considerations for privilege data i.e. permission data resident at the MS of a second identity ID grammar ID IDType depending on privileges granted in the following scenarios 

Various embodiments will implement any reasonable subset of the considerations of for example to minimize or eliminate communicating a user s permissions and or charters to another MS or to prevent storing the same permissions and or charters data at more than one MS. are intended to highlight feasible embodiments wherein terminology incoming is used generally for referring to WDRs in process which are a being maintained e.g. incoming as being maintained to queue and b incoming to a particular MS e.g. incoming as being communicated to the MS .

In one subset embodiment privileges and charters are only maintained at the MS where they are configured for driving LBX features and functionality. In another embodiment privileges are maintained at the MS where they were configured as well as any MSs which are relevant for those configurations yet charters are only maintained at the MS where they are configured. In yet another embodiment privileges and charters are maintained at the MS where they were configured as well as any MSs which are relevant for those configurations. In another embodiment a MS may not have all privileges assigned to itself said to be assigned to the user of the MS by default. Privileges may require being enabled as needed for any users to have the benefits of the associated LBX features and functionality. Thus the considerations highlighted by are to cover many bases with any subset embodiment within the scope of the present disclosure.

Preferably statistics are maintained by WITS for counting occurrences of each variety of the processing scenarios. WITS processing should also keep statistics for the count by privilege and by charter of each applicable WITS processing event which was affected. Other embodiments will maintain more detailed statistics by MS ID Group ID or other labels for categories of statistics. Still other embodiments will categorize and maintain statistics by locations time applications in use at time of processing scenarios etc. Applicable statistical data can be initialized at internalization time to prepare for proper gathering of useful statistics during WITS processing.

With reference now to in the vicinity language is described in more detail for the MS e.g. DLM as determined by clarified maximum range of transmission . In some embodiments maximum wireless communications range e.g. is used to determine what is in the vicinity of the DLM . In other embodiments a data processing system may be communicated to as an intermediary point between the DLM and another data processing system e.g. MS or service for increasing the distance of in the vicinity between the data processing systems to carry out LBX peer to peer data communications. Data processing system may further be connected to another data processing system by way of a connection which is in turn connected to a data processing system by wireless connectivity as disclosed. Data processing systems and may be a MS service router switch bridge or any other intermediary data processing system between peer to peer interoperating data processing systems and capable of communicating data with another data processing system. Connection may be of any type of communications connection for example any of those connectivity methods options and or systems discussed for . Connection may involve other data processing systems not shown for enabling peer to peer communications between DLM and data processing system . clarifies that in the vicinity is conceivably any distance from the DLM as accomplished with communications well known to those skilled in the art demonstrated in . In some embodiments data processing system may be connected at some time with a physically connected method to data processing system or DLM may be connected at some time with a physically connected method to data processing system or DLM and data processing system may be connected to the same intermediary data processing system. Regardless of the many embodiments for DML to communicate in a LBX peer to peer manner with data processing system DLM and data processing system preferably interoperate in context of the LBX peer to peer architecture. In some embodiments data processing systems between DLM and the data processing intercept data for tracking book keeping statistics and for maintaining data potentially accessed by service informant code however the LBX peer to peer model is preferably not interfered with.

Data processing system may be a DLM ILM or service being communicated with by DML as disclosed in the present disclosure for or for . LBX architecture is founded on peer to peer interaction between MSs without requiring a service to middleman data however data processing systems and those applicable to connection can facilitate the peer to peer interactions. In some embodiments data processing systems between DLM and the data processing intercept data for tracking book keeping statistics and for maintaining data potentially accessed by service informant code however the LBX peer to peer model is preferably not interfered with. Data processing system generically represents a DLM ILM or service s for analogous processing for sending broadcasting data such as a data packet like . When a Communications Key CK like is embedded within data data is considered usual communications data e.g. protocol voice or any other data over conventional forward channel reverse channel voice data channel data transmission channel or any other appropriate channel which has been altered to contain CK . Data contains a CK which can be detected parsed and processed when received by an MS or other data processing system in the vicinity conceivably any distance depending on embodiment of data processing system as determined by the maximum range of transmission like . CK permits piggy backing on current transmissions to accomplish new functionality as disclosed herein. Transmissions radiate out in all directions in a manner consistent with the wave spectrum used and data carried thereon may or may not be encrypted e.g. encrypted WDR information . The radius like represents a first range of signal reception from data processing system e.g. antenna thereof perhaps by a MS. The radius like represents a second range of signal reception from data processing system e.g. antenna thereof perhaps by a MS. The radius like represents a third range of signal reception from data processing system e.g. antenna thereof perhaps by a MS. The radius like represents a last and maximum range of signal reception from data processing system e.g. antenna thereof perhaps by a MS not shown . The time of transmission from data processing system to radius is less than times of transmission from service to radiuses or . The time of transmission from data processing system to radius is less than times of transmission to radiuses or . The time of transmission from data processing system to radius is less than time of transmission to radius . In another embodiment data contains a Communications Key CK because data is new transmitted data in accordance with the present disclosure. Data purpose is for carrying CK information for being detected parsed and processed when received by another MS or data processing system in the vicinity conceivably any distance depending on embodiment of data processing system as determined by the maximum range of transmission.

With reference now to in the vicinity language is described in more detail for the MS e.g. ILM as determined by clarified maximum range of transmission . In some embodiments maximum wireless communications range e.g. is used to determine what is in the vicinity of the ILM . In other embodiments a data processing system may be communicated to as an intermediary point between the ILM and another data processing system e.g. MS or service for increasing the distance of in the vicinity between the data processing systems to carry out LBX peer to peer data communications. Data processing system may further be connected to another data processing system by way of a connection which is in turn connected to a data processing system by wireless connectivity as disclosed. Data processing systems and may be a MS service router switch bridge or any other intermediary data processing system between peer to peer interoperating data processing systems and capable of communicating data with another data processing system. Connection may be of any type of communications connection for example any of those connectivity methods options and or systems discussed for . Connection may involve other data processing systems not shown for enabling peer to peer communications between ILM and data processing system . clarifies that in the vicinity is conceivably any distance from the ILM as accomplished with communications well known to those skilled in the art demonstrated in . In some embodiments data processing system may be connected at some time with a physically connected method to data processing system or ILM may be connected at some time with a physically connected method to data processing system or ILM and data processing system may be connected to the same intermediary data processing system. Regardless of the many embodiments for ILM to communicate in a LBX peer to peer manner with data processing system ILM and data processing system preferably interoperate in context of the LBX peer to peer architecture. In some embodiments data processing systems between ILM and the data processing intercept data for tracking book keeping statistics and for maintaining data potentially accessed by service informant code however the LBX peer to peer model is preferably not interfered with.

With reference now to in the vicinity language is described in more detail for service s as determined by clarified maximum range of transmission . In some embodiments maximum wireless communications range e.g. is used to determine what is in the vicinity of the service s . In other embodiments a data processing system may be communicated to as an intermediary point between the service s and another data processing system e.g. MS for increasing the distance of in the vicinity between the data processing systems to carry out LBX peer to peer data communications. Data processing system may further be connected to another data processing system by way of a connection which is in turn connected to a data processing system by wireless connectivity as disclosed. Data processing systems and may be a MS service router switch bridge or any other intermediary data processing system between peer to peer interoperating data processing system service s and capable of communicating data with another data processing system. Connection may be of any type of communications connection for example any of those connectivity methods options and or systems discussed for . Connection may involve other data processing systems not shown for enabling peer to peer communications between service s and data processing system . clarifies that in the vicinity is conceivably any distance from the service s as accomplished with communications well known to those skilled in the art demonstrated in . In some embodiments data processing system may be connected at some time with a physically connected method to data processing system or service s may be connected at some time with a physically connected method to data processing system or service s and data processing system may be connected to the same intermediary data processing system. Regardless of the many embodiments for service s to communicate in a LBX peer to peer manner with data processing system service s and data processing system preferably interoperate in context of the LBX peer to peer architecture. In some embodiments data processing systems between service s and the data processing intercept data for tracking book keeping statistics and for maintaining data potentially accessed by service informant code however the LBX peer to peer model is preferably not interfered with.

In an LN expanse it is important to know whether or not WDR information is of value for locating the receiving MS for example to grow an LN expanse with newly located MSs. demonstrate that WDR information sources may be great distances over a variety of communications paths from a particular MS receiving the WDR information. Carrying intermediary system indication is well known in the art for example to know the number of hops of a communications path. The preferred embodiment uses communications reference field to maintain whether or not the WDR encountered any intermediate systems for example as identified with hops network address change s channel extender transmission indications or any pertinent data to indicate whether the WDR encountered anything other than a wireless transmission e.g. directly between the sending MS and receiving MS . This provides with a means to qualify the peek at block for only those WDRs which show field to be over a single wireless connection from the source to the MS i.e. block to read as Peek all WDRS from queue for confidence confidence floor and most recent in trailing f WTV period of time and field indicating a wireless connected source over no intermediary systems . Field would be set intelligently for all WDRs received and processed by the MS e.g. inserted to queue . In another embodiment fields and are used to indicate that the WDR can be relied upon for triangulating a new location of the MS e.g. block altered to get the next WDR from the REMOTE MS list which did not arrive except through a single wireless path . In other embodiments the correlation e.g. field can be used to know whether it involved more than a single wireless communications path. The requirement is to be able to distinguish between WDRs that can contribute to locating a MS and WDRs which should not be used to locate the MS. In any case WDRs are always useful for peer to peer interactions as governed by privileges and charters see WITS filtering discussed below .

In other embodiments the WDR fields and information is altered to additionally contain the directly connected system whereabouts e.g. intermediary system whereabouts so that the MS e.g. can use that WDR information relevant for locating itself e.g. triangulating the MS whereabouts . This ensures that a MS receives all relevant WDRs from peers and also uses the appropriate WDR information for determining its own location. would distinguish between the data that describes the remote MS whereabouts from the data useful for locating the receiving MS. A preferred embodiment always sets an indicator to at least field or for indicating that the WDR was in transit through one or more intermediary system s . This provides the receiving MS with the ability to know whether or not the WDR was received directly from a wireless in range MS versus a MS which can be communicated with so that the receiving MS can judiciously process the WDR information see WITS filtering discussed below .

An alternate embodiment supports WDR information source systems which are not in wireless range for contributing to location determination of a MS. For example a system can transmit WDR information outbound in anticipation of when it will be received by a MS given knowledge of the communication architecture. Outbound date time information is strategically set along with other WDR information to facilitate making a useful measurement at a receiving MS e.g. TDOA . The only requirement is the WDR conform to a MS interface and be true to how fields are set for LBX interpretation and appropriate processing for example to emulate a MS transmitting useful WDR information.

WITS filtering provides a method for filtering out or in WDRs which may be of use for locating the receiving MS or are of use for permission and or charter processing. Supporting ranges beyond a range within wireless range to a MS can cause a massive number of WDRs to be visible at a MS. Thus only those WDRs which are of value or are candidate for triggering permissions or charter processing are to be processed. WITS filtering can use the source information e.g. MS ID or any other WDR fields or any combination of WDR fields to make a determination if the WDR deserves further processing. The longer range embodiment of preferably incorporates a send transmission for directing the WDRs to MSs which have candidate privileges and or charters in place rather than a broadcast for communicating WDRs. Broadcasting can flood a network and may inundate MSs with information for WITS filtering however the multithreaded LBX architecture may process efficiently even for broadcast data.

In another embodiment a configuration can be made user or system wherein are applicable and non wireless range originated WDRs are always ignored. For example a WDR Range Configuration WRC indicates how to perform WITS filter processing 

It is important to understand that WDRs in process e.g. to queue  ref outbound  O ref and inbound  I ref cause the recognized trigger of WDR processing to scan charters for testing expressions and then performing actions for those expressions which evaluate to true. Expressions are evaluated within the context of applicable privileges. Actions are performed within the context of privileges. Thus WDRs in process are the triggering objects for consulting charters at run time. Depending on the MS hardware and how many privileged MSs are in the vicinity there may be many e.g. dozens of WDRs in process every second at a MS. Each WDR in process at a MS is preferably in its own thread of processing preferred architecture so that every WDR in process has an opportunity to scan charters for conditional actions.

Parenthesis are used to affect how to evaluate the expression as is customary for an arithmetic expression and can be used to determine which construct the optional specifications are for. Of course a suitable precedence of operators is implemented. So if the Expression evaluates to true the actions shall be processed. There can be one or more actions processed. The first action performs an Invoke command with an Application operand and provides the parameter of myscript.cmd S which happens to be an executable script invocable on the particular MS. A parameter of S is passed to the script. The script can perform anything supported in the processable script at the particular MS. The second action performs a Notify command with an Autodial operand and provides the parameter of 214 405 6733 . Notify Autodial will automatically perform a call to the phone number 214 405 6733 from the MS. So if the MS of this configuration is currently at a location where Jason or Michael in the vicinity had been at some time before as maintained in LBX History if necessary or in last 2 weeks in refined example then the two actions are processed. LBX History will be searched for previous WDR information saved for Michael and Jason to see if the expression evaluates to true when queue does not contain a matching WDR for Michael or Jason.

It is interesting to note that the condition locByID Michael loc my locByID Jason loc my accomplishes the same expression shown in described above. locRef  is an atomic term for the WDR location field with the suffix Ref referring to the value for test. loc R e f is an acceptable format when there are significant blanks in the suffix for testing against the value of the WDR field. It is also interesting to note that the expression loc my locByID Michael is quite different. The expression loc my locByID Michael tests if my current location was at Michael s location in history again checking LBX history. However the WDR in process only provided the trigger to check permissions and charters. There is no field of the in process WDR accessed here.

The  I fldname syntax is a WDRTerm for inbound WDRs which makes sense for our expression above. A careless programmer user could in fact create expressions that may never occur. For example if the user specified  O instead of  I  then outbound rather than inbound WDRs would be tested.  O msid Brian  O location loc my causes outbound WDRs to be tested e.g. deposited to send queue for MS ID Brian which are at my current location i.e. current location of the MS with the configuration being discussed . Mixing    I  and  O prefixes has certain semantic implications and must be well thought out by the user prior to making such a configuration. The charter expression is considered upon an event involving each single WDR and is preferably not used to compare to a plurality of potentially ambiguous unrelated WDRs at the same time. A single WDR can be both in process locally e.g. inserted to queue and inbound to the MS when received from MSs in the vicinity. It will not be known that the WDR meets both criteria until after it has been inbound and is then being inserted to queue . Likewise a single WDR can be both in process locally e.g. inserted to queue and outbound from the MS. It will not be known that the WDR meets both criteria until after it has been retrieved from queue and then ready for being sent outbound. The programmer user can create bad configurations when mixing these syntaxes. It is therefore recommended but not required that users not mix WDR trigger syntax. Knowing a WDR is inbound and then in process to queue is straightforward e.g. origination other than this MS . Knowing a WDR was on queue and is outbound is also straightforward e.g. origination at outbound this MS . However a preferred embodiment prevents mixing these syntaxes for triggered processing.

In looking at actions for this example the command operand pair is for Notify Indicator with two parameters M sender thisms . M sender is what to use for the indicator the source address matched . Thus an AppTerm can be used as a parameter. thisms is an atomic term for this MS ID. If the expression evaluates to true the MS hosting the charter configuration will be notified with an indicator text string e.g. billj iswtechnologies.com . Notify Indicator displays the indicator in the currently focused title bar text of a windows oriented interface. In another embodiment Notify indicator command processing displays notification data in the focused user interface object at the time of being notified. The action has optional specifications for Description and History information to be generated when internalized .

In general History information will be updated as the user changes the associated configuration in the future either in syntax recognized on internalization e.g. to data structures with etc.

The action demonstrates an interesting format for representing the optional Host construct qualifier of the BNF grammar for where the action should take place assuming privilege to execute there is configured . ms group G . tells the internalizer to search for a group definition like an array and find the first member of the group meeting the subscript definition. This would be George the G . Any substring of George or the entire string could have been used to indicate use George from the ms group . This allows a shorthand reference to the item s of the group. Multiple members that match G would all apply for the action. Also note that the double quotes are used whenever variables contain significant blanks. ms group G .Store DBobject tells the internalizer that the Command Operand pair is to be executed at the George MS for storing to a database object per parameters. An equivalent form is George.Store DB object with the Host specification explicitly specified as George. The parameters of JOESDB.LBXTABS.TEST INSERT INTO TABLESAV thisMS timestamp 9 thisMS indicates to insert a row into the table TABLESAV of the TEST database at the system this MS the MS hosting the configuration . The second query parameter matches the number of columns in the table for performing a database row insert. Like other compilers interpreters the evaluates to a single double quote character when double quotes are needed inside strings. A single quote can also be legal to delimit query string parameters as shown . This example shows using atomic term s for a parameter i.e. elaborates to underlying value WDRTerm s can also be used for parameters . This example introduces a concatenation operator for concatenating together multiple values into a result string for one parameter e.g. INSERT INTO TABLESAV Bill 20080421024421.45 9 . Other embodiments will support other programmatic operators in expressions for parameters. Still other embodiments will support any reasonable programmatic statements operators and syntax among charter configuration to facilitate a rich method for defining charters .

Note that while we are configuring for the MS George to execute the action we are still performing the insert to the MS hosting the Charter configuration i.e. target system is thisms . We could just as easily have configured 

In sum there are many embodiments derived from the BNF grammar of . are simple examples with some interesting syntactical feature considerations. Some embodiments will support programmatic statements intermingled with the BNF grammar syntax derivative used to support looping arithmetic expressions and other useful programmatic functionality integrated into Privilege and Charter definitions. illustrate a WPL for programming how a MS is to behave. WPL is a unique programming language wherein peer to peer interaction events containing whereabouts information WDRs provide the triggers for novel location based processing. Permissions and charters provide rules which govern the interoperable LBX processing between MSs. While WPL is more suited for a programmer type of user the intent of this disclosure is to simplify configurations for all types of users. WPL may suit an advanced user while may suit more prevalent and novice users. Other embodiments may further simplify configurations. Some WPL embodiments will implement more atomic operators AppTerm s WDRTerm s and other configurable terms without departing from the spirit and scope of this disclosure. It is the intent that less time be spent on documentation and more time be spent implementing it. Permissions and charters are preferably centralized to the MS and maintained with their own user interface outside of any particular MS application for supervisory control of all MS LBX applications. See for how PIP data is maintained outside of other MS processing data and resources for centralized governing of MS operations.

In alternate embodiments an action can return a return code value for example to convey success failure or some other value s back to the point of performing the action. A syntactical embodiment 

In one preferred embodiment PRRs are supplied with a MS prior to user first MS use and no administrator or user has to maintain them. In another embodiment only a special administrator can maintain PRRs which may or may not have been configured in advance. In another embodiment a MS user can maintain PRRs which may or may not have been configured in advance.

The syntax  location 300M loc my is a condition for the WDR in process being within 300 Meters of the vicinity of my current location. Other syntax is identifiable based on previous discussions.

If block determines the associated PRR was not found or all data items of the found PRR for modification are not described by field then processing continues directly to block for releasing the semaphore lock thereby performing no updates to an AppTerm. PRRs control eligibility for modification by applications as well as which AppTerm references can be made in charter processing.

Data handling of a source code for compiling interpreting an encoding from a communication connection or an encoding from some processing source starts at block . At some point in BNF grammar derived data handling a block gets the next or first token from the source encoding. Tokens may be reserved keywords delimiters variable names expression syntax or some construct or atomic element of an encoding. Thereafter if block determines the token is a reserved key or keyword block checks if the reserved key or keyword is for identifying permissions e.g. Permissions permission Permissions Permission etc in which case block sets a stringVar pointer to the entire datastream representative of the permission s to be processed and block prepares parameters for invoking LBX data internalization processing at block .

If block determines the reserved key or keyword is not for permission s then processing continues to block . Block checks if the reserved key or keyword is for identifying charters e.g. Charters charter Charters Charter etc in which case block sets a stringVar pointer to the entire datastream representative of the charter s to be processed and block prepares parameters for invoking LBX data internalization processing at block .

Blocks and preferably have a stringVar set to the permission charter data encoding start position and then set a length of the permission charter data for processing by block . Alternatively the stringVar is a null terminated string for processing the permission s charter s data encoding. Embodiment requirements are for providing appropriate parameters for invoking block for unambiguous processing of the entire permission s charter s for parsing and processing. The procedure of block has already been described throughout this disclosure e.g. creating a processable internalized form e.g. database records programmatic structure etc . Upon return from block processing block resets the parsing position of the data source encoding provided at block for having already processed the permission s charter s encoding handled by block . Thereafter processing continues back to block for getting the next token from the data encoding source.

If block determines the reserved key or keyword is not for charter s then processing continues to process the applicable reserved key or keyword identified in the source data encoding. If block determines the token is not a reserved key or keyword then processing continues to the appropriate block for handling the token which is not a reserved key or keyword. In any case there may be processing of other source data encoding not specifically for a permission or charter.

Eventually processing continues to a block for checking if there is more data source to handle process. If block determines there is more data encoding source processing continues back to block for getting the next token. If block determines there is no more data encoding source processing continues to block for data encoding source processing completion and then to block for termination of processing.

Blocks through may represent plug in processing for permissions and or charters . Depending on when and where processing occurs for appropriate semaphores may be used to ensure data integrity.

As WDR information is transmitted received between MSs privileges and charters are used to govern automated actions. Thus privileges and charter govern processing of at least future whereabouts information to be processed. There is WDR In process Triggering Smarts WITS in appropriate executable code processing paths. WITS provides the intelligence of whether or not privilege s and or charter s trigger s an action. WITS is the processing at a place where a WDR is automatically examined against configured privileges and charter to see what actions should automatically take place. There are three different types of WITS namely maintained WITS mWITS inbound WITS iWITS and outbound WITS oWITS . Each type of WITS is placed in a strategic processing path so as to recognize the event for when to process the WDR. Maintained WITS mWITS occur at those processing paths applicable to a WDR in process for being maintained at an MS e.g. inserted to queue . Other embodiments may define other maintained varieties of a WDR in process for configurations e.g. inbound outbound in process2Q22 in process2History i.e. WDR in process of being maintained to LBX history in process2application s i.e. WDR in process of being maintained communicated to an application etc . Inbound WITS iWITS occur at those processing paths applicable to a WDR which is inbound to a MS e.g. communicated to the MS . Outbound WITS oWITS occur at those processing paths applicable to a WDR which is outbound from a MS e.g. sent by an MS . There are various WITS embodiments as described below. Users should keep in mind that a single WDR may be processed multiple times by different WITS with configuring charters that refer to different WITS e.g. first inbound then to queue . One embodiment supports only mWITS. Another embodiment supports only iWITS. Another embodiment supports oWITS. Yet another embodiment supports use of any combination of available WITS.

Block continues to block where the WRC and applicable origination information of the WDR is accessed. Thereafter if the WRC and WDR information indicates to ignore the WDR at block then processing continues to block otherwise processing continues to block . Whenever block is encountered the decision is made assumed in to continue processing the WDR or not continue processing the WDR in processing which includes i.e. as described above. This decision depends on how block was arrived to by processing.

Block determines the identity e.g. originating MS of the in process WDR e.g. check field . Thereafter if block determines the identity of the in process WDR does not match the identity of the MS of processing processing continues to block . Block continues to block when a the in process WDR is from other MSs and is being maintained at the MS of processing i.e. mWITS or b the in process WDR is from other MSs and is inbound to the MS of processing i.e. iWITS . For example a first MS of processing handles a WDR from a second MS starting at block .

With reference now to depicted is an illustration for granted data characteristics in the present disclosure LBX architecture specifically with respect to granted permission data and granted charter data as maintained by a particular MS of processing i.e. as maintained by this MS . To facilitate discussion of permission data can be viewed as permission data collection wherein arrows shown are to be interpreted as provides privileges to i.e. Left Hand Side LHS provides privileges to the Right Hand Side RHS . Any of the permissions representations heretofore described internalized datastream XML source code or any other BNF grammar derivative can be used to represent or encode data of the collection . Regardless of the BNF grammar derivative representation deployed the minimal requirement of collection is to define the relationships of privileges granted from one ID to another ID and perhaps with associated MSRelevance and or TimeSpec qualifier s . Whether grants or explicit privileges are assigned ultimately there are privileges granted from a grantor ID to a grantee ID.

Different identity embodiments are supported e.g. MS ID or user ID for the LHS and or RHS see BNF grammar for different embodiments . Permission data collection is to be from the perspective of one particular MS namely the MS of processing. Thus the terminology this MS ID refers to the MS ID of the MS of processing. The terminology WDR MS ID is the MS ID field of an in process WDR of processing distinguished from all other MS IDs configured in collection at the time of processing the WDR. The terminology other MS IDs is used to distinguish all other MS IDs configured in collection which are not the same as the MS ID of the terminology WDR MS ID i.e. MS IDs other than the MS ID field of the in process WDR of processing also other than the this MS MS ID . Privilege configurations are privileges provided from an in process WDR MS ID i.e. WDR being processed by at this MS to the MS ID of processing. The groups an ID belongs to can also provide or be provided with privileges so that the universe of privileges granted should consider groups as well. Privilege configurations are privileges provided from the MS of processing this MS to the MS ID field of the in process WDR being processed by . Privilege configurations are privileges provided from the MS of processing this MS to MS IDs field configured in collection other than the MS ID of the in process WDR being processed by also other than the this MS MS ID . Privilege configurations are privileges provided from MS IDs configured in collection at the MS of processing this MS which are different than the MS ID of the in process WDR being processed by also different than the this MS MS ID .

Also to facilitate discussion of charter data can be viewed as a charter data collection wherein arrows shown are to be interpreted as creates enabled charters for i.e. Left Hand Side LHS creates enabled charters for the Right Hand Side RHS . Any of the charter representations heretofore described internalized datastream XML source code or any other BNF grammar derivative can be used to represent or encode data of the collection . Regardless of the BNF grammar derivative representation deployed the minimal requirement of collection is to define the charters granted by one ID to another and perhaps with associated TimeSpec qualifier s TimeSpec may be an aggregate result of TimeSpec specified for the charter charter expression charter condition and or charter term . Preferably for charters with multiple actions each action is evaluated on its own specified TimeSpec merit if applicable. In embodiments that use a tense qualifier in TimeSpecs LBX history appropriate queue s and any other reasonable source of information shall be utilized appropriately.

Different identity embodiments are supported e.g. MS ID or user ID for the LHS and or RHS see BNF grammar for different embodiments . A privilege preferably grants the ability to create effective enabled charters for one ID from another ID. However in some embodiments the granting of a charter by itself from one ID to another ID can be treated like the granting of a permission privilege to use the charter thereby preventing special charter activating permission s be put in place. Charter data collection is also to be from the perspective of the MS of processing. Thus the terminology this MS ID refers to the MS ID of the MS of processing. The terminology WDR MS ID is the MS ID field of the in process WDR of processing distinguished from all other MS IDs configured in collection at the time of processing the WDR. The terminology other MS IDs is used to distinguish all other MS IDs configured in collection which are not the same as the MS ID of the terminology WDR MS ID i.e. MS IDs other than the MS ID field of the in process WDR of processing also other than the this MS MS ID . Charter configurations are charters created by the MS ID of an in process WDR i.e. WDR being processed by at this MS for being effective at the MS of processing this MS ID . The groups an ID belongs to can also provide or be provided with charters so that the universe of charters granted should consider groups as well. Charter configurations are charters created by the MS ID of processing i.e. this MS for being effective at the MS of processing this MS ID . Charter configurations include the most common embodiments of creating charters for yourself at your own MS. Charter configurations are charters created by the MS ID of processing this MS for being effective at MSs with MS IDs configured in collection other than the MS ID of the in process WDR being processed by . Charter configurations are charters at the MS of processing this MS which are created by MS IDs other than the MS ID of the in process WDR being processed by also other than the this MS MS ID .

Any subset of data collections and can be resident at a MS of processing depending on a particular embodiment of the present disclosure however preferred and most common data used is presented in . While facilitates flowchart descriptions and discussions for in process WDR embodiments of being maintained e.g. to queue being inbound e.g. communicated to the MS and or being outbound e.g. communicated from the MS provide relevant discussions for WDR in process embodiments when considering generally incoming WDRs i.e. being maintained e.g. to queue or being inbound e.g. communicated to the MS .

In the preferred embodiment groups defined local to the MS are used for validating which data using group IDs of collections and are relevant for processing. In alternate embodiments group information of other MSs may be visible to processing for broader group configuration consideration either by remote communications local maintaining of MS groups which are privileged to have their groups maintained there communicated and maintained like charters or another reasonable method.

With reference back to block forms a PRIVS2ME list of configurations and continues to block for eliminating duplicates that may be found. Block may collapse grant hierarchies to form the list. Duplicates may occur for privileges which include the duplicated privileges i.e. subordinate privileges . For example lbxall specifies all LBX privileges and nearar is only one LBX privilege already included in lbxall. Recall that some privileges can be higher order scoped subordinate privileges for a plurality of more granulated privileges. Block additionally eliminates duplicates that may exist for permission embodiments wherein a privilege can enable or disable a feature. In a present disclosure embodiment wherein a privilege can enable and a privilege can disable the same feature or functionality there is preferably a tie breaker of disabling the feature i.e. disabling wins . In an alternate embodiment enabling may break a tie of ambiguity. Block further eliminates privileges that have a MSRelevance qualifier indicating the MS of processing is not supported for the particular privilege and also eliminates privileges with a TimeSpec qualifier invalid for the time of processing an alternate embodiment can enforce TimeSpec interpretation at blocks i.e. in processing and i.e. in processing . Thereafter block forms a PRIVS2WDR list of configurations and continues to block for eliminating duplicates that may be found in a manner analogous to block i.e. subordinate privileges enable disable tie breaker MSRelevance qualifier TimeSpec qualifier . Block may collapse grant hierarchies to form the list. An alternate embodiment can enforce TimeSpec interpretation at block i.e. in processing . Thereafter block forms a CHARTERS2ME list of configurations and preferably eliminates variables by instantiating elaborating at points where they are referenced. Then block eliminates those charters which are not privileged. In some embodiments block is not necessary continues to because unprivileged charters will not be permitted to be present at the MS of processing anyway e.g. eliminated when receiving . Nevertheless block removes from the CHARTERS2ME list all charters which do not have a privilege e.g. using PRIVS2WDR granted by the MS the MS user of processing to the creator of the charter for permitting the charter to be in effect activated . In the preferred embodiment there is a privilege e.g. chrtrs which can be used to grant the permission of activating any charters of another MS or MS user at the MS of processing. In the preferred embodiment there can be any number of subordinate charter privileges i.e. subordinate to chrtrs for specifically indicating which type of charters are permitted. For example privileges for governing which charters are to be active from a remote MS include 

Block checks the PRIVS2ME list to see if there is a privilege granted from the identity of the in process WDR to the MS or user of MS of processing for being able to see the WDR. One main privilege e.g. lbxiop can enable or disable whether or not the MS of processing should be able to do anything at all with the WDR from the remote MS. If block determines this MS can process the WDR then processing continues to block . Block enables local features and functionality in accordance with privileges of the PRIVS2ME list by invoking the enable features and functionality procedure of with the PRIVS2ME list and the in process WDR as parameters preferably passed by pointer reference .

With reference now to depicted is a flowchart for describing a preferred embodiment of a procedure for enabling LBX features and functionality in accordance with a certain type category of permissions. Blocks and enable or disable LBX features and functionality for semantic privileges. Processing of block starts at block and continues to block where the permission type list parameter passed i.e. PRIVS2ME when invoked from block is determined and the in process WDR may be accessed. The list parameter passed provides not only the appropriate list to processing but also which list configuration or has been passed for processing by . There are potentially thousands of specific privileges that can handle. Therefore processing is shown to generically handle different classes categories of privileges namely privilege classes of privilege configuration charter configuration data send impersonation WDR processing situational location monitoring LBX LBS and any others as handled by block . Privileges disclosed throughout the present disclosure fall into one of these classes handled by .

Block continues to block where if it is determined that a privilege configuration privilege is present in the list parameter passed to processing then block will remove privileges from the list parameter if appropriate to do that. For example a privilege or absence thereof detected in the list parameter for indicating no privileges can be defined enabled in context of the list parameter causes block to remove all privileges from the list parameter and also from permissions i.e. of collection when invoked from block . Similarly any more granular privilege configuration privileges of the list parameter causes processing to continue to block for ensuring remaining privileges of the list parameter and of permissions configurations are appropriate. There can be many different privilege configuration privileges for what can and can t be defined in permissions for example by any characteristic s of permissions data according to the present disclosure BNF grammar. Block continues to block when all privilege configuration privileges are reflected in the list parameter and collection of permissions . If block determines there are no privilege configuration privileges to consider in the list parameter passed to processing then processing continues to block .

Block gets the next individual privilege entry or the first entry upon first encounter of block for an invocation of from the list parameter and continues to block . Blocks through iterate all individual privileges list entries associated with the list parameter of permissions provided to block . If block determines there was an unprocessed privilege entry remaining in the list parameter i.e. of collection when invoked from block then the entry gets processed starting with block . If block determines the entry is a charter configuration privilege then block will remove charters from CHARTERS2ME if appropriate to do that. For example a privilege or absence thereof detected in the list parameter for indicating no CHARTERS2ME charters can be defined enabled in context of the list parameter causes block to remove all charters from CHARTERS2ME and also from charters i.e. of collection when invoked from block . Similarly any more granular charter configuration privileges of the list parameter causes processing to continue to block for ensuring remaining charters of CHARTERS2ME and of charters configurations are appropriate. There can be many different charters configuration privileges for what can and can t be defined in charters for example by any characteristic s of charters data according to the present disclosure BNF grammar in particular for an in process WDR from another MS. Any aspect of charters can be privileged all certain commands certain operands certain parameters certain values of any of those whether can specify Host for action processing certain conditions and or terms See BNF grammar . Block then continues to block . Block will remove charters from MYCHARTERS if appropriate to do that. For example a privilege or absence thereof detected in the list parameter for indicating certain MYCHARTERS charters e.g. those that involve the in process WDR can cannot be defined enabled in context of the list parameter causes block to remove charters from MYCHARTERS for subsequent processing. Changes to charters for the MYCHARTERS list does not occur. This prevents deleting charters locally at the MS that the user spent time creating at his MS. Removing from the MYCHARTERS list is enough to affect subsequent processing for example of an in process WDR. Block shown does additionally remove from charters because the charters are not valid from a remote user anyway. One preferred embodiment to block will not alter charters only CHARTERS2ME similarly to block so that subsequent processing continues properly while preventing a remote MS user from resending charters use of at a subsequent time for reinstatement upon discovering the this MS processing user had not provided a needed permission privilege. Block continues back to block for the next entry. Blocks and make use of the privilege entry data from block e.g. grantor ID grantee ID privilege etc to properly affect change of CHARTERS2ME and MYCHARTERS. CHARTERS2ME and MYCHARTERS are shown as global variables accessible from processing to processing but an alternate embodiment will pass these lists as additional parameters determined at block . If block determined the currently iterated privilege is not a charter configuration privilege then processing continues to block .

If block determines the entry is a data send privilege then block will enable LBX features and functionality appropriately in context for the list parameter and processing continues back to block . A data send privilege may be one that is used at block and enforced at block for exactly what data can or cannot be received. Any granulation of permission data or charter data e.g. by any characteristic s may be supported. A data send privilege may overlap with a privilege configuration privilege or a charter configuration privilege since either may be used at blocks and depending on an embodiment. It may be useful to control what data can be received by a MS at blocks and versus what data actually gets used for processing as controlled by blocks and . If block determines the entry is not a data send privilege then processing continues to block . Data send privileges can control what privilege charter and or group data can and cannot be sent to a MS i.e. received by a MS . Data send privileges can be overall privileges subordinate privileges and or privileges for any granulation of data based on type size value age or any other characteristic s available from a derivative of the BNF grammar of .

If block determines the entry is an impersonation privilege then block will enable LBX features and functionality appropriately in context for the list parameter and processing continues back to block . An impersonation privilege is one that is used to access certain authenticated user interfaces some of which were described above. Any granulation of permission data e.g. by any characteristic s may be supported for example for any subset of MS user interfaces with respect to the present disclosure. Block may access security or certain application interfaces accessible to the MS of processing for read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage associated identity impersonation at the MS. If block determines the entry is not an impersonation privilege then processing continues to block . Impersonation privileges can be overall privileges subordinate privileges and or privileges for any granulation of identity data or any other characteristic s available from a derivative of the BNF grammar of .

If block determines the entry is a WDR privilege then block will enable LBX features and functionality appropriately in context for the list parameter and processing continues back to block . A WDR privilege is one that is used to govern access to certain fields of the in process WDR. Any granulation of permission data e.g. by any characteristic s may be supported for example for any subset of available in process WDR data. Block may access any in process WDR field subfield s or associated in process WDR data to make use of certain application interfaces accessible to the MS of processing for read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage appropriate in process WDR processing. If block determines the entry is not a WDR privilege then processing continues to block . WDR privileges can be overall privileges subordinate privileges and or privileges for any granulation of in process related WDR data perhaps using any characteristic s available from a derivative of the BNF grammar of .

If block determines the entry is a Situational Location privilege then block will enable LBX features and functionality appropriately in context for the list parameter and processing continues back to block . A Situational Location privilege may overlap with a WDR privilege since WDR fields are consulted for automated processing however it may be useful to distinguish. Any granulation of permission data e.g. by any characteristic s may be supported for example for any subset of available in process relevant WDR data. The term situational location is useful for describing location based conditions e.g. as disclosed in Service delivered location dependent content of U.S. Pat. Nos. 6 456 234 6 731 238 7 187 997 Johnson . Block may access any in process WDR field subfield s or associated in process WDR data for appropriate LBX processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage appropriate in process WDR situational location processing. If block determines the entry is not a situational location privilege then processing continues to block . Situation location privileges can be overall privileges subordinate privileges and or privileges for any granulation of in process related WDR data perhaps using any characteristic s available from a derivative of the BNF grammar of .

If block determines the entry is a monitoring privilege then block will enable LBX features and functionality appropriately in context for the list parameter and processing continues back to block . A monitoring privilege governs monitoring any data of a MS for any reason e.g. in charter conditions . Any granulation of permission data e.g. by any characteristic s may be supported for example for any subset of MS data. Block may access any MS data or associated in process WDR data for appropriate LBX processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage appropriate in process WDR processing at the MS. If block determines the entry is not a monitoring privilege then processing continues to block . Monitoring privileges can be overall privileges subordinate privileges and or privileges for any granulation of MS data MS of processing or of the in process WDR perhaps using any characteristic s available from a derivative of the BNF grammar of .

If block determines the entry is a LBX privilege then block will enable LBX features and functionality appropriately in context for the list parameter and processing continues back to block . A LBX privilege governs LBX processing behavior at the MS of processing. Other privileges so far discussed for processing may overlap with an LBX privilege. Any granulation of permission data e.g. by any characteristic s may be supported for example for unique LBX processing at the MS of processing. Block may access any MS data or associated in process WDR data for appropriate LBX processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to perform LBX processing at the MS. If block determines the entry is not a LBX privilege then processing continues to block . LBX privileges can be overall privileges subordinate privileges and or privileges for any granulation of MS data MS of processing or of the in process WDR perhaps using any characteristic s available from a derivative of the BNF grammar of .

If block determines the entry is a LBS privilege then block will enable LBS features and functionality appropriately in context for the list parameter and processing continues back to block . A LBS privilege governs LBS processing behavior at the MS of processing. Other privileges so far discussed for processing may overlap with an LBS privilege. Any granulation of permission data e.g. by any characteristic s may be supported for example for unique LBS processing at the MS of processing. Block may access any MS data or associated in process WDR data for appropriate LBS processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to perform LBS processing at the MS and perhaps cause processing at a connected LBS. If block determines the entry is not a LBS privilege then processing continues to block . LBS privileges can be overall privileges subordinate privileges and or privileges for any granulation of MS data MS of processing or of the in process WDR perhaps using any characteristic s available from a derivative of the BNF grammar of and perhaps using any data or interface of a connected LBS.

Block is provided for processing completeness for handling appropriately e.g. enable or disable MS processing a privilege that some reader may not appreciate falling into one of the privilege classes of processing. Block then continues to block . Referring back to block if it is determined there are no more unprocessed entries remaining in the list parameter i.e. of collection when invoked from block then the caller invoker is returned to at block .

In one embodiment uses the absence of certain privileges to enable or disable LBX features and functionality wherein block A determines which privileges were not provided block B enables disables LBX features and functionality in accordance with the lack of privileges and block C returns to the caller invoker.

With reference back to block continues to block . Some embodiments of blocks etc may perform sorting for a best processing order e.g. as provided to procedures of . Block performs actions in accordance with privileges of the PRIVS2ME list by invoking the do action procedure of with the PRIVS2ME list and the in process WDR as parameters preferably passed by pointer reference .

With reference now to depicted is a flowchart for describing a preferred embodiment of a procedure for performing LBX actions in accordance with a certain type of permissions. Blocks and perform actions for semantic privileges. Processing of block starts at block and continues to block where the permission type parameter passed i.e. PRIVS2ME when invoked from block is determined and the in process WDR may be accessed. The list parameter passed provides not only the appropriate list to processing but also which list configuration or has been passed for proper processing by . There are potentially thousands of specific privileges that can handle. Therefore processing is shown to generically handle different classes categories of privileges namely privilege classes of data send impersonation WDR processing situational location monitoring LBX LBS and any others as handled by block . Privileges disclosed throughout the present disclosure fall into one of these classes handled by .

Block continues to block . Block gets the next individual privilege entry or the first entry upon first encounter of block for an invocation of from the list parameter and continues to block . Blocks through iterate all individual privileges associated with the list parameter of permissions provided to block . If block determines there was an unprocessed privilege entry remaining in the list parameter i.e. of collection when invoked from block then the entry gets processed starting with block .

If block determines the entry is a data send privilege then block will perform any LBX actions in context for the list parameter if any applicable and processing continues back to block . A data send privilege may be one that is used at block and enforced at block for exactly what data can or cannot be received or alternatively block can perform actions for communicating data between MSs or affecting data at MSs for an appropriate local image of permissions and or charters . Any granulation of permission data or charter data e.g. by any characteristic s may be supported. If block determines the list entry is not a data send privilege processing continues to block .

If block determines the entry is an impersonation privilege then block will perform any LBX actions in context for the list parameter if any applicable and processing continues back to block . Block may access security or certain application interfaces accessible to the MS of processing for read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage associated identity impersonation at the MS. If block determines the entry is not an impersonation privilege then processing continues to block .

If block determines the entry is a WDR privilege then block will perform any LBX actions in context for the list parameter if any applicable and processing continues back to block . Block may access any in process WDR field subfield s or associated in process WDR data to make use of certain application interfaces accessible to the MS of processing for read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage appropriate in process WDR processing. If block determines the entry is not a WDR privilege then processing continues to block .

If block determines the entry is a Situational Location privilege then block will perform any LBX actions in context for the list parameter if any applicable and processing continues back to block . Block may access any in process WDR field subfield s or associated in process WDR data for appropriate LBX processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage appropriate in process WDR situational location processing. If block determines the entry is not a situational location privilege then processing continues to block

If block determines the entry is a monitoring privilege then block will perform any LBX actions in context for the list parameter if any applicable and processing continues back to block . Block may access any MS data or associated in process WDR data for appropriate LBX processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to manage appropriate in process WDR processing at the MS. If block determines the entry is not a monitoring privilege then processing continues to block .

If block determines the entry is a LBX privilege then block will perform any LBX actions in context for the list parameter if any applicable and processing continues back to block . Block may access any MS data or associated in process WDR data for appropriate LBX processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to perform LBX processing at the MS. If block determines the entry is not a LBX privilege then processing continues to block .

If block determines the entry is a LBS privilege then block will perform any LBS actions in context for the list parameter and processing continues back to block . Block may access any MS data or associated in process WDR data for appropriate LBS processing involving read modify add or otherwise alter certain related data or cause the processing of certain related executable code for example to perform LBS processing at the MS and perhaps cause processing at a connected LBS. If block determines the entry is not a LBS privilege then processing continues to block .

Block is provided for processing completeness for handling appropriately e.g. performing any LBX actions in context for the list parameter if any applicable a privilege that some reader may not appreciate falling into one of the privilege classes of processing. Block then continues to block . Referring back to block if it is determined there are no more unprocessed entries remaining in the list parameter i.e. of collection when invoked from block then the caller invoker is returned to at block .

In one embodiment uses the absence of certain privileges to perform LBX actions in context for the list parameter wherein block A determines which privileges were not provided block B performs LBX actions in context for the lack of privileges and block C returns to the caller invoker.

With reference back to block continues to block . Block performs actions in accordance with privileges of the PRIVS2WDR list by invoking the do action procedure of with the PRIVS2WDR list and the in process WDR as parameters preferably passed by pointer reference and then continues to block . processing is analogously as described above except in context for the PRIVS2WDR list and for the in process WDR of processing relative the PRIVS2WDR list. One embodiment may incorporate a block block continues to which continues to block for invoking processing with PRIVS2WDR. Generally privilege configurations involve actions for the benefit of the WDR originator.

Block processing merges the MYCHARTERS and CHARTERS2ME lists into a CHARTERS2DO list and continues to block for eliminating inappropriate charters that may exist in the CHARTERS2DO list. Block additionally eliminates charters with a TimeSpec qualifier invalid for the time of processing an alternate embodiment can enforce TimeSpec interpretation at block . If all actions or any condition term expression or entire charter itself has a TimeSpec outside of the time of processing then preferably the entire charter is eliminated. Action s are removed from a charter which remains in effect if action s for a charter have an invalid TimeSpec for the time of processing in which case any remaining actions with no TimeSpec or a valid TimeSpec are preserved for the effective charter. If all charter actions are invalid per TimeSpec then the charter is completely eliminated. Thereafter block performs charter actions in accordance with conditions of charters of the CHARTERS2DO list see and processing then terminates at block .

Block can eliminate charters which are irrelevant for processing for example depending upon the type of in process WDR. For a maintained WDR inappropriate charters may be those which do not have a maintained condition specification i.e.  fldname . For an inbound WDR inappropriate charters may be those which do not have an in bound condition specification i.e.  I fldname . For an outbound WDR inappropriate charters may be those which do not have an out bound condition specification i.e.  I fldname . The context of WITS processing mWITS iWITS oWITS may be used at block for eliminating inappropriate charters.

With reference back to block if it is determined that this MS should not process see the WDR in process processing continues to block where processing is terminated and the processing host of i.e. appropriately ignores the WDR.

With reference back to block if it is determined that the WDR identity matches the MS of processing processing continues to block . Block continues to block when a the in process WDR is from this MS and is being maintained at the MS of processing i.e. mWITS or b the in process WDR is outbound from this MS i.e. oWITS . Block forms a PRIVS2OTHERS list of configurations and continues to block for eliminating duplicates that may be found. Block may collapse grant hierarchies to form the list. Duplicates may occur for privileges which include the duplicated privileges i.e. subordinate privileges as described above. Block additionally eliminates duplicates that may exist for permission embodiments wherein a privilege can enable or disable a feature. In a present disclosure embodiment wherein a privilege can enable and a privilege can disable the same feature or functionality there is preferably a tie breaker of disabling the feature i.e. disabling wins . In an alternate embodiment enabling may break a tie of ambiguity. Block further eliminates privileges that have a MSRelevance qualifier indicating the MS of processing is not supported for the particular privilege and also eliminates privileges with a TimeSpec qualifier invalid for the time of processing an alternate embodiment can enforce TimeSpec interpretation at block i.e. in processing . Thereafter block forms a MYCHARTERS list of configurations and preferably eliminates variables by instantiating elaborating at points where they are referenced. Then block forms a CHARTERS2ME list of configurations and preferably eliminates variables by instantiating elaborating at points where they are referenced. Then block eliminates those charters which are not privileged. In some embodiments block is not necessary continues to because un privileged charters will not be permitted to be present at the MS of processing. Nevertheless block removes from the CHARTERS2ME list all charters which do not have a privilege granted by the MS the MS user of processing to the creator of the charter for permitting the charter to be enabled as described above for block . In any embodiments block ensures no charters from other users are considered active unless appropriately privileged. Thereafter block performs actions in accordance with privileges of the PRIVS2OTHERS list by invoking the do action procedure of with the PRIVS2ME list and the in process WDR as parameters preferably passed by pointer reference and then continues to block which has already been described. processing is the same as described above except in context for the PRIVS2OTHERS and for the in process WDR of processing relative the PRIVSOTHERS list. Of course the context of blocks through are processed for in process WDRs which are a maintained to the MS of for the whereabouts of the MS of processing or b outbound from the MS of processing e.g. an outbound WDR describing whereabouts of the MS of processing . One embodiment may incorporate a block block continues to which continues to block for invoking processing with PRIVS2OTHERS. Generally privilege configurations involve actions for the benefit of others i.e. other than this MS .

When considering the terminology incoming as used for a WDR in process at this MS the MS of processing which was originated by this MS with an identity for this MS uses a this MS charters confirmed by bullet 2 part 1 bullet 2 part 1 b others charters per this MS or this MS user privileges to them confirmed by bullet 3 bullet 2 bullet 3 bullet 2 and c this MS or this MS user privileges to others confirmed by bullet 4 bullet 4 bullet 4 bullet 4 . An alternate embodiment additionally uses d others privileges to this MS or this MS user for example to determine how nearby they are at outbound WDR time or at the time of maintaining the MS s own whereabouts. This alternate embodiment would cause to include a new block for forming a PRIVS2ME list of privileges a new block for eliminating duplicates MSRelevance rejects and invalid TimeSpec entries a new block for enabling features an functionality in accordance with the PRIVS2ME list of block by invoking the enable features and functionality procedure of with PRIVS2ME as a parameter processing analogous to as described above except for PRIVS2ME and a new block for performing actions in accordance with PRIVS2ME by invoking the do action procedure of with PRIVS2ME as a parameter processing analogous to as described above except for PRIVS2ME . Such an embodiment would cause block to continue to block which continues to block which continues to block which continues to block which then continues to block .

When considering the terminology incoming as used for a WDR in process at this MS the MS of processing which was originated by a remote MS with an identity different than this MS uses e this MS charters per other s privileges to this MS or this MS user confirmed by bullet 2 part 2 bullet 2 part 2 bullet 2 f others charters per this MS or this MS user privileges to them confirmed by bullet 2 bullet 3 bullet 2 bullet 3 g this MS or this MS user privileges to others confirmed by bullet 3 bullet 3 bullet 3 bullet 3 and h others privileges to this MS or this MS user confirmed by bullet 2 bullet 2 bullet 2 bullet 2 . An alternate embodiment additionally uses i others charters per this MS or this MS user privileges to them and or j this MS or this MS user privileges to others and or k others privileges to this MS or this MS user . This alternate embodiment would cause to alter block to further include charters alter block to further include privileges include a new block for forming a PRIVS2OTHERS list of privileges new block for eliminating duplicates new block for enabling features an functionality in accordance with the PRIVS2OTHERS list of block new block for enabling features an functionality in accordance with the modified PRIVS2ME list of block and new block for performing actions in accordance with the modified PRIVS2ME i.e. block continues to block which continues to block which continues to block which continues to block which continues to block which then continues to block . Also blocks and would appropriately handle new charters of altered block . Such an embodiment would cause new blocks and to invoke the applicable procedure or with analogous processing as described above except in context for the parameter passed.

In some embodiments blocks and or and or and or relevant alternate embodiment blocks discussed are remotely accessed by communicating with the MS having the identity determined at block for the WDR in process. The preferred embodiment is as disclosed for maintaining data local to the MS for processing there. In other embodiments there are separate flowcharts e.g. for each variety of handling in process WDRs e.g. mWITS iWITS oWITS processing .

Various embodiments processing will invoke the procedure of with appropriate parameters i.e. lists for and or and or and or so that any category subset of the permission data collection i.e. and or and or and or is used to enable appropriate LBX features and functionality according to the WDR causing execution of processing. For example privileges between the MS of processing and an identity other than the WDR causing processing may be used e.g. relevant MS third party notification features functionality or processing as defined by related privileges .

Various embodiments processing will invoke the procedure of with appropriate parameters i.e. lists for and or and or and or so that any category subset of the charter data collection i.e. and or and or and or is used to perform LBX actions according to the WDR causing execution of processing. For example charters between the MS of processing and an identity other than the WDR causing processing may be used e.g. relevant MS third party charters as defined by related privileges .

Preferably statistics are maintained by WITS processing for each reasonable data worthy of tracking from standpoints of user reporting automated performance fine tuning e.g. thread throttling automated adjusted processing and monitoring of overall system processing. In fact every processing block of can have a plurality of statistics to be maintained.

If block determines there is a charter to process then processing continues to block for instantiating any variables that may be referenced in the charter and then continues to block . Charter parts are scanned for referenced variables and they are instantiated so that the charter is intact without a variable reference. The charter internalized form may be modified to accommodate instantiation s . may have already instantiated variables for charter elimination processing. Block is typically not required since the variables were likely already instantiated when internalized to a preferred embodiment CHARTERS2DO processable form and also processed by previous blocks of processing. Nevertheless block is present to cover other embodiments and to handle any instantiations which were not already necessary. In some embodiments block is not required since variable instantiations can occur as needed when processing the individual charter parts during subsequent blocks of processing. Block would continue to block when a block is not required.

Block begins an iterative loop blocks through for processing all special terms from the current charter expression. Block gets the next or first special term if any from the charter expression and continues to block . A special term is a BNF grammar WDRTerm AppTerm or atomic term. If block determines a special term was found for processing from the expression then block accesses privileges to ensure the special term is privileged for use. Appropriate permissions are accessed in this applicable context of processing. Block then continues to block . Blocks and may not be required since unprivileged charters were already eliminated in previous blocks of processing e.g. see blocks and . Nevertheless blocks and are shown to cover other embodiments and to ensure unprivileged charters are treated ineffective. Depending on an embodiment blocks and may only perform obvious eliminations. In other embodiments there may be no blocks or so that charter part processing occurs only in one place i.e. to achieve better MS performance by preventing more than one scan over charter data. In another embodiment blocks and are not required since all charter eliminations based on privileges already occurred at the previous blocks of processing. Block can continue to block when blocks and are not required.

If block determines the special term is privileged for use e.g. explicit privilege or lack of a privilege denying use depending on privilege deployment embodiments then block appropriately accesses the special term data source and replaces the expression referenced special term with the corresponding value. Block accesses special term data dynamically so that the terms reflect values at the time of block processing. Block continues back to block . A WDRTerm is accessed from the in process WDR to processing. An AppTerm is an anticipated registered application variable accessed by a well known name typically with semaphore control since an asynchronous application thread is writing to the variable. An atomic term will cause access to WDR data at queue or LBX history application status for applications in use at the MS of processing system date time the MS ID of the MS of processing or other appropriate data source.

Referring back to block if it is determined that the special term of the charter expression is not privileged then block logs an appropriate error e.g. to LBX history and processing continues back to block for the next charter. An alternate block may alert the MS user and in some cases require the user to acknowledge the error before continuing back to block . So the preferred embodiment of charter processing eliminates a charter from being processed if any single part of the charter expression is not privileged.

Referring back to block if it is determined there are no special terms in the expression remaining to process or there were none in the expression then block evaluates the expression to a Boolean True or False result using well known processing for a stack based parser for expression evaluation e.g. See well known compiler interpreter development techniques e.g. Algorithms Data Structures Programs by Nicklaus Wirth published by Prentice Hall Inc. 1976 . Block implements atomic operators using the WDR queue most recent WDR for this MS LBX history or other suitable MS data. Any Invocation is also invoked for resulting to a True or False wherein a default is enforced upon no return code or no suitable return code returned. Invocation parameters that had special terms would have been already been updated by block to eliminate special terms prior to invocation. Thereafter if block determines the expression evaluated to False then processing continues back to block for the next charter i.e. expression False implies to prevent not cause the action s of the charter . If block determines the expression evaluated to True then processing continues to block .

Block begins an iterative loop blocks through for processing all actions from the current charter. Block gets the next or first action if any from the charter and continues to block . There should be at least one action in a charter provided to processing since the preferred embodiment of processing will have eliminated any placeholder charters without an action specified e.g. charters with no actions preferably eliminated at blocks as part of the merge process at block or as part of previous processing to form privileged charter lists . If block determines an unprocessed action was found for processing then block initializes a REMOTE variable to No. Thereafter if it is determined at block that the action has a BNF grammar Host specification then block accesses privileges and block checks if the action is privileged for being executed at the Host specified. The appropriate permissions are accessed at block in this applicable context of processing. If block determines the action is privileged for running at the Host then block sets the REMOTE variable to the Host specified and processing continues to block . If block determines the action is not privileged for running at the Host then processing continues to block for error processing already described above. If block determines there was no Host specified for the action processing continues directly to block . Blocks and may not be required since unprivileged charters were already eliminated in previous blocks of processing e.g. see blocks and . Nevertheless blocks and are shown to cover other embodiments and to ensure unprivileged charters are treated ineffective. Depending on an embodiment blocks and may only perform obvious eliminations. In other embodiments there may be no blocks or so that charter part processing occurs only in one place i.e. to achieve better MS performance by preventing more than one scan over charter data. In another embodiment blocks and are not required since all charter eliminations based on privileges already occurred at the previous blocks of processing. Block can continue to block when blocks and are not required and a Host was specified with the action.

Block accesses appropriate permissions in this applicable context of processing for ensuring the command and operand are appropriately privileged. Thereafter if block determines that the action s command and operand are not privileged then processing continues to block for error processing already described. If block determines the action s command and operand are to be effective then processing continues to block . Blocks and may not be required since unprivileged charters were already eliminated in previous blocks of processing e.g. see blocks and . Nevertheless blocks and are shown to cover other embodiments and to ensure unprivileged charters are treated ineffective. Depending on an embodiment blocks and may only perform obvious eliminations. In other embodiments there may be no blocks or so that charter part processing occurs only in one place i.e. to achieve better MS performance by preventing more than one scan over charter data. In another embodiment blocks and are not required since all charter eliminations based on privileges already occurred at the previous blocks of processing. Block and the No condition of block would continue to block when blocks and are not required.

Block begins an iterative loop blocks through for processing all parameter special terms of the current charter. Block gets the next or first parameter special term if any and continues to block . A special term is a BNF grammar WDRTerm AppTerm or atomic term as described above . If block determines a special term was found for processing from the parameter list then block accesses privileges to ensure the special term is privileged for use. The appropriate permissions are accessed in this applicable context of processing. Block then continues to block . Blocks and may not be required since unprivileged charters were already eliminated in previous blocks of processing e.g. see blocks and . Nevertheless blocks and are shown to cover other embodiments and to ensure unprivileged charters are treated ineffective. Depending on an embodiment blocks and may only perform obvious eliminations. In other embodiments there may be no blocks or so that charter part processing occurs only in one place i.e. to achieve better MS performance by preventing more than one scan over charter data. In another embodiment blocks and are not required since all charter eliminations based on privileges already occurred at the previous blocks of processing. Block can continue to block when blocks and are not required.

If block determines the special term is privileged for use e.g. explicit privilege or lack of a privilege denying use depending on privilege deployment embodiments then block appropriately accesses the special term data source and replaces the parameter referenced special term with the corresponding value. Block accesses special term data dynamically so that the terms reflect values at the time of block processing. Block continues back to block . A WDRTerm AppTerm and atomic term are accessed in a manner analogous to accessing them at block .

Referring back to block if it is determined that the special term of the parameter list is not privileged then processing continues to block for error processing already described. Referring back to block if it is determined there are no special terms in the parameter list remaining to process or there were none then block evaluates each and every parameter expression to a corresponding value using well known processing for a stack based parser for expression evaluation e.g. See well known compiler interpreter development techniques e.g. Algorithms Data Structures Programs by Nicklaus Wirth published by Prentice Hall Inc. 1976 . Block implements the atomic operators using the WDR queue most recent WDR for this MS LBX history or other suitable MS data. Any Invocation is also invoked for resulting to Data or Value wherein a default is enforced upon no returned data. Invocation parameters that had special terms would have been updated at block to eliminate special terms prior to invocation. Block ensures each parameter is in a ready to use form to be processed with the command and operand. Each parameter results in embodiments of a data value a data value resulting from an expression a data reference e.g. pointer or other embodiments well known in the art of passing parameters arguments to a function procedure or script for processing. Thereafter if block determines the REMOTE variable is set to No i.e. No equals a value distinguishable from any Host specification for having the meaning of No Host Specification then processing continues to block where the ExecuteAction procedure of is invoked with the command operand and parameters of the action in process. Upon return from the procedure of processing continues back to block for any remaining charter actions. If block determines the REMOTE variable is set to a Host for running the action then processing continues to block for preparing send data procedure parameters for performing a remote action of the command operand and parameters and then invoking the send data procedure of for performing the action at the remote MS also see . Processing then continues back to block . An alternate embodiment will loop on multiple BNF grammar Host specifications for multiple invocations of the send data procedure i.e. when multiple Host specifications are supported . Another embodiment to processing permits multiple actions with a single Host specification.

Referring back to block if it is determined all current charter actions are processed then processing continues to block for any next charter to process. Referring back to block if it is determined all charters have been processed processing terminates at block .

Depending on various embodiments there may be obvious error handling in charter parsing. Preferably the charters were reasonably validated prior to being configured and or previously processed parsed e.g. processing . Also TimeSpec and or MSRelevance information may be used in so that charter part processing occurs only in one place i.e. rather than to achieve better MS performance by preventing more than one scan over charter data. Some embodiments of may be the single place where charters are eliminated based on privileges TimeSpecs MSRelevance or any other criteria discussed with for charter elimination to improve performance i.e. a single charter parse when needed . Third party MSs i.e. those that are not represented by the in process WDR and the MS of processing can be affected by charter actions e.g. via Host specification privileged action privileged feature etc .

Preferably statistics are maintained throughout processing for how charters were processed which charters became effective why they became effective which commands were processed e.g. invocation of etc.

With reference now to depicted is a flowchart for describing a preferred embodiment of a procedure for sending data to a remote MS for example to perform a remote action as invoked from block . is preferably of linkable PIP code . The purpose is for the MS of processing e.g. a first or sending MS to transmit data to other MSs e.g. at least a second or receiving MS for example an action command operand and any parameter s or specific processing for a particular command e.g. Send atomic command . Multiple channels for sending or broadcasting should be isolated to modular send processing feeding from a queue . In an alternative embodiment having multiple transmission channels visible to processing of e.g. block there can be intelligence to drive each channel for broadcasting on multiple channels either by multiple send threads for processing loop processing on a channel list and or passing channel information to send processing feeding from queue . If does not transmit directly over the channel s i.e. relies on send processing feeding from queue an embodiment may provide means for communicating the channel for broadcast send processing when interfacing to queue e.g. incorporate a channel qualifier field with send packet inserted to queue .

In any case see detailed explanations of as well as long range exemplifications shown in respectively. Processing begins at block continues to block where the caller parameter s passed to processing e.g. action for remote execution or command for remote execution are used for sending at least one data packet containing properly formatted data for sending and for being properly received and interpreted. Block may reformat parameters into a suitable data packet s format so the receiving MS can process appropriately see . Depending on the present disclosure embodiment any reasonable supported identity ID IDType is a valid target e.g. as derived from a recipient or system parameter . Thereafter block waits for an acknowledgement from the receiving MS if the communication embodiment in use utilizes that methodology. In one embodiment the send data packet is an unreliable datagram that will most likely be received by the target MS. In another embodiment the send data packet is reliably transported data which requires an acknowledgement that it was received in good order. In any case block continues to block .

Block formats the data for sending in accordance with the specified delivery method along with necessary packet information e.g. source identity wrapper data etc and sends data appropriately. For a broadcast send block broadcasts the information using a send interface like interface by inserting to queue so that send processing broadcasts data e.g. on all available communications interface s for example as far as radius and processing continues to block . The broadcast is for reception by data processing systems e.g. MSs in the vicinity of as further explained by which includes potentially any distance. The targeted MS should recognize that the data is meant for it and receives it. For a targeted send block formats the data intended for recognition by the receiving target. In an embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place information as CK embedded in usual data at the next opportune time of sending usual data . As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends broadcasts new data .

Block waits for a synchronous acknowledgement if applicable to the send of block until either receiving one or timing out. Block will not wait if no ack response is anticipated in which case block sets status for block to got it . If a broadcast was made one 1 acknowledgement may be all that is necessary for validation or all anticipated targets can be accounted for before deeming a successful ack. Thereafter if block determines an applicable ack response was received i.e. data successfully sent received or none was anticipated i.e. assume got it then processing continues to block for potentially processing the response. Block will process the response if it was anticipated for being received as determined by data sent at block . Thereafter block performs logging for success e.g. to LBX History . If block determines an anticipated ack was not received then block logs the attempt e.g. to LBX history . An alternate embodiment to block will log an error and may require a user action to continue processing so a user is confirmed to have seen the error. Both blocks and continue to block where the caller invoker is returned to for continued processing e.g. back to block .

With reference now to depicted is a flowchart for describing a preferred embodiment of processing for receiving execution data from another MS for example action data for execution or processing of a particular atomic command for execution. processing describes a Receive Execution Data RxED process worker thread and is of PIP code . There may be many worker threads for the RxED process just as described for a process. The receive execution data RxED process is to fit identically into the framework of architecture as other processes with specific similarity to process in that there is data received from receive queue the RxED thread s stay blocked on the receive queue until data is received and a RxED worker thread sends data as described e.g. using send queue . Blocks through blocks through and applicable invocation of block block blocks through and any other applicable architecture process thread framework processing is to adapt for the new RxED process. For example the RxED process is initialized as part of the enumerated set at blocks e.g. preferably next to last member of set and e.g. preferably second member of set for similar architecture processing. Receive processing identifies targeted broadcasted data destined for the MS of processing. An appropriate data format is used for example using X.409 encoding of for some subset of data packet s received wherein RxED thread s purpose is for the MS of processing to respond to incoming data. It is recommended that validity criteria set at block for RxED Max be set as high as possible e.g. 10 relative performance considerations of architecture to service multiple data receptions simultaneously. Multiple channels for receiving data fed to queue are preferably isolated to modular receive processing.

In an alternative embodiment having multiple receiving transmission channels visible to the RxED process there can be a RxED worker thread per channel to handle receiving on multiple channels simultaneously. If RxED thread s do not receive directly from the channel the preferred embodiment of would not need to convey channel information to RxED thread s waiting on queue anyway. Embodiments could allow specification configuration of many RxED thread s per channel.

A RxED thread processing begins at block continues to block where the process worker thread count RxED Ct is accessed and incremented by 1 using appropriate semaphore access e.g. RxED Sem and continues to block for retrieving from queue sent data using interface like interface perhaps a special termination request entry and only continues to block when a record of data e.g. action for remote execution particular atomic command or termination record is retrieved. In one embodiment receive processing deposits data as record s to queue . In another embodiment XML is received and deposited to queue or some other suitable syntax is received as derived from the BNF grammar. In another embodiment receive processing receives data in one format and deposits a more suitable format for processing.

Block stays blocked on retrieving from queue until data is retrieved in which case processing continues to block . If block determines a special entry indicating to terminate was not found in queue processing continues to block . There are various embodiments for RxED thread s RxCD thread s thread s and thread s to feed off a queue for different record types for example separate queues A B C and D or a thread target field with different record types found at queue e.g. like field . In another embodiment there are separate queues D and E for separate processing of incoming remote action and send command data. In another embodiment thread s are modified with logic of RxED thread s to handle remote actions and send command data requests since thread s are listening for queue data anyway. In yet another embodiment there are distinct threads and or distinct queues for processing each kind of an atomic command to processing i.e. as processed by blocks through .

Block validates incoming data for this targeted MS before continuing to block . A preferred embodiment of receive processing already validated the data is intended for this MS by having listened specifically for the data or by having already validated it is at the intended MS destination e.g. block can continue directly to block no block and block required . If block determines the data is valid for processing then block checks the data for its purpose remote action or particular command . If block determines the data received is for processing a remote action then block accesses source information the command the operand and parameters from the data received. Thereafter block accesses privileges for each of the remote action parts command operand parameters to ensure the source has proper privileges for running the action at the MS of processing. Depending on embodiments block may include evaluating the action for elaborating special terms and or expressions as described for blocks through although the preferred embodiment preferably already did that prior to transmitting the remote action for execution e.g. remote action already underwent detailed privilege assessment . However in some embodiments where privileges are only maintained locally the action processing of processing would be required at block to check privileges where appropriate in processing the action. In such embodiments would process local actions as disclosed but would not process actions known to be for remote execution i.e. Host specification since a embodiment would include processing for performing privilege check processing to determine that sufficient privileges are granted. Thus depending on the present disclosure embodiment block may include little privilege verification no privilege verification or may include all applicable action privilege verification discussed already in .

In yet another embodiment special terms processing of can be delayed until processing e.g. block continues to a new block which continues to block . It may be advantageous to have new block elaborate evaluate special terms at the MS of processing in some embodiments. In a further embodiment a syntax or qualifier can be used to differentiate where to perform special term elaboration evaluation.

Thereafter if block determines the action for execution is acceptable and perhaps privileged or privileged per source or there was no check necessary then block invokes the execute action procedure of with the action command operand and any parameter s completes at block an acknowledgement to the originating MS of the data received at block and block sends broadcasts the acknowledgement ack before continuing back to block for the next incoming execution request data. Block sends broadcasts the ack using a send interface like interface by inserting to queue so that send processing transmits data for example as far as radius . Embodiments will use the different correlation methods already discussed above to associate an ack with a send.

If block determines the data is not acceptable privileged then processing continues directly back to block . For security reasons it is best not to respond with an error. It is best to ignore the data entirely. In another embodiment an error may be returned to the sender for appropriate error processing and reporting.

Referring back to block if it is determined that the execution data is for processing a particular atomic command then processing continues to block . Block accesses the command e.g. send the operand and parameters from the data received. Thereafter block accesses privileges for each of the parts command operand parameters to ensure the source has proper privileges for running the atomic command at the MS of processing. Depending on embodiments block may include evaluating the command for elaborating special terms and or expressions as described for blocks through although the preferred embodiment preferably already did that prior to transmitting the command for execution. However in some embodiments where privileges are only maintained locally the privilege processing of would be required at block to check privileges where appropriate in processing the command. In such embodiments would process local actions as disclosed but would not process actions known to be for remote execution i.e. Host specification since a embodiment would include processing for performing privilege check processing to determine that sufficient privileges are granted. Thus depending on the present disclosure embodiment block may include little privilege verification no privilege verification or may include all applicable action privilege verification discussed already in .

In yet another embodiment special terms processing of can be delayed until processing e.g. block continues to a new block which continues to block . It may be advantageous to have new block elaborate evaluate special terms at the MS of processing in some embodiments. In a further embodiment a syntax or qualifier can be used to differentiate where to perform special term elaboration evaluation.

Thereafter if block determines the command Command Operand Parameters for execution is acceptable and perhaps privileged or privileged per source or there was no check necessary then block performs the command locally at the MS of processing. Thereafter block checks if a response is needed as a result of command e.g. Find command processing at block . If block determines a response is to be sent back to the originating MS completes a response to the originating MS of the data received at block and block sends broadcasts the response before continuing back to block for the next incoming execution request data. Block sends broadcasts the response containing appropriate command results using a send interface like interface by inserting to queue so that send processing transmits data for example as far as radius . Embodiments will use the different correlation methods already discussed above to associate a response with a send.

If block determines a response is not to be sent back to the originating MS then processing continues directly back to block . If block determines the data is not acceptable privileged then processing continues back to block . For security reasons it is best not to respond with an error. It is best to ignore inappropriate e.g. unprivileged unwarranted data entirely. In another embodiment an error may be returned to the sender for appropriate error processing and reporting.

Blocks through are presented generically so that specific atomic command descriptions below provide appropriate interpretation and processing. The actual implementation may replace blocks through with programming case statement conditional execution for each atomic command supported.

Referring back to block if it is determined that the data is not valid for the MS of processing processing continues back to block . Referring back to block if a worker thread termination request was found at queue then block decrements the RxED worker thread count by 1 using appropriate semaphore access e.g. RxED Sem and RxED thread processing terminates at block . Block may also check the RxED Ct value and signal the RxED process parent thread that all worker threads are terminated when RxED Ct equals zero 0 .

Block causes sending broadcasting data containing CK depending on the type of MS wherein CK contains ack response information prepared. In the embodiment wherein usual MS communications data of the MS is altered to contain CK for listening MSs in the vicinity send processing feeding from queue caused by block processing will place ack response information as CK embedded in usual data at the next opportune time of sending usual data . As the MS conducts its normal communications transmitted data contains new data CK to be ignored by receiving MS other character processing but to be found by listening MSs within the vicinity which anticipate presence of CK . Otherwise when LN Expanse deployments have not introduced CK to usual data communicated on a receivable signal by MSs in the vicinity sends broadcasts new ack response data .

In an alternate embodiment remote action and or atomic command data records contain a sent date time stamp field of when the data was sent by a remote MS and a received date time stamp field like field is processed at the MS in processing. This would enable calculating a TDOA measurement while receiving data e.g. actions or atomic command that can then be used for location determination processing as described above.

For other acceptable receive processing methods are well known to those skilled in the art for hooking customized processing into application processing of sought data received just as discussed with above e.g. mail application callback function API etc . Thus there are well known methods for processing data in context of this disclosure for receiving remote actions and or atomic command data from an originating MS to a receiving MS for example when using email. Similarly as described above SMS messages can be used to communicate data albeit at smaller data exchange sizes. The sending MS may break up larger portions of data which can be sent as parse able text to the receiving MS. It may take multiple SMS messages to communicate the data in its entirety.

Regardless of the type of receiving application those skilled in the art recognize many clever methods for receiving data in context of a MS application which communicates in a peer to peer fashion with another MS e.g. callback function s API interfaces in an appropriate loop which can remain blocked until sought data is received for processing polling known storage destinations of data received or other applicable processing . are an embodiment of MS to MS communications referred to with the acronym MS2MS.

If it is determined at block that the action atomic command is a send command then processing continues to block where the send command action procedure of is invoked. The send command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the send command action procedure block continues to block . Block returns to the calling block of processing e.g. block that invoked processing. If block determines the action atomic command is not a send command then processing continues to block . If it is determined at block that the action atomic command is a notify command then processing continues to block where the notify command action procedure of is invoked. The notify command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the notify command action procedure block continues to block . If block determines the action atomic command is not a notify command then processing continues to block . If it is determined at block that the action atomic command is a compose command then processing continues to block where the compose command action procedure of is invoked. The compose command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the compose command action procedure block continues to block . If block determines the action atomic command is not a compose command then processing continues to block . If it is determined at block that the action atomic command is a connect command then processing continues to block where the connect command action procedure of is invoked. The connect command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the connect command action procedure block continues to block . If block determines the action atomic command is not a connect command then processing continues to block . If it is determined at block that the action atomic command is a find command then processing continues to block where the find command action procedure of is invoked. The find command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the find command action procedure block continues to block . If block determines the action atomic command is not a find command then processing continues to block . If it is determined at block that the action atomic command is an invoke command then processing continues to block where the invoke command action procedure of is invoked. The invoke command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the invoke command action procedure block continues to block . If block determines the action atomic command is not an invoke command then processing continues to block . If it is determined at block that the action atomic command is a copy command then processing continues to block where the copy command action procedure of is invoked. The copy command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the copy command action procedure block continues to block . If block determines the action atomic command is not a copy command then processing continues to block . If it is determined at block that the action atomic command is a discard command then processing continues to block where the discard command action procedure of is invoked. The discard command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the discard command action procedure block continues to block . If block determines the action atomic command is not a discard command then processing continues to block . If it is determined at block that the action atomic command is a move command then processing continues to block where the move command action procedure of is invoked. The move command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the move command action procedure block continues to block . If block determines the action atomic command is not a move command then processing continues to block . If it is determined at block that the action atomic command is a store command then processing continues to block where the store command action procedure of is invoked. The store command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the store command action procedure block continues to block . If block determines the action atomic command is not a store command then processing continues to block . If it is determined at block that the action atomic command is an administrate command then processing continues to block where the administrate command action procedure of is invoked. The administrate command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the administrate command action procedure block continues to block . If block determines the action atomic command is not an administrate command then processing continues to block . If it is determined at block that the action atomic command is a change command then processing continues to block where the change command action procedure of is invoked. The change command action procedure is invoked with parameters including the passed parameters of Operand and Parameters discussed for block . Upon return from the change command action procedure block continues to block . If block determines the action atomic command is not a change command then processing continues to block for handling other supported action atomic commands on the MS. There are many commands that can be implemented on a MS. Block continues to block for processing as already described. describe action processing for recognized events to process WDRs.

Together with processing disclosed above provided is a user friendly development platform for quickly building LBX applications wherein the platform enables conveniently enabled LBX application interoperability and processing including synchronized processing across a plurality of MSs. Some commands involve a plurality of MSs and or data processing systems. Others don t explicitly support a plurality of MSs and data processing systems however that is easily accomplished for every command since a single charter expression can cause a plurality of actions anyway. For example if a command does not support a plurality of MSs in a single command action the plurality of MSs is supported with that command through specifying a plurality of identical command actions in the charter configuration for each desired MS. Actions provided in this LBX release enable a rich set of LBX features and functionality for 

Syntax and reasonable validation should be performed at the time of configuration although it is preferable to check for errors at run time of actions as well. Various embodiments may or may not validate at configuration time and may or may not validate at action processing time. Validation should be performed at least once to prevent run time errors from occurring. Obvious error handling is assumed present when processing commands such error handling preferably including the logging of the error to LBX History and or notifying the user of the error with or without request for the user to acknowledge the reporting of error.

Atomic command descriptions are to be interpreted in the broadest sense and some guidelines when reading the descriptions include 

The reader should cross reference compare operand descriptions in the B matrices for each command to appreciate full exploitation of the Operand options and intended embodiments since descriptions assume information found in other commands is relevant across commands. Some operand description information may have been omitted from a command matrix to prevent obvious duplication of information already described for the same operand in another command.

Block validates Parameters some of which may have been defaulted in previous blocks and and continues to block . If bock determines there is an error in Parameters then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines that Parameters are in good order for using the email transport then block updates an email object in context for the send command Operand and Parameters block uses a send email interface to send the email and block returns to the caller e.g. block . Block can use the attributes parameter to affect how Parameters is to be interpreted. The attributes parameter may be modified and can be used by any processes which receive the sent distribution. Those skilled in the art know well known email send interfaces e.g. APIs depending on a software development environment. The email interface used at block will be one suitable for the underlying operating system and available development environments for example a standardized SMTP interface. In a C environment an SMTP email interface example is 

Those skilled in the art recognize other interfaces of similar messaging capability for carrying out the transport of an action e.g. Send command . Email is a preferred embodiment. While there are Send command embodiments that make using an existing transport layer e.g. email more suitable than not even the most customized Send command Operands can use email instead of MS2MS by implementing one or more recognizable signature s indication s or the like of in the email distribution to be used for informing a receiving email system to treat the email uniquely for carrying out the present disclosure. Depending on the embodiment integrated processing code is maintained built as part of the email system or processing code is plugged hooked into an existing email system in an isolated third party manner. Regardless the email system receiving the present disclosure email will identify the email as being one for special processing. Then email contents is parsed out and processed according to what has been requested.

In embodiments where Send command Operands are more attractively implemented using an existing transport layer e.g. email those send commands can also be sent with MS2MS encoded in data packet s that are appropriate for processing.

Referring back to block if it is determined that the Operand indicates to not use an email transport e.g. use a MS2MS transport for performing the send command or send command is to be processed locally then block checks if a sender parameter was specified. If block determines a sender was specified processing continues to block otherwise block defaults one e.g. valid MS ID and then processing continues to block . Block checks if a subject message parameter was specified. If block determines a subject message was specified processing continues to block otherwise block defaults one and then processing continues to block . Block may specify a null message. Block checks if an attributes parameter was specified. If block determines attributes were specified processing continues to block otherwise block defaults attributes e.g. confirmation of delivery high priority etc and then processing continues to block . Block checks if at least one recipient parameter was specified. If block determines at least one recipient was specified processing continues to block otherwise block defaults one e.g. valid ID for this MS and then processing continues to block . Block may specify a null recipient list so as to cause an error in later processing detected at block .

Block validates Parameters some of which may have been defaulted in previous blocks and and continues to block . If bock determines there is an error in Parameters then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines that Parameters are in good order then block updates a data object in context for the send command Operand and Parameters and block begins a loop for delivering the data object to each recipient. Block gets the next or first recipient from the recipient list and processing continues to block .

If block determines that all recipients have been processed then processing returns to the caller at block otherwise block checks the recipient to see if it matches the ID of the MS of processing i.e. this MS . If block determines the recipient matches this MS then block see discussions performs the atomic send command locally and processing continues back to block for the next recipient. If block determines the recipient is an other MS block prepares parameters for processing and block invokes the procedure of for sending the data send command operand and parameters to the other MS. Processing then continues back to block for the next recipient. Blocks and can use the attributes parameter to affect how Parameters is to be interpreted. The attributes parameter may be modified and can be used by any processes which receive the send result.

MS2MS processing is as already described above see except performs sending data for the send command to a remote MS and blocks through carry out processing specifically for the send command. Block processes the send command locally like block see .

In Parameters for the atomic send command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks through and or through required . In yet another embodiment no defaulting or some defaulting of parameters is implemented. In some embodiments any subset of send commands will utilize email distributions for processing between MSs. In other embodiments any subset of send commands will utilize for processing between MSs. Operations of the send command can be carried out regardless of the transport that is actually used to perform the send command.

With reference back to note that the column of information headed by 101 represents the parameters applicable for the Send command. The Send command has the following parameters all of which are interpreted in context of the Operand 

Block validates Parameters some of which may have been defaulted in previous blocks and and continues to block . If bock determines there is an error in Parameters then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines that Parameters are in good order for using the email transport then block updates an email object in context for the notify command Operand and Parameters block uses a send email interface to notify through email and block returns to the caller e.g. block . Block can use the attributes parameter to affect how Parameters is to be interpreted. The attributes parameter may be modified and can be used by any processes which receive the notify. The email interface used at block will be one suitable for the underlying operating system and available development environments for example a standardized SMTP interface and other messaging capability as described above for .

While there are Notify command embodiments that make using an existing transport layer e.g. email more suitable than not even the most customized Notify command Operands can use email instead of MS2MS by implementing one or more recognizable signature s indication s or the like of in the email distribution to be used for informing a receiving email system to treat the email uniquely for carrying out the present disclosure. Depending on the embodiment integrated processing code is maintained built as part of the email system or processing code is plugged hooked into an existing email system in an isolated third party manner. Regardless the email system receiving the present disclosure email will identify the email as being one for special processing. Then email contents is parsed out and processed according to what has been requested.

In embodiments where Notify command Operands are more attractively implemented using an existing transport layer e.g. email those notify commands can also be sent with MS2MS encoded in data packet s that are appropriate for processing.

Referring back to block if it is determined that the Operand indicates to not use an email transport e.g. use a MS2MS transport for performing the notify command or notify command is to be processed locally then block checks if a sender parameter was specified. If block determines a sender was specified processing continues to block otherwise block defaults one e.g. valid MS ID and then processing continues to block . Block checks if a subject message parameter was specified. If block determines a subject message was specified processing continues to block otherwise block defaults one and then processing continues to block . Block may specify a null message. Block checks if an attributes parameter was specified. If block determines attributes were specified processing continues to block otherwise block defaults attributes e.g. confirmation of delivery high priority etc and then processing continues to block . Block checks if at least one recipient parameter was specified. If block determines at least one recipient was specified processing continues to block otherwise block defaults one e.g. valid ID for this MS and then processing continues to block . Block may specify a null recipient list so as to cause an error in later processing detected at block .

Block validates Parameters some of which may have been defaulted in previous blocks and and continues to block . If bock determines there is an error in Parameters then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines that Parameters are in good order then block updates a data object in context for the notify command Operand and Parameters and block begins a loop for delivering the data object to each recipient. Block gets the next or first recipient from the recipient list and processing continues to block .

If block determines that all recipients have been processed then processing returns to the caller at block otherwise block checks the recipient to see if it matches the ID of the MS of processing i.e. this MS . If block determines the recipient matches this MS then block see discussions performs the atomic notify command locally and processing continues back to block for the next recipient. If block determines the recipient is an other MS block prepares parameters for processing and block invokes the procedure of for sending the data notify command operand and parameters to the other MS. Processing then continues back to block for the next recipient. Blocks and can use the attributes parameter to affect how Parameters is to be interpreted. The attributes parameter may be modified and can be used by any processes which receive the notify result.

MS2MS processing is as already described above see except performs sending data for the notify command to a remote MS and blocks through carry out processing specifically for the notify command. Block processes the notify command locally like block see .

In Parameters for the atomic notify command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks through and or through required . In yet another embodiment no defaulting or some defaulting of parameters is implemented. In some embodiments any subset of notify commands will utilize email distributions for processing between MSs. In other embodiments any subset of notify commands will utilize for processing between MSs. Operations of the notify command can be carried out regardless of the transport that is actually used to perform the notify command.

With reference back to note that the column of information headed by represents the parameters applicable for the Notify command. The Notify command has the following parameters all of which are interpreted in context of the Operand 

An example of block is similar to the Microsoft Windows XP Microsoft and Windows XP are trademarks of Microsoft corp. O S association of applications to file types for convenient application launch. For example a user can double click a file e.g. when viewing file system from Window Explorer and the appropriate application will be launched for opening the file assuming an application has been properly registered for the file type of the file opened. In a Windows graphical user interface scenario registration of an application to the file type is achieved for example from the user interface with the File Types tab of the Folder Options option of the File Types pulldown of the Windows Explorer interface. There a user can define file types and the applications which are to be launched when selecting invoking e.g. double clicking the file type from the file system. Alternatively an O S API or interface may be used to configure an object to associate to a launch able executable for handling the object. In this same scheme the MS will have a similar mechanism whereby an association of an application to a type of object e.g. file type has been assigned. Block makes use of the system interface for association which was set up outside of present disclosure processing e.g. via MS O S .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the applicable application for composing the object passed as a parameter then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block for returning to the caller.

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for composing the object passed as a parameter then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues to block for returning to the caller.

Referring back to block if it is determined that the Operand indicates to perform the compose command locally e.g. use operating system interface e.g. set semaphore program object data signal etc then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines there were no parameter errors then block performs the compose command and block returns to the caller.

In Parameters for the atomic compose command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

With reference back to note that the column of information headed by represents the parameters applicable for the Compose command. The Compose command has the following parameters all of which are interpreted in context of the Operand 

Compose command data is preferably maintained to LBX history a historical call log e.g. outgoing when call placed or other useful storage for subsequent use some embodiments may include this processing where appropriate e.g. as part of blocks etc .

An example of block is similar to the Microsoft Windows XP O S association of applications to file types for convenient application launch and is the same as processing of block described above. Block makes use of the system interface for association which was set up outside of present disclosure processing e.g. via MS O S .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the applicable application for the object passed as a parameter then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block for returning to the caller.

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for the object passed as a parameter then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues to block for returning to the caller.

Referring back to block if it is determined that the Operand indicates to perform the connect command locally e.g. use operating system interface e.g. set semaphore program object data signal etc or to use MS2MS for processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines there were no parameter errors then block checks the operand for which processing to perform. If block determines that MS2MS processing is needed to accomplish processing then block prepares parameters for processing and block invokes the procedure of for sending the data connect command operand and parameters for connect processing at the MS to connect. Processing then continues to block . MS2MS processing is as already described above see except performs sending data for the connect command to the remote MS for processing and blocks through carry out processing specifically for the connect command. Block processes the connect command for connecting the MSs in context of the Operand. Referring back to block if it is determined that MS2MS is not to be used then block performs the connect command and block returns to the caller.

In Parameters for the atomic connect command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

In the case of automatically dialing a phone number at a MS there are known APIs to accomplish this functionality depending on the MS software development environment by passing at least a phone number to the MS API programmatically at the MS e.g. see C phone application APIs J2ME phone APIs etc . In a J2ME embodiment you can place a call by calling the MIDP 2.0 platformRequest method inside the MIDIet class e.g. platformRequest tel mobileNumber will request the placing call functionality from the applicable mobile platform .

With reference back to note that the column of information headed by represents the parameters applicable for the Connect command. The Connect command has the following parameters all of which are interpreted in context of the Operand 

Connect command data is preferably maintained to LBX history a historical call log e.g. outgoing when call placed or other useful storage for subsequent use some embodiments may include this processing where appropriate e.g. as part of blocks etc .

In one embodiment block causes processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the find command perhaps involving search of storage memory or operating system resources which is shared by many MSs.

Referring back to block if it is determined that the system for processing is the MS of processing then processing continues to block for checking which Operand was passed. If block determines the Operand indicates to launch a search application for the sought operand with a standard contextual object type interface then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns back to block . If block determines there were no parameter errors then block interfaces to the MS operating system to start the search application for the particular object passed as a parameter. Block may prepare parameters in preparation for the O S contextual launch for example if parameters are passed to the application which is invoked for finding the object. Processing leaves block and returns to block .

An example of block is similar to the Microsoft Windows XP association of applications to file types for convenient application launch just as was described above for block .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the applicable search application for finding the object passed as a parameter then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block .

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for finding the object passed as a parameter then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues back to block .

Referring back to block if it is determined that the Operand indicates to perform the find command with other local processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then block checks the operand for which find processing to perform and performs find processing appropriately.

Referring back to block if it is determined that there are no remaining unprocessed system parameters then processing returns to the caller at block .

In Parameters for the atomic find command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

With reference back to note that the column of information headed by represents the parameters applicable for the Find command. The Find command has the following parameters all of which are interpreted in context of the Operand 

Find command processing discussed thus far demonstrates multithreaded multiprocessed processing for each system to search. In one embodiment the same methodology is used for each system and each launched find processing saves results to a common format and destination. In this embodiment block processing continues to a new block when all systems are processed. New block gathers the superset of find results saved and then launches an application perhaps the same one that was launched for each find to show all results found asynchronously from each other. The application launched will be launched with the same choice of schemes as blocks through . Block then continues to block . This design requires all applications invoked to terminate themselves after saving search results appropriately for gathering a superset and presenting in one find results interface. Then the new block handles processing for a single application to present all search results.

In another embodiment while an application may be launched multiple times for each system the application itself is relied upon for handling multiple invocations. The application itself has intelligence to know it was re launched thereby permitting a single resulting interface for multiple target system searches regardless of the number of times the same search application was launched.

In one preferred embodiment find processing permits multiple instances of a search application launched wherein Find processing is treated independently this is shown in .

Preferably all find command embodiments provide the ability to perform other commands e.g. Copy Move Discard Change Administrate etc wherever possible from the resulting interface in context for each search result found.

Find command data is preferably maintained to LBX history a historical log or other useful storage for subsequent use some embodiments may include this processing where appropriate . Additional find command parameters can be provided for how and where to search e.g. case sensitivity get all or first how to present results etc .

If block determines the Operand is not for the email messaging transport use then processing continues to block for getting the next or first system parameter block starts an iterative loop for processing system s . At least one system parameter is required for the invoke command at block . If at least one system is not present for being processed by block then block will handle the error and continue to block for returning to the caller not shown considered obvious error handling or was already validated at configuration time . Block continues to block . If block determines that an unprocessed system parameter remains then processing continues to block . If block determines the system is not the MS of processing then MS2MS processing is used to accomplish the remote invoke processing in which case block continues to block for preparing parameters for processing and block invokes the procedure of for sending the data invoke command operand and parameters for remote invoke processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above see except performs sending data for the invoke command to the remote MS for an invocation at the remote MS and blocks through carry out processing specifically for the invoke command. Block processes the invoke command for invocation in context of the Operand at the MS of processing e.g. using invocation methodologies of .

In one embodiment blocks and cause processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the invoke command perhaps involving invocation of a suitable executable in context for the operand.

Referring back to block if it is determined that the system for processing is the MS of processing then processing continues to block for checking which Operand was passed. If block determines the Operand indicates to invoke launch an appropriate application for the operand with a standard contextual object type interface then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns back to block . If block determines there were no parameter errors then block interfaces to the MS operating system to start the appropriate application for the particular object passed as a parameter. Block may prepare parameters in preparation for the O S contextual launch for example if parameters are passed to the application which is invoked. Processing leaves block and returns to block .

An example of block is similar to the Microsoft Windows XP association of applications to file types for convenient application launch just as described above for block .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom invocation launch is not to use an Application Programming Interface API to invoke the application for the object passed as a parameter then block prepares a command string for invoking the particular application block invokes the command string for launching the application and processing continues to block .

If block determines the custom invocation launch is to use an Application Programming Interface API to invoke the applicable for the object passed as a parameter then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues back to block .

Referring back to block if it is determined that the Operand indicates to perform the invoke command with other local processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then block checks the operand for which invoke processing to perform and performs invoke command processing appropriately.

Referring back to block if it is determined that there are no remaining unprocessed system parameters then processing returns to the caller at block .

In Parameters for the atomic invoke command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

With reference back to note that the column of information headed by 109 represents the parameters applicable for the Invoke command. The Invoke command has the following parameters all of which are interpreted in context of the Operand 

In some embodiments the invoke command may be used as an overall strategy and architecture for performing most if not all actions e.g. other commands .

If block determines the source system parameter source is this MS then processing continues to block . If block determines the Operand indicates to launch a search application for the sought operand object with a standard contextual object type interface then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines there were no parameter errors then block interfaces to the MS operating system to start the search application for the particular object for Operand . Block may prepare parameters in preparation for the operating system. Processing leaves block and continues to block which is discussed below.

An example of block is similar to the Microsoft Windows XP association of applications to file types for convenient application launch just as was described above for block .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller at block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the searching application for copying the object then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block discussed below.

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for searching then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues to block .

Referring back to block if it is determined that the Operand indicates to perform the copy command with local search processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller at block . If block determines there were no parameter errors then block searches for the operand object in context for the Operand and processing continues to block .

Referring back to block if it is determined the source parameter is not for this MS then block prepares parameters for processing. Thereafter block checks to see if there were any parameter errors since block also validates them prior to preparing them. If block determines there was at least one parameter error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller at block . If block determines there were no errors then block invokes the procedure of for sending the data copy command operand and parameters for remote copy search processing at the remote MS. Processing then continues to block discussed below. MS2MS processing is as already described above see except performs searching for data for the copy command at the remote MS and blocks through carry out processing specifically for the copy command search processing. Block processes the copy command for finding the object to copy in context of the Operand. Blocks and will return the results to the requesting MS of processing and block will complete appropriate copy search processing so that processing receives the search results. can convey the found object s for copy by returning from a function interface the send procedure being a function returning to a file setting data visible to both processes etc. Note that block may invoke application launch processing e.g. like found in for invoking the best application in the appropriate manner for determining copy search results returned from processing or block may process results itself.

In one embodiment block causes processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the find command perhaps involving search of storage memory or operating system resources which are shared by many MSs.

By the time processing reaches block from any previous processing a search result is communicated to processing and any launched executable application for searching for the copy object s has terminated. Search results can be passed back as a function return placed to a well known directory placed to a file placed to interfaced variable s or other communications of the result to further processing. Regardless of the embodiment search results are accessed at block . An alternate embodiment is like wherein the application processing invoked at blocks and handles the ack parameter and ambiguous results appropriately i.e. no need for blocks through to proceed with completing the copy processing of blocks through incorporated . Different methods are disclosed for similar processing to highlight methods for carrying out processing for either one of the commands Copy or Discard .

Block checks the results of finding the source object for copying to ensure there are no ambiguous results i.e. not sure what is being copied since the preferred embodiment is to not copy more than a single operand object at a time . If block determines that there was an ambiguous search result then processing continues to block for error handling as discussed above e.g. in context for an ambiguous copy since there were too many things to copy . If block determines there is no ambiguous entity to copy block checks the acknowledgement parameter passed to processing. An alternate embodiment assumes that a plurality of results is valid for copying all results to the target system s i.e. no ambiguous check . In another embodiment an ambiguous result relies on user reconciliation to reconcile whether or not to perform the copy like discard processing .

If block determines the acknowledgement ack parameter is set to true then block provides the search result which is to be copied. Thereafter processing waits for a user action to either a continue with the copy or b cancel the copy. Once the user action has been detected processing continues to block . Block provides a user reconciliation of whether or not to perform the copy. In another embodiment there is no ack parameter and multiple results detected at block forces processing into the reconciliation by the MS user. In yet another embodiment the ack parameter is still provided however multiple search results forces processing into the reconciliation by the MS user anyway for selecting which individual object shall be copied. In still other embodiments all results are copied.

If block determines the user selected to cancel processing then block logs the cancellation e.g. log error to LBX History and processing returns to the caller at block . If block determines the user selected to proceed with the copy then processing continues to block for getting the next or first system parameter block starts a loop for processing system s for the copy result . Also if block determines that the ack parameter was set to false then processing continues directly to block . At least one system parameter is required for the copy as validated by previous parameter validations. Block continues to block . If block determines that an unprocessed system parameter remains then processing continues to block . If block determines the system target for copy is the MS of processing then block appropriately copies the source object to the system and processing continues back to block . If block determines the system is not the MS of processing then MS2MS processing is used to accomplish the copy processing to the remote data processing system e.g. MS in which case block prepares parameters for processing and block invokes the procedure of for sending the data copy command operand and search result for remote copy processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above see except performs sending data for the copy action to the remote MS for copying sought operand dependent criteria to the remote MS and blocks through carry out processing specifically for the copy processing. Block processes the copy of the search result from to the system of processing.

In one embodiment blocks and cause processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the copy command perhaps involving storage memory or operating system resources which are shared by many MSs.

Referring back to block if it is determined that there are no remaining unprocessed system parameters then processing returns to the caller at block .

In Parameters for the atomic copy command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

The first parameter may define a plurality of entities to be copied when the object inherently contains a plurality e.g. directory container . In an alternate embodiment the search results for copying can be plural without checking for ambiguity at block in which case all results returned can will be copied to the target systems.

With reference back to note that the column of information headed by represents the parameters applicable for the Copy command. The Copy command has the following parameters all of which are interpreted in context of the Operand 

In a preferred embodiment an additional parameter is provided for specifying the target destination of the system for the copy. For example a directory can be placed to a target path an email can be placed to a target folder etc. Otherwise there is an assumed target destination. In another embodiment a user can select from a plurality of search results which objects are to be copied.

Blocks and will return the results to the requesting MS of processing when the ack parameter is set to true and block will complete appropriate discard processing after prompting the user of the MS of processing for whether or not to continue just like blocks through discussed below . Note that block may include invoking the best application in the appropriate manner e.g. like found in with the discard results returned when an acknowledgement ack parameter has been specified to true or block may process results appropriately itself. Processing should be enabled for then continuing with the discard through another invocation of from block and a following processing of blocks through to do the discard if the user chooses to do so. Block includes significant processing all of which has been disclosed in anyway and then included at block if needed there for ack processing.

In one embodiment block causes processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the discard command perhaps involving search of storage memory or operating system resources which are shared by many MSs.

Referring back to block if it is determined that the system for processing is the MS of processing then processing continues to block for checking which Operand was passed. If block determines the Operand indicates to launch a search application for the sought operand with a standard contextual object type interface then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns back to block . If block determines there were no parameter errors then block interfaces to the MS operating system to start the search application for the particular object passed as a parameter and then to continue with the discard for ack set to false and to prompt for doing the discard for the prompt set to true. Block may prepare parameters in preparation for the operating system for example if parameters are passed to the application which is invoked for discarding the object. Processing leaves block and returns to block . An alternate embodiment processes like wherein the application launched at block produces only a search result prior to continuing to block . Then the search result is discarded if there are no ambiguous results or the ack parameter is set to false or there are ambiguous results and the user selects to continue or the ack parameter is set to true and the user selects to continue. demonstrates processing where the executable launched is an all inclusive processing. Likewise can be like wherein the application launched handles the ack parameter appropriately. Different methods are disclosed for similar processing to highlight methods to carrying out processing for either one of the commands Copy or Discard .

An example of block is similar to the Microsoft Windows XP association of applications to file types for convenient application launch just as was described above for block .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the applicable search application for discarding the object passed as a parameter then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block . An alternate embodiment processes like wherein the application launched at block produces only a search result prior to continuing to block . Then the search result is discarded if there are no ambiguous results or the ack parameter is set to false or there are ambiguous results and the user selects to continue or the ack parameter is set to true and the user selects to continue. demonstrates processing where the executable launched is an all inclusive processing e.g. includes processing of blocks through .

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for discarding the object passed as a parameter then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues back to block . An alternate embodiment processes like wherein the application launched at block produces only a search result prior to continuing to block . Then the search result is discarded if there are no ambiguous results or the ack parameter is set to false or there are ambiguous results and the user selects to continue or the ack parameter is set to true and the user selects to continue. demonstrates processing where the executable launched is an all inclusive processing includes processing of blocks through .

Referring back to block if it is determined that the Operand indicates to perform the discard command with other local processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then block checks the operand for which discard processing to perform and performs discard search processing appropriately. Thereafter block checks the results.

Block checks the results of finding the source object for discard to ensure there are no ambiguous results i.e. not sure what is being discarded since the preferred embodiment is to not discard more than a single operand object at a time . If block determines that there was an ambiguous search result then processing continues to block . If block determines there is no ambiguity then processing continues to block . If block determines the ack parameter is set to true then processing continues to block otherwise processing continues to block . Block checks the acknowledgement parameter passed to processing. An alternate embodiment assumes that a plurality of results is valid and discards all results at the target system s i.e. no ambiguous check . In another embodiment an ambiguous result causes error handling at block like copy processing .

Block causes processing for waiting for a user action to either a continue with the discard or b cancel the discard. Once the user action has been detected processing continues to block . Block provides a user reconciliation of whether or not to perform the discard. In another embodiment there is no ack parameter and multiple results detected at block are handled for the discard.

If block determines the user selected to cancel processing then block logs the cancellation e.g. log error to LBX History and processing returns to block . If block determines the user selected to proceed with the discard then processing continues to block . Block performs the discard of the object s found at block . Thereafter processing continues back to block .

Referring back to block if it is determined that there are no remaining unprocessed system parameters then processing returns to the caller at block .

In Parameters for the atomic discard command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

With reference back to note that the column of information headed by represents the parameters applicable for the Discard command. The Discard command has the following parameters all of which are interpreted in context of the Operand 

Discard command processing discussed thus far demonstrates multithreaded multiprocessed processing for each system to search. In search results processing for example when a plurality of results for discard are available an application may be launched multiple times. For each system the application itself is relied upon for handling multiple invocations. The application itself has intelligence to know it was re launched thereby permitting a single resulting interface for multiple target system searches regardless of the number of times the same search application was launched. In a preferred embodiment discard processing permits multiple instances of a search application launched. In another embodiment a user selects which of a plurality of results are to be discarded prior to discarding.

If block determines the source system parameter source is this MS then processing continues to block . If block determines the Operand indicates to launch a search application for the sought operand object with a standard contextual object type interface then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller invoker at block . If block determines there were no parameter errors then block interfaces to the MS operating system to start the search application for the particular object. Block may prepare parameters in preparation for the operating system. Processing leaves block and continues to block which is discussed below.

An example of block is similar to the Microsoft Windows XP association of applications to file types for convenient application launch just as was described above for block .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller at block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the searching application for moving the object then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block discussed below.

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for searching then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues to block .

Referring back to block if it is determined that the Operand indicates to perform the move command with local search processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller at block . If block determines there were no parameter errors then block searches for the operand object in context for the Operand and processing continues to block .

Block checks the results of finding the source object for moving to ensure there are no ambiguous results i.e. not sure what is being moved since the preferred embodiment is to not move more than a single operand object at a time . If block determines there was an ambiguous search result then processing continues to block for error handling as discussed above e.g. in context for an ambiguous move since there were too many things to move . If block determines there is no ambiguous entity to move block checks the acknowledgement parameter passed to processing. An alternate embodiment assumes that a plurality of results is valid and moves all results to the target system s i.e. no ambiguous check . In another embodiment an ambiguous result relies on user reconciliation to reconcile whether or not to perform the move like discard processing .

If block determines the acknowledgement ack parameter is set to true then block provides the search result which is to be moved. Thereafter processing waits for a user action to either a continue with the move or b cancel the move. Once the user action has been detected processing continues to block . Block provides a user reconciliation of whether or not to perform the move. In another embodiment there is no ack parameter and multiple results detected at block forces processing into the reconciliation by the user. In yet another embodiment the ack parameter is still provided however multiple search results forces processing into the reconciliation by the MS user anyway for selecting which individual object shall be moved. In still other embodiments all results are moved.

If block determines the user selected to cancel processing then block logs the cancellation e.g. log error to LBX History and processing returns to the caller at block . If block determines the user selected to proceed with the move then processing continues to block for getting the next or first system parameter block starts an iterative loop for processing system s for the move result . Also if block determines that the ack parameter was set to false then processing continues directly to block . At least one system parameter is required for the move as validated by previous parameter validations. Block continues to block .

If block determines that an unprocessed system parameter remains then processing continues to block . If block determines the system target for move is the MS of processing then block appropriately moves the source object to the system and processing continues back to block . If block determines the system is not the MS of processing then MS2MS processing is used to accomplish the move processing to the remote data processing system e.g. MS in which case block prepares parameters for processing and block invokes the procedure of for sending the data move command operand and search result for remote move processing at the remote MS. Processing then continues back to block . MS2MS processing is as already described above see except performs sending data for the move action to the remote MS for moving sought operand dependent criteria to the remote MS and blocks through carry out processing specifically for the move processing. Block processes the move of the search result from to the system of processing.

Referring back to block if it is determined the source parameter is not for this MS then block prepares parameters for processing. Thereafter block checks to see if there were any parameter errors since block also validates them prior to preparing them. If block determines there was at least one parameter error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to the caller at block . If block determines there were no errors then block invokes the procedure of for sending the data move command operand and parameters for remote move search processing at the remote MS. Processing then continues to block discussed below. In one embodiment the object s to move are discarded from the source system via block in preparation for the move command processing at blocks and . In another embodiment the object s to move will be discarded from the source system when completing move processing at blocks or . MS2MS processing via block is as already described above see except performs searching for data for the move command at the remote MS and blocks through carry out processing specifically for at least the move command search processing for the source system. Block processes the move command for finding the object to move in context of the Operand. Blocks and will return the results to the requesting MS of processing and block will complete appropriate move search processing so that processing receives the search results. can convey the found object s for the move by returning from a function interface the send procedure being a function returning to a file setting data visible to both processes etc. Note that block may include application launch processing e.g. like found in for invoking the best application in the appropriate manner for determining move search results returned from processing or block may process returned results itself.

In one embodiment block causes processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the find command perhaps involving search of storage memory or operating system resources which are shared by many MSs.

By the time processing reaches block from any previous processing a search result is communicated to processing and any launched executable application for searching for the move object s has terminated. Search results can be passed back as a function return placed to a well known directory placed to a file placed to interfaced variable s or other communications of the result to further processing. Regardless of the embodiment search results are accessed at block . An alternate embodiment is like wherein the application processing invoked at blocks and handles the ack parameter and ambiguous results appropriately i.e. no need for blocks through to proceed with completing the move processing of blocks through incorporated . Different methods are disclosed for similar processing to highlight methods for carrying out processing for either one of the commands Move or Discard .

In one embodiment blocks and cause processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the move command perhaps involving storage memory or operating system resources which are shared by many MSs.

Referring back to block if it is determined that there are no remaining unprocessed system parameters then processing returns to the caller at block .

In Parameters for the atomic move command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

The first parameter may define a plurality of entities to be moved when the object inherently contains a plurality e.g. directory container . In an alternate embodiment the search results for moving can be plural without checking for ambiguity at block in which case all results returned will be moved to the target systems.

With reference back to note that the column of information headed by 115 represents the parameters applicable for the Move command. The Move command has the following parameters all of which are interpreted in context of the Operand 

In an alternate embodiment an additional parameter is provided for specifying the target destination of the system for the move. For example a directory can be placed to a target path an email can be placed to a target folder etc.

In one embodiment block causes processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the store command perhaps involving search of storage memory or operating system resources which are shared by many MSs.

Referring back to block if it is determined that the system for processing is the MS of processing then processing continues to block for checking which Operand was passed. If block determines the Operand indicates to launch a store application for the sought operand with a standard contextual object type interface then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns back to block . If block determines there were no parameter errors then block interfaces to the MS operating system to start the storing application for the particular object passed as a parameter. Block may prepare parameters in preparation for the operating system for example if parameters are passed to the application which is invoked for storing the object. Processing leaves block and returns to block .

An example of block is similar to the Microsoft Windows XP association of applications to file types for convenient application launch just as was described above for block .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the applicable application for storing the object passed as a parameter then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block .

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for storing the object passed as a parameter then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues back to block .

Referring back to block if it is determined that the Operand indicates to perform the store command with other local processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then block checks the operand for which store processing to perform and performs store processing appropriately.

Referring back to block if it is determined that there are no remaining unprocessed system parameters then processing returns to the caller at block .

In Parameters for the atomic store command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

With reference back to note that the column of information headed by represents the parameters applicable for the Store command. The Store command has the following parameters all of which are interpreted in context of the Operand 

In one embodiment block causes processing at a remote data processing system which incorporates similar MS2MS processing but the remote data processing system is not a MS i.e. system parameter is for a data processing system identifier accessible to the MS of processing . The remote data processing system may be a service data processing system or any other data processing system capable of similar MS2MS processing as described for the administrate command perhaps involving search of storage memory or operating system resources which are shared by many MSs.

Referring back to block if it is determined that the system for processing is the MS of processing then processing continues to block for checking which Operand was passed. If block determines the Operand indicates to launch the administration application for the sought operand with a standard contextual object type interface then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns back to block . If block determines there were no parameter errors then block interfaces to the MS operating system to start the administration application for the particular object passed as a parameter. Block may prepare parameters in preparation for the operating system for example if parameters are passed to the application which is invoked for administration of the object. Processing leaves block and returns to block .

An example of block is similar to the Microsoft Windows XP association of applications to file types for convenient application launch just as was described above for block .

Referring back to block if it is determined the Operand does not indicate to launch with a standard contextual object type interface processing continues to block . If block determines the Operand indicates to perform a custom launch then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then processing continues to block .

If block determines the custom launch is not to use an Application Programming Interface API to launch the applicable administration application for administration of the object passed as a parameter then block prepares a command string for launching the particular application block invokes the command string for launching the application and processing continues to block .

If block determines the custom launch is to use an Application Programming Interface API to launch the applicable application for administration of the object passed as a parameter then block prepares any API parameters as necessary block invokes the API for launching the application and processing continues back to block .

Referring back to block if it is determined that the Operand indicates to perform the administrate command with other local processing then parameter s are validated at block and block checks the result. If block determines there was at least one error then block handles the error appropriately e.g. log error to LBX History and or notify user and processing returns to block . If block determines there were no parameter errors then block checks the operand for which administration processing to perform and performs administration processing appropriately.

Referring back to block if it is determined that there are no remaining unprocessed system parameters then processing returns to the caller at block .

In Parameters for the atomic administrate command in accordance with the Operand were shown to be validated for being properly privileged prior to processing by processing . However an alternate embodiment could move some or all applicable privilege validation to in context of where the Parameters are processed. Also some embodiments may not validate Parameters since they or some reasonable subset thereof can be understood to be in good order by the time processing occurs e.g. no blocks and or and or required . In yet another embodiment some defaulting of parameters is implemented.

With reference back to note that the column of information headed by is not shown. However it is assumed to be present . . . . The Administrate command has the following parameters all of which are interpreted in context of the Operand 

Administrate command processing discussed thus far demonstrates multithreaded multiprocessed processing for each system to perform administration. In one embodiment the same methodology is used for each system and each launched administrate processing saves results to a common format and destination. In this embodiment block processing continues to a new block when all systems are processed. New block gathers the superset of administrate results saved and then launches an application perhaps the same one that was launched for each administrate to show all results found asynchronously from each other. The application launched will be launched with the same choice of schemes as blocks through . Block then continues to block . This design will want all applications invoked to terminate themselves after saving search results appropriately. Then the new block starts a single administration application to present all search results for performing the administration.

In another embodiment while an application may be launched multiple times for each system the application itself is relied upon for handling multiple invocations. The application itself has intelligence to know it was re launched thereby permitting a single resulting interface for multiple target system searches regardless of the number of times the same search application was launched.

In one preferred embodiment administrate processing permits multiple instances of a search application launched. Administrate processing is treated independently this is shown in .

Preferably all administrate command embodiments provide the ability to perform other commands e.g. Copy Move Discard Change . . . wherever possible from the resulting interface in context for each search result found.

There are many other reasonable commands and operands some of which may intersect processing by other commands. For example there is a change command. The change command can be described by operand as the other commands were except the change command has identical processing to other commands for a particular operand. There are multiple commands duplicated with the change command depending on the operand of the change command like Connect command overlap of functionality . depicts a flowchart for describing a preferred embodiment of a procedure for Change command action processing and depicts a flowchart for describing one embodiment of a procedure for Change command action processing as derived from the processing of .

Charters certainly provide means for a full spectrum of automated actions from simple predicate based conditional alerts to complex application processing. Actions includes API invocations executable script invocations e.g. from command line executable program invocations O S contextual launch executions integrated execution processing e.g. part of block processing or any other processing executions. As incoming WDRs indicate that a MS MS user of interest is nearby charters provide the mechanism for the richest possible executions of many varieties to be automatically processed. From as simple a use as generating nearby nearness distantness status to performing a complicated set of processing based on nearby nearness distantness relative a MS user there is no limit to the processing that can occur. All of the processing is handled locally by the MS and no connected service was required.

A first LBX enabled MS with phone capability can have a charter configuration for automatically placing a call to a second LBX enabled MS user upon determining that the second MS is close by the first MS user for example when both users are coincidentally nearby each other. Perhaps the users are in a store at the same time or are attending an event without knowledge of each other s attendance. It is cool to be able to cause an automatic phone call for connecting the users by conversation to then determine that they should hook up since they are nearby. Furthermore a charter at the first MS can be configured wherein the first MS automatically dials calls the second MS user or alternatively a charter at the first MS can be configured wherein the second MS automatically dials calls the first MS user provided appropriate privileges are in place.

If at block it is determined the user attempted to paste WDR information from an untimely WDR then block provides the user with a warning preferably including how stale the WDR information is and processing waits for a user action to proceed with the paste or cancel the paste. Thereafter if block determines the user selected to cancel the paste operation then processing terminates at block otherwise processing continues to block .

Referring back to block if it determined the paste operation is not for a WDRTerm then processing continues directly to block for pasting the other Term construct terms being referenced by the paste operation i.e. atomic term AppTerm etc .

In another embodiment the keystroke sequence for the particular paste operation includes a keystroke as defined in a prefix or in a new record field for an application so that particular application field s are accessible from WDR Application fields . In other embodiments there are special paste actions for LBX maintained statistics whereabouts information averages or any other useful current or past LBX data including from LBX History . In another embodiment there are special paste actions for predicted data which is based on current and or passed LBX data for example using an automated analysis of a plurality of WDRs application terms atomic terms statistics or information thereof.

Application fields are preferably set in a WDR when it is completed for queue insertion for processing . This ensures WDRs which are in process to queue contain the information at appropriate times. This also ensures the WDRs which are to be sent outbound contain the information at the appropriate time and ensures the WDRs which are to be received inbound contain the information at the appropriate time. Fields may be set when processing at inbound time as well. Application fields can add a significant amount of storage to a WDR. Alternate embodiments may not maintain field to queue but rather append information or an appropriate subset thereof to field when sending WDRs outbound to minimize storage WDRs utilize at a MS. This alternate embodiment will enable appropriate WITS processing for maintained WDRs inbound WDRs and outbound WDRs without an overhead of maintaining lots of data to queue however application fields functionality will be limited to application data from an outbound originated perspective rather than application field setting at the time of an in process WDR regardless of when it was in process. For example field may alternatively be set at blocks and and then stripped after being processed by receiving MSs prior to any insertion to queue . In some embodiments certain field data can be enabled or disabled for being present in WDR information.

Preferably there are WDRTerms for referencing each reasonable application fields section individually as a subset or as a set. For example  appfld.appname.dataitem should resolve to the value of dataitem for the application section appname of application fields i.e.  appfld . The hierarchy qualification operator i.e. . indicates which subordinate member is being referenced for which organization is use of field . The requirement is the organization be consistent in the LN expanse e.g. data values for anticipated application categories . For example  appfld.email.source resolves to the email address associated with the email application of the MS which originated the WDR. For example  appfld.phone.id resolves to the phone number associated with the phone application of the MS which originated the WDR e.g. for embodiments where the MS ID is not the same as the MS caller id phone number . If a WDRTerm references an application field which is not present in a WDR then preferably a run time error during WITS processing is logged with ignoring of the expression and any assigned action or the applicable condition defaults to false. Preferably a user has control for enabling any application subsets of data in field

Application fields K specification processing begins at block upon a user action for the user interface processing of and continues to block where the user is presented with options. Thereafter block waits for a user input action. The user is able to specify any of a plurality of application data for enablement or disablement in at least outbound WDR fields . Various embodiments will support enablement disablement for inbound outbound or any other in process WDR event executable processing paths. Field can be viewed as containing application sections each section containing data for a particular type of MS application or a particular type of application data as described above.

Upon detection of a user action at block block checks if the user selected to enable a particular application section of fields . If block determines the user selected to enable a particular application fields section then block sets the particular indicator for enabling that particular application fields section and processing continues back to block . If block determines the user did not select to enable a particular application fields section then processing continues to block . If block determines the user selected to disable a particular application fields section then block sets the particular indicator for disabling that particular application fields section and processing continues back to block . If block determines the user did not select to disable a particular application fields section then processing continues to block . If block determines the user selected to disable sending profile information in a application fields section then block sets the profile participation variable to NULL i.e. disabled and processing continues back to block . If block determines the user did not select to disable sending profile information then processing continues to block . If block determines the user selected to enable sending profile information in a application fields section then block prompts the user for the file to be used for the profile preferably the last used or best used file is defaulted in the interface and block interfaces with the user for a validated file path specification. The user may not be able to specify a validated profile specification at block in which case the user can cancel out of block processing. Thereafter if block determines the user cancelled out of block processing processing continues back to block . If block determines the user specified a validated profile file then block sets the profile participation variable to the fully qualified path name of the profile file and processing continues back to block . Block preferably parses the profile to ensure it conforms to an LN expanse standard format or error processing is handled which prevents the user from leaving block with an incorrect profile.

In an alternate embodiment block additionally internalizes the profile for well performing access e.g. to a XML tag tree which can be processed . This alternate internalization embodiment for block would additionally require performing internalization after every time the user modified the profile in which case there could be a special editor used by the user for creating maintaining the profile a special user post edit process to cause internalization or some other scheme for maintaining a suitable internalization. In an embodiment which internalizes the profile from a special editor the special editor processing can also limit the user to what may be put in the profile and validate its contents prior to internalization. An internalized profile is preferably always in correct parse friendly form to facilitate performance when being accessed. In the embodiment of block which sets the fully qualified path name of the profile file a special editor may still be used as described or any suitable editor may be used but validation and obvious error handling may have to be performed when accessing the profile if not validated by block beyond a correct file path. Some embodiments may implement a profile in a storage embodiment that is not part of a file system.

If block determines the user did not select to enable profile information to be maintained to field then processing continues to block . If block determines the user selected to exit processing application fields specification processing terminates at block . If block determines the user did not select to exit then processing continues to block where any other user actions detected at block are handled appropriately. Block then continues back to block .

There can be many MS application sections of field which are enabled or disabled by blocks through . In the preferred embodiment of profile processing the profile is a human readable text file and any file of the MS can be compared to a profile of a WDR so that the user can maintain many profiles for the purpose of comparisons in expressions. Alternate embodiments include a binary file data maintained to some storage or any other set of data which can be processed in a similar manner as describe for profile processing. Some embodiments support specification of how to enable disable at blocks through derivatives for mW ITS iWITS and or oWITS.

In the preferred embodiment a profile text file contains at least one tagged section preferably using XML tags. Alternatively Standard Generalized Markup Language SGML or HTML may be used for encoding text in the profile. There may be no standardized set of XML tags although this would make for a universally consistent interoperability. The only requirement is that tags be used to define text strings which can be searched and compared. It helps for a plurality of users to know what tags each other uses so that comparisons can be made on a tag to tag basis between different profiles. A plurality of MS users should be aware of profile tags in use between each other so as to provide functionality for doing comparisons otherwise profiles that use different tags cannot be compared.

Indicators disabled or enabled as well as the profile participation variable is to be observed by WDR processing so that field is used accordingly. In some embodiments certain application field sections cannot be enabled or disabled by users i.e. a MS system setting . In preferred embodiments WITS processing checks these settings to determine whether or not to perform applicable processing. In some embodiments WITS processing checks these settings to strip out e.g. for setting s disabled information from a WDR which is to be in process.

This condition determines if the benchmark.xml file contains greater than 5 tag section matches in the entire WDR profile of the WDR in process. Text elements of the lowest order tag sections are used to decide the comparison results. A tag hierarchy if present facilitates how to compare. Six six or more matches evaluates to true otherwise the condition evaluates to false. d myprofs benchmark.xml 75 This condition determines if the benchmark.xml file contains greater than or equal to 75 of tag section matches in the entire WDR profile of the WDR in process. Contents that occurs between every tag is compared for a match. The number of matches found divided by the number of tag matches performed provides the percentage of matches after multiplying the result by 100 . The resulting percentage greater than or equal to 75 evaluates to true otherwise the condition evaluates to false. interests d myprofs benchmark.xml 2 In using as an example this condition determines if the benchmark.xml file contains greater than two 2 semicolon delimited matches within only the interests tag in the WDR profile of the WDR in process. If either the benchmark.xml file or the WDR profile does not contain the interests tag then the condition evaluates to false. If both contain the interests tag then the semicolon delimited items which is interests tag delimited are compared. Three 3 or more semicolon delimited interests that match evaluates to true otherwise the condition evaluates to false.

WITS processing preferably uses an internalized form of to perform comparisons. The internalized form may be established ahead of time as discussed above for better WITS processing performance or may be manufactured by WITS processing in real time as needed.

As mentioned above architecture provides a set of processes which can be started or terminated for desired functionality. Thus architecture provides a palette from which to choose desired deployment methods for an LN expanse.

In some embodiments all whereabouts information can be pushed to expand the LN expanse. In such embodiments the palette of processes to choose from includes at least process process and process . Additionally process would be required in anticipation of LN expanse participating data processing systems having NTP disabled or unavailable. Additionally process could be used for ensuring whereabouts are timely e.g. specifically using all blocks except through . Depending on DLM capability of MSs in the LN expanse a further subset of processes and may apply. Thread s beacon whereabouts information regardless of the MS being an affirmifier or pacifier.

In some embodiments all whereabouts information can be pulled to expand the LN expanse. In such embodiments the palette of processes to choose from includes at least process e.g. specifically using all blocks except and process process and process . Additionally process would be required in anticipation of LN expanse participating data processing systems having NTP disabled or unavailable. Depending on DLM capability of MSs in the LN expanse a further subset of processes and may apply.

There are many embodiments derived from architecture . Essential components are disclosed for deployment varieties. In communications protocols which acknowledge a transmission processes may not be required even in absence of NTP use. A sending MS appends a sent date time stamp e.g. field on its time scale to outbound data and an acknowledging MS or service responds with the sent date time stamp so that when the sending MS receives it receives data or the sending MS now a receiving MS calculates a TDOA measurement by comparing when the acknowledgement was received and when it was originally sent. Appropriate correlation outside of process deployment enables the sending MS to know which response went with which data was originally sent. A MS can make use of processes as is appropriate for functionality desired.

In push embodiments disclosed above useful summary observations are made. Service s associated with antennas periodically broadcast beacon their reference whereabouts e.g. WDR information for being received by MSs in the vicinity. When such services are NTP enabled the broadcasts include a sent date time stamp e.g. field . Upon receipt by a NTP enabled MS in the vicinity the MS uses the date time stamp of MS receipt e.g. with the date time stamp of when sent e.g. field to calculate a TDOA measurement. Known wave spectrum velocity can translate to a distance. Upon receipt of a plurality of these types of broadcasts from different reference antennas the MS can triangulate itself for determining its whereabouts relative known whereabouts of the reference antennas. Similarly reference antennas are replaced by other NTP enabled MSs which similarly broadcast their whereabouts. A MS can be triangulated relative a mixture of reference antennas and other NTP enabled MSs or all NTP enabled MSs. Stationary antenna triangulation is accomplished the same way as triangulating from other MSs. NTP use allows determining MS whereabouts using triangulation achievable in a single unidirectional broadcast of data or . Furthermore reference antennas service s need not communicate new data and MSs need not communicate new data . Usual communications data are altered with a CK as described above. Usual communications data are altered with a CK as described above. This enables a MS with not only knowing there are nearby hotspots but also where all parties are located including the MS . Beaconing hotspots or other broadcasters do not need to know who you are the MS ID and you do not need to know who they are in order to be located. Various bidirectional correlation embodiments can always be used for TDOA measurements.

In pull embodiments disclosed above data processing systems wanting to determine their own whereabouts requestors broadcast their requests e.g. record . Service s or MSs responders in the vicinity respond. When responders are NTP enabled the responses include a sent date time stamp e.g. field that by itself can be used to calculate a TDOA measurement if the requestor is NTP enabled. Upon receipt by a requestor with no NTP the requestor uses the date time stamp of a correlated receipt e.g. with the date time stamp of when sent e.g. fields or to calculate a time duration TDOA for whereabouts determination as described above. New data or usual communications data applies as described above.

If NTP is available to a data processing system it should be used whenever communicating date time information e.g. NTP bit of field or so that by chance a receiving data processing is also NTP enabled a TDOA measurement can immediately be taken. In cases where either the sending first data processing system or receiving second data processing system is not NTP enabled then the calculating data processing system wanting a TDOA measurement will need to calculate a sent and received time in consistent time scale terms. This includes a correlated bidirectional communications data flow to properly determine duration in time terms of the calculating data processing system. In a send initiated embodiment a first sending data processing system incorporates a sent date time stamp e.g. fields or and determines when a correlated response is received to calculate the TDOA measurement both times in terms of the first sending data processing system . In another embodiment a second receiving data processing system receives a sent date time stamp e.g. field and then becomes a first sending data processing as described in the send initiated embodiment. Whatever embodiment is used it is beneficial in the LN expanse to minimize communications traffic.

The NTP bit in date time stamps enables optimal elegance in the LN expanse for taking advantage of NTP when available and using correlated transmissions when it is not. A NTP enabled MS is somewhat of a chameleon in using unidirectional data or received to determine whereabouts relative NTP enabled MS s and or service s and then using bidirectional data or relative MS s and or service s without NTP. A MS is also a chameleon when considering it may go in and out of a DLM or ILM identity role depending on what whereabouts technology is available at the time.

The MS ID or pseudo MS ID in transmissions is useful for a receiving data processing system to target a response by addressing the response back to the MS ID. Targeted transmissions target a specific MS ID or group of MS IDs while broadcasting is suited for reaching as many MS IDs as possible. Alternatively just a correlation is enough to target a data source.

In some embodiments where a MS is located relative another MS this is applicable to something as simple as locating one data processing system using the location of another data processing system. For example the whereabouts of a cell phone first data processing system is used to locate an in range automotive installed second data processing system for providing new locational applications to the second data processing system or visa versa . In fact the second data processing may be designed for using the nearby first data processing system for determining its whereabouts. Thus as an MS roams in the know of its own whereabouts the MS whereabouts is shared with nearby data processing systems for new functionality made available to those nearby data processing systems when they know their own whereabouts by associating to the MS whereabouts . Data processing systems incapable of being located are now capable of being located for example locating a data processing equipped shopping cart with the location of an MS or plurality of MSs.

Architecture presents a preferred embodiment for IPC Interprocess Communications Processing but there are other embodiments for starting terminating threads signaling between processes semaphore controls and carrying out present disclosure processing without departing from the spirit and scope of the disclosure. In some embodiments threads are automatically throttled up or down e.g. Max per unique requirements of the MS as determined by how often threads loop back to find an entry already waiting in a queue. If thread s spend less time blocked on queue they can be automatically throttled up. If thread s spend more time blocked on queue they can be automatically throttled down. Timers can be associated with queue retrieval to keep track of time a thread is blocked.

LBX history preferably maintains history information of key points in processing where history information may prove useful at a future time. Some of the useful points of interest may include 

Location applications can use the WDR queue for retrieving the most recent highest confidence entry or can access the single instance WDR maintained or most recent WDR of block discussed above . Optimally applications are provided with an API that hides what actually occurs in ongoing product builds and for ensuring appropriate semaphore access to multi threaded accessed data.

Correlation processing does not have to cause a WDR returned. There are embodiments for minimal exchanges of correlated sent date time stamps and or received date time stamps so that exchanges are very efficient using small data exchanges. Correlation of this disclosure was provided to show at least one solution with keeping in mind that there are many embodiments to accomplish relating time scales between data processing systems.

Architecture provides not only the foundation for keeping an MS abreast of its whereabouts but also the foundation upon which to build LBX nearby functionality. Whereabouts of MSs in the vicinity are maintained to queue . Permissions and charters can be used for governing which MSs to maintain to queue how to maintain them and what processing should be performed. For example MS user Joe wants to alert MS user Sandy when he is in her vicinity or user Sandy wants to be alerted when Joe is in her vicinity. Joe configures permissions enabling Sandy to be alerted with him being nearby or Sandy configured permissions for being alerted. Sandy accepts the configuration Joe made or Joe accepts the configuration Sandy made. Sandy s queue processing will ensure Joe s WDRs are processed uniquely for desired functionality.

To maintain modularity in interfaces to queues and parameters may be passed rather than having the modular send receive processing access fields of application records. When WDRs are sent the WDR will be targeted e.g. field perhaps also with field indicating which communications interface to send on e.g. MS has plurality of comm. interfaces . When WDRs are broadcast e.g. null MS ID the WDR is preferably outbound on all available comm. interfaces unless field indicates to target a comm. interface. Analogously when WDR requests are sent the request will be targeted e.g. field perhaps also with field indicating which communications interface to send on e.g. MS has plurality of comm. interfaces . When WDR requests are broadcast e.g. null MS ID the WDR is preferably outbound on all available comm. interfaces unless field indicates to target a comm. interface.

Fields and are also of interest to the transport layer. Any subset or all of transport related fields may be passed as parameters to send processing or received as parameters from receiving processing to ensure send and receive processing is adaptable using pluggable transmission reception technologies.

An alternate embodiment to the BESTWDR WDR returned by processing may be set with useful data for reuse toward a future processing thread whereabouts determination. Field see pg. 168 can be set with useful data for that WDR to be in turn used at a subsequent whereabouts determination of . This is referred to as Recursive Whereabouts Determination RWD wherein ILMs determine WDRs for their whereabouts and use them again for calculating future whereabouts by populating useful TDOA AOA MPT and or whereabouts information to field .

An alternate embodiment may store remote MS movement tolerances if they use one to WDR field so the receiving MS can determine how stale are other WDRs in queue from the same MS for example when gathering all useful WDRs to start with in determining whereabouts of processing e.g. block . Having movement tolerances in effect may prove useful for maximizing useful WDRs used in determining a whereabouts processing .

Many LBX aspects have been disclosed some of which are novel and new in LBS embodiments. While it is recommended that features disclosed herein be implemented in the context of LBX it may be apparent to those skilled in the art how to incorporate features which are also new and novel in a LBS model for example by consolidating distributed permission charters and associated functionality to a shared service connected database.

Privileges and or charters may be stored in a datastream format e.g. X.409 syntactical format e.g. XML source code like compiled or linked programming data database data e.g. SQL tables or any other suitable format. Privileges and or charters may be communicated between MSs in a datastream format e.g. X.409 syntactical format e.g. XML source code like compiled or linked programming data database data e.g. SQL tables or any other suitable format.

Block may access an all or none permission privilege to receive permission and or charter data depending on what data is being received from a particular identity e.g. user or particular MS . Alternate embodiments implement more granulated permissions privileges on which types sets or individual privileges and or charters can be received so that block will update local data with only those privileges or charters that are permitted out of all data received. One embodiment is to receive all privileges and or charters from remote systems for local maintaining so that processing can later determine what privileges and charters are enabled. This has the benefit for the receiving user to know locally what the remote user s desire for privileges and charters without them necessarily being effective. Another embodiment is for to only receive the privileged subset of data that can be used privileged at the time and to check at block which privileges should be used to alter existing privileges or charters from the same MS e.g. altered at block . This has the potential benefit of less MS data to maintain and better performance in processing for dealing only with those privileges and charters which may be useable. A user may still browse another user s configurations with remote data access anyway.

WPL is a unique programming language wherein peer to peer interaction events containing whereabouts information WDRs provide the triggers for novel location based processing however a LBS embodiment may also be pursued. Events seen or collected by a service may incorporate WPL the table record embodiments of a suitable programming executable and or data structures or any other BNF grammar derivative to carry out analogous event based processing. For example the service would receive inbound whereabouts information e.g. WDRS from participating MSs and then process accordingly. An inbound outbound and in process methodology may be incorporated analogously by processing whereabouts information from MSs as it arrives to the service inbound processing whereabouts information as it is sent out from the service outbound to MSs and processing whereabouts information as it is being processed by the service in process for MSs. In one embodiment service informant code is used to keep the service informed of the LBX network. In another embodiment a conventional LBS architecture is deployed for collecting whereabouts of MSs.

An alternate embodiment processes inbound outbound maintained WDRs in process transmitted to a MS from non mobile data processing systems perhaps data processing systems which are to emulate a MS or perhaps data processing systems which are to contribute to LBX processing. Interoperability is as disclosed except data processing systems other than MSs participate in interacting with WDRs. In other embodiments the data processing systems contain processing disclosed for MSs to process WDRs from MSs e.g. all disclosed processing or any subset of processing e.g. WITS processing .

Communications between MSs and other MSs or between MSs and data processing systems may be compressed encrypted and or encoded for performance or concealing. Any protocol X.409 encodings datastream encodings or other data which is critical for processing shall have integrity regardless of an encapsulating or embedded encoding that may be in use. Further internalizations of the BNF grammar may also be compressed encrypted and or encoded for performance or concealing. Regardless of an encapsulating or embedded encoding that may be in use integrity shall be maintained for processing. When other encodings are used compression encryption etc an appropriate encode and decode pair of processing is used compress decompress encrypt decrypt etc .

Grammar specification privileges are preferably enforced in real time when processing charters during WITS processing. For example charters specified may initially be ineffective but can be subsequently enabled with a privilege. It is preferred that privileges and charters be maintained independently during configuration time and through appropriate internalization. This allows specifying anything a user wants for charters regardless of privileges in effect at the time of charter configuration so as to build those charters which are desired for processing but not necessarily effective yet. Privileges can then be used to enable or disable those charters as required. In an alternate embodiment privileges can be used to prevent certain charters from even being created. This helps provide an error to the user at an appropriate time creating an invalid charter however a valid charter may lose a privilege later anyway and become invalid. The problem of a valid charter becoming invalid later has to be dealt with anyway rather than automatically deleting the newly invalid charter . Thus it is preferable to allow any charters and privileges to be specified and then candidate for interpreting at WITS processing time.

Many embodiments are better described by redefining the W in acronyms used throughout this disclosure for the more generic Wireless use rather than Whereabouts use. Thus WDR takes on the definition of Wireless Data Record. In various embodiments locational information fields become less relevant and in some embodiments mobile location information is not used at all. As stated above with when a WDR is referenced in this disclosure it is referenced in a general sense so that the contextually reasonable subset of the WDR of is used. This notion is taken steps further.

A WDR may be redefined with a core section containing only the MS ID field . The MS ID field facilitates routing of the WDR and addressing a WDR for example in a completely wireless transmission of . In an embodiment with a minimal set of WDR fields the WDR may contain only two 2 fields a MS ID field and application fields . In an embodiment with minimal changes to the architecture heretofore disclosed all WDR fields through are maintained to field . Disclosure up to this point continues to incorporate processing heretofore described except WDR fields which were peers to application fields in a WDR are now subordinate to field . However the field data is still processed the same way as disclosed albeit with data being maintained subordinate to field . Thus field may have broader scope for carrying the data or for carrying similar data.

In a more extreme embodiment a WDR Wireless Data Record will contain only two fields a MS ID field and application fields wherein a single application or certain applications of data is maintained to field . For example the WDR is emitted from mobile MSs as a beacon which may or may not be useful to receiving MSs however the beaconed data is for one application other embodiments can be for a plurality of applications . In this minimal embodiment a minimal embodiment of architecture is deployed with block changes removing whereabouts location processing. The following processes may provide such a minimal embodiment palette for implementation 

One application using such a minimal embodiment may be the transmission of profile information see and operators above . As a MS roams it beacons out its profile information for other MSs to receive it. The receiving MSs then decide to process the profile data in fields according to privileges and or charters that are in place. Note that there is no locating information of interest. Only the profile information is of interest. Thus the MSs become wireless beacons of data that may or may not be processed by receiving MSs within the wireless vicinity of the originating MS. Consider a singles dating application wherein the profile data contains characteristics and interests of the MS user. A privilege or charter at the receiving MS could then process the profile data when it is received assuming the receiving MS user clarified what is of interest for automated processing through configurations for WITS processing.

While a completely wireless embodiment is the preferred embodiment since MS users may be nearby by virtue of a completely wireless transmission a longer range transmission could be facilitated by architectures of . In an architecture of transmission which is not completely wireless the minimal embodiment WDR would include field s indicating a route which was not completely wireless perhaps how many hops etc as disclosed above. WITS filtering would play an important role to ensure no outbound transmissions occur unless there are configurations in place that indicate a receiving MS may process it i.e. there are privileges and or charters in place and no inbound processing occurs unless there are appropriate configurations in place for the originating MS s i.e. there are privileges and or charters in place . Group identities of WDRs can become more important as a criteria for WITS filtering in particular when a group id indicates the type of WDR. The longer range embodiment of preferably incorporates a send transmission for directing the WDRs to MSs which have candidate privileges and or charters in place rather than a broadcast for communicating WDRs. Broadcasting can flood a network and may inundate MSs with information for WITS filtering.

While various embodiments of the present disclosure have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of the present disclosure should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

