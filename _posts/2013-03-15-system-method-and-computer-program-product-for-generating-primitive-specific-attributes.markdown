---

title: System, method, and computer program product for generating primitive specific attributes
abstract: A system, method, and computer program product are provided for generating primitive-specific attributes. In operation, it is determined whether a portion of a graphics processor is operating in a predetermined mode. If it is determined that the portion of the graphics processor is operating in the predetermined mode, only one or more primitive-specific attributes are generated in association with a primitive.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09269179&OS=09269179&RS=09269179
owner: NVIDIA Corporation
number: 09269179
owner_city: Santa Clara
owner_country: US
publication_date: 20130315
---
The present invention relates to graphics processors and more particularly to efficiently processing primitives utilizing graphics processors.

In some cases a developer of a graphics application may desire to change an attribute of a primitive that is constant for the primitive in the graphics pipeline. However when an input to a traditional geometry shader includes adjacent primitives that share common vertices the output of the traditional geometry shader requires each primitive output to have unique vertices. The output of the additional vertices leads to a slowdown in a primitive processing rate of a graphics pipeline. There is thus a need for addressing these and or other issues associated with the prior art.

A system method and computer program product are provided for generating primitive specific attributes. In operation it is determined whether a portion of a graphics processor is operating in a predetermined mode. If it is determined that the portion of the graphics processor is operating in the predetermined mode only one or more primitive specific attributes are generated in association with a primitive.

In the context of the present description a primitive refers to any element e.g. a polygonal element etc. that is capable of being utilized to image a polygon e.g. such as a triangle a rectangle etc. or that is capable of being used to image a figure capable of being represented by polygons. Further in the context of the present description primitive specific attributes refer to attributes that are associated with an entire primitive beyond just a subset portion e.g. a vertex etc. thereof. For example in various embodiments the primitive specific attribute may include a viewport index a render target array index a color attribute a generic attribute and or a mask attribute etc. In one embodiment the primitive specific attribute may not necessarily be limited to a specific vertex. For example in one embodiment only primitive specific attributes may be generated in association with the primitive by avoiding generation of vertex specific attributes.

In various embodiments the graphics processor may include any number of graphics processor pipeline units as well as associated hardware and software. For example in one embodiment the graphics processor may include a vertex shader a tessellation initialization shader a tessellation shader and a geometry shader. Moreover in one embodiment the vertex shader and the geometry shader may each operate on a single streaming multiprocessor.

Further in one embodiment determining whether the portion of the graphics processor is operating in the predetermined mode may be carried out by hardware. In another embodiment determining whether the portion of the graphics processor is operating in the predetermined mode may be carried out by software.

In one embodiment the predetermined mode may include a mode associated with a geometry shader. For example in one embodiment the predetermined mode may include a mode where no expansion or limiting expansion of input geometry occurs as a result of geometry shader processing. In this case in one embodiment a one new vertex per triangle in a triangle strip may be maintained for the geometry shader output. In one embodiment a less than one new vertex per triangle in a triangle strip may be maintained for the geometry shader output. For example if a mesh is received an input a mesh typically has fewer vertices than primitives e.g. an 8 4 mesh of vertices has 42 primitives for 32 vertices etc. . Furthermore in one embodiment the geometry shader need not copy per vertex attributes from an input to an output.

Additionally in one embodiment the one or more vertex specific attributes may be generated by a first stage of a pipeline of the graphics processor that is followed by a second stage of the pipeline of the graphics processor that generates the one or more primitive specific attributes. For example in one embodiment the first stage may include at least one of a vertex shader or a tessellation unit etc. that are capable of generating the one or more vertex specific attributes. In one embodiment the second stage may include a geometry shader.

In the context of the present description a vertex shader refers to any graphics processor related unit or units capable of transforming a three dimensional position of a vertex in virtual space to a two dimensional coordinate e.g. capable of being utilized for display etc. . In one embodiment the vertex shader may be configured to manipulate properties such as position color and texture coordinate.

Further in the context of the present description a tessellation unit refers to any unit or units associated with a graphics processor capable of being utilized to perform tessellation. Additionally a geometry shader may refer to any unit or code that is capable of governing the processing of primitives. In one embodiment the geometry shader may include a layered rendering capability. For example in one embodiment the geometry shader may cause a primitive to be rendered to a particular layer of a frame buffer.

Furthermore in one embodiment a plurality of vertices may be associated with the primitive at least one of which may be a provoking vertex associated with the primitive. The provoking vertex of a primitive refers to the vertex that determines the constant primary and secondary colors when flat shading is enabled. In one embodiment the provoking vertex for a triangle may include the last vertex used to assemble the primitive. In other embodiments the provoking vertex may include the first or second vertex used in assembly.

In one embodiment a policy may be in place that each primitive has a unique provoking vertex associated therewith. In this case in one embodiment the method may include enforcing the policy that each primitive has a unique provoking vertex associated therewith. As an option the policy may be enforced by invalidating any non unique provoking vertex and replacing the same.

The primitive specific attributes may be generated in association with the primitive in connection with any application. For example in various embodiments the one or more primitive specific attributes may be generated in association with the primitive in connection with an application including at least one of voxelization cube mapping or cascaded shadow mapping etc.

In the context of the present description voxelization refers to the synthesis of voxel represented objects. Further cube mapping refers to a technique of environment mapping that uses a cube as the map shape where the environment is projected onto six faces of a cube and stored as six square textures or unfolded into six regions of a single texture. Cascaded shadow mapping refers to a shadow mapping technique capable of being implemented by splitting a camera view frustum and creating a separate depth map for each partition e.g. in an attempt to make a screen error constant etc. .

In another embodiment the primitive specific attributes may be generated in association with an application including swizzling a plurality of coordinates of at least one vertex of the at least one primitive. In the context of the present description swizzling refers to rearranging elements of a vector.

Further in another embodiment the method may be utilized to avoid vertex expansion. For example in one embodiment only per primitive attributes may be produced for a plurality of primitives and a connectivity of the primitives as well as per vertex attributes may defined by a last pipeline stage prior to a geometry shader stage e.g. a last world space shading stage prior to the geometry shading stage such as a vertex shader stage or a domain shader stage etc. .

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

As shown for triangle strips if unique vertices are utilized for each triangle in a triangle strip for geometry shader processing vertex expansion may occur. As an example it may be desired to change an attribute of a primitive that is constant for the primitive in a graphics pipeline. However when a triangle strip triangle mesh or the like is input into a traditional geometry shader where adjacent primitives in the strip or mesh share common vertices the output of a traditional geometry shader as defined by an API requires each primitive output to have unique vertices. For example if the input is a triangle strip then each triangle on input introduces one new vertex whereas for a traditional geometry shader output each triangle introduces three new vertices. This may lead to a 3 slowdown in the primitive processing rate of the graphics pipeline.

Often it is desired to change only per primitive attributes i.e. attributes that are constant across the entire primitive etc. . For example it may be desired to change a viewport index of a primitive a render target array index or any other generic attribute that is constant.

Accordingly in one embodiment a fast geometry shader FGS may be implemented that produces just per primitive attributes on output and the connectivity of the primitives as well as the per vertex attributes may be defined by the last world space shading stage prior to a geometry shader stage which for example may be a vertex shader stage or a domain shader stage.

Thus in one embodiment a property of one new vertex per triangle or fewer in a triangle strip may be maintained for a fast geometry shader output. Furthermore the fast geometry shader need not copy per vertex attributes from input to output e.g. as a traditional geometry shader would operate etc. . The fast geometry shader may reduce the number of unique vertices per primitive which may improve a rate of viewport transform processing e.g. preformed by a viewport clip cull unit etc. and improve a rate setup processing e.g. since only one new vertex per primitive needs to be fetched etc. . Furthermore the fast geometry shader may reduce the attribute traffic that flows between a world space pipeline and a screen space pipeline. Accordingly the fast geometry shader may operate to reduce attribute bandwidth and attribute storage.

Further in one embodiment a unique provoking vertex may be identified for each primitive. For example in one embodiment a viewport clip cull unit e.g. positioned subsequent to the fast geometry shader etc. may ensure a unique provoking vertex for each primitive that is sent downstream to the rest of the pipeline. For example this may be implemented to allow the viewport clip cull unit to copy the per primitive attributes into the provoking vertex for each primitive. In one embodiment the viewport clip cull unit may invalidate the provoking vertex if the provoking vertex is already present in an associated vertex cache and the viewport clip cull unit may create a new instance that is specific to the primitive being processed. In the context of the present description a viewport clip cull unit refers to any unit or group of units capable of performing clipping culling perspective correction and viewport scaling operations on primitive data.

Further in one embodiment where the fast geometry shader is implemented to limit or prohibit expansion of input geometry an optimization in the graphics pipeline may be applied such that a vertex shader and the fast geometry shader may be run in sequence on the same streaming multiprocessor without performing a re distribution of geometry between the vertex shader and the fast geometry shader stages. In one embodiment this may be implemented to avoid copying attributes between streaming multiprocessors. This may in turn eliminate overhead of time slicing between stages that normally require re distribution e.g. between a first stage including a vertex attribute fetch vertex shader operation hull shader operation and task generation and a second stage including topology generation domain shader operation geometry shader operation and viewport clip cull operation etc. .

Still yet in one embodiment a driver may be utilized to detect when to apply a fast geometry shader optimization through examination of a traditional geometry shader. Thus in one embodiment a fast geometry shader optimization may be implemented automatically utilizing a traditional geometry shader without developer involvement. For example a driver may detect that geometry shader code simply copies all per vertex attributes from input to output and only change per primitive attributes such that there is a one to one input to output correspondence of primitives e.g. the driver may cause a traditional geometry shader to function as a fast geometry shader automatically etc. . Thus in one embodiment the fast geometry shader optimization does not necessarily need to be exposed at an API level to be effective. Of course in one embodiment the fast geometry shader optimization may be exposed at the API level where a programmer may explicitly declare the geometry shader as being of this nature e.g. such as through a pass through specifier etc. .

Utilizing the fast geometry shader optimization makes it possible to specify per primitive attributes in a geometry shader stage following either vertex shading or tessellation in an efficient manner without introducing an unnecessary expansion of vertices. In various embodiments this feature may be implemented in the context of voxelization cube map rendering and or cascaded shadow maps etc.

As an example in the case of voxelization cube mapping and or cascaded shadow mapping it may be desirable to project primitives to multiple viewports render targets. In the case of voxelization for example in one embodiment a geometry shader may be utilized to identify a dominant direction of a primitive. In this case in one embodiment the geometry shader may project the primitive to a corresponding three dimensional volume.

In the case of cube mapping in one embodiment a geometry shader may be utilized to identify the faces of a cube map to which a primitive projects. In this case in one embodiment a multi projection engine may project the primitive to each of the identified faces. Of course it is desired that such projection occur in an efficient manner. In one embodiment a viewport array mask attribute which is a per primitive attribute may be utilized to accomplish this.

In one embodiment world space processing e.g. a first stage etc. of a primitive may be performed exactly once. Additionally in one embodiment the world space processing of a primitive may be performed exactly once regardless of a number of viewports render targets a primitive is projected.

Furthermore sharing of vertices between adjacent primitives may be maintained for a particular projection. In one embodiment vertices between adjacent primitives may be maintained in order to maintain a one new vertex per primitive ratio for triangle strips that all project to the same surface. In another embodiment a greater than one new vertex per primitive ratio for triangle strips may be maintained. In another embodiment a less than one new vertex per primitive ratio for triangle strips may be maintained. Additionally in one embodiment a primitive may be completely culled if it does not project to any surface based on a world space shader evaluation.

In the case of projecting a primitive to multiple viewports i.e. viewport multi cast etc. in one embodiment a unit associated with a graphics processor e.g. a shader a tessellation unit etc. may specify a set of viewports into which a primitive is to be output. In one embodiment a data structure may be associated with each primitive where the data structure specifies the set of viewports to which a primitive is to be output.

In one embodiment the data structure may include a form of a bitmask e.g. a 16 bit bitmask etc. where each bit in the bitmask corresponds to a viewport slot at that bit position. For example in one embodiment a set bit in the bitmask may indicate that a primitive is to be output to a viewport that is associated with that bit position. In one embodiment multiple bits may be set in which case the same primitive may be output e.g. multicast etc. to the viewports corresponding to the set bits. In the case that no bits are set in the mask in one embodiment the primitive may be silently discarded e.g. killed etc. such that no further processing is performed for that primitive.

Furthermore in one embodiment a render target array index generated e.g. by a geometry shader etc. may be configured to be offset by the viewport slot number for each output. In one embodiment the offset render target array index may be implemented in concert with a non expanding fast geometry shader implementation which allows the geometry shader to run at virtually no overhead.

As noted viewport multi cast may be implemented to avoid introducing vertex expansion by sharing vertices between adjacent primitives that are output to the same viewport. For example in some cases at least a portion of the graphics processing pipeline e.g. a portion for performing clipping culling viewport transform and perspective correction etc. may have a limited vertex cache. In this case to ensure hits in the vertex cache in one embodiment all the primitives that are sent to the same viewport may be processed consecutively.

More information associated with viewport multicasting may be found in U.S. patent application Ser. No. 13 834 981 titled SYSTEM METHOD AND COMPUTER PROGRAM PRODUCT FOR EXECUTING PROCESSES INVOLVING AT LEAST ONE PRIMITIVE IN A GRAPHICS PROCESSOR UTILIZING A DATA STRUCTURE file Mar. 15 2013 now published US2014 026726 which is incorporated herein by reference in its entirety.

In another embodiment a render target array index may be configured to be offset by the viewport slot number the render target array index may be guaranteed not to wrap e.g. by shader examination etc. and all primitives may have the same base render target array index e.g. such as when an array index is not generated by a geometry shader and a class default is used instead etc. . In this case in one embodiment primitives may be processed in a viewport order since the viewports are guaranteed to go to different render targets and there are no API imposed ordering requirements between different render targets. In yet another embodiment the application may explicitly specify in the API whether to process primitives in a viewport order or in a strict primitive order. In yet another embodiment hardware may be utilized to determine whether to process primitives in a viewport order or in a strict primitive order.

Further in one embodiment when processing primitives in a viewport order a unit in the graphics processing pipeline e.g. a unit for performing clipping culling viewport transform and or perspective correction etc. may read the viewport mask for all primitives in a batch and may then process the output primitives in the batch by traversing all output primitives for a particular viewport before moving on to the next viewport. In one embodiment when processing primitives in a strict primitive order the pipeline portion or unit etc. may process all output primitives i.e. all viewports for a particular input primitive before moving on to the next input primitive.

In another embodiment the graphics processing pipeline or a portion thereof may be configured to implement viewport coordinate swizzling. In one embodiment viewport coordinate swizzling may introduce additional coordinate transformation just after a vertex or geometry shader and before a clipping and perspective divide. In one embodiment the transformation may include a programmable permutation over vertex position coordinate components x y z w with optional negation. Further in one embodiment the transformation may be specified as part of viewport state and may take the form of a mask e.g. a 12 bit mask etc. . For example in one embodiment the mask may include three bits per coordinate to pick one out of eight choices for each coordinate x x y y z z w w.

In various embodiments several different swizzling transformations may be specified by using different viewports e.g. one per viewport etc. . In this case in one embodiment the geometry shader may then pick a desired swizzling transformation by routing output primitives to the corresponding viewport. In one embodiment this feature may be implemented in concert with a non expanding fast geometry shader implementation.

Utilizing these techniques unnecessary expansion of vertices due to a geometry shader generating unique vertices for each primitive may be avoided. In some embodiments this may improve a primitive processing rate avoiding the overhead of additional attribute traffic and attribute storage in the pipeline. Furthermore in some embodiments the geometry shader shading workload may be reduced by moving the operations of multi cast and coordinate swizzle into fixed function hardware.

As shown the graphics processing pipeline may include at least one vertex shader a tessellation initialization unit a tessellation shader and a geometry shader . In one embodiment the vertex shader the tessellation initialization unit the tessellation shader the geometry shader and or hardware software associated therewith may represent a stage of the graphics processing pipeline e.g. a world space shader pipeline or shader pipeline etc. .

Furthermore in one embodiment the graphics processing pipeline may include a viewport clip cull unit a raster unit and a raster operations ROP unit . In one embodiment the shader pipeline may operate within a streaming multiprocessor. Further in one embodiment the shader pipeline may include a plurality of shader units that may be enabled to process primitive data. In one embodiment the vertex shader the tessellation initialization unit the tessellation shader the geometry shader and or hardware software associated therewith may sequentially perform processing operations. Once the sequential processing operations performed by the shaders within shader pipeline are complete in one embodiment the viewport clip cull unit may utilize the data.

In one embodiment primitive data processed by the shader pipeline may be written to cache e.g. L1 cache a vertex cache etc. . In this case in one embodiment the viewport clip cull unit may access the data in the cache. In one embodiment the viewport clip cull unit may perform clipping culling perspective correction and viewport scaling operations on primitive data.

In one embodiment the viewport clip cull unit may be configured to perform a bounding box calculation with the primitives to determine which region of a display each graphics primitive belongs. In one embodiment this information may be used to route each primitive to one of a plurality of raster units such as raster unit . In one embodiment each raster unit may rasterize graphics primitives and fragments of graphics primitives that overlap a particular region of the display. Additionally in one embodiment the raster operations unit may include a processing unit that performs raster operations such as stencil z test and the like and may output pixel data as processed graphics data.

Further in one embodiment the viewport clip cull unit may be configured to read a data structure associated with a primitive. For example in one embodiment the viewport clip cull unit may read a mask for all primitives in a batch. The viewport clip cull unit may then process the output primitives in the batch by traversing all output primitives for a particular viewport before moving on to the next viewport. In another embodiment the viewport clip cull unit may process all output primitives i.e. all viewports etc. for a particular input primitive before moving on to the next input primitive.

In one embodiment the viewport clip cull unit may be configured to invalidate the provoking vertex if the provoking vertex is already present in an associated vertex cache and the viewport clip cull unit may create a new instance that is specific to the primitive being processed. In the context of the present description a viewport clip cull unit refers to any unit or group of units capable of performing clipping culling perspective correction and viewport scaling operations on primitive data.

Further in one embodiment where the fast geometry shader mode is implemented to limit or prohibit expansion of input geometry an optimization in the graphics pipeline may be applied such that the vertex shader and the geometry shader may be run in sequence on the same streaming multiprocessor without performing a re distribution of geometry between the vertex shader and the fast geometry shader stages. In one embodiment this may be implemented to avoid copying attributes between streaming multiprocessors. This may in turn eliminate overhead of time slicing between stages that normally require re distribution e.g. between a first stage including a vertex attribute fetch vertex shader operation hull shader operation and task generation and a second stage including topology generation domain shader operation geometry shader operation and viewport clip cull operation etc. .

As shown vertex attributes are fetched as part of a graphics pipeline process. See operation . In one embodiment the vertex attributes may be fetched as part of a vertex shader unit process. In another embodiment the vertex attributes may be fetched prior to a vertex shader unit process.

The vertex attributes are then stored. See operation . In one embodiment the vertex attributes may be written to Level 1 cache. In another embodiment the vertex shader output may be written to a buffer.

As shown further it is determined whether a geometry shader is to operate in a per primitive attribute mode. See decision . In one embodiment a driver may be utilized to detect whether a geometry shader is to operate in a per primitive attribute mode e.g. whether to utilize fast geometry shader optimization etc. . For example a driver may cause a change to operate utilizing only per primitive attributes such that there is a 1 1 input to output correspondence of primitives.

If it is determined that a geometry shader is to operate in per primitive attribute mode the geometry shader is launched to operate in per primitive attribute mode e.g. a fast geometry shader mode etc. . See operation . Furthermore per primitive attributes are stored e.g. in L1 cache in a vertex cache etc. . See operation .

Still yet vertex and per primitive attributes are reconciled. See operation . If it is determined that a geometry shader is not to operate in per primitive attribute mode the geometry shader is launched to operate in a normal mode e.g. traditional geometry shader mode etc. . See operation .

As shown a primitive is received e.g. by a viewport clip cull unit etc. . See operation . Further a provoking vertex is identified. See operation .

The provoking vertex of a primitive refers to the vertex that determines the constant primary and secondary colors when flat shading is enabled. In one embodiment the provoking vertex for a triangle may include the last vertex used to assemble the primitive. In other embodiments the provoking vertex may include any vertex.

As shown further it is determined whether the provoking vertex is a shared vertex. See decision . If the provoking vertex is not a shared vertex the vertex is processed normally. See operation . If the provoking vertex is a shared vertex the vertex is ignored and a miss is returned and a new instance of the provoking vertex is created. See operation . Furthermore a tag associated with the vertex is invalidated e.g. a tag stored in cache etc. . See operation .

For example in one embodiment a viewport clip cull unit e.g. positioned subsequent to the fast geometry shader etc. may ensure a unique provoking vertex for each primitive that is sent downstream to the rest of the pipeline. In one embodiment this may be implemented to allow the viewport clip cull unit to copy the per primitive attributes into the provoking vertex for each primitive. In one embodiment the viewport clip cull unit may invalidate the provoking vertex if it is already present in an associated vertex cache and the viewport clip cull unit may create a new instance that is specific to the primitive being processed. In another embodiment units earlier in the pipeline may be configured to guarantee a unique provoking vertex for each primitive. Specifically in one embodiment for the non tessellation case a PD unit also called primitive distributor may ensure a unique provoking vertex for each primitive when constructing a batch. In another embodiment for the tessellation case the tessellation unit may ensure a unique provoking vertex for each tessellated primitive.

In the context of the present description voxelization refers to the synthesis of voxel represented objects. A voxel refers to any volume element representing a value on a regular grid in three dimensional space. In one embodiment a unit in a graphics processing pipeline e.g. a geometry shader etc. may identify a dominant direction of a primitive and may project the primitive to corresponding three dimensional volume. In one embodiment the dominant direction may be determined by determining a normal associated with a primitive. In one embodiment the primitive may be projected in a multicast manner.

In the context of the present description cube mapping refers to any technique of environment mapping that uses a cube as the map shape where the environment is projected onto six faces of a cube and stored as six square textures or unfolded into six regions of a single texture. In one embodiment a unit in a graphics processing pipeline e.g. a geometry shader etc. may identify faces of the cube map to which a primitive projects. Further in one embodiment a multi projection aspect of the graphics processing pipeline may be utilized to project the primitive to each of the identified faces utilizing the techniques described herein.

While a parallel processor is provided herein as an example of the PPU it should be strongly noted that such processor is set forth for illustrative purposes only and any processor may be employed to supplement and or substitute for the same. In one embodiment the PPU is configured to execute a plurality of threads concurrently in two or more streaming multi processors SMs . A thread i.e. a thread of execution is an instantiation of a set of instructions executing within a particular SM . Each SM described below in more detail in conjunction with may include but is not limited to one or more processing cores one or more load store units LSUs a level one L1 cache shared memory and the like.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. a memory interface etc. as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls etc. that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp etc. in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system etc. as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

