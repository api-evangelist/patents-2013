---

title: System, method, and computer program product for recovering from a memory underflow condition associated with generating video signals
abstract: A system, method, and computer program product for recovering from a memory underflow condition associated with generating video signals are disclosed. The method includes the steps of determining that a first counter is greater than a second counter, incrementing an address corresponding to a memory fetch request by an offset, and issuing the memory fetch request to a memory. The first counter represents a number of pixels that have been read by a display pipeline for a current frame and the second counter represents a number of pixels requested from a memory for the current frame.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251557&OS=09251557&RS=09251557
owner: NVIDIA Corporation
number: 09251557
owner_city: Santa Clara
owner_country: US
publication_date: 20130605
---
The present invention relates to generating video data for display and more particularly to memory systems associated with a graphics processing unit.

Conventional electronic systems generate computer rendered graphics for display on display devices such as a liquid crystal display LCD . In a typical system a central processing unit CPU is coupled to a graphics processing unit GPU that has a dedicated video memory for storing computer rendered pixel data for display on a screen. The GPU renders pixel data from two dimensional or three dimensional graphics primitives and copies the pixel data to a frame buffer in the video memory. Then a display controller within the GNU reads the pixel data from the frame buffer and generates video signals for output to the display device.

The video signals are time sensitive. The display device may be configured to operate at a specific refresh frequency such as 60 Hz. In other words each pixel in the display device is updated a number of times per second e.g. 60 times per second . The timing requirements for the video signals are precise but the video memory typically operates asynchronously from the display controller. In other words the display controller transmits a request to the video memory to read the pixel data for a particular line of pixels some time before that pixel data is utilized to generate the time sensitive video signals. However multiple clients may attempt to access the video memory at the same time. For example the CPU may be writing data to the video memory that is used to generate pixel data for the next frame of video the graphics pipeline may access the data to generate the pixel data or the graphics pipeline may write pixel data to the frame buffer in the video memory. Because the bandwidth of the video memory is limited a memory fetch request submitted to the video memory may be delayed for a number of clock cycles before the pixel data associated with the fetch request is returned to the display controller. If the delay is long enough then the pixel data received by the display controller corresponds to a particular point in the video signals that was already sent to the display. Thus the pixel data must be discarded and the video signals sent to the display contained invalid data for those particular pixels. This condition is referred to herein as a memory underflow condition where the memory request is not returned in time to meet the timing requirements of the video signals. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product for recovering from a memory underflow condition associated with generating video signals are disclosed. The method includes the steps of determining that a first counter is greater than a second counter incrementing an address corresponding to a memory fetch request by an offset and issuing the memory fetch request to a memory. The first counter represents a number of pixels that have been read for a current frame and the second counter represents a number of pixels requested from a memory for the current frame.

A display controller is described below that is configured to alleviate display issues caused by a memory underflow condition. The display controller analyzes the extent of the memory underflow condition and if the magnitude of the memory underflow condition is above a threshold then the display controller skips fetching a portion of the pixel data for the current frame from the video memory. Instead the display controller advances to a line of pixels further down the frame and fetches the new line of pixel data conceding that the pixel data in front of the advanced line of pixel data will probably not be returned to the display controller in time to be utilized to generate the video signals. The effect of this technique is to attempt to recover from memory underflow conditions fast enough that video artifacts caused by the memory underflow conditions are corrected by the next frame.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

In one embodiment as shown in the display controller includes a memory fetch unit . The memory fetch unit receives commands from a request out unit that indicate which addresses in the memory the display controller should fetch for a current frame. For example the request out unit may track a base address for a frame of pixel data. The pixel at the base address is fetched and then the address is incremented to give an address for the next pixel of the frame. In some cases multiple pixels may be fetched by a particular memory request. For example the bandwidth between the memory fetch unit and the memory via the memory interface may be 512 bits wide. Thus a plurality of pixels within a single scan line of pixel data may be fetched by each memory request. In this example the memory fetch unit may request 512 bits of data representing 16 pixels at 32 bits per pixel in a single memory request. The memory fetch unit tracks memory fetch requests sent to the memory and collects pixel data returned from the memory to route the pixel data to the correct display pipeline . As shown in a single request out unit may handle multiple display pipelines . In another embodiment each display pipeline may be associated with a separate and distinct request out unit .

As shown in the display controller may include a plurality of different display pipelines for processing pixel data from different logical display surfaces in parallel. A logical display surface is a two dimensional array of pixel data that represents an image to be displayed on the display device. Each application window on a desktop for example may be associated with a separate and distinct logical display surface. The logical display surfaces may be combined to generate the pixel data for each corresponding pixel in the display device. The display controller has N separate and distinct display pipelines . The display pipelines perform various processing tasks on the pixel data such as scaling the data converting the data format e.g. 12 bit or 15 bit pixel data to 24 bit pixel data for RGB 8 bits per channel filtering the data converting the colorspace of the pixel data e.g. YUV to RGB mapping the pixel data to a color palette having a larger bandwidth and so forth. It will be appreciated that the display pipelines may perform other pixel processing tasks not explicitly described herein and that such tasks are within the scope of the present disclosure.

The memory fetch unit receives commands from the request out unit that specifies memory addresses to be fetched from the memory . The memory fetch unit transmits memory fetch requests to the memory and waits to receive a response from the memory with data associated with the various memory addresses. The memory fetch unit may track outstanding memory fetch requests and route received data i.e. pixel data associated with the outstanding memory fetch requests to the correct display pipelines .

The memory fetch unit feeds the pixel data to the data packer DP units . The DP units are configured to pack the data associated with one or more memory fetch requests into an internal buffer to pass to the buffer units . The DP units may reorder memory fetch requests within the internal buffer. The DP units pass pixel data for display to the buffer units . Each of the buffer units is an asynchronous FIFO that receives and stores a plurality of pixel data asynchronously from a pixel clock PCLK rate that is utilized to operate the display pipelines . The pixel clock rate is a frequency based on the refresh rate of the display device coupled to system . The memory fetch unit request out unit and DP units may operate at a faster clock rate than the pixel clock rate. Thus the memory fetch unit can fetch pixels for each display pipeline sporadically and store that pixel data in the buffer units until the pixel data is needed by the display pipeline.

Each of the display pipelines feeds into a blend unit that combines the pixel data for different logical surfaces into a single surface for display on the display device. For example the blend unit may combine multiple logical surfaces associated with different display pipelines as well as a cursor that is associated with a separate display pipeline . The blend unit may transmit the combined pixel data to a backend unit that is configured to generate the video signals . The backend unit may format and pack the data into digital or analog signals for transmission to the display device according to the particular specification for the video signal e.g. DisplayPort DVI VGA etc. . If the video signals are analog then the display controller backend unit may include one or more DACs for converting the digital pixel data to an analog signal.

Typically short term underflow conditions i.e. pixels worth of missing data may arise as a result of an over taxed memory system e.g. when the memory has too many units trying to access the memory at the same time . Long term underflow conditions i.e. scan lines worth of missing data arise as a result of changes of frequency within the memory interface . For short term underflow conditions the memory fetch unit and request out unit may be able to catch up during the horizontal blanking period within a video signal. In other words the video signals may get behind by fifteen or twenty pixels within a particular scan line thereby not being able to display the correct color for those pixels at the end of the scan line. However during the horizontal blanking period at the end of the scan line the memory fetch unit may receive enough data to at least partially fill the line buffer units with some pixel data from the next scan line. In some cases the memory fetch unit cannot receive enough pixel data during the horizontal blanking period to catch up when the memory fetch unit is significantly behind. As shown in the video signals have advanced to a time tassociated with reading pixel from the line buffer units and the display controller has not been able to catch up with the video signals over at least the previous two scan lines. If the system has experienced a long term memory underflow condition then the same color may be used to refresh each and every pixel in the remaining portion of the second frame . In addition if the magnitude of the memory underflow condition is serious enough the display controller may not be able to fully recover during the vertical blanking period of the video signals which is typically much longer than a horizontal blanking period. If this is the case then the display controller may not be able to provide valid pixel data for the next frame of video at the start of refreshing the display device for the next frame such that the memory underflow condition causes image artifacts to propagate to the next frame. Although the display controller cannot control the causes which lead to the memory underflow conditions certain advantages may be realized for recovering from a memory underflow condition and preventing image artifacts from propagating to the next frame of video.

Returning now to various units of the display controller may be configured to monitor the magnitude of a memory underflow condition and adjust the operation of the various units within the display controller to recover from the memory underflow condition more quickly when compared to prior art display controllers. In one embodiment the display pipelines may be configured to monitor the number of underflow pixels when a memory underflow condition occurs. At least one unit within each of the display pipelines may include an underflow counter that is incremented for each rising edge of the pixel clock i.e. for each pixel and decremented for each pixel read from the buffer unit . As a memory underflow condition occurs the underflow counter will be incremented but not decremented because there is no available pixel data in the buffer unit . Thus the underflow counter value measures the magnitude of the memory underflow condition. A small underflow counter value indicates a potential short term underflow condition that could be recovered from during the next horizontal blanking period. A large underflow counter value indicates a potential long term underflow condition that could cause image artifacts to propagate to the next frame of video.

Alternatively the request out unit may include a req out counter for each of the display pipelines that represents a number of pixels in the current frame that have been requested by the request out unit for each of the display pipelines . In addition each of the display pipelines may include a corresponding scanout counter that indicates a number of pixels in the current frame that have been read from the buffer units by the display pipelines . If the req out counter is less than the scanout counter then a memory underflow condition has occurred. The magnitude of the memory underflow condition is then given by the difference between the req out counter and the scanout counter.

It will be appreciated that memory underflow conditions may be monitored for each of the display pipelines within the display controller . In other words each surface may be associated with a separate and distinct underflow counter scanout counter and req out counter that enables the request out unit to control the memory addresses output to the memory fetch unit for each of the display pipelines separately.

In one embodiment when pixel data corresponding to underflow pixels is received by the memory fetch unit the pixel data is stored in the buffer unit and immediately read and discarded by the display pipeline until the underflow counter reaches zero thereby indicating that the display controller has caught up to the video signal . The operation of reading and discarding underflow pixels from the buffer unit continues even during the horizontal blanking period. Once valid pixel data is available at the input to the display pipeline i.e. the underflow counter reaches zero the display pipeline returns to normal operation. While this technique may be sufficient to overcome short term underflow conditions simply waiting for the underflow condition to self correct during the horizontal blanking period may not be sufficient to catch up before the start of the next frame.

In one embodiment when the req out counter is less than the scanout counter the request out unit includes logic that increments the memory address associated with the next pixel to fetch by some offset value. In other words the memory fetch unit may be so far behind the video signals that fetching pixels in the next scan line is a futile operation because there is little to no chance that pixel data for the scan line will be returned to the memory fetch unit before the display pipeline reads that pixel data from the buffer units to generate video signals for the display device. Thus the request out unit may increment the memory address associated with the next memory fetch request by a value corresponding to a number of pixels such that the pixel data returned to the display pipeline is advanced to a point in the current frame that is sufficiently far enough ahead of the video signals that the pixel data has a chance to be returned to the memory fetch unit by the memory in time to be read by the display pipeline .

The offset may be set to a value that corresponds to a small number of pixels e.g. two scan lines worth of pixels in order to recover from short term memory underflow conditions. Alternatively the offset may be set to a value that corresponds to a large number of pixels e.g. the number of scan lines remaining in the current frame in order to recover from long term memory underflow conditions. For example when the underflow counter indicates that the memory fetch unit is behind the video signals by a small number of pixels equal to for example one scan line the request out unit may increment the address associated with the next memory fetch request by an offset corresponding to three scan lines to attempt to alleviate the memory underflow condition. In this manner the display controller may attempt to reduce the image artifacts caused by the memory underflow condition sooner than prior art display controllers. Alternatively when the underflow counter indicates that the memory fetch unit is behind the video signals by a large number of pixels equal to for example ten scan lines the request out unit may increment the address associated with the next memory fetch request by an offset corresponding to the number of scan lines remaining in the current frame to attempt to alleviate the memory underflow condition by the start of the next frame.

In one embodiment the offset is set equal to a difference between the scanout counter and the req out counter plus some threshold value. The offset is set in this manner to always advance the memory address associated with the next memory fetch request to be some threshold number of pixels beyond the current pixel being read from the buffer unit . The size of the threshold value may be adjusted based on the magnitude of the memory underflow condition. For example when the underflow counter indicates a short term memory underflow condition the threshold value may be smaller than when the underflow counter indicates a long term memory underflow condition.

In another embodiment the request out unit is only configured to advance the address associated with the next memory fetch request when the video signal is nearing the end of the current frame. When the scanout counter is greater than a threshold value e.g. a value equal to 80 of the pixel in the frame then the display controller stops outputting memory fetch requests for the current frame and increments the address for the next memory fetch request to correspond to a pixel at the beginning of the next frame of video. In effect when the display controller estimates that the number of pixels left to scanout in the current frame is small enough that the memory underflow condition cannot be corrected the request out unit begins fetching data for the next frame of video and skips fetching any additional data for the current frame of video.

In one embodiment each DP unit is associated with a corresponding tag FIFO that tags each memory fetch request with a frame bit that indicates whether the pixel data associated with the memory fetch request corresponds to the current frame or the next frame. When the request out unit generates a memory fetch request for a particular display pipeline the request out unit may also write a frame bit to the tag FIFO for that display pipeline . Because data corresponding to the memory fetch requests are returned to the memory fetch unit in the order the memory fetch requests were transmitted to the memory the DP units can check which frame pixel data returned by the memory fetch unit belongs to. When the scanout of a particular frame ends i.e. video signals indicate that scanning out the last pixel of a frame is complete a value indicating which frame is being scanned out is toggled. The value may take the form of either a zero or a one. As the request out unit generates memory fetch requests the request out unit also writes a frame bit to the tag FIFO that indicates whether the data is associated with the current frame or the next frame. As the value representing the current frame is toggled at the start of scanout of the current frame any pixel data in the buffer units associated with the previous frame may be discarded i.e. cleared from the memory in the buffer units . In addition after the current frame has started scanout the DP units may simply discard any pixel data that is associated with the previous frame. As the DP units receive pixel data for a particular memory fetch request the DP units compare the frame bit associated with the memory fetch request with the value representing the current frame. If the frame bit associated with the memory fetch request does not match the value representing the current frame then the pixel data may be discarded because the pixel data corresponds to pixel data for the previous frame of video.

In one embodiment the value representing the current frame of video is toggled at the start of the vertical synchronization signal VSYNC . The time during the vertical synchronization signal enables pixel data for the first pixel in the next frame to be returned to the display controller . Thus the memory underflow condition encountered during the previous frame does not cause image artifacts to propagate to the next frame. At the start of the vertical synchronization signal the underflow counter scanout counter and req out counter for each of the display pipelines may be reset in order to track the memory underflow conditions encountered during the next frame.

In one embodiment a memory underflow condition may occur for a logical surface that is overlaid on top of a different surface. For example a logical surface may be allocated for a cursor. The cursor is overlaid over other logical surfaces such as a desktop or an application window. In such cases the display pipeline for that surface may be configured to output a pixel value with an alpha channel of zero i.e. transparent when a memory underflow condition is detected. In other words rather than output invalid pixel data such as a default color or the color associated with the last valid pixel prior to the memory underflow condition the display pipeline causes the pixels associated with underflow pixels to be completely transparent. That way when the blend unit generates the blended pixel data for the surface that defines the image for display the underlying pixel data is displayed rather than the invalid data caused by the memory underflow condition.

Returning to step if the pixel data for the next pixel is not in the buffer unit i.e. the pixel data for the next pixel has not been received by the memory fetch unit then the method proceeds to step where a color for the pixel is selected by the display pipeline . If the pixel data for the next pixel was read from the buffer unit then the display pipeline selects the color as specified in the pixel data for the next pixel. However if the pixel data was not read from the buffer unit then the display pipeline may select another color for the next pixel. In one embodiment the display pipeline selects a default color to use for all underflow pixels. In another embodiment the display pipeline selects a color equal to a color of a previous valid pixel read by the display pipeline . In other words the display pipeline may buffer the last color read from the buffer unit and copy that color for any underflow pixels until another valid pixel color is read from the display pipeline . At step the display controller generates a video signal for display on a display device.

As shown in a method begins at step where a request out unit determines whether the scanout counter is greater than the req out counter. If the scanout counter is greater than the req out counter then the method proceeds to step where the request out unit increments an address corresponding to a memory fetch request by an offset. At step the memory fetch unit issues the memory fetch request to the memory . At step the request out unit transmits a frame identifier associated with the memory fetch request to a tag FIFO. Returning to step if the scanout counter is less than or equal to the req out counter then the method proceeds to step and step without incrementing the address corresponding to the memory fetch request.

At step the display controller monitors the video signals to detect a vertical synchronization signal VSYNC . If the display controller does not detect the VSYNC signal then the method returns to step and issues additional memory fetch requests for the next pixels in the frame. However if the display controller detects the VSYNC signal then at step the display controller resets the buffer unit clearing any pixel data stored in the buffer unit that is associated with the previous frame. The underflow counter scanout counter and req out counter are reset to zero for the start of the next frame. The method may be repeated for each frame of video displayed on the display device.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

