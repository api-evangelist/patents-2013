---

title: Method for modeling source code having code segments that lack source location
abstract: A system and method for modeling code segments that do not have a location is disclosed. Source code may be indexed and modeled in a data graph with nodes representing code elements and edges representing relationships between nodes. However, some code elements may be hidden or implicit and therefore may lack location information. In these cases, code figments are created and represented as nodes in the graph. Figment nodes may be specially designated so that the figment nodes may be easily distinguished from real source code nodes. The graph is then updated to include location information for the code figments in the nodes that interact with the hidden or implicit code. The data graph may then be provided to a user or as a service to be used by coding tools.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09116780&OS=09116780&RS=09116780
owner: GOOGLE INC.
number: 09116780
owner_city: Mountain View
owner_country: US
publication_date: 20130206
---
Software developers write source code in several different programming languages. Each programming language has distinct syntax and semantics. Coding tools including code browsers Integrated Development Environments IDES and historical analysis tools need to be able to understand source code languages in order for these tools to be useful to the software developers. Most tools are good at representing one or two languages but have difficulty supporting other languages. In order to have adequate tool support across all programming languages there should be a single code model that can be used by all tools. Representing semantics and syntax of source code for all languages requires a complex data model and a service that understand each language s nuances. The data model and service also need to be able to index elements and display relationships among elements from any programming language and across languages.

This specification describes technologies relating to data modeling in general and specifically to methods and systems for modeling code segments that lack source locations.

In general one aspect of the subject matter described in this specification can be embodied in a system and method for modeling source code. An exemplary system includes one or more processing devices and one or more storage devices storing instructions that when executed by the one or more processing devices cause the one or more processing devices to receive source code including code segments that do not have a source location index the received source code create a data model from the indexed source code that includes a plurality of nodes representing code elements and a plurality of edges for relationships between elements determine the source location to be associated with each node responsive to recognizing one of the code segments as a hidden or implicit code segment create a figment representation for the code segment and assign the created figment as the source location associated with the code segment s node. An exemplary method includes receiving source code including code segments that do not have a source location indexing the received source code creating a data model from the indexed source code that includes a plurality of nodes representing code elements and a plurality of edges for relationships between elements determining the source location to be associated with each node responsive to recognizing one of the code segments as a hidden or implicit code segment creating a figment representation for the code segment and assigning the created figment as the source location associated with the code segment s node. A second exemplary method for using a data model that represents a code segment that does not have a source location includes requesting a data model for code which includes a code segment that does not have a source location receiving the requested data model including a figment representation of the code segment that does not have a source location and optionally displaying the figment representation of the code segment to an end user.

These and other embodiments can optionally include one or more of the following features a figment node may be specially annotated to distinguish the node from other nodes in the date model the data model may be provided to a user the data model may be provided via an application programming interface API the data model may be provided to a user via a user interface the data model may be provided to a user via command line code the figment representation s content may be valid code syntax the figment representation s content models code behavior but does not represent valid code syntax there may be an edge between a node for source code which uses the hidden or implicit code segment and a node representing the created figment the data model may contain metadata about the figment representation the metadata may be used to show or hide the figment representation from the end user the metadata may be used to display information that a code segment is a figment the metadata may be used to display information that a code segment contains a figment and a data model may be requested using an application programming interface.

The details of one or more embodiments of the invention are set forth in the accompanying drawings which are given by way of illustration only and the description below. Other features aspects and advantages of the invention will become apparent from the description the drawings and the claims. Like reference numbers and designations in the various drawings indicate like elements.

An exemplary data model and service provides a language neutral canonical representation of source code and compiler metadata. The model represents source code as a data graph. A data graph is a data structure that stores data and shows relationships among data using a finite collection of points called nodes and lines called edges. Relationships within a graph are represented by connecting nodes with each other using edges as depicted in .

In order to create a data graph model from source code the source code must be translated to a set of nodes and edges that form a graph. A convenient method that leads to high levels of accuracy is to reuse existing compilers for that source code. A compiler may be provided with indexers that extract data from the compiler to construct nodes and edges for the data graph model.

As discussed above nodes are created to represent segments of the source code. Nodes can represent several different types of elements such as built in types parameterized types composite types pointer types declarations of symbols user defined types references methods method calls fields assignments comments inline documentation and files. Each node may contain certain information including a globally unique identifier for the node a kind of element a display name a location for the element in the source code the element s modifiers dimensions and snippets of code that exist around the element in the source code. A node could be but is not limited to one of several kinds such as unresolved comment lost namespace package module class structure interface enumeration enumeration constant function method constructor field local parameter variable property boolean character string regular expression integer float fixed number rational number complex number big number object instance file directory symbolic link diagnostic pointer reference alias null void unit variatic type parameter type variable type specialization type symbol name value usage array set map list tuple and union.

Edges may represent relationships among elements in the data model. These edges may be bi directional meaning that each edge from a first node to a second node has a mirrored edge from the second node to the first node. There may be several different kinds of edge pairs including extends extended by implements implemented by overrides overridden by inherits inherited by declares declared by captures captured by base type composing type has type is type of return type returned by call called at instantiate instantiated at reference referenced at has property property of has declaration declaration of has definition definition of has input consumed by has output produced by generates generated by restricted to allowed access to usage context enclosed usage annotated with annotation of parent child and throws thrown by.

In some instances a data graph stores semantic information about elements that have no source location because some pieces of code are hidden or implicit and do not have a physical location. Examples of code that does not have a location include default constructors macro expansions template instantiations statically indexable runtime objects implicit function arguments lambda expansions document comments constant folding and generated code.

Hidden or implicit code segments may be referenced used or otherwise linked to other parts of the source code. It is problematic for these code segments to lack a location. If a user wants to traverse the data graph from a place in the source code that calls one of the above mentioned code segments to the segment the usual jump function does not work since there is no actual physical place in the source code for the hidden or implicit code segment and therefore no location in the data graph for the element. Hidden or implicit code segments may also not have a representation that is valid syntax in the source language.

In certain cases where there is hidden or implicit code customary data models often show messages that tell users that there is no source location available. Other customary models alternatively synthesize a location that points to a related piece of source code. Although this synthesizing approach may be good enough for a software developer to understand the code the approach is not usable for static analysis tools. For example in the case of default constructors if the user clicks on an instantiation of the constructor a data graph model may take the user to the declaration of the class instead. Most users if they clicked on a default constructor would understand why a data graph model would take them to the declaration that brought the the implicit default constructor into existence. However a static analysis tool may not have this special knowledge. Therefore if a static analysis tool were to refactor the source code when there is hidden or implicit code the tool would most likely rewrite the code into code that is invalid. Another customary model includes building custom user interfaces but this model requires that each kind of hidden implicit data have its own way of storing metadata as well as custom UI.

An exemplary data graph model does not skip or synthesize alternative locations to hidden or implicit code segments. Instead the exemplary model exposes representations of the hidden implicit code segments by creating code figments. An exemplary method recognizes hidden implicit code segments within source code. Source figments are then generated for the hidden implicit code. These figments do not need to be actual compiled code or even valid syntax in the source language. However the figments should represent the hidden or implicit code in a meaningful way. It is preferable that the figments have syntax as close as possible to the original source language so that the end user can understand the figment.

An exemplary method for modeling code segments that do not have a source location begins with receiving source code as illustrated in . The source code should then be indexed . A data model may be created from the indexed source code using nodes to represent elements and edges to represent relationships between nodes . For each node the source location may be determined . If the code segment represented by the node is hidden or implicit a code figment representation of the code segment may be created . The figment location may then be used to model the location in any node that represents any aspect of the hidden or implicit code . Figment nodes may also be specially annotated to distinguish figment nodes from real nodes. The data may then be provided to an end user via a user interface an application programming interface or some other mechanism.

In an exemplary data graph model such as the one illustrated in a figment is added to represent the implicit Tester constructor . This figment which is a snippet of java code that may not be compilable on its own contains enough information about the constructor for a user to understand the implicit code. The node describing the figment is labeled with a special annotation such as figment true as shown in the node indicating that the node is a figment. The node describing the Tester constructor is then modified to have the node s location point to the newly added figment.

Location information may be any kind of information that is useful about the location of a code segment. Although location information in the figures is shown as a file and a line number this information is illustrated merely for example purposes.

In an exemplary embodiment coding tools and User Interfaces may use that data model enhanced with figments to represent code to an end user. An exemplary method for using a data model that represents a code segment which does not have a source location begins with requesting a data model as illustrated in . A data model may be requested using application programming interface API calls to an exemplary data graph model service. The received data model may contain at least one code segment that does not have a source location. The received data model may include a figment representation of the code segment that does not have a source location . This data model may then be displayed to an end user . In addition to a figment representation of a code segment that does not have a source location the data model may contain metadata about the figment representation. This metadata may include a distinction between model nodes that are figments and those nodes that are not. The data model may also provide edge relationships between a node that contains a code segment without a source location and the node representing the code segment without a source location. The edge relationship may be modeled as a FIGMENT OF HAS FIGMENT relationship. Code tools and user interfaces may use the metadata edge relationships and other provided information to determine what information to display to a user.

Depending on the desired configuration the processor can be of any type including but not limited to a microprocessor P a microcontroller C a digital signal processor DSP or any combination thereof. The processor can include one more levels of caching such as a level one cache and a level two cache a processor core and registers . The processor core can include an arithmetic logic unit ALU a floating point unit FPU a digital signal processing core DSP Core or any combination thereof. A memory controller can also be used with the processor or in some implementations the memory controller can be an internal part of the processor .

Depending on the desired configuration the system memory can be of any type including but not limited to volatile memory such as RAM non volatile memory such as ROM flash memory etc. or any combination thereof. System memory typically includes an operating system one or more applications and program data . The application may include a system for double filtering email annotations so that only annotations associated with actions that a user is likely to take are shown to a user. Program Data includes storing instructions that when executed by the one or more processing devices implement a system and method for parsing actionable items from email text and filtering these actionable items to only display those that a user is likely to act upon. . Program data may also include service data . In some embodiments the application can be arranged to operate with program data on an operating system .

The computing device can have additional features or functionality and additional interfaces to facilitate communications between the basic configuration and any required devices and interfaces.

System memory is an example of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media can be part of the device .

The computing device can be implemented as a portion of a small form factor portable or mobile electronic device such as a cell phone a smart phone a personal data assistant PDA a personal media player device a tablet computer tablet a wireless web watch device a personal headset device an application specific device or a hybrid device that include any of the above functions. The computing device can also be implemented as a personal computer including both laptop computer and non laptop computer configurations.

The foregoing detailed description has set forth various embodiments of the devices and or processes via the use of block diagrams flowcharts and or examples. Insofar as such block diagrams flowcharts and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams flowcharts or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof. In one embodiment several portions of the subject matter described herein may be implemented via Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs digital signal processors DSPs or other integrated formats. However those skilled in the art will recognize that some aspects of the embodiments disclosed herein in whole or in part can be equivalently implemented in integrated circuits as one or more computer programs running on one or more computers e.g. as one or more programs running on one or more computer systems as one or more programs running on one or more processors e.g. as one or more programs running on one or more microprocessors as firmware or as virtually any combination thereof and that designing the circuitry and or writing the code for the software and or firmware would be well within the skill of one of skill in the art in light of this disclosure. In addition those skilled in the art will appreciate that the mechanisms of the subject matter described herein are capable of being distributed as a program product in a variety of forms and that an illustrative embodiment of the subject matter described herein applies regardless of the particular type of non transitory signal bearing medium used to actually carry out the distribution. Examples of a non transitory signal bearing medium include but are not limited to the following a recordable type medium such as a floppy disk a hard disk drive a Compact Disc CD a Digital Video Disk DVD a digital tape a computer memory etc. and a transmission type medium such as a digital and or an analog communication medium. e.g. a fiber optic cable a waveguide a wired communications link a wireless communication link etc. 

With respect to the use of substantially any plural and or singular terms herein those having skill in the art can translate from the plural to the singular and or from the singular to the plural as is appropriate to the context and or application. The various singular plural permutations may be expressly set forth herein for sake of clarity.

Thus particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

