---

title: Memory space mapping techniques for server based graphics processing
abstract: The server based graphics processing techniques, describer herein, include loading a given instance of a guest shim layer and loading a given instance of a guest display device interface that calls back into the given instance of the guest shim layer, in response to loading the given instance of the guest shim layer, wherein the guest shim layer and the guest display device interface are executing under control of a virtual machine guest operating system. The given instance of the shim layer requests a communication channel between the given instance of the guest shim layer and a host-guest communication manager (D3D HGCM) service module from a host-guest communication manager (HGCM). In response to the request for the communication channel loading, the D3D HGCM service module is loaded and a communication channel between the given instance of the shim layer and the D3D HGCM service module is created by the HGCM. The given instance of the shim layer maps the graphics buffer memory space of a host D3D DDI binary executing under control of a host operating system. Thereafter, function calls are sent from the given instance of the guest shim layer through the communication channel to the D3D HGCM service module utilizing the graphics buffer memory space mapping.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09542715&OS=09542715&RS=09542715
owner: NVIDIA CORPORATION
number: 09542715
owner_city: Santa Clara
owner_country: US
publication_date: 20131029
---
Computing systems have made significant contributions toward the advancement of modern society and are utilized in a number of applications to achieve advantageous results. Numerous devices such as desktop personal computers PCs laptop PCs tablet PCs netbooks smart phones servers and the like have facilitated increased productivity and reduced costs in communicating and analyzing data increased consumption of electronic content and the like in most areas of entertainment education business and science. Developing aspects of computing systems include client server computing platforms virtual machine computing platforms and cloud computing platforms and graphics processing thereon.

For graphics intensive applications such as multiplayer online computer games the Windows operating system runs each instance of the application in full screen mode. The full screen mode is an exclusive mode such that another instance of the running application cannot output display frames because the first instance is running full screen. Therefore even on a server with multiple graphics processing units multiple instances of an application cannot be run at the same time because the fast application will be running in full screen mode. Similarly even on virtual machine implementations the first application running on a guest operating system will run full screen and prevent other applications running on other guest devices from outputting display frames. However with the proliferation of multi processor and or multi core CPU and or GPU server devices it would be beneficial to be able to run multiple graphics intensive applications or instances of the same application. Accordingly there is a continued need for improved graphics processing techniques on client server computing platforms virtual machine computing platforms and cloud computing platforms.

The present technology may best be understood by referring to the following description and accompanying drawings that are used to illustrate embodiments of the present technology directed toward server based graphics processing techniques.

In one embodiment a server based graphics processing method includes loading a given instance of a guest shim layer and loading a given instance of a guest display device interface that calls back into the given instance of the guest shim layer in response to loading the given instance of the guest shim layer. The guest shim layer and the guest display device interface are executing under control of a virtual machine guest operating system. The given instance of the shim layer requests a communication channel between the given instance of the guest shim layer and a three dimensional graphics application programming interface host guest communication manager D3D HGCM service module from a host guest communication manager HGCM in response to the loading of the given instance of the guest shim layer. The D3D HGCM service module is loaded and a communication channel between the given instance of the shim layer and the D3D HGCM service module is created by the HGCM in response to the request for the communication channel. The given instance of the shim layer request a copy of the binary of the host D3D DDI that is stored on the host device. The given instance of the shim layer receives the host D3D DDI binary and store the host D3D binary on the disk of the virtual machine. Thereafter the given instance of the shim layer loads and uses the entry point of the imported host D3D DDI binary to generate command buffers to pass down to the host through the HGCM.

Embodiments of the present technology advantageously map graphic buffers allocated by a thunk layer in a kernel mode driver stack so that a guest DDI in a guest VM OS can access the memory space in the host OS directly.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Reference will now be made in detail to the embodiments of the present technology examples of which are illustrated in the accompanying drawings. While the present technology will be described in conjunction with these embodiments it will be understood that they are not intended to limit the invention to these embodiments. On the contrary the invention is intended to cover alternatives modifications and equivalents which may be included within the scope of the invention as defined by the appended claims. Furthermore in the following detailed description of the present technology numerous specific details are set forth in order to provide a thorough understanding of the present technology. However it is understood that the present technology may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail as not to unnecessarily obscure aspects of the present technology.

Some embodiments of the present technology which follow are presented in terms of routines modules logic blocks and other symbolic representations of operations on data within one or more electronic devices. The descriptions and representations are the means used by those skilled in the art to most effectively convey the substance of their work to others skilled in the art. A routine module logic block and or the like is herein and generally conceived to be a self consistent sequence of processes or instructions leading to a desired result. The processes are those including physical manipulations of physical quantities. Usually though not necessarily these physical manipulations take the form of electric or magnetic signals capable of being stored transferred compared and otherwise manipulated in an electronic device. For reasons of convenience and with reference to common usage these signals are referred to as data bits values elements symbols characters terms numbers strings and or the like with reference to embodiments of the present technology.

It should be borne in mind however that all of these terms are to be interpreted as referencing physical manipulations and quantities and are merely convenient labels and are to be interpreted further in view of terms commonly used in the art. Unless specifically stated otherwise as apparent from the following discussion it is understood that through discussions of the present technology discussions utilizing the terms such as receiving and or the like refer to the actions and processes of an electronic device such as an electronic computing device that manipulates and transforms data. The data is represented as physical e.g. electronic quantities within the electronic device s logic circuits registers memories and or the like and is transformed into other data similarly represented as physical quantities within the electronic device.

In this application the use of the disjunctive is intended to include the conjunctive. The use of definite or indefinite articles is not intended to indicate cardinality. In particular a reference to the object or a object is intended to denote also one of a possible plurality of such objects. It is also to be understood that the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting.

Referring to a hardware level representation of a client server or cloud computing platform in accordance with one embodiment of the present technology is shown. The client server or cloud computing platform includes a plurality of user devices communicatively coupled by one or more networks to one or more server devices . In the cloud computing platform hardware resources software and information are provided to user devices as a utility over a network. Therefore the cloud computing platform delivers computing as a service rather than a product. User devices access cloud based resources through a web browser or a light weight desktop or mobile application. The cloud computing platform enables device and location independence virtualization multi tenancy reliability performance security maintenance infrastructure convergence shared services and or the like to service demands that may be fluctuating unpredictable and or the like.

Each server may include one or more processing units one or more computing device readable media e.g. memory one or more network interfaces and or the like communicatively coupled together by one or more communication links . In one implementation the server includes a central processing unit CPU non volatile memory such as read only memory ROM magnetic hard disk drive optical disk drive and or the like volatile memory such as random access memory one or more network interface cards for communicatively coupling the server to one or more networks and a plurality of graphics processing units .

Applications running on the server device may render display frames to be output on a display of the user device . The display frame data is encoded at the server to compress it and transmitted across one or more networks to the user device . The user device decodes the display frame data and outputs it on the display attached to the user device . In one implementation the application may be a graphics intensive application such as a multiplayer computer game or the like.

Referring now to a virtual machine representation of the client server or cloud computing platform is shown. The one or more processors of the server executing computing device executable instructions implement a host operating system a virtual machine management VMM host application and a plurality of virtual machine VM guest operating systems . In one implementation the host operating system may be Windows 7 Operating System by Microsoft of Redmond Wash. USA. The VMM host application is run as an application of the host operating system . In one implementation the virtual machine management host application may be VirtualBox by Oracle of Redwood Shores Calif. USA. A plurality of VM guest operating systems run in the virtual machine implemented by the VMM host application . In one implementation each VM guest operating system may be an instance of the Windows 7 Operating System. Each of one or more user devices may communicatively couple to the server as a guest through a corresponding instance of the VM guest operating system 

Referring now to a virtual machine representation at the rendering function level of the client server or cloud computing platform in accordance with one embodiment of the present technology is shown. The server device includes applications drivers utilities and the like for each of a plurality of guests executing under control of a respective virtual guest operating system . The server device also includes a virtual machine monitor host application and drivers utilities and the like for each of one or more hosts executing under control of a VMM host operating system . In one implementation the VM guest OS controls the execution of a user application an application initialization utility a runtime application programming interface API a guest shim layer and a guest device driver interface DDI . The VMM host OS controls the execution of a host guest communication manager HGCM a three dimension graphics application programming interface host guest communication manager D3D HGCM service module a thunk layer an OS kernel mode driver and a device specific kernel mode driver .

For each rendering context in one implementation the guest may include an instance of the user application the application initialization utility the runtime application programming interface the guest shim layer the guest DDI the thunk layer the OS kernel mode driver the device specific kernel mode driver and the given GPU . The HGCM and D3D HGCM service module are shared across a plurality of guests. Although illustrates a single guest it is appreciated that a plurality of guests are typically implemented on a server device.

When an application starts running on the VM guest OS the application initialization routine is injected. In one implementation the application initialization routine is a short dynamic link library e.g. appin.dll . The application initialization routine injected in the application includes some entry points one of which includes a call e.g. set dll searchpath to change the search path for the display device interface. During initialization the search path for the display device interface e.g. c windows system32 . . . umd.dll is changed to the search path of the guest shim layer e.g. c . . . vmm . . . umd.dll . Therefore the runtime API will search for the DDI in a different path which will result in the runtime API loading the guest shim layer . In one implementation the guest shim layer is an independent library. The guest shim layer library has the same entry points as a conventional display device interlace DDI .

During initialization the guest shim layer loads the guest DDI . In one implementation the guest DDI may be a user mode driver dynamic linked library nvd3dUMD.dll . The runtime API passes one or more pointers to the guest shim layer when calling into the applicable entry point e.g. OpenAdapter in the guest shim layer . The pointers passed to the guest shim layer are call hacks into the runtime API . The guest shim layer stores the pointers received from the runtime API . The guest shim layer loads and initializes the guest DDI by passing pointers which are call backs into local functions of the guest shim layer . The guest DDI also returns pointers to one or more data structures to the guest shim layer . The pointers returned from the guest DDI to the guest shim layer may include pointers to one or more command buffers. The data structure pointers returned by the guest DDI are stored by the guest shim layer . Accordingly the guest DDI is able to initialize without talking back to the runtime API .

During initialization each guest shim layer also requests a communication channel e.g. pipe socket from the HGCM . When a communication channel is established a mapping is created to associate a rendering context of a given guest to a given GPU hardware of the host. In one implementation the HGCM returns a token identifier ID to the guest shim layer that identifies the rendering context mapping. The guest shim layer also requests that the HGCM load the D3D HGCM service module . The guest shim layer further requests a copy of the binary file of the thunk layer . OS kernel mode driver and or device specific user mode driver . In response the HGCM retrieves the binary of the thunk layer . OS kernel mode driver and or device specific user mode driver and returns it across the communication channel to the guest shim layer . The guest shim layer stores the binary of the thunk layer OS kernel mode driver and or device specific user mode driver hereinafter referred to as the host stack binary in memory e.g. virtual disk for use in determining the format of applicable data structures so that the commands sent by the guest shim layer match the format utilized in the host stack. The data structure details referenced in the host stack binary may include the particular buffers utilized the locations thereof and the like. The D3D HGCM service module thunk layer OS kernel mode driver and or device specific kernel mode driver also create a memory allocation to storing the data structures used for passing rendering commands down through stack from the guest application to the device specific kernel mode driver.

Thereafter during rendering the application sends various commands to the runtime API . The commands may include such things as draw a triangle change a color set a texture and or the like. In one implementation the commands from the application may be DirectX commands. The runtime API may validate the commands before calling into the guest shim layer with the commands. The runtime API may operate substantially in accordance with a conventional runtime API from Microsoft Corporation e.g. d3d9.dll . The guest shim layer in turn calls into the guest DDI with the commands. The guest DDI transforms the command functions calls into byte code calls in command buffers allocated in accordance with the copy of the stored copy of the host stack binary. When the command buffers have been set one or more function calls including pointers to the command buffers are forwarded from the guest DDI to the guest shim layer by callbacks specified in the initialization phase. The function calls including pointers to the command buffers are forwarded by the guest shim layer through the HGCM to the D3D HGCM service module . The remote procedure calls are routed across a pipe between the guest and the host setup when the HGCM was initialized. In one implementation the guest shim layer passes a token ID associated with the rendering context to the D3D HGCM service module along with the calls from the guest DDI .

The D3D HGCM service module determines a rendering context for the function call received from the guest shim layer . In one implementation the D3D HGCM service module utilizes the token ID as a handle to a data structure that defines the rendering context of the corresponding guest. The D3D HGCM service module in turn forwards the function calls through the thunk layer to the operating system kernel mode driver . The operating system kernel mode driver in response schedules the command buffers at the function pointers included with the function calls with the device specific kernel mode driver for execution of the functional calls by a given GPU . The device specific kernel mode driver sets command register of the GPU to execute the graphics command and controls the execution thereof by the GPU . In one implementation the thunk layer may operate substantially the same as a conventional thunk layer from Microsoft Corporation e.g. GDI32.dll . The OS kernel mode driver may operate substantially the same as a conventional OS kernel mode driver from Microsoft Corporation e.g. dxgkrnl.sys . In one implementation the device specific kernel mode driver may operate substantially the same as a conventional device specific kernel mode driver from Nvidia Corporation of Santa Clara Calif. e.g. kmd.sys .

For a display related function call e.g. Present the D3D HGCM service module routes the rendered frame data to an encoder associated API and driver hereinafter simply referred to as the encoder when the rendered frame data is returned to the D3D HGCM service module . The rendered frame data is rerouted by the D3D HGCM service module to the encoder instead of back to the guest shim layer guest DDI runtime API and application. The encoder encodes the rendered frame data to compress the data. The compressed data is then sent from the encoder to a network interface associated API and driver hereinafter simply referred to as the network interface for transmission to the appropriate user device . In one implementation the encoder may be a conventional encoder such as a H.264 encoder.

At the thunk layer OS kernel mode driver and device specific kernel mode driver levels the function calls are merely rendering tasks and there is not a sense of full screen mode. The D3D HGCM service module can be the target of several host guest communication manager sessions which means that several guest VM can talk to the same components in the host. The way components in the host are scheduled they do not need to go full screen. However the application running in the VM guest OS is running full screen but does not show anything on its virtual screen. In fact the VM guest OS need not receive the rendered image hack from the VMM host OS .

Referring now to a client server or cloud computing based graphics processing method in accordance with one embodiment of the present technology is shown. The method may be implemented as one or more sets of computing device executable instructions e.g. computer programs utilities drivers routines that are stored in one or more computing device readable media e.g. computer memory and executed by one or more processing units e.g. CPUs GPUs .

The method begins with receiving graphics commands by a runtime application programming interface API from an application running under control of a virtual machine VM guest operating system OS at . At a guest shim layer is loaded in response to the runtime API receiving a first graphics command. At the guest shim layer requests from a host guest communication manager HGCM a communication channel e.g. pipe socket to a three dimension graphics application programming interface a host guest communication manager D3D HGCM service module when the guest shim layer is loaded. The HGCM is loaded under control of a virtual machine management VMM host OS. At the HGCM loads the D3D HGCM service module if it has not already been loaded and creates a communication channel e.g. pipe socket between the guest shim layer and the D3D HGCM service module in response to the request from the guest shim layer. At the HGCM associates a rendering context e.g. adapter between the given instances of the guest shim layer and a thank layer. At the thunk layer is loaded for the associated rendering context. At one or more command buffers are allocated by the thunk layer when the thunk layer is loaded. At an OS kernel mode driver is loaded when the thunk layer is loaded. At a device specific kernel mode driver for a given graphics processing unit GPU is loaded when the OS kernel mode driver is loaded.

At the guest shim layer requests from the D3D HGCM service module through the HGCM a copy of the binary of the host D3D DDI that is stored on the host device. At the D3D HGCM service module returns the copy of the host D3D DDI to the guest shim layer through the HGCM. At the guest shim layer receives the host D3D DDI binary and stores the host D3D DDI binary on the disk of the virtual machine. The shim layer loads and uses the entry points of the imported host D3D DDI binary to generate command buffers to pass down to the host through the HGCM.

In one implementation VirtualBox includes a software development kit SDK that provides a HGCM. The HGCM provides for registering that the D3D HGCM service module is callable by the shim layer within the guest. Conventionally VirtualBox also has its own graphics drivers e.g. user mode and kernel mode for software based rendering on the central processing unit. However software based rendering on the central processing unit provides substantially lower rendering performance compared to hardware based graphics rendering on a graphics processing unit. Accordingly embodiments of the present technology make use of the HGCM of VirtualBox but not the graphics drivers of VirtualBox.

At the guest shim layer loads a guest display device interface DDI user mode driver when the guest shim layer is loaded and passes the pointers to the one or more command buffers to the guest DDI. At the guest DDI returns to the guest shim layer callbacks to rendering functions with pointers to corresponding data structures when the guest DDI is loaded. The processes of are repeated for each application running under control of an instance of a virtual machine guest OS.

At the runtime API calls to the guest shim layer with the received graphics commands. At the guest shim layer calls to the guest DDI with the received graphics commands. At the guest DDI processes the received graphics commands including filling one or more command buffers with arguments from the rendering command. At the guest DDI calls back to the guest shim layer with an appropriate function call after the guest DDI processes a set of one or more corresponding rendering commands. The function calls may be rendering functions present functions and or the like. If the function is a rendering function the call includes pointers to one or more command buffers. At the guest shim layer sends the function calls with a token ID e.g. handle from the guest DDI through the communication channel provided by the HGCM to the D3D HGCM service module. The processes of are performed for each application running under control of a different instance of a virtual machine guest OS.

In one implementation the runtime API may receive approximately 100 300 graphics commands for each rendered frame. The guest DDI calls back with approximately 2 6 function calls for each rendered frame. The parameters of the graphics commands are loaded by the guest DDI directly into command buffers in the VMM host OS memory space that the OS kernel mode driver and or device specific kernel mode driver can access directly without additional memory accesses. Accordingly the communication channel between the shim layer and D3D HGCM service module is limited to 2 6 function calls instead of 100 300 graphics commands.

At the D3D HGCM service module determines a rendering context associated with the token ID for each function call received from a guest shim layer instance. At the D3D HGCM service module sends each function call of a given rendering context to the corresponding instance of the thunk layer. At the given thunk layer sends the function call to the OS kernel mode driver. At the OS kernel mode driver sends the function call to the device specific kernel mode driver. At the OS kernel mode driver schedules the function call by setting command register of the GPU to execute the function call. The processes of are performed by the corresponding instances of the thunk layer OS kernel mode driver and device specific mode driver for the associated rendering context.

At the GPU outputs rendered frame data to the device specific kernel mode driver if the function call is a present function. At the device specific kernel mode driver returns the rendered frame data through the OS kernel mode driver and thunk layer to the D3D HGCM service module. At the D3D HGCM service module passes the rendered frame data to an encoder for encoding to compress the rendered frame data. At the encoder passes the encoded compressed frame data to a network interface for transmission to a user device.

Embodiments of the present technology advantageously enable several graphics applications to run at the same time on a server computing device with several graphics processing unit. Embodiments advantageously enable increased density on graphics processing unit client server platforms and cloud computing platforms. The host to guest communication is relatively low and fast in accordance with embodiments of the present technology which is good for performance. In one implementation calls from the guest OS to the host OS may occur in approximately 0.3 ms or less roundtrip. The guest physical addresses can overlap the physical addresses of the GPU running on the base OS so that there is no duplication which is also good for performance. The applications in accordance with embodiments of the present technology see genuine operating system files which are robust for anti cheat techniques and digital rights management techniques. The applications have the impression of running full screen which is also good for performance. The user mode drivers run in the virtual machine which can be capped pinned throttled and or the like to cores threads and or the like. Encoding can feed off the render target in the host which is also good for performance. The virtual machine driver can report 1 n FB size wherein n is the number of virtual machines. The rendering can be done on any GPU including headless Tesla when attached as a headless DX rendering device.

The foregoing descriptions of specific embodiments of the present technology have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the present technology and its practical application to thereby enable others skilled in the art to best utilize the present technology and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto and their equivalents.

