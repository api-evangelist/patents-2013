---

title: Programming framework for applications
abstract: An application comprises program code that includes API tags, which during execution of the application may be resolved to reference-able data objects. The data objects may be objects in a knowledge base. The API tags decouple the program code from the specific data contained in the knowledge base, allowing for applications that access the knowledge base to be written independently of the knowledge base; even before the knowledge base is loaded with data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09158599&OS=09158599&RS=09158599
owner: SAP SE
number: 09158599
owner_city: Walldorf
owner_country: DE
publication_date: 20130627
---
This application is related to commonly owned concurrently filed U.S. application Ser. No. 13 902 677 entitled REPRESENTING ENTERPRISE DATA IN A KNOWLEDGE GRAPH and U.S. application Ser. No. 13 902 686 entitled IDENTIFYING AND INVOKING APPLICATIONS BASED ON DATA IN A KNOWLEDGE GRAPH each of which is incorporated herein by reference in its entirety for all purposes.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

A typical organization such as a business enterprise collects large amounts of data. Most users of the data are casual users who may get periodic reports from their IT group or business analysis groups. Oftentimes the data contained in the reports are old and the reports themselves may not provide the right information or analytics that a particular user may desire. Requests for specialized reports however typically require three to six or more months turnaround time. By the time the user gets their report the data or the report is no longer relevant.

In the following description for purposes of explanation numerous examples and specific details are set forth in order to provide a thorough understanding of the present disclosure. It will be evident however to one skilled in the art that the present disclosure as expressed in the claims may include some or all of the features in these examples alone or in combination with other features described below and may further include modifications and equivalents of the features and concepts described herein.

In accordance with the present disclosure the knowledge base may comprise a knowledge graph an index a database system and a knowledge builder . The knowledge base may represent an organization s knowledge as manifested in the knowledge graph index and database system . In some embodiments the database system may be a relational database RDB although in other embodiments the database system may be based on other suitable database architectures. The knowledge builder may receive data from the organization and incorporate that data into the knowledge base thus increasing the store of the organization s knowledge.

The search input engine may receive search inputs from a user. The search input engine may invoke a selected application from among the collection of query processing applications based on the user s search input. An application e.g. App1 that is invoked may process the query represented in the user s search input by accessing the knowledge base via the query engine to produce a results output which may then be presented to the user.

In accordance with the present disclosure the knowledge base may be connected to various sources of data in order to build up the knowledge base. In a business enterprise for example a source of data may be enterprise data . For example the knowledge base may be connected to the enterprise s backend systems to collect and store the enterprise data . Typical backend systems include customer relationship management CRM enterprise resource planning ERP and so on. The example of a business enterprise will be used in the remaining discussions with the understanding that organizations other than businesses may be served by the system of the present disclosure.

Another source of data that can be stored in the knowledge base may include for example publicly accessible data. In some embodiments public data may be accessed from the Internet for example by scouring the Internet using known web crawling techniques. Other data sources may include for example public records posted on government web sites and such. These additional sources of data may add further context to the enterprise data provide supplemental information about the enterprise data and so on to enhance the quality and usefulness of the enterprise data. For example data from a CRM system typically includes information about the enterprise s customers. Crawling the Internet may reveal additional information about its customers e.g. publicly available information from their Facebook account and so on that can be read into and incorporated into the knowledge base .

Another source of data that can be included in the knowledge base are analytics . Analytics data may comprise data that are derived from computations and analyses performed on the data stored in the knowledge base . In some embodiments analytics data may incorporate other data as well. Analytics data may be generated within the system . In some embodiments for example background processes not shown within the system may perform computation and other analyses on the data. The results may serve an additional source of data that can be incorporated into the knowledge base . In other embodiments analytics data may be generated from processes or systems external to the system . This approach may be useful when the volume of data in the knowledge base increases to a point where the computing capacity of one data system is insufficient.

In some embodiments an initial knowledge graph may be provided to the knowledge base for example when the system is first installed. The initial knowledge graph may represent the initial state of the knowledge graph and in the context of an enterprise may represent a rudimentary view of the enterprise data. As will be explained below the knowledge graph will grow as more and more data is fed into the knowledge base .

In accordance with the present disclosure the system may be implemented using any suitable technology for example in the cloud e.g. using the software as a service SaaS models and the like in hardware that is on enterprise premises or some combination of cloud computing and hardware. Referring to an example of a hardware embodiment is shown. In an illustrative implementation the system may include a computer system having a processing unit a system memory and a system bus . The system bus may connect the various system components including but not limited to the processing unit the system memory an internal data storage device and a communication interface .

The processing unit may comprise a single processor configuration or may be a multi processor architecture. The system memory may include read only memory ROM and random access memory RAM . The internal data storage device may be an internal hard disk drive HDD a magnetic floppy disk drive FDD e.g. to read from or write to a removable diskette an optical disk drive e.g. for reading a CD ROM disk or to read from or write to other high capacity optical media such as the DVD and so on. The internal data storage device and its non transitory computer readable storage media may serve as nonvolatile storage for data data structures computer executable instructions and so forth. It is noted that computer readable storage media may include zip drives magnetic cassettes flash memory cards cartridges and the like. Any such media may contain computer executable instructions for performing the methods disclosed herein.

The system memory and or the internal data storage device may store a number of program modules including an operating system one or more application programs program data and other program system modules . The application programs when executed by the processing unit may cause the processing unit to perform steps set forth in the present disclosure for example to operate one or more of the knowledge base and it components the search input engine the query engine and so on.

An external data storage device may be connected to the computer system . In some embodiments the elements of the knowledge base may be implemented on the data storage device . In other embodiments separate data storage systems may be deployed to store the knowledge graph the index and the database system .

Access to the computer system may be provided by a suitable input device e.g. keyboard mouse touch pad etc. and a suitable output device e.g. display screen . Thus an administrative user may access the system to maintain and otherwise manage the system.

The computer system may operate in a networked environment using logical connections via wired and or wireless communications to one or more remote computers not shown over a communication network . The communication network may be a local area network LAN and or larger networks such as a wide area network WAN . The communication interface may provide access to the enterprise s backend systems the Internet and so on. User s may access the system remotely for example using a web interface.

Referring now to details of the knowledge builder in accordance with some embodiments of the present disclosure will be discussed. As explained above the knowledge builder may receive enterprise data and build or otherwise incorporate that data into the knowledge base . As will be explained in more detail below the data may be incorporated into one or more of the knowledge graph the index and or the database system .

The knowledge builder may include reader converter modules for each source of data. Each reader converter module will know how to interface to its particular source of date. Data sources may include the backend systems of the enterprise e.g. CRM data pulled from the Internet external databases data files and so on. A reader converter module for an enterprise backend system may comprise a communication interface both hardware and software to communicate with that backend system access and download the data stored and managed by that backend system. The reader converter module for accessing data on the Internet may comprise web crawler applications or other similar technology. And so on with other data sources.

The data from the data sources will likely exist in several forms and formats. Accordingly each reader converter may perform data conversion to convert data to an internal standardized format to facilitate data handling and data processing efforts downstream in the knowledge builder .

A data assembler may receive data from the reader converters . In accordance with the present disclosure the data assembler may process the data and incorporate the data into the knowledge stores of the knowledge base namely the knowledge graph index and database system .

In accordance with the present disclosure data may be classified according to classes of data defined in the knowledge graph . Accordingly the data assembler may provide the received data to a classifier to do perform the classification of data. In some embodiments the classifier may use one or more helper modules to facilitate the classification process. For example the classifier may be able to classify the data based only on a sample of the data. Accordingly a sampler helper module may be provided to take a suitable sample of the data for the classifier .

A data loader and access module may coordinate access to the knowledge stores. The data loader and access module may be responsible for adding data to the various components of the knowledge base . For example the data loader and access module may manage the knowledge graph such as adding nodes to the graph creating links edges between nodes and so on. Similarly the data loader and access module may manage the contents of the index and the database system .

Interfaces may be provided in order to hide the low level details of the knowledge graph the index and the database system . Accordingly the loader and access module be given access to these parts of the knowledge base via interfaces and .

The description will now turn to a discussion of knowledge graphs e.g. knowledge graph in accordance with the present disclosure. A knowledge graph represents data and more particularly the knowledge graph represents the semantics in the data. introduces some terminology used in the following discussions of knowledge graphs. A knowledge graph may be viewed as a network of connected nodes. In specific embodiments the knowledge graph may be represented in a computer with structured data that represent nodes properties and or attributes of nodes links edges between nodes properties and or attributes of links and the like.

The knowledge graph comprises first level nodes also referred to as meta nodes entity nodes that define an abstraction of the data represented by the knowledge graph. In particular the data that is represented by the knowledge graph may be classified into different classes of data. Each first level node represents a class of data among the classes of data. Merely to illustrate the point a class of data might be automobiles which would be represented by a first level node another class of data might be elementary schools which would be represented by another first level node and so on. First level nodes may include a properties list which specify properties attributes collectively properties of instances of data in the corresponding class. For example properties of the class of data called automobiles may include make model color and so on. The properties list may also include information about the first level node itself.

Some first level nodes may be related to other first level nodes. Links e.g. link may be defined between two first level nodes that have a relationship between them. For example if there is a relation between two first level nodes then link may be defined between the two nodes. The link is directed in that the link represents the idea that node is related to node in some way. Likewise if node was related to node in some way then a directed link in the direction from node to node would be defined.

As mentioned above first level nodes define the properties of data that they represent in their associated properties list . The first level nodes do not otherwise represent instances of the data they define and for this reason first level nodes may be referred to as meta nodes . Instances of the data that a first level node defines may be represented by second level nodes also referred to as instance nodes . Using the automobiles example above an instance of the class of data called automobiles might be a red Ford Mustang. Thus while a first level node may define the properties of the class of data called automobiles namely make model and color a second level node may store actual values for an instance of an automobile for example Ford Mustang Red.

Second level nodes are linked to their respective first level nodes . For example second level node is linked to first level node by the relation that the second level node is an instance of the first level node. Likewise second level nodes and are instances of first level node and second level node is an instance of first level node . As will be explained below some second level nodes may be linked together e.g. link to reflect the linkage between respective first level nodes that the second level nodes are instances of.

Second level nodes may include a properties list . The properties list may store or otherwise identify the actual data values of a given instance for example Ford Mustang Red. The properties list may include field names that identify what the values are data types and so on in other words the properties list may include metadata that describes attributes of the actual data that correspond to the instance node .

In accordance with the present disclosure the data that is represented by the knowledge graph may also be stored in a separate data store . More particularly each class of data may be stored in it own data store . The knowledge graph may include data source nodes that point to their respective data stores . Each data source node may include a properties list that describes the details of the data store such as information on how to locate and access the data store how the data is stored in the data store and so on. This aspect of the present disclosure will be described in more detail below.

Each first level node may have a link to a corresponding data source node that points to the data store which contains the class of data represented by that first level node. For example first level node may have a link to data source node which in turn points to data store . Data store may store instances of the class of data defined by the first level node.

In order to provide context for the remaining discussion of embodiments of the present disclosure the example introduced in of an enterprise and its enterprise data such as might be obtained from the enterprise s backend systems will be used. The enterprise data may include data that represents the customers of the enterprise including information such as customer name address and so on. The enterprise data may further include data about its products including information such as product identifiers pricing and the like. Data about the enterprise s sales orders may include information such as who i.e. customer purchased what i.e. product and related information such as when the purchase was made how many units and so on.

As explained above the knowledge builder can build the knowledge base from a data source such as enterprise data . shows an example of the knowledge graph component of the knowledge base . The knowledge graph may represent the above enterprise data as three classes of data Customer data Sales Order data and Product data. Accordingly the knowledge graph may include first level nodes called Customer Product and Sales Order. The property list for the Customer node may include for example the name of the properties of instances of a customer e.g. customer name customer ID and so on and property information about the node itself e.g. name of the node such as Customer a node identifier such as 34837 and so on .

Each first level node e.g. Customer may be linked to a data source node DS . For example the Customer node may be linked to a data source node that points to or otherwise identifies a location e.g. a database where data for the instances of customers are stored. In some embodiments rather than storing the instance data in the I nodes the I nodes may point to or otherwise identify a specific record in the database which contains the instance data.

The knowledge graph may represent the relationships between the Customer node Product node and Sales Order node using links and . For example the link may represent the relationship that a customer has purchased a product while the link may represent the relationship that a product has been purchased by a customer. The link may represent the relationship that a sales was made by a customer. The link may represent the relationship that a sales represents a sale of a product. In some embodiments the link information may be stored in the property lists of the first level nodes.

In accordance with the present disclosure the second level instance nodes I node inherit the linkage relationship s of the first level nodes that they are instances of. In other words the second level instance nodes are linked to other second level instance nodes depending on how their respective first level nodes are linked. Consider for example second level instance nodes and . Node is an instance of the Customer node and node is an instance of the Product node. Since the Customer node and the Product node are linked by links and the nodes and may be similarly linked by links and to represent the fact a specific customer identified in node has purchased link a specific product identified in node . Conversely the link represents that the specific product identified in node has been purchased by the specific customer identified in node .

Similarly the second level instance node is linked to second level instance node by virtue of the first level nodes that they are instances of namely the Sales Order node and the Customer node. Since the Customer node and the Sales Order node are linked by link the nodes and may be similarly linked by link to represent the fact a specific sales order identified in node was made by a specific customer identified in node . Likewise second level instance node instance of Sales Order node is linked to second level instance node instance of Product node in the same way that their respective first level nodes are linked namely by link . Accordingly nodes and node may be linked by to represent the fact a specific sales order identified in node represents a sale of a specific product identified in node . As will be explained in more detail below whether a second level node is linked to another second level node depends on the data that is loaded into the knowledge graph .

Referring now to a high level logical description of a data loading operation performed by the knowledge builder to build the knowledge base in accordance with some embodiments of the present disclosure will now be discussed. The process of data loading will occur several times during the life of the knowledge base to load new data into the knowledge base to load updated data or both. The data loading process flow will be explained in terms of the example embodiment of the knowledge builder disclosed herein. It will be appreciated that the specific algorithms and process flows will vary depending on particular embodiments of the knowledge builder . It will be appreciated that the specific algorithms used to implement particular embodiments of the knowledge builder will vary form one implementation to the next.

At block the system may receive and install an initial knowledge graph to establish an initial state of the knowledge graph . This may occur for example when the system is initially installed in an enterprise. As another example if an existing knowledge base needs to be re initialized the knowledge graph may be set to an initial state by loading in the initial knowledge graph . The initial knowledge graph may be designed and supplied by the provider of system developed by an IT group in the enterprise and so on.

Returning to at block the system e.g. using the knowledge builder may receive enterprise data from the enterprise. The data may be presented by the enterprise from any source and in any suitable form. In some embodiments for example the data may be a data file e.g. from a spreadsheet application that an administrative user may provide to the knowledge builder . In other embodiments the system may be interfaced to some of the backend systems of the enterprise. Data may be loaded to the knowledge builder directly from the enterprise backend systems. Typically the data will be organized into rows of data although this is not necessary. For discussion purposes we can assume without loss of generality that the knowledge builder receives or otherwise organizes the data into rows of data for incorporation into the knowledge base .

At block the classifier may analyze the received enterprise data to identify which class of data or classes of data the enterprise data belongs to and by so doing identify one or more entity nodes. In some embodiments the enterprise data may have headings that can be used to identify one or more suitable entity nodes. For example if the enterprise data is received as spreadsheet data e.g. in a comma separated value CSV format the first row may be a header row that includes headings like customer name customer ID and so on that describe the nature of the subsequent rows of data. In some embodiments the classifier may match the heading information in the received enterprise data against data in the property lists e.g. node name of each entity node to find a matching entity node. The classifier may include suitable matching algorithms to identify exact matches or approximate matches between terms in the enterprise data and terms in the property lists of the entity nodes.

In some embodiments the classifier may use string matching algorithms to identify one or more entity nodes that best match the enterprise data using whatever data is available in the enterprise data. This may be suitable when the enterprise data does not have explicit header information. For example the classifier may attempt to match available text in the enterprise data against any of the properties in the property lists of the entity nodes. In some embodiments for example the classifier may employ a metric called the Levenshtein distance which measures how closely two strings match to find a matching entity node. The enterprise data may be sampled by the sampler helper module to apply the matching algorithm s to a subset of the enterprise data rather than processing all of the enterprise data. In other embodiments several kinds of matching algorithms may be used to identify several candidate entity nodes and a matching entity node may be selected from the list of candidates. And so on.

Further in block the classifier may map the columns of data in the received enterprise data to one or more properties vis vis the property list of the identified entity node. In some embodiments the same or similar processing described above to identify the entity node may be used to map columns of data to the entity s properties.

The classifier may map the received enterprise data to more than one entity node. For example some rows of data in the received enterprise data may map to one entity node while other rows of data map to another entity node. In addition some columns of data in the received enterprise data may map to properties of one entity node while other columns of data may map to another entity node.

In some embodiments if the classifier does not identify any entity nodes from the knowledge graph that map to the received enterprise data then the classifier may create a new entity node and add it to the knowledge graph . In this way the classifier can grow the knowledge graph to incorporate data that was not previously contemplated. An administrative tool may be provided to allow an administrator to supply information about the newly added entity node e.g. a node name and property data linkage to other entity node s and so on. For purposes of discussion we can assume without loss of generality that the classifier has identified only one entity node from among the entity nodes comprising the knowledge graph .

At block a determination is made whether the entity node identified at block is associated with a data store such as a database. As explained above the database may be used to store instance data for instances of the class of data represented by the identified entity node. If no database has been created then at block the knowledge builder may create a database table. The name of the database table for example may be based on the name of the identified entity node. At block a data source node DS may be created and added to the knowledge graph see for example for example by linking the data source node to the entity node identified at block . The data source node DS may contain information about the database table for example its name information about how to access it what columns comprise the database table and so on.

At block the received enterprise data may be incorporated into the knowledge graph using the identified entity node as an entry point into the knowledge graph. For example each row of data in the received enterprise data may represent an instance e.g. customer belonging to the class of data that is represented by the identified entity node. The knowledge builder may create one or more instance nodes I node for each row of data. Each instance node may be linked to the identified entity node.

The knowledge builder may store each row of data into a corresponding instance node I node . In some embodiments the property list of the corresponding instance node may be used to identify the data instance data from the given row of data. Data in the given row of data that does not map to any of the properties in the property list may be stored in the corresponding instance node as unclassified. 

As explained above e.g. in connection with entity nodes may be related. For example the Customer node may be related to the Product node by the relation has purchased link the Sales Order node may be related to the Product node by the relation represents a sale of link and so on. When instance nodes are created and linked to their respective entity nodes the instance nodes may be related to other instances nodes based on the relationships between the respective entity nodes that they are instances of. Accordingly processing in block may include linking an instance node to other instance nodes in the knowledge graph. This aspect of the present disclosure will be discussed below in connection with .

At block the database that is associated with the identified entity node may be updated with the contents of the received enterprise data that was used to identify the entity node. The updates may include adding rows of data from the received entity data into the database. If a row of data is already stored in the database then that row may be updated with any new data contained in that row of data. For example if the row of data refers to a customer that is already represented in the database e.g. from a previous data loading operation then the information stored in the database may be updated. If the received enterprise data includes columns of data that were not previously represented in the database the database may be extended to include additional columns to accommodate the new data.

Returning to at block in accordance with the present disclosure the knowledge builder may cross reference the received enterprise data into index . The index may cross reference the enterprise data with references to corresponding nodes in the knowledge graph that store the data. For example each data value in the enterprise data may be cross referenced as an indexed value with a node in the knowledge graph . In some embodiments where the data value is a text string the knowledge builder may cross reference sub strings of the text string in addition to cross referencing the entire string.

The index may further include an entity node ID field that identifies the entity first level node associated with an indexed value. If the indexed value appears in an instance node e.g. in the property list of the instance node then the entity node ID would identify the entity node that the instance node is an instance of. If the indexed value appears in an entity node then the node ID and the entity node ID for that indexed value would be the same. The index may further include a key ID field that identifies which property in the properties list of the entity node or properties list instance node that the indexed value is associated with.

Referring to the discussion will now turn to the linking of instance nodes. Recall from the discussion of block above the in addition to creating and linking instances nodes to their respective entity nodes that linking between instance nodes may be performed. This can happen when the knowledge graph contains two or more entities. illustrates a state of the knowledge graph having two entity nodes Customer and Product. The figure represents the addition of a product instance to the knowledge graph in accordance with block . will not describe the linking of instance nodes that may be performed in block .

The knowledge builder may execute loop for each entity node that has a relation to the target entity node. For example in the figure represents the addition of an instance to the Product node which we will call the target node. Nodes that have a relation to the target node e.g. Customer and Sales Orders may be referred to as related nodes. The knowledge builder will process each related node in turn in loop .

Suppose the related node Sales Order is processed first. The evaluation at block in the first iteration of loop will result in NO since the knowledge graph currently has no instance nodes for Sales Order thus ending the loop for Sales Order.

The loop will be repeated for the next related entity node Customer. Block will evaluate to YES for three iterations of the loop because Customer has three instance nodes. Accordingly the process builder will consider each instance node of Customer in turn through loop . Thus for example loop may be iterated to process instance node then instance node then instance node . The following are performed in loop 

At block if the related entity node Customer has a forward relation to the target entity node Product then the knowledge builder determines if that same forward relationship exists between the instance node under consideration or and the target instance node . Referring to the relationship represented by link may be referred to as a forward relationship in the direction from Customer to Product namely the relationship has purchased. In accordance with the present disclosure the knowledge builder may use data in the properties list of the instance node under consideration and data in the properties list of the target node to evaluate whether the same forward relationship exists between them as between their respective entity nodes that they are instances of. For example the properties list for the Customer instance may include a field called item purchased and the properties list for the Product instance may include a field called item name. The forward relation has purchased may then be evaluated by comparing the item purchased data value and the item name data value. If block evaluates to YES then at block a link e.g. between the Customer instance and the Product instance may be created.

A similar evaluation is made at block but for a reverse relationship. Referring to link may be referred to as a reverse relationship because the relationship is expressed in the direction from Product to Customer namely Product has been purchased by Customer. Since the evaluation in block is being made with respect to the Customer entity the term reverse is used. If block evaluates to YES then at block a link e.g. between the Customer instance and the Product instance may be created. Processing in loop is then repeated.

This concludes the discussion of how an organization s data e.g. enterprise data from a business enterprise can be loaded into the knowledge base and represented in the knowledge graph in accordance with the present disclosure. It will be appreciated that additional data sources such as public data can be loaded into the knowledge base in similar fashion. An advantageous aspect of the system is that the organization s data is not simply loaded into storage as raw data the system also represents the data in terms of the organization s understanding of the data and the context in which that data is used and referenced.

The discussion will now turn to a description of searching querying or otherwise accessing collectively referred to herein as searching the knowledge base . Referring for a moment to in accordance with the present disclosure a collection of applications may be provided to produce search output that is relevant to the user by invoking an application from the collection that is suited to the user s search input. The collection of applications may be extendable to allow for new applications to be added to the collection to provide for new kinds of search capability that users may require. The applications may include data processing capability such as analytics reporting and so on to produce output that is appropriate for the user s search input.

Referring now to in accordance with the present disclosure the search input engine may receive search input from a user. In some embodiments for example the user may enter their search input in an input area presented on an output device e.g. computer monitor touchscreen display etc. of a computing device. The search input engine may process the search input in accordance with the present disclosure by selecting an application from the collection of applications and invoking the query engine to process the search input using the selected application.

In some embodiments the search input engine may comprises a search parser an entity resolver module an index searcher module and an application app resolver module . The search parser may parse the search input to provide terms from the search input and or terms derived from the search input to the entity resolver the index searcher and the app resolver . The entity resolver may interface with the knowledge graph to access information comprising the knowledge graph to identify candidate entities based on the search input . The index searcher may interface with the index also to identify candidate entities based on the search input . The app resolver may interface with the database system to identify an application to invoke using information provided by the entity resolver and the index searcher .

The search parser may produce information about a selected application selected entity ies and one or more filters and provide that information to the query engine to process search input . Output produced by the selected application may be presented on the output device for example in various output areas on the display device . It will be appreciated that any suitable presentation is contemplated including producing a hardcopy output e.g. on a printer sending the output to a recipient on a different computer system e.g. email and so on.

Referring to a high level logical description of processing by the search input engine in accordance with some embodiments of the present disclosure will now be described. More specifically the process flow will be explained in terms of the example embodiment of the search input engine disclosed herein. It will be appreciated that the specific algorithms and process flows will vary depending on particular embodiments of the search input engine .

At block the search input engine may receive a search input from a user. At block the search parser may parse the search input to generate search terms from the search input. In some embodiments the search parser may use natural language processing techniques in order to identify meaningful word groupings. In other embodiments the search parser may employ other language processing technologies to analyze the search input. Search terms produced by the search parser may include the individual words contained in the search input as well as groupings of words in the search input. For example if the search input is Sales of ETL product in North America the search parser may generate the following search terms sales ETL ETL product and North America. 

In some embodiments the search parser may derive search terms from the search input that may include words phrases that are not in the search input. For example search terms may be derived by considering terms that are synonymous with words or phrases in the search input e.g. the word purchaser may generate derived search terms such as buyer customer and so on. In other embodiments the search parser may take into account spelling errors and so on.

At block the search terms obtained from the search input may be used to identify one or more first level entity nodes from the knowledge graph . As will be explained below the identified entity nodes provide the sources of data against which the search input will be processed e.g. the data stores via data source nodes . In some embodiments processing in block may be coordinated by the search parser using the entity resolver and the index searcher .

Details of the processing in block will be explained in below. Briefly entity nodes will be identified based on the search terms produced from the search input. Accordingly the identified entity nodes and hence the data sources provided by those entity nodes will be relevant in terms of the semantics and context of the knowledge graph base because the entity nodes will be identified based on how the search terms from the search input are related by the knowledge graph . This represents an important advantage because a user in the enterprise will likely compose a search input from the point of view of the enterprise knowledge as it is represented in the knowledge base . The data sources against which the search input will be processed and the resulting output can therefore be highly relevant to the user.

At block the search terms obtained from the search input block may be used to generate one or more filters. Filters serve to limit the amount of information that is retrieved when processing the search input to obtain results. Details of the processing in block will be explained in below. As will be explained the search term s that will be included in the filter s will be selected based on how the search terms are related by the knowledge graph . Accordingly filters may provide filtering of the retrieved data to filter out irrelevant data and retain data that is relevant with respect to the semantics and context of the knowledge base . This represents an important advantage because the data will be filtered based on the semantics of the user s search input.

At block the entity nodes identified in block and the filters generated in block may be used to identify a selected application from the collection of applications . The processing of block for example may be performed by the app resolver . In some embodiments information meta data about each application may be stored in the database system . Application metadata may include for example the entity node s that the application expects to use what filters the application expects input parameters and so on. A best match between the application metadata and the identified entities and filters may be used to select an application to process the user s search input.

At block the selected application may be invoked. In some embodiments the entity nodes identified in block and the filters generated in block may be passed as inputs to the selected application. Recall from that each entity node e.g. is linked to a data source node . The data source node in turn points to a data store that contains the data comprising instances of the entity node for example if the entity node is Product the data store will contain information about specific products i.e. Product instances . The entity node s that are passed to the selected application therefore provide data source s for the selected application. The particular data that the selected application extracts from the data source s may be controlled filtered by the filter s that are passed to the selected application.

Referring now to a high level logical description of processing in the search input engine to identify entities using the search terms block will now be discussed. At block the search terms generated from the search input at block may be used to identify a set of candidate entity nodes in the knowledge graph . In some embodiments for example the search parser may pass the list of generated search terms to the index searcher . The index searcher may search the index for each search term. Referring for a moment to for example the index searcher may search the value field of the index for instances of each search term. For example if the search input is forecast for printer servers the search terms may include forecast printer and printer server. Accordingly the index searcher may retrieve entries from the index that have values for forecast printer and printer server. For each entry that is retrieved its node ID field and entity node ID fields are recorded for example in a list of candidate entity nodes. After all the search terms have been searched for the index searcher may pass the final list of candidate entity nodes to the entity resolver for processing in block .

At block the list of candidate entity nodes represents all the nodes in the knowledge graph that relate to the search input because the search terms used to identify the candidates were derived either literally or by equivalence e.g. synonymous from the search input. In accordance with the present disclosure the entity node s to be used with the selected application blocks will be identified from the candidate entity nodes based on their relationships in the knowledge graph . By so doing the entity node s that feed into the selected application may provide data source s that are particularly relevant to the search input in terms of the user s understanding and context.

The entity resolver may compare distances between entity nodes in the list of candidates to determine relevancy. For example two entity nodes that are separated by a short distance say one or two links may be deemed to be relevant to each other and thus may remain in the list of candidates for further analysis. If the separation distance is far say four or more links then one or both of the entity nodes may be removed.

Another basis for relevancy may be based on the connectivity linkage among the entity nodes. If an entity node in the list of candidates is not linked to any other entity node in the list for example then that entity node may be removed from the list of candidates since it has no relationship with any other entity node in the list and thus that entity node may be deemed to have no relevance to the user s search input.

For example a simple search input Smith sales may generate search terms smith and sales . Suppose a search on the index using smith results in a match of entity nodes Customer e.g. because there is a customer called Smith and Vendor e.g. because another Smith is a vendor to the enterprise and a search on sales results in a match of the Sales Order entity node. The resulting list of candidate entity nodes comprises Customer Sales Order and Vendor. Suppose further that in the knowledge graph the Customer and Sales Order entity nodes are linked. Since a vendor typically has no relationship with the enterprise s customers or with the enterprise s sales orders we will suppose that the Vendor entity node is not linked to either the Customer entity node or Sales Order entity node. The question is which entity node Customer or Vendor is correct of the given search input Since Customer and Sales Order are linked it is likely that the Customer entity node is relevant to the search input. Considering that Vendor is not linked to either Customer or Sales Order the Vendor entity may be removed from the list of candidates.

It can be appreciated from the foregoing that the entity resolver the resulting entity node s selected from the list of candidate entity nodes are semantically relevant to the search input in the context of the knowledge graph . Search terms generated from the search input are used to identify all the entity nodes in the knowledge graph that may be relevant to the search input. Relevance is then determined by assessing the list of candidate entity nodes against the knowledge graph for example by eliminating entity nodes that are far away from other entity nodes. The remaining entity nodes may then provide a source of data via their respective associated data stores that the selected application may then use to process the search input.

Referring now to a high level logical description of the processing of block to identify search terms block to be used as filters will now be discussed. At block a list of candidate nodes may be identified from the knowledge graph . In some embodiments for example each search term obtained from the parsing in block may be searched against the index . The list of candidate entity nodes and instance nodes may be obtained from hits on the index .

At block the list of candidate entity nodes and instance nodes may be analyzed against the knowledge graph to identify entity and instance nodes that are related. For example as discussed above distances between entity nodes may be used to eliminate either or both of the entity nodes from the candidate list. Connectivity among the nodes in the candidates list may be used to eliminate nodes. For example instance nodes in the candidates list that are not connected to entity nodes in the candidates list may be eliminated. The remaining nodes in the candidates list may be viewed nodes that have been identified as being relevant to the user s search input in the context of the knowledge represented in the knowledge graph .

At block one or more filters may be constructed using the entity and instance nodes that have been identified at block . In some embodiments for example the filters may be expressed in terms of the search terms node IDs attribute value pairs and the like.

The values are the search terms that correspond to the identified nodes. The attributes may be obtained form the properties list e.g. for entity nodes for instance node of the respective entity or instance node where the search term was found.

The discussion will now turn to a description of processing that takes place in accordance with the present disclosure when an identified application e.g. block is invoked e.g. block . The discussion begins with the building of the knowledge base and in particular the building of knowledge graph .

Referring back to in accordance with the present disclosure node attributes including attributes of entity nodes and instance nodes may be tagged. As will be explained below the notion of tagging an attribute provides a link between the knowledge base and an application that is invoked to access the knowledge base.

In some embodiments tagging may be based on predefined application programming interface API tags . API tags may be used in the program code comprising applications and in accordance with the present disclosure API tags may also be used to direct which attributes in the knowledge graph are tagged and what the attributes are tagged with. API tags thus provide a linkage between references to API tags in the applications and tagged attributes in the knowledge graph . In some embodiments the API tags may be predefined tags developed in conjunction with the initial knowledge graph which representing a view of the enterprise data.

In accordance with the present disclosure an application e.g. can be written by a developer independently of the knowledge base and without having to know the specific database tables in the database system used to store the data of the knowledge base. In fact the database tables that comprise the knowledge base are typically not available to the developer. Indeed API tags allow the developer to develop their application even before data is loaded into the knowledge base when the database tables have not yet been created.

The API tags allow the program code comprising an application to communicate with or otherwise access data in the knowledge base . By decoupling the knowledge base from applications that access the knowledge base a high degree of flexibility is achieved in terms of the enterprise being able to maintain the knowledge base already written applications can still work with the knowledge base as it evolves and changes in the enterprise. Conversely developers of applications can write code using the API tags to communicate with the knowledge base irrespective of whether the knowledge base is already in place or just being built.

Referring now to recall that the figure describes a high level logical description of a data loading operation performed by the knowledge builder to build the knowledge base in accordance with some embodiments of the present disclosure. At block incoming data e.g. enterprise data may be classified to identify which class of data or classes of data the enterprise data belongs to and by so doing identify one or more entity nodes in the knowledge graph e.g. . Part of processing in block includes mapping of columns of data in the incoming data such as a data table to properties attributes which may be stored in the property list of an entity node that is identified with the incoming data.

As explained node attributes may be tagged. Thus in some embodiments in block in addition to mapping columns of data to attributes knowledge builder may tag the attributes based on the predefined API tags . For example the knowledge builder may determine if the attribute matches a predefined API tag and if so then the attribute may be tagged. In some embodiments an attribute may be explicitly tagged or the attribute itself may serve as a tag.

Suppose for example we have an entity node called Customer. The attributes of Customer may include a customer ID a customer name a customer phone number and so on which may be stored in the property list . One or more of the attributes may be designated as being key attributes e.g. the customer ID may be a key attribute that uniquely identifies each customer. The entity node may include meta data for example that designates the customer ID as a key attribute. The designation of an attribute as being a key attribute may serve a secondary purpose of tagging that attribute which can then be referenced in an application. This aspect of the present disclosure will be explained in more detail below.

An attribute may be explicitly tagged. Consider for example the customer name attribute. In the customer entity node for example the customer name attribute may be represented by the attribute value pair of attribute name this may also be referred to as a key data type tag the value e.g. we might have key Customer Name value String.Description String being a data type and Description being an explicit tag. In an instance node of the customer entity node the key value pair for an actual customer may be key Customer Name value XYZ Incorporated .

In accordance with the present disclosure the property list may include private attributes that relate to the entity node itself. For example an entity node may include a set of private counters that are associated with each attribute. A counter may be incremented each time its associated attribute is accessed in a query. In accordance with the present disclosure such private attributes may also be tagged and subsequently referenced in an application. Another example is that users can flag certain attributes as being more or less important using a tag that indicates an importance level. For example the UI may provide like dislike button that will increment or decrement an importance tag that is associated with a particular attribute.

Referring now to a high level block diagram of the query engine shown in will be described. It will be appreciated however that in other embodiments the details of the query engine may differ. As explained above a user s search input may be used to identify an application to process the search input along with entity nodes and filters with which to invoke the application as inputs . The application and inputs may be processed by the query engine .

In some embodiments the query engine may include a parser to parse the program code that comprises the application . A generator may produce references to the knowledge base that correspond to API tags incorporated in the program code comprising the application and identified during the parsing. The generator may access the data structures of the knowledge base including the knowledge graph the index and the database system to resolve identified API tags into actual references to the data structures of the knowledge base. An execution engine may then execute the program code including the resolved API tags to produce an output. The execution engine may access the database system for example if an API tag resolves to an SQL query into the database system.

Referring now to shows a high level logical description of processing by the query engine in accordance with some embodiments of the present disclosure. More specifically the process flow will be explained in terms of the example embodiment of the query engine disclosed herein. It will be appreciated that the specific algorithms and process flows will vary depending on particular embodiments of the query engine . illustrates the processing with an example application .

At block the parser may receive an application and inputs such as entity node s and filter s that feed into the application. shows an example of an application called Search that can result the search input Customer 123 as described above in connection with . In the example shown in the inputs to Search include an entity node having a node ID of 65 and an entity name of Customer and a filter value of 123. The inputs may further include information that identify node instances from the Customer entity that match the filter value their customer IDs matched attribute value pairs and so on.

At block the parser may resolve the program code at line 0001 using information in the inputs to assign the Customer entity node to the variable x so that subsequent references to x are also resolved. For example at line 0002 the program code might read 

At block the parser may parse the program code that comprises the application to identify one or more API tags in the program code. illustrates examples of API tags Key and KeyDescription in program code comprising the application .

At block the generator may resolve each of the identified API tags. Thus at block an attribute in the node identified at block may be identified using the API tag. For example the predefined API tags in may provide a mapping that the generator can use to map the identified API tag to an attribute in an entity node. Generator may do a string compare of the identified API tag with attribute names of the attributes in the entity node and so on. Thus for example referring to the application the program code at line 0003 has a reference to an API tag Key and to another API tag KeyDescription . Suppose the Customer node has the following attributes expressed as key value pairs 

After each API tag is resolved then at block the program code with its API tags resolved to reference able objects may then be executed. In some embodiments the flow in may be that a line of program code is resolved of any API tags and then executed. For example this may line by line processing may occur in an interpreted environment. In other embodiments the entire application may be resolve of its API tags and the entire resolved application may then be executed e.g. interpreted or compiled into executable binary code.

In other embodiments API tags can be used to retrieve information from the knowledge graph in addition to attributes. For instance we can distinguish between measures numeric data that can be summed up etc. and dimensions. The classification process during building of the knowledge base may include detecting monetary currencies units of measure time related attributes and so on. Consequently it is possible to retrieve say a measure of type amount by requesting an attribute of type measure which is associated with an attribute of type currency . In this context the term associated may mean that those two attributes amount and currency where next to each other when the data was classified during knowledge building e.g. 100 . The classifier may capture these relationships and store them in the knowledge graph.

A system in accordance with the present disclosure allows users in an organization to access the organization s data to do useful work with the data without having to rely on the organization s IT group to provide them with the proper reports and analytics. A user can pose queries and other search input and obtain results that are relevant to the semantics and context of the organization s data. The selection of a suitable application based on the user s search input to process the search input can produce meaningful output rather than generic and superfluous results that one might get using a generic search tool.

The above description illustrates various embodiments of the present disclosure along with examples of how aspects of the particular embodiments may be implemented. The above examples should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the particular embodiments as defined by the following claims. Based on the above disclosure and the following claims other arrangements embodiments implementations and equivalents may be employed without departing from the scope of the present disclosure as defined by the claims.

