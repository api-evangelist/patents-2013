---

title: Use case-specific entity identifiers
abstract: Use case-specific entity identifiers are disclosed. Entity data associated with an actual entity identifier of an entity is generated. A use case-specific entity identifier is generated based at least in part on encrypting the actual entity identifier using reversible encryption. The entity data, in association with the use case-specific entity identifier, is sent to another service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251375&OS=09251375&RS=09251375
owner: Amazon Technologies, Inc.
number: 09251375
owner_city: Seattle
owner_country: US
publication_date: 20130905
---
The collection and use of sensitive information deserves heightened protection. In some cases third party services can gain access to private user information. Such uncontrolled access to private sensitive information could result in serious security risks including online identity abuse.

The present disclosure relates to providing use case specific entity identifiers. An enterprise or other organization may assign their customers unique identifiers. The unique identifiers may be important for purposes of record keeping and to associate data of various forms with the customer. Additionally unique identifiers may provide a form of anonymization. Rather than using personally identifiable information e.g. full name Social Security numbers telephone numbers etc. a randomized number or string may be generated and assigned as a unique identifier. Thus if a malicious user were to gain access to a customer associated data item the malicious user would not know the identity of the customer merely from the unique identifier.

In one scenario an organization may assign a single unique identifier to each customer and then associate all data pertaining to the customer with the single unique identifier. However this presents a security risk. If a malicious user were to gain access to different types of data associated with the same unique identifier the malicious user may learn information about the corresponding customer that may constitute an invasion of privacy. Further in some cases the malicious user may be able to correlate the unique identifier with personally identifiable information within the different types of data.

Various embodiments of the present disclosure protect entity identifiers by creating use case specific or application specific entity identifiers. As used herein the term entity may refer to a customer or customer account a user or user account an organization or organizational account and so on. In some situations a service may be associated with a single use case thereby making the use case specific entity identifier a service specific entity identifier.

For example the data pertaining to a particular service may be associated with use case specific entity identifiers that are generated from the actual entity identifiers. Nonetheless it may be important to facilitate correlation among the use case specific entity identifiers on an authorized basis. For example an application may need to correlate product purchase entity identifiers with page view entity identifiers. To this end a use case specific entity identifier may comprise an encrypted version of the actual entity identifier where different encryption keys are employed for different services. A central broker may provide corresponding decryption keys to an application or service on an authorized basis. In some embodiments the use case specific entity identifiers may be centrally managed by an identifier translation service such that the other services need not be aware of the actual entity identifiers or perform identifier conversion functions.

With reference to shown is a drawing illustrating one example scenario using use case specific entity identifiers according to an embodiment of the present disclosure. In the example scenario suppose that an organization has three services A B and C. Service A generates page view data for product detail pages. Service B generates order data for product orders. Finally Service C consumes data produced by Services A and B and performs processing and or analysis on the data thereby generating data as a result. Each of the services employs use case specific entity identifiers.

In this example Service A has generated data record regarding a page view of a product having a product identifier of 1024 and a use case specific entity identifier of encrypted ServiceKey1 CustID4098 . In other words the actual entity identifier of CustID4098 has been encrypted with a key pertaining to Service A. Additionally Service B has generated data record regarding an order of a product having a product identifier of 2048 and a use case specific entity identifier of encrypted ServiceKey2 CustID4098 . In other words the actual entity identifier of CustID4098 has been encrypted with a key pertaining to Service B. Consequently the data records and cannot be correlated based upon the use case specific entity identifiers which differ. For purposes of understandability the use case specific entity identifiers have been denoted in as corresponding to exemplary function calls that produce the respective use case specific entity identifiers. In practice such use case specific entity identifiers may correspond to strings of random characters or random binary data.

Suppose that data records and are made available to Service C along with use case specific keys ServiceKey1 and ServiceKey2 . By contrast it may be the case that Service A is not provided with the use case specific key of Service B and that Service B is not provided with the use case specific key of Service A. Having the appropriate use case specific keys and Service C is then able to decrypt the respective use case specific entity identifiers of the data records and thereby producing data records and . In data records and the corresponding entity identifier fields have been decrypted from encrypted ServiceKey1 CustID4098 and encrypted ServiceKey2 CustID4098 to be CustID4098 which is the actual entity identifier for the customer. Accordingly Service C is able to correlate data record with data record given the common actual entity identifier of CustID4098. 

Service C may then produce a data record as output which may encompass data from both Service A and Service B. In this example the data record links products viewed and products purchased to a customer. Before making the data available to other services Service C may obtain its own use case specific key and encrypt the actual entity identifier thereby producing a data record . In the data record the entity identifier field corresponds to encrypted ServiceKey3 CustID4098 . In an alternative scenario Service C may first convert the use case specific entity identifiers of data records and to encrypted ServiceKey3 CustID4098 and then perform correlation based upon the newly matching use case specific entity identifier.

The data record may be used for a Customers Who Viewed Product X Purchased Product Y feature to suggest products to customers. A Service D that generates such a feature may have no need to know the actual customer behind the data record . Accordingly Service D may be restricted from accessing the use case specific key

Although the term customer is used herein it is not intended to be limiting. In this regard a customer may correspond to one or more users or individuals who may or may not have purchased or leased products or services from the organization. Another organization may also correspond to a customer. Further a unified system of customer identification may be shared among multiple organizations. Thus references to an organization may be understood as encompassing multiple organizations which coordinate shared use of a unified system of customer identification. Although the term service is employed here it is understood that the principles of the present disclosure may apply to applications modules use cases and or any other logic that is capable of employing independent namespaces for entity identifiers.

Various techniques relevant to application specific anonymization are disclosed in U.S. patent application Ser. No. 13 561 686 entitled AUTOMATIC APPLICATION DEPENDENT ANONYMIZATION and filed on Jun. 30 2012 which is incorporated herein by reference in its entirety. In the following discussion a general description of the present system and its components is provided followed by a discussion of the operation of the same.

With reference to shown is a networked environment according to various embodiments. The networked environment includes a computing environment and a computing environment which are in data communication with each other via a network . The network includes for example the Internet intranets extranets wide area networks WANs local area networks LANs wired networks wireless networks or other suitable networks etc. or any combination of two or more such networks. For example such networks may comprise satellite networks cable networks Ethernet networks and other types of networks.

The computing environment may comprise for example a server computer or any other system providing computing capability. Alternatively the computing environment may employ a plurality of computing devices that may be arranged for example in one or more server banks or computer banks or other arrangements. Such computing devices may be located in a single installation or may be distributed among many different geographical locations. For example the computing environment may include a plurality of computing devices that together may comprise a hosted computing resource a grid computing resource and or any other distributed computing arrangement. In some cases the computing environment may correspond to an elastic computing resource where the allotted capacity of processing network storage or other computing related resources may vary over time.

Various applications and or other functionality may be executed in the computing environment according to various embodiments. Also various data is stored in data stores that are accessible to the computing environment . Each of the data stores may be representative of a plurality of data stores as can be appreciated. The data stored in the data stores for example is associated with the operation of the various applications and or functional entities described below.

The components executed on the computing environment for example include a plurality of services . . . M a broker service and other applications services processes systems engines or functionality not discussed in detail herein. The services and the broker service may be in data communication via inter process communication remote method invocation remote procedure call simple object access protocol SOAP representational state transfer REST and or other communication application programming interfaces APIs . Each of the services is executed to perform a business function relating to the organization operating the computing environment . To this end each of the services may respectively include business logic identifier conversion logic service data and or other components. The service data may include entity data use case specific entity identifiers IDs that incorporate encrypted versions of actual entity identifiers use case specific keys and or other data.

The business logic performs one or more business functions which may involve obtaining generating transforming storing and or performing other operations on entity data . For example for an organization that operates an electronic commerce system the business logic may perform network page component generation functions data logging functions order management functions order fulfillment functions shopping cart management functions customer product review management functions catalog management functions and or other functions.

The identifier conversion logic is executed to convert use case specific entity identifiers that are specific to another service . To this end the identifier conversion logic may obtain a decryption key from the broker service in order to decrypt the actual entity identifier in the use case specific entity identifier . The identifier conversion logic may then convert the actual entity identifier to another use case specific entity identifier that is specific to the present service . Some services may be configured to operate upon only the use case specific entity identifiers and therefore may exclude the identifier conversion logic and or the use case specific keys . Thus some services may be restricted from accessing the actual entity identifiers .

The entity data may include data records that are associated with customers of the organization or other entities. In particular each data record may be associated with a corresponding use case specific entity identifier to identify the corresponding customer. The use case specific entity identifier comprises an encrypted version of an actual entity identifier that has been encrypted using a use case specific key and a form of reversible encryption. The actual entity identifier may comprise a number a character string binary data or any other form of unique identifier. The use case specific entity identifier may also include a unique identifier of the use case specific key or of the service pertaining to the use case specific key .

The actual entity identifiers and use case specific entity identifiers for the different use cases may share a unified namespace. In other words the actual entity identifiers and use case specific entity identifiers for the different use cases may be unique with respect to each other. Uniqueness may be enforced for example by incorporating a use case identifier. For example a unique identifier for a use case may be prepended to the use case specific entity identifiers for that use case to ensure uniqueness across the use cases. In other embodiments the actual entity identifiers and use case specific entity identifiers for the different use cases may each be associated with distinct corresponding namespaces that are distinguished by context of usage. For example if a first service obtains entity data from a second service associated with a specific use case the first service may assume that the associated use case specific entity identifiers correspond to the namespace of the second service .

An example format for a use case specific entity identifier will next be discussed. For example a use case specific entity identifier may include a flag that indicates whether the use case specific entity identifier is a canonical identifier a length value a namespace indicator a key identifier corresponding to a use case specific key used to generate the use case specific entity identifier the encrypted version of the corresponding actual entity identifier a checksum value an expiration time value and or other data. The namespace indicator may indicate for example a specific namespace or the specific use case to which the use case specific entity identifier pertains. The use case specific entity identifier may correspond to a numerical value with a bit mask to decode the specific fields therein. Alternatively the use case specific entity identifier may correspond to an extensible markup language XML document JavaScript object notation JSON formatted data and or other data.

The use case specific keys may correspond to public private asymmetric key pairs or symmetric keys. Where the use case specific key is a symmetric key the same use case specific key used to encrypt the actual entity identifier may be used to decrypt the actual entity identifier . Where the use case specific key corresponds to a public private key pair the public key is used to encrypt the actual entity identifier and the private key is used to decrypt the actual entity identifier . It is noted that a given service or use case may employ multiple use case specific keys . For example a given service may employ a different use case specific key for each grouping of one or more entities e.g. groupings of one hundred entities. Further different use case specific keys may be employed based upon the current time e.g. a different use case specific key is employed every thirty minutes.

In one embodiment one of multiple use case specific keys for a use case may be selected at random to encrypt the actual entity identifier . In one embodiment the same one of the multiple use case specific keys for a single use case will be selected for a particular actual entity identifier . In another embodiment different ones of the multiple use case specific keys for the single use case may be selected for the particular actual entity identifier .

The broker service is executed to provide decryption keys to services upon request. For example a first service may need to convert use case specific entity identifiers generated by a second service . The first service then may request the appropriate decryption key from the broker service . The broker service may authenticate the first service and then determine whether the first service should have access to the requested decryption key . If the first service is authorized to access the decryption key the broker service then provides the decryption key to the first service via for example an encrypted channel of communication. Although one broker service is depicted in it is understood that multiple broker services may be employed. For example one broker service may be utilized by a first set of services and another broker service may be utilized by a second set of services .

The data stored in the data store includes for example decryption keys service authorization data and potentially other data. In one embodiment access to the data store may be restricted to the broker service . In some embodiments the data store may also store the some or all of the service data for the services . In such embodiments access to the service data may be restricted e.g. so that a service can access only its own service data or other service data to which it has been granted access.

The decryption keys correspond to the decryption components of the use case specific keys . Where the use case specific keys are symmetric keys the decryption keys may be the same as the use case specific keys . Where the use case specific keys correspond to public private key pairs the decryption keys may comprise the key pair or to the private key portion of the key pair. The service authorization data includes configuration data that may allow the broker service to determine whether a given service is authorized to access to a particular decryption key . It may be the case that a given service may be authorized to access only a subset of the decryption keys . Additionally a given service may be provided with access only at certain times to accomplish certain tasks or under certain conditions.

The data stored in the data store includes for example entity data and or other data. The data store may be accessible to one or more of the services . While in one embodiment entity data may be stored within the service data accessible only to the respective service in another embodiment the entity data may be stored in the data store such that a single copy of the entity data may be accessible by multiple services . For example multiple services may implement a particular use case and the data in the entity data may be accessible via the data store to each of the multiple services that implement the particular use case.

Similar to the computing environment the computing environment may comprise for example a server computer or any other system providing computing capability. Alternatively the computing environment may employ a plurality of computing devices that may be arranged for example in one or more server banks or computer banks or other arrangements. Such computing devices may be located in a single installation or may be distributed among many different geographical locations. For example the computing environment may include a plurality of computing devices that together may comprise a hosted computing resource a grid computing resource and or any other distributed computing arrangement. In some cases the computing environment may correspond to an elastic computing resource where the allotted capacity of processing network storage or other computing related resources may vary over time.

Various applications and or other functionality may be executed in the computing environment according to various embodiments. The components executed on the computing environment for example include one or more services N and other applications services processes systems engines or functionality not discussed in detail herein. The services N may be similar to the services . . . M illustrated in the computing environment . For example the services N may include identifier conversion logic that assigns use case specific entity identifiers to entity data . The use case specific entity identifiers may use the same unified namespace as those for the services . . . M. However the computing environment may be operated by a different organization from the organization operating the computing environment . The broker service may be implemented in a separate computing environment in some embodiments.

Next a general description of the operation of the various components of the networked environment is provided. To begin services are configured to receive and or generate entity data using the business logic . The entity data is associated with an actual entity identifier of a customer or other entity. The services are configured to use the identifier conversion logic to replace the association with the actual entity identifier with an association with a use case specific entity identifier . To do this the identifier conversion logic obtains a use case specific key and encrypts the actual entity identifier . The identifier conversion logic may then perform various processing on the encrypted result such as for example prepending a key or use case identifier adding an expiration date adding other metadata and or other forms of processing. The use case specific entity identifier is generated thereby and associated with the entity data pertaining to the customer. Subsequently the business logic may process store transfer and or perform other operations on the entity data that is associated with the customer.

In addition services may obtain entity data associated with use case specific entity identifiers of other services or use cases. In order to correlate the obtained entity data with the entity data of the present service the identifier conversion logic of the present service may be configured to convert the use case specific entity identifiers of the other services to new use case specific entity identifiers of the present service as will be described. It is noted that a service N of a computing environment may communicate with the services and the broker service of the computing environment via the network to perform the same or similar functions as the services of the computing environment . In some cases the computing environments and may share a unified namespace for use case specific entity identifiers and or actual entity identifiers to assure uniqueness via resolution of potential collisions among the unique identifiers.

In some embodiments the use case specific keys may have a fixed lifespan or may expire. To handle this the identifier conversion logic may be configured to rotate the use case specific entity identifiers via decryption using the old use case specific key and replacement with a new use case specific key . The identifier conversion logic may obtain the new use case specific key from the broker service and or provide a new corresponding decryption key to the broker service in various embodiments.

With reference to shown is a networked environment according to various embodiments. The networked environment includes a computing environment and a computing environment which are in data communication with each other via a network . In contrast to the computing environment the computing environment includes an identifier translation service in place of the broker service . While in the identifier conversion logic of the service performs the identifier conversion the embodiments of employ a centralized identifier translation service . It is noted that some embodiments may employ the broker service in conjunction with the identifier translation service .

The identifier translation service is executed to receive and respond to identifier translation requests from services for conversion of use case specific entity identifiers from one use case to another. As such the identifier translation service may perform the key management authentication and authorization functions of the broker service . By performing the identifier conversion in the identifier translation service the individual services need not be provided with decryption keys and need not have access to the actual entity identifiers . The identifier translation service may also function to update expired use case specific entity identifiers that were encrypted using a key that has expired or will soon expire.

As shown the actual entity identifiers and the use case specific entity identifiers may be accessible to the identifier translation service . In some cases the identifier translation service may be configured to cache the translation between use case specific entity identifiers to provide a faster response. Although one identifier translation service is depicted in it is understood that multiple identifier translation services may be employed. For example one identifier translation service may be utilized by a first set of services and another identifier translation service may be utilized by a second set of services .

In one embodiment the identifier translation service may be configured to function as a transparent proxy. For example rather than merely translating use case specific entity identifiers the identifier translation service may be configured to pass a service call from one service to another service . In passing the service call onto the other service the identifier translation service may perform the translation of the use case specific entity identifiers . The translation may occur in the opposite direction as well when the response is returned to the service that originated the service call.

The data store may store the use case specific keys the service authorization data use case generic keys use case specific salts and or other data. In one embodiment the identifier translation service may employ use case specific keys for encryption and decryption similar to the identifier conversion logic . In another embodiment the identifier translation service may employ use case generic keys which may be shared among multiple use cases in conjunction with use case specific salts . The use case specific salts may be employed to produce distinct use case specific entity identifiers for multiple use cases that share a use case generic key . Although the term salt is used herein the use case specific salts may correspond to randomization values nonce values or initialization vectors. The use case specific keys and or the use case generic keys employed by the identifier translation service may be symmetric keys and or asymmetric key pairs.

In some embodiments the identifier translation service and or the identifier conversion logic may be configured to perform the identifier translation conversion within a trusted computing environment. For example such a trusted computing environment may be within a secure execution platform a trusted platform module or a hardware security module.

Referring next to shown is a flowchart that provides one example of the operation of a portion of a service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the service as described herein. As an alternative the flowchart of may be viewed as depicting an example of elements of a method implemented in the computing environment or according to one or more embodiments.

Beginning with box the service generates entity data that is associated with an actual entity identifier . In box the service generates a use case specific entity identifier based at least in part on encryption of the actual entity identifier using reversible encryption. To this end the service may determine an appropriate use case specific key and encrypt the use case specific entity identifier using the use case specific key .

It is noted that in some embodiments the service may select from multiple use case specific keys that are specific to that use case based at least in part on various conditions e.g. time actual entity identifier type of entity data and so on. In some embodiments the service may request the use case specific key from the broker service . The service may thereafter cache the use case specific key in the service data accessible to the service . In some embodiments the service may generate the use case specific key and subsequently register the use case specific key with the broker service such that the broker service is provided with the decryption key for the use case specific key .

In box the service stores the entity data in association with the use case specific entity identifier that is generated. In various embodiments the stored entity data may be unassociated with the actual entity identifier . In box the service sends at least a portion of the entity data in association with the use case specific entity identifier to another service . Thereafter the portion of the service ends. It is noted that the flow depicted in may also be applied to processing bulk entity data pertaining to multiple entities and associated with multiple actual entity identifiers .

Moving on to shown is a flowchart that provides another example of the operation of a portion of a service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the service as described herein. As an alternative the flowchart of may be viewed as depicting an example of elements of a method implemented in the computing environment or according to one or more embodiments.

Beginning with box the service obtains entity data associated with a first use case specific entity identifier from a first service . In box the service obtains a decryption key for decrypting the first use case specific entity identifier from the broker service . The decryption key may be requested based at least in part on a key or use case identifier in the first use case specific entity identifier . In box the service decrypts the first use case specific entity identifier to obtain an actual entity identifier . In some embodiments the service may then correlate the entity data with other entity data based at least in part on a comparison of actual entity identifiers .

In box the service obtains a second use case specific key for encryption. The second use case specific key may be stored in the service data or may be requested from the broker service . If the second use case specific key is service specific the service may always have its own key. Otherwise where the use case pertaining to the second use case specific key is employed by multiple services or if the particular service operates on multiple use cases the service may be configured to request the second use case specific key from the broker service . For availability and escrow purposes it may make sense for the second use case specific key to be generated and or managed by the broker service .

In box the service generates a second use case specific entity identifier by using a second use case specific key to encrypt the actual entity identifier . In box the service associates the entity data with the second use case specific entity identifier . In some embodiments the service may then correlate the entity data with other entity data based at least in part on a comparison of second use case specific entity identifiers . Such comparisons may rely on a property of the use case specific entity identifiers such that a given actual entity identifier will be encrypted into a single unique use case specific entity identifier for the namespace of the service . It is noted however that the first use case specific entity identifier may differ from the second use case specific entity identifier . Further a given service may have multiple use cases and may maintain multiple namespaces and corresponding use case specific keys for use case specific entity identifiers .

In box the service stores the entity data in association with the second use case specific entity identifier . The stored entity data may be unassociated with the first use case specific entity identifier and or the actual entity identifier . Thereafter the portion of the service ends. It is noted that the flow depicted in may also be applied to processing bulk entity data pertaining to multiple entities and associated with multiple actual entity identifiers .

Referring next to shown is a flowchart that provides another example of the operation of a portion of a service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the service as described herein. As an alternative the flowchart of may be viewed as depicting an example of elements of a method implemented in the computing environment or according to one or more embodiments.

Beginning with box the service obtains a request for entity data from a second service . In box the service obtains the requested entity data associated with a first use case specific entity identifier from the service data . In box the service obtains a decryption key for decrypting the first use case specific entity identifier from the broker service . The decryption key may be requested based at least in part on a key or entity identifier in the first use case specific entity identifier . In box the service decrypts the first use case specific entity identifier to obtain an actual entity identifier . In some embodiments the service may then correlate the entity data with other entity data based at least in part on a comparison of actual entity identifiers .

In box the service obtains a second use case specific key for encryption. The second use case specific key may be stored in the service data or may be requested from the broker service . In box the service generates a second use case specific entity identifier by using a second use case specific key to encrypt the actual entity identifier . In box the service associates the entity data with the second use case specific entity identifier . In some embodiments the service may then correlate the entity data with other entity data based at least in part on a comparison of second use case specific entity identifiers . Such comparisons may rely on a property of the use case specific entity identifiers such that a given actual entity identifier will be encrypted into a single unique use case specific entity identifier for the namespace of the use case. It is noted however that the first use case specific entity identifier may differ from the second use case specific entity identifier . Further a given service may have multiple use cases and may maintain multiple namespaces and corresponding use case specific keys for use case specific entity identifiers .

In box the service sends the entity data in association with the second use case specific entity identifier to the second service . Thereafter the portion of the service ends. It is noted that the flow depicted in may also be applied to processing bulk entity data pertaining to multiple entities and associated with multiple actual entity identifiers .

Turning now to shown is a flowchart that provides one example of the operation of a portion of the broker service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the broker service as described herein. As an alternative the flowchart of may be viewed as depicting an example of elements of a method implemented in the computing environment according to one or more embodiments.

Beginning with box the broker service authenticates a service . In box the broker service obtains a request for a key such as a use case specific key or decryption key from the authenticated service . The request may present a use case identifier or a key identifier which may be based at least in part on a use case specific entity identifier that is to be converted by the service .

In box the broker service determines whether the requested key exists. If the requested key does not exist the broker service moves to box and generates the requested key. The broker service then moves to box . If the requested key exists the broker service moves directly from box to box .

In box the broker service determines whether the requesting service is authorized to access the requested key. The broker service may employ the service authorization data to determine whether the access is to be authorized. If the access is to be authorized the broker service moves from box to box and returns the requested key to the requesting service . Thereafter the portion of the broker service ends. If access is not to be authorized the broker service instead moves from box to box and denies the requesting service access to the key. Thereafter the portion of the broker service ends.

Moving on to shown is a flowchart that provides one example of the operation of a portion of the identifier translation service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the identifier translation service as described herein. As an alternative the flowchart of may be viewed as depicting an example of elements of a method implemented in the computing environment according to one or more embodiments.

Beginning with box the identifier translation service authenticates a service . In box the identifier translation service receives an identifier translation request from the service for translating a first use case specific entity identifier into a second use case specific entity identifier . The request specifies the first use case specific entity identifier . In box the identifier translation service determines whether the service has authorization to receive such a translation by consulting the service authorization data .

The service authorization data may specify whether a service has access to translate use case specific entity identifiers from a specific use case and or to a specific use case. In some situations a service may be provided with authorization to translate to or from actual entity identifiers and such translation may be implemented in the identifier translation service . If the service is determined not to have authorization the identifier translation service continues to box and rejects the identifier translation request. Thereafter the portion of the identifier translation service ends.

If the service is determined to have authorization the identifier translation service continues from box to box . In box the identifier translation service obtains an actual entity identifier from the first use case specific entity identifier specified in the request. To do so the identifier translation service decrypts the first use case specific entity identifier . In one embodiment the identifier translation service determines a use case specific key for a use case associated with the first use case specific entity identifier . The first use case specific entity identifier may include an identification of the use case to which it pertains a key and or salt used to encrypt decrypt it. There may be a single use case specific key associated with the use case or there may be multiple use case specific keys associated with the use case. The first use case specific entity identifier may include an identifier of the appropriate use case specific key .

In another embodiment the identifier translation service determines a use case generic key that may be shared among multiple use cases and decrypts the first use case specific entity identifier using the use case generic key . The identifier translation service may then remove a use case specific salt from the resulting decrypted data in order to obtain the actual entity identifier .

In box the identifier translation service generates a second use case specific entity identifier by encrypting the actual entity identifier . In one embodiment the identifier translation service may employ a use case specific key that is specific to the particular use case of the second use case specific entity identifier in order to perform the encryption. In some scenarios the identifier translation service may select one of several such use case specific keys specific to the target use case based at least in part on the actual entity identifier and or other data in order to perform the encryption.

In another embodiment the identifier translation service may encode the actual entity identifier with a use case specific salt for the target use case before encrypting the result using a use case generic key . The use case specific salt may be selected from multiple use case specific salts associated with the target use case in some scenarios. An identification of the use case key or salt may be concatenated to or otherwise associated with the resulting encrypted data to produce the second use case specific entity identifier .

In box the identifier translation service sends the second use case specific entity identifier to the requesting service . Thereafter the portion of the identifier translation service ends. Although the flowchart of depicts processing of an identifier translation request for a translation of one use case specific entity identifier it is understood that a single identifier translation request may specify multiple use case specific entity identifiers to be translated.

Turning now to shown is a flowchart that provides one example of the operation of a portion of the identifier translation service that implements a transparent proxy according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the identifier translation service as described herein. As an alternative the flowchart of may be viewed as depicting an example of elements of a method implemented in the computing environment according to one or more embodiments.

In box the identifier translation service receives a service call from a first service . The service call includes use case specific entity identifiers for a first use case. In box the identifier translation service determines the second service to receive the service call. In box the identifier translation service determines a use case associated with the second service that will employ the data contained in the service call. In box the identifier translation service determines whether the use case specific entity identifiers are to be translated.

If the use case specific entity identifiers are to be translated the identifier translation service obtains the actual entity identifiers in box by decrypting the use case specific entity identifiers . In box the identifier translation service generates second use case specific entity identifiers by encrypting the actual entity identifiers for the use case associated with the second service . In box the identifier translation service sends the service call including the second use case specific entity identifiers that have been translated to the second service . The identifier translation service then continues to box .

If use case specific entity identifiers are not to be translated the identifier translation service instead moves from box to box and sends the service call to the second service without performing the translation. The identifier translation service then continues to box .

In box the identifier translation service receives a response from the second service . In box the identifier translation service determines whether the response includes use case specific entity identifiers that are to be translated. If the response includes use case specific entity identifiers to be translated the identifier translation service moves from box to box . In box the identifier translation service obtains actual entity identifiers by decrypting use case specific entity identifiers in the response. In box the identifier translation service generates first use case specific entity identifiers by encrypting the actual entity identifiers . In box the identifier translation service returns the response to the first service that includes the first use case specific entity identifiers that have been translated. Thereafter the portion of the identifier translation service ends.

If instead the identifier translation service determines that the response does not include use case specific entity identifiers to be translated the identifier translation service moves from box to box . In box the identifier translation service returns the response to the first service . Thereafter the portion of the identifier translation service ends.

With reference to shown is a schematic block diagram of the computing environment according to an embodiment of the present disclosure. The computing environment includes one or more computing devices . Each computing device includes at least one processor circuit for example having a processor and a memory both of which are coupled to a local interface . To this end each computing device may comprise for example at least one server computer or like device. The local interface may comprise for example a data bus with an accompanying address control bus or other bus structure as can be appreciated.

Stored in the memory are both data and several components that are executable by the processor . In particular stored in the memory and executable by the processor are the services the broker service and potentially other applications. Also stored in the memory may be data stores and other data. In particular the memory may include one or more regions of protected memory where access is restricted to specific processes and or services . Stored in the protected memory may be the actual entity identifiers the decryption keys and or other data. In addition an operating system may be stored in the memory and executable by the processor .

It is understood that there may be other applications that are stored in the memory and are executable by the processor as can be appreciated. Where any component discussed herein is implemented in the form of software any one of a number of programming languages may be employed such as for example C C C Objective C Java JavaScript Perl PHP Visual Basic Python Ruby Flash or other programming languages.

A number of software components are stored in the memory and are executable by the processor . In this respect the term executable means a program file that is in a form that can ultimately be run by the processor . Examples of executable programs may be for example a compiled program that can be translated into machine code in a format that can be loaded into a random access portion of the memory and run by the processor source code that may be expressed in proper format such as object code that is capable of being loaded into a random access portion of the memory and executed by the processor or source code that may be interpreted by another executable program to generate instructions in a random access portion of the memory to be executed by the processor etc. An executable program may be stored in any portion or component of the memory including for example random access memory RAM read only memory ROM hard drive solid state drive USB flash drive memory card optical disc such as compact disc CD or digital versatile disc DVD floppy disk magnetic tape or other memory components.

The memory is defined herein as including both volatile and nonvolatile memory and data storage components. Volatile components are those that do not retain data values upon loss of power. Nonvolatile components are those that retain data upon a loss of power. Thus the memory may comprise for example random access memory RAM read only memory ROM hard disk drives solid state drives USB flash drives memory cards accessed via a memory card reader floppy disks accessed via an associated floppy disk drive optical discs accessed via an optical disc drive magnetic tapes accessed via an appropriate tape drive and or other memory components or a combination of any two or more of these memory components. In addition the RAM may comprise for example static random access memory SRAM dynamic random access memory DRAM or magnetic random access memory MRAM and other such devices. The ROM may comprise for example a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other like memory device.

Also the processor may represent multiple processors and or multiple processor cores and the memory may represent multiple memories that operate in parallel processing circuits respectively. In such a case the local interface may be an appropriate network that facilitates communication between any two of the multiple processors between any processor and any of the memories or between any two of the memories etc. The local interface may comprise additional systems designed to coordinate this communication including for example performing load balancing. The processor may be of electrical or of some other available construction.

Although the services the broker service the identifier translation service and other various systems described herein may be embodied in software or code executed by general purpose hardware as discussed above as an alternative the same may also be embodied in dedicated hardware or a combination of software general purpose hardware and dedicated hardware. If embodied in dedicated hardware each can be implemented as a circuit or state machine that employs any one of or a combination of a number of technologies. These technologies may include but are not limited to discrete logic circuits having logic gates for implementing various logic functions upon an application of one or more data signals application specific integrated circuits ASICs having appropriate logic gates field programmable gate arrays FPGAs or other components etc. Such technologies are generally well known by those skilled in the art and consequently are not described in detail herein.

The flowcharts of show the functionality and operation of an implementation of portions of the services the broker service and the identifier translation service . If embodied in software each block may represent a module segment or portion of code that comprises program instructions to implement the specified logical function s . The program instructions may be embodied in the form of source code that comprises human readable statements written in a programming language or machine code that comprises numerical instructions recognizable by a suitable execution system such as a processor in a computer system or other system. The machine code may be converted from the source code etc. If embodied in hardware each block may represent a circuit or a number of interconnected circuits to implement the specified logical function s .

Although the flowcharts show a specific order of execution it is understood that the order of execution may differ from that which is depicted. For example the order of execution of two or more blocks may be scrambled relative to the order shown. Also two or more blocks shown in succession in may be executed concurrently or with partial concurrence. Further in some embodiments one or more of the blocks shown in may be skipped or omitted. In addition any number of counters state variables warning semaphores or messages might be added to the logical flow described herein for purposes of enhanced utility accounting performance measurement or providing troubleshooting aids etc. It is understood that all such variations are within the scope of the present disclosure.

Also any logic or application described herein including the services the broker service and the identifier translation service that comprises software or code can be embodied in any non transitory computer readable medium for use by or in connection with an instruction execution system such as for example a processor in a computer system or other system. In this sense the logic may comprise for example statements including instructions and declarations that can be fetched from the computer readable medium and executed by the instruction execution system. In the context of the present disclosure a computer readable medium can be any medium that can contain store or maintain the logic or application described herein for use by or in connection with the instruction execution system.

The computer readable medium can comprise any one of many physical media such as for example magnetic optical or semiconductor media. More specific examples of a suitable computer readable medium would include but are not limited to magnetic tapes magnetic floppy diskettes magnetic hard drives memory cards solid state drives USB flash drives or optical discs. Also the computer readable medium may be a random access memory RAM including for example static random access memory SRAM and dynamic random access memory DRAM or magnetic random access memory MRAM . In addition the computer readable medium may be a read only memory ROM a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other type of memory device.

Further any logic or application described herein including the services the broker service and the identifier translation service may be implemented and structured in a variety of ways. For example one or more applications described may be implemented as modules or components of a single application. Further one or more applications described herein may be executed in shared or separate computing devices or a combination thereof. For example a plurality of the applications described herein may execute in the same computing device or in multiple computing devices in the same computing environment . Additionally it is understood that terms such as application service system engine module and so on may be interchangeable and are not intended to be limiting.

Disjunctive language such as the phrase at least one of X Y or Z unless specifically stated otherwise is otherwise understood with the context as used in general to present that an item term etc. may be either X Y or Z or any combination thereof e.g. X Y and or Z . Thus such disjunctive language is not generally intended to and should not imply that certain embodiments require at least one of X at least one of Y or at least one of Z to each be present.

It should be emphasized that the above described embodiments of the present disclosure are merely possible examples of implementations set forth for a clear understanding of the principles of the disclosure. Many variations and modifications may be made to the above described embodiment s without departing substantially from the spirit and principles of the disclosure. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

