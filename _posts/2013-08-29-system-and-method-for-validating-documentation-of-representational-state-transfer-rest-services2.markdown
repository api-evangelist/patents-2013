---

title: System and method for validating documentation of representational state transfer (REST) services
abstract: A validation tool is provided for a representational state transfer (REST) service. In one embodiment, a method for validating documentation of a REST service includes including detecting one or more messages for a REST service by a validator, wherein the one or more messages are intercepted for the REST service, translating documentation of the REST service, by the validator, into a representation of an automaton, and validating the one or more messages by the validator based on the automaton, wherein validation of the messages determines conformance of the REST service to the documentation of the REST service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09621440&OS=09621440&RS=09621440
owner: Rackspace US, Inc.
number: 09621440
owner_city: San Antonio
owner_country: US
publication_date: 20130829
---
This application claims the benefit under 35 U.S.C. 119 e of provisional application No. 61 695 728 filed Aug. 31 2012 which is entitled System and Method for Validating Documentation of Representational State Transfer Rest Service which is incorporated herein by reference.

REST REpresentational State Transfer is an architectural style described by Roy Fielding in his PhD dissertation Fielding2000. REST seeks to adapt the architecture of the Web along with its scalability performance and other advantages as a platform for any kind of application. In REST as on the Web a resource is an item of interest. Each resource has an address URI and one or more representations a file with a given media type . A client can interact with a resource through a URL and these interactions in turn act as the engine of application state because the representations provide hypermedia links offering alternative directions the client can take to proceed through the workflow. The RESTful ideal is that just as you interact with a Web site and choose which step to take next without being frustrated that the layout of the page and links offered have changed since the last time you visited the site so a client using a RESTful API can pick its way through a workflow without demanding a fixed brittle contract. Likewise the Web s mature and well understood caching mechanisms can improve the performance and scalability of your application protecting the server from spikes in traffic and the client from brief interruptions in the server s availability.

While many APIs describe themselves as RESTful some RESTful APIs are more RESTful than others. At the most rudimentary level APIs may employ one or more URIs but still use only one method GET POST to tunnel their requests over HTTP and do not represent a radical break from WS services. APIs that embrace the RESTful architecture more fully offer a larger number of resources each with a URI and map a variety of HTTP verbs to the Create Read Update Delete CRUD operations found in most applications. In these services parameters are passed in with requests either as elements of the URI or as query parameters appended to the URI. The Web s caching infrastructure also comes into play. Finally in an ideal more often discussed than achieved services that fully embrace the idea of hypermedia as the engine of application state HATEOS relying on the client to navigate through the workflow in the same way an end user at an e commerce site would by inspecting the available links and picking the appropriate one.

As a REST service is being developed the goal is to ensure that the documentation accurately matches the implementation. Once a REST service reaches a mature state or is released publicly the documentation becomes a contract both clients and alternate implementations use this contract to guide their development. Interoperability between all parties requires that both the documentation and the implementation remain stable even in the face of bug fixes upgrades enhancements and the introduction of new features via extensions.

In the presence of these changes there always exists the possibility that either REST service implementation or documents may inadvertently drift from one another. This drift often introduces incompatibilities that can cause clients to fail. Thus it is important to constantly test that the implementation and documentation of a REST service conform to one another. Unfortunately document conformance is typically not focused on nor the intricate details of the REST HTTP aspects of the service. Instead testing typically focuses on the functionality of a REST service itself which can result in a number of incompatibilities. Because a focus on functional testing has little to no regard to documentation of the service cases may arise where both the implementation and testing of a REST service drift away from the documents simultaneously. Adding to the complexity is the fact that service developers tend to allow their implementations to be flexible and loose when accepting messages from clients this means that conformance and functional tests may inadvertently drift from the service contract without notice.

In one exemplary aspect the present disclosure is directed to method for validating documentation of representational state transfer REST service. The method includes detecting one or more messages for a REST service by a validator wherein the one or more messages are intercepted by the validator for the REST service translating by the validator documentation of the REST service into a representation of an automaton and validating the one or more messages by the validator based on the automaton wherein validation of the messages determines conformance of the REST service to the documentation of the REST service.

In another exemplary aspect the present disclosure is directed to a non transitory computer accessible storage medium storing program instructions that when executed by a computer cause the computer to implement a representational state transfer REST service validator. The validator configured to detect one or more messages for a REST service wherein the one or more messages are intercepted by the validator for the REST service translate documentation of the REST service into a representation of an automaton and validate the one or more messages based on the automaton wherein validation of the messages determines conformance of the REST service to the documentation of the REST service.

The following disclosure describes one or more embodiments for validating documentation of a representational state transfer REST service. In on embodiment documentation of a REST service is incorporated in the testing process of a REST service in an automated way. According to another embodiment a documentation pipeline is configured to generate validation rules that can be checked in a layer between the function tests and service itself.

One embodiment is directed to a method for validating documentation of a REST service. In particular a the method is provided for addressing one or more of the issues described below with respect to validation of a REST service.

Accordingly a system and method for validation are provided that better incorporates the documentation in the testing process in an automated way. In one embodiment a documentation pipeline is used to generate validation rules that can be checked in a layer between the function tests and the service itself.

Referring now to a graphical representation is depicted of a computing system including a validator to validate representational state transfer REST services. REST validator intercepts requests e.g. messages from the functional tests before the requests reach the REST service . The requests may be at least one of client and server application messages and can include one or more messages. In certain embodiments the requests are functional tests messages for testing functions of the REST service.

REST validator checks requests for strict conformance to documentation of the REST service. In one embodiment the documentation is a machine readable description of the XML Web Application Description Language WADL . REST validator intercepts and validates responses from the REST service. One advantage of REST validator may be the ability to ensure that the validator is strictly accurate with conformance to documents of the REST service because the validation rules are generated directly from the documentation. Another advantage may be that the validator can check for drift by both the functional tests and REST service simultaneously because the validator sits between the functional tests and the REST service . Another advantage may be that validator can be easily incorporated into existing services as the method and system of does not require changes to existing functional tests.

According to one embodiment validator can validate documentation of a representational state transfer REST service. In one embodiment validator is configured to detect one or more messages for a REST service by a validator wherein the one or more messages are intercepted by the validator for the REST service. Validator can translate documentation of the REST service into a representation of an automaton and validate the one or more messages by the validator based on the automaton wherein validation of the messages determines conformance of the REST service to the documentation of the REST service. Translating documentation of the REST service by validator can include parsing the documentation validating the documentation against schema and normalizing the documentation. The automaton can be a representation in an XML format of URL paths and URI resources for validating messages for the REST service. Validator may be configured to optimize an automaton determined for a REST service. In certain embodiments validator may be embodied in a non transitory computer accessible storage medium the non transitory computer accessible storage medium storing program instructions that when executed by a computer cause the computer to implement the representational state transfer REST service validator.

According to another embodiment validator is an intermediary approach for performing validation where messages are intercepted between client and server applications and an automata based programming approach that enables the efficient validation of messages at run time. Although depicted as a separate element from REST service in validator can be incorporated into existing REST services and does not require a change to existing functions of the REST service. As will be described in more detail below validation by validator may be configured for one or more of filtering accurate error reporting authorization and API coverage. According to another embodiment validation may be based on a tag set chosen to semantically describe all aspects of a RESTful service and contain author friendly features.

Referring now to diagram shows an information processing system including sever configured to host one or more machines such as device and device coupled to network . Examples of information processing systems include a server computer a personal computer e.g. a desktop computer or a portable computer such as for example a laptop computer a handheld computer and or a variety of other information handling systems known in the art. The information processing system shown is representative of one of or a portion of the information processing systems described above.

The information processing system and one or more of device device and server may include any or all of the following a a processor for executing and otherwise processing instructions b one or more network interfaces e.g. circuitry for communicating between the processor and other devices those other devices possibly located across the network c a memory device e.g. FLASH memory a random access memory RAM device or a read only memory ROM device for storing information e.g. instructions executed by processor and data operated upon by processor in response to such instructions . In some embodiments the information processing system may also include a separate computer readable medium operably coupled to the processor for storing information and instructions as described further below.

In one embodiment the information processing system includes at least one type of computer readable media that is non transitory. For explanatory purposes below singular forms such as computer readable medium memory and disk are used but it is intended that these may refer to all or any portion of the computer readable media available in or to a particular information processing system without limiting them to a specific location or implementation

According to one or more embodiments validation of a REST service may be based on an automaton the automaton generated based on documentation for the REST service.

Accepting messages that meet some criteria is a common problem in computer science. One technique for solving the problem is to utilize an automaton. An automaton is a state machine that transitions from an initial start state to other states based on the current input. If after the message is read the machine is in an accept state then the message is accepted otherwise the message does not meet the required criteria.

For validation of a REST service the validator of can be configured to determine whether any possible HTTP message meets all of the criteria defined in the documentation and whether an HTTP message does not. By way of example the validation according to one or more embodiments includes validator accepting the subset of all HTTP messages that are valid according to the description in the source document. According to another embodiment the validator also needs to categorize those messages that are not valid according to the error code that should be generated by the underlying REST service so that the error code that the REST service produces can also be verified.

According to one or more embodiments the system and methods for validation into a representation of an automaton. In one exemplary embodiment validation includes translating documentation of the REST service in the form of a web application description language WADL either stand alone or extracted from the contents of a RackBook document into a representation of an automaton that can be used to validate messages as they are intercepted between functional tests and the REST service. A WADL describes a RESTful API in a machine readable format.

Referring now to an exemplary automaton is depicted. For simplicity the automaton is only checking for conformance to the URL path and the HTTP method. In this particular API the only allowed operation is a GET on the path path to record date where date is an xs date as defined by W3C XML Schema W3CSchema2010. The start state is S0. In automaton there are three accept states 

2. d30U accepts HTTP messages for which a 404 Not Found response should be expected from the REST service.

Starting at state S0 the process examines the URL path one path segment at a time. The HTTP method is not accessible until the path has been completely parsed. The transition from one state to another is based on input matches except in the case of an transition where a state is advanced without regard to the current input. In the automaton of U x matches the current URL path segment to x where x may be a regular expression or a QName representing an XML Schema simple type. U x matches an URL segment that is not accepted by x. On a successful match the URL path is advanced to the next path element. After the URL path is completely read the machine proceeds to read the HTTP Method. Here M x and M x work the same as U x and U x except they match against the HTTP method instead of the URL path segment. Because the automaton is only checking for URL paths and Methods the process ends after the HTTP method has been read.

Referring now to diagram depicts a representation of the automaton of . According to one embodiment REST automata are internally represented by an XML format or checker format. Diagram is an exemplary representation of automaton in checker format.

According to one embodiment checker format is a simple terse document type that maps each state in the state machine along with the edges that it connects to into a single step element. All steps in the checker format contain an id attribute of type xs ID which uniquely identifies the step in the machine and a type attribute which indicates the type of check the step performs. In diagram there are two types of URL checks the steps that check a path segment against a regular expression are of type URL and those that check the segment against a simple XML Schema type are of type URLXSD. Connections between steps are represented by a next attribute of type xs IDREFs. Additionally most steps also contain a match or notMatch attribute that provides the details of how a match is interpreted.

To match against all aspects of the HTTP request including steps that match against request media types steps may be taken to check the form of XML and JSON content to validate XML via an W3C XML Schema XSD 1.1 validator and to check for the presence of required elements by means of XPath expressions. According to one or more embodiments because a REST service may define many different types of elements and the element attribute in a representation binds an element to a particular operation these aspects of REST service can be enforced via an XPath expression step in the machine.

According to another embodiment a validator may include an XSLT checker step which performs a transformation of the request message before it is validated by the XSD step. In some cases it may seem odd that an XSLT transform may be required for validation but the requirement comes into play in cases where the type of the request document needs to be restricted or extended based on the operation being performed. For example a pattern in REST services may include a REST API dealing with Widgets that allows a Widget to have all attributes when performing a PUT operation but restricts the POST operation to Widget documents containing only a subset of the available attributes. The restriction on POST is specified in the WADL. Validation may include using a WADL plain parameter to connect a restricted type of a widget WADL to a post operation.

The automata created to validate REST services may be quite complex often involving many states and connections. As an example depicts an exemplary graphical representation of an automaton for validating the OpenStack Compute API excluding extensions .

According to one or more embodiments optimization stages may be introduced into the transformation process of REST service documentation to try to reduce the number of states in the automaton. In certain embodiments each optimization stage is simply an XSLT that takes a checker document as input and creates a checker document with less states as output. Optimization stages can therefore be chained together. With each stage the checker document produced should perform the exact same function as the original unoptimized one.

Optimization stages may be employed that compress redundant or non distinguishable states into a single state. Redundant states occur quite frequently because the translation code that converts a WADL to a checker document does so without regard to the number of states produce in order to keep the translation code simple. illustrates the effect of running optimization stages on the computed API of . As shown in the number of states is reduced dramatically in automaton realtive to automaton .

According to one or more other embodiments other optimization techniques that may be employed include converting the simple type checks in URLXSD steps into regular expression URL steps compressing multiple regular extension checks into a single check compressing multiple boolean XPath expressions into a single expression and compressing XPath expressions XSLT transformations and XSD schema validation into a single schema aware XSLT transform step.

According to one or more embodiments a validation as described herein may include a validation pipeline responsible for producing REST automata from WADLs.

Referring now to a graphical illustration of a validation pipeline is illustrated. Validation pipeline includes parse the WADL at block validate against WADL schema at block normalize the WADL at block convert the WADL to checker format at block run through optimization stages at block validate against checker schema at block and convert to internal immutable data structure at block .

The first three parts of the pipeline e.g. block and can be shared with a general documentation pipeline. The stages utilize XProc XSLT2 and XSD 1.1 to generate the final checker document. The final stage block creates an immutable data structure from this document that is used by the Repose WADL proxy component to process and validate API requests within the Repose HTTP proxy. Block is implemented by means of a specialized SAX handler. The data structure the handler produces is essentially a model of the automaton that can be executed by the Repose component when validating request. The process for validating HTTP request with the data structure avoids the use of global state meaning that most content is passed via the call stack. As such and because the internal data structure is immutable the entire process of is thread safe meaning that it can validate multiple HTTP request simultaneously in different threads of execution.

According to one or more embodiments validation pipeline is a prepossessing step. Once the immutable data structure is created at block it can be used to handle many HTTP request simultaneously at run time and in an efficient manner.

Stages in the validation pipeline are configurable. For example the strictness of validation may be configured for one or more stages wherein the strictness is determined by which validation steps should be added to the final checker. Specialized options for each individual step of the validation pipeline may be configured. For example configuring whether one or more of an XPath version 2 implementation be used in an XPath step and whether a Saxon EE or Xerces be used for XSD 1.1 validation in the XSD step. Stages of validation pipeline may also be configured based on the optimization stages to use.

In one embodiment validation may include performing checks on the HTTP response generated by the REST service the checks extended into the automata to account for this. In another embodiment JSONPath and JSON Schema stages may be added in a validation pipeline. The validation pipeline may also include support for other validation languages in XML such as RelaxNG and Schematron.

In addition to validating documentation of REST services a validator as described herein and the validation pipeline can be used to solve other problems.

REST services can receive many millions of HTTP requests a day. Many of these requests are malformed the result of user errors. According to one embodiment a validator such as the validator of can detect malformed requests and filter the malformed requests from the underlying REST implementation. The validator can additionally respond with an appropriate error message. For example rather than responding with simply a 404 Not Found the validator can respond with 404 path to widget not found expecting server image instead of widget . According to one or more embodiments validation may include filtering malformed messages by the validator from implementation of the REST service and reporting errors by the validator to identify documentation and REST service discrepancy.

According to one or more embodiments a validator is provided with capabilities based on authorization of a user. Often different sets of users can access different parts of the API. For example administrators may have the capability to reboot a server but regular users may not. According to one embodiment a validator can include filtering capabilities and assign different sets of users different validators. In that fashion administrators can have a validator that accepts the reboot operation while regular users have a validator that does not. In this case the documentation such as a WADL becomes an authorization policy file.

In yet another embodiment validators can log stages in the automaton that have been visited. This information can be used to compute test coverage. If there are states in the automaton that are not visited by functional tests then the functional tests are obviously missing something. Also in production the information can be used to gain insight into what parts of an API are frequently accessed by users.

The embodiments described herein provide a system and method to use a documentation pipeline for documenting REST APIs and extend the documentation pipeline to support the creation of validators that can help confirm that the documentation accurately reflects reality or that an implementation does not drift from what is stated in the documentation for the REST service.

According to one or more embodiments systems and methods for validating may interoperate with one or more platforms. According to another embodiment XML media types are described with XSD 1.1 because of the open content features that are offered by the standard. OpenStack APIs are extensible describing the XML media types with XSD 1.0 was not an option. Since OpenStack is an open and free platform one goal is to provide developments open and accessible to the community while still remaining friendly to enterprise customers. To that end validators may be configured to support both the Xerces open source and the Saxon EE proprietary XSD 1.1 implementations.

WADL makes references to XPaths when describing plain parameters. According to one embodiment XPaths need to be successfully copied as they proceed along the validation pipeline . Ensuring that the XPaths remain intact under all circumstances has proved difficult given that there may be conflicts with namespace prefixes or worst contention for the default namespace. In one embodiment an XSLT extension may be created to keep XPath valid and that will enable leveraging an XPath 2 parser or to write an XPath 2 parser in XSLT to resolve the issue.

Because validation and our documentation pipeline both rely on the WADL normalizer it is important to ensure that the output of the normalizer accurately reflects the intent of the original WADL author. In on embodiment a functional testing framework is provided to avoid regression the framework takes advantage of the XML features of Scala to perform transformations on simple WADLs and WADL XSD combinations and compare those with the expected result. The code sample in depicts a graphical representation of such a test according to one or more embodiments.

Even though illustrative embodiments have been shown and described a wide range of modification change and substitution is contemplated in the foregoing disclosure and in some instances some features of the embodiments may be employed without a corresponding use of other features. Accordingly it is appropriate that the appended claims be construed broadly and in a manner consistent with the scope of the embodiments disclosed herein.

