---

title: System, method, and computer program product for passing attribute structures between shader stages in a graphics pipeline
abstract: A system, method, and computer program product are provided for passing attribute structures between shader stages of a processing pipeline. The method includes the steps of receiving data represented at a first level by a processing pipeline including an upstream shader unit, a downstream shader unit, and a processing unit. The upstream shader unit processes the data to generate a first set of attributes corresponding to the data represented at a second level. The upstream shader unit also stores the first set of the attributes in a first portion of a memory system that can be read by the downstream shader unit and any shader units that are downstream in the processing pipeline relative to the upstream shader unit. In one embodiment, the processing unit is coupled between the upstream shader unit and the downstream shader unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09659399&OS=09659399&RS=09659399
owner: NVIDIA Corporation
number: 09659399
owner_city: Santa Clara
owner_country: US
publication_date: 20130823
---
Conventional graphics processing pipelines include a vertex shader hull shader tessellation unit domain shader a geometry shader and a pixel shader that each process graphics geometry and generate attributes. The attributes generated by the vertex shader processed by a hull shader and passed to the tessellation unit that produces a primitive topology and then to the domain shader. Dedicated first in first out FIFO buffer circuits may be coupled between the vertex shader and tessellation unit between the tessellation unit and the domain shader between the domain shader and the geometry shader and between the geometry shader and the pixel shader to accommodate different processing throughputs. However the number of entries in the FIFO buffer circuits is limited.

The domain shader computes per vertex attributes that are output to the pixel shader e.g. position lighting texture coordinates and color. Modern graphics processing pipelines may be configured to generate as many as 128 different attributes so the amount of data that is passed between the different shaders for each vertex has increased compared with conventional graphics processing pipelines. The per vertex attributes are output by the domain shader to the geometry shader which may subdivide primitives that are defined by the vertices thereby generating additional vertices and associated attributes that are output to a rasterizer. The rasterizer determines pixel coverage and outputs the per vertex attributes to the pixel shader that are needed to determine a color for each pixel.

As graphics processing capabilities have improved the size of the primitives has decreased so that in some cases each primitive may only cover a single pixel. The amount of attribute data that is generated and passed through the graphics processing pipeline to produce each pixel of an image has increased significantly compared with traditional graphics processing. Consequently the capacity of the FIFO buffer circuits may be exceeded resulting in a reduction in processing throughput and decreased performance. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for passing attribute structures between shader stages of a processing pipeline. The method includes the steps of receiving represented at a first level by a processing pipeline including an upstream shader unit a downstream shader unit and a processing unit. The upstream shader unit processes the data to generate a first set of attributes corresponding to the data represented at a second level. The upstream shader unit also stores the first set of the attributes in a first portion of a memory system that can be read by the downstream shader unit and any additional shader units that are downstream in the processing pipeline relative to the upstream shader unit. In one embodiment the processing unit is coupled between the upstream shader unit and the downstream shader unit.

The amount of attribute data that is generated may be reduced by delaying generation of some attributes until later in the graphics processing pipeline. The attributes that are generated by earlier stages in the graphics processing pipeline may be stored in attribute structures that can be accessed by one or more downstream processing units. Memory needed to store the attributes structures may be allocated by a shader program as the attributes to be stored in the structure are generated and may be deallocated by a last consuming processing stage of the graphics processing pipeline. Thereby the amount of attribute data that is generated and passed through the graphics processing pipeline to produce each pixel of an image is decreased significantly compared with traditional graphics processing.

At step the upstream shader unit processes the data to generate a first set of attributes corresponding to the data represented at a second level. In the context of the present description data that is graphics geometry represented at the first level may include vertices defining high order graphics primitives in object space control points or vertices defining surface patches or vertices defining graphics primitives such as points lines and triangles. In the context of the present description data that is graphics geometry represented at the second level or another level may include control points or vertices defining surface patches vertices defining graphics primitives or pixel fragments in screen space. In general the first level representation of graphics geometry requires less data compared with a descendent or lower second third etc. level representation of the graphics geometry. In the context of the present description a set of attributes may be implemented as an attribute structure that includes one or more attributes associated with graphics geometry or a graphics primitive. Examples of attributes include but are not limited to position coordinates normal vectors texture map coordinates lighting parameters color and the like.

At step the upstream shader unit also stores the first set of the attributes in a first portion of a memory system that can be read by the downstream shader unit and additional shader units that are downstream in the processing pipeline relative to the upstream shader unit. In the context of the following description a memory system may include one or more of a first level L1 cache a second level L2 cache and memory comprising one or more discrete memory devices e.g. die or chips that are external to the graphics processing pipeline such as dynamic random access memory DRAM static random access memory SRAM and the like.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. Attributes may include one of more of position color surface normal vector texture coordinates etc. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCle slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

As shown in the graphics processing pipeline comprises a pipeline architecture that includes a number of stages. The stages include but are not limited to a data assembly stage a vertex shader stage a hull shader stage a tessellation primitive assembly stage a domain shader stage a geometry shader stage a viewport transform stage a rasterization stage a pixel shader stage and a raster operations stage . In one embodiment the input data comprises commands that configure the processing units to implement the stages of the graphics processing pipeline and high order geometric primitives to be processed by the stages. The output data may comprise pixel data i.e. color data that is copied into a frame buffer or other type of surface data structure in a memory e.g. memory . The SMs may be configured by shader program instructions to function as one or more of the shader stages e.g. vertex hull domain geometry and pixel shaders .

The data assembly stage receives the input data that specifies vertex data for high order graphics geometry. The data assembly stage collects the vertex data defining the high order graphics geometry in a temporary storage or queue such as by receiving a command from the host processor that includes a pointer to a buffer in a memory system and reading the vertex data from the buffer. In one embodiment the memory system may include one or more of the memory the L2 cache and the shared memory L1 cache . The vertex data is then transmitted to the vertex shader stage for processing.

The vertex shader stage processes vertex data by performing a set of operations i.e. a vertex shader or a program once for each of the vertices. Vertices may be e.g. specified as a 4 coordinate vector associated with one or more vertex attributes. The vertex shader stage may manipulate properties such as position color texture coordinates and the like. In other words the vertex shader stage performs operations on the vertex coordinates or other vertex attributes associated with a vertex. Such operations commonly including lighting operations i.e. modifying color attributes for a vertex and transformation operations i.e. modifying the coordinate space for a vertex . For example vertices may be specified using coordinates in an object coordinate space which are transformed by multiplying the coordinates by a matrix that translates the coordinates from the object coordinate space into a world space or a normalized device coordinate NCD space. The vertex shader stage generates transformed vertex data that is transmitted to the hull shader stage .

Conventional graphics processing pipelines transmit the transformed vertex data between different stages through a set of pipeline registers or a dedicated FIFO buffer. As shown in the vertex shader stage may pass the vertex data directly to the hull shader stage or alternately may pass the vertex data to the hull shader stage through an attribute structure that is stored in the memory system . An attribute structure that is stored to the memory system by the vertex shader stage may be read by one or more downstream shader units.

The storage capacity of the attribute structure is less limited compared with a dedicated FIFO buffer and the attribute structure may be sized as needed to store the specific attributes generated by each vertex shader program. Therefore when only a few attributes are generated the amount of memory consumed is smaller than when many attributes are generated. In contrast the size of a dedicated FIFO buffer is fixed. In one embodiment the attribute structures and are implemented as circular buffers. Each attribute structure and may be configured to store data in a structure of arrays SOA or in an array of structures AOS format as specified by the corresponding shader program. Portions of the attribute buffers and may be cached in the L2 cache and or the shared memory L1 cache with the memory serving as a spill storage when the capacity of the L2 cache and or the shared memory L1 cache is exceeded. Mechanisms using techniques known in the art may be used to ensure coherency as needed between the different caches and memory . In one embodiment ownership of cache lines may be passed from one warp to another during execution of a shader program and the last warp to access a particular cache line may invalidate the cache line.

Separate attribute structures are stored for each of the different shader stages so that the memory allocated to store an attribute structure may be deallocated when a last consumer of the attribute structure has read the attribute structure. The memory used to store an attribute structure is allocated by the shader program that generates and stores data into the attribute structure. In contrast the memory allocated to store texture maps and a frame buffer is allocated by a device driver and the scope of memory allocated to texture maps and the frame buffer is global meaning that the data can be accessed by a CPU the PPU and other processing devices in a system. The scope of the memory storing the attributes structures and is limited to the shader programs executed by the PPU by the processing units in the graphics processing pipeline.

The vertex attributes associated with a high order graphics geometry that are stored in the attribute structure are read by the hull shader stage and processed to generate per patch attributes where each patch may be defined by up to 32 control points. The per patch attributes generated by the hull shader stage are written to the attribute structure or alternately may also be transmitted directly to the tessellation primitive assembly stage .

The tessellation primitive assembly stage receives the control points passed from the hull shader stage and tessellates the patches into geometric primitives for processing by the domain shader stage . For example the tessellation primitive assembly stage may be configured to group every three consecutive vertices as a geometric primitive i.e. a triangle for transmission to the domain shader stage . In some embodiments specific vertices may be reused for consecutive geometric primitives e.g. two consecutive triangles in a triangle strip may share two vertices . The tessellation primitive assembly stage may be configured to store intermediate data into the attribute structure and read the intermediate data to generate the tessellated vertices that are passed to the domain shader directly or through the attribute structure . After tessellation the amount of data representing the graphics geometry that was received as input data may be significantly larger because the granularity of the geometry typically becomes finer as the geometry is processed by the different stages of the graphics processing pipeline.

The domain shader stage computes vertex position attributes for each tessellated vertex and stores the attributes in the attribute structure . The domain shader stage may read attributes stored in the attribute structure to compute the vertex position attributes. The attribute structure provides a path for passing attributes from the vertex shader stage to the domain shader stage without passing the attributes through the intervening stages of the graphics processing pipeline e.g. the hull shader stage and tessellation primitive assembly . In contrast in conventional graphics processing pipelines attributes are passed from the vertex shader stage through the hull shader stage and the tessellation primitive assembly stage to reach the domain shader stage .

The vertex position attributes generated by the domain shader stage are passed directly to the geometry shader stage or are passed to the geometry shader stage through the attribute structure . The geometry shader stage processes geometric primitives by performing a set of operations i.e. a geometry shader program on the geometric primitives. Geometry shading operations may generate one or more geometric primitives from each geometric primitive. In other words the geometry shader stage may subdivide each geometric primitive into a finer mesh of two or more geometric primitives for processing by the rest of the graphics processing pipeline . The geometry shader stage transmits geometric primitives e.g. points lines triangles and the like to the viewport stage either directly or through the attribute structure .

The viewport stage may read attributes from one or more of the attribute structures and . The viewport stage performs a viewport transform culling and clipping of the geometric primitives. Each surface being rendered to is associated with an abstract camera position. The camera position represents a location of a viewer looking at the scene and defines a viewing frustum that encloses the objects of the scene. The viewing frustum may include a viewing plane a rear plane and four clipping planes. Any geometric primitive entirely outside of the viewing frustum may be culled i.e. discarded because the geometric primitive will not contribute to the final rendered scene. Any geometric primitive that is partially inside the viewing frustum and partially outside the viewing frustum may be clipped i.e. transformed into a new geometric primitive that is enclosed within the viewing frustum. Furthermore geometric primitives may each be scaled based on depth of the viewing frustum. All potentially visible geometric primitives are then transmitted to the rasterization stage .

The rasterization stage converts the 3D geometric primitives into 2D fragments. The rasterization stage may be configured to utilize the vertices of the geometric primitives to setup a set of plane equations from which various attributes can be interpolated. The rasterization stage may also compute a coverage mask for a plurality of pixels that indicates whether one or more sample locations for a pixel intercept the geometric primitive. In one embodiment z testing may also be performed to determine if the geometric primitive is occluded by other geometric primitives that have already been rasterized. The rasterization stage generates fragment data i.e. coverage masks for each covered geometric primitive that are transmitted to the pixel shader stage .

The pixel shader stage processes fragment data by performing a set of operations i.e. a fragment shader or a program on each of the fragments. The pixel shader stage may generate pixel data i.e. color values for the fragment such as by performing lighting operations or sampling texture maps using interpolated texture coordinates for the fragment. The pixel shader stage generates pixel data that is transmitted to the raster operations stage . Rather than using only the data that is received from the rasterization stage the pixel shader stage may access one or more of the attribute structures and to read attributes that were generated by an upstream processing unit at a different level of the graphics geometry.

For example the pixel shader stage may read per patch attributes that were generated and stored in the attribute structure by the hull shader stage and or per primitive attributes that were generated and stored in the attribute structure by the geometry shader stage . The pixel shader stage may read per vertex attributes that were generated for the graphics geometry represented at the different levels from any of the attribute structures and . In one embodiment the pixel shader stage may read interpolated attributes from the attribute structure and the viewport stage may be configured to compute additional attributes for clipped perspective corrected barycentric coordinates that are used by the pixel shader stage to perform barycentric interpolation to compute per sample or per pixel attributes as further described in conjunction with . In another embodiment the pixel shader stage may read per patch control point attributes from the attribute structure and compute the per sample or per pixel attributes as further described in conjunction with .

The raster operations stage may perform various operations on the pixel data such as performing alpha tests stencil tests and blending the pixel data with other pixel data corresponding to other fragments associated with the pixel. When the raster operations stage has finished processing the pixel data i.e. the output data the pixel data may be written to a render target such as a frame buffer a color buffer or the like.

It will be appreciated that one or more additional stages may be included in the graphics processing pipeline in addition to or in lieu of one or more of the stages described above. Various implementations of the abstract graphics processing pipeline may implement different stages. Furthermore one or more of the stages described above may be excluded from the graphics processing pipeline in some embodiments. Other types of graphics processing pipelines are contemplated as being within the scope of the present disclosure. Furthermore any of the stages of the graphics processing pipeline may be implemented by one or more dedicated hardware units within a graphics processor such as PPU . Other stages of the graphics processing pipeline may be implemented by programmable hardware units such as the SM of the PPU .

When large numbers of different attributes are supported bit vectors may be used between the different shader stages of the graphics processing pipeline to indicate the attributes that are used for a particular image or even for particular graphics geometry. In one embodiment the bit vectors may be used to determine the capacity i.e. the amount of memory allocated for each attribute structure. In another embodiment the capacity of each attribute structure may be configured to store the maximum number of attributes that are supported.

At step graphics geometry represented at a first level is received by a graphics processing pipeline. At step the upstream shader unit processes the graphics geometry to generate a first set of attributes corresponding to the graphics geometry represented at a second level. In the context of the present description the upstream shader unit may be one of the vertex shader stage the hull shader stage the tessellation primitive assembly stage the domain shader stage and the geometry shader stage .

At step the upstream shader unit also stores the first set of the attributes in an attribute structure or within the memory system . The attribute structures and can be read by a downstream shader unit and additional shader units that are downstream in the graphics processing pipeline relative to the upstream shader unit. In the context of the present description the upstream shader unit and additional shader units may include the hull shader stage the tessellation primitive assembly stage the domain shader stage the geometry shader stage the viewport stage and the pixel shader stage .

At step the first set of attributes is read by a downstream shader unit. At step the downstream shader unit processes the graphics geometry to generate a second set of attributes corresponding to the graphics geometry represented at a third level. The downstream shader unit may also process the first set of attributes. At step the downstream shader unit stores the second set of attributes in a second attribute structure such as the attribute structure or within the memory system . At step the downstream shader unit determines if another downstream shader unit will consume the attribute structure read by the downstream shader unit at step and if not at step the attribute structure read by the downstream shader unit at step is deallocated. At step the downstream shader unit determines if the downstream shader unit is the last stage in the graphics processing pipeline. If the downstream shader unit is the last stage in the graphics processing pipeline then the geometry processing terminates. Otherwise steps and are repeated.

If at step the downstream shader unit determines that another downstream shader unit will consume the attribute structure read by the downstream shader unit at step then steps and are repeated.

At step the viewport stage computes the plane equation coefficients for the alpha and beta barycentric coordinates for a graphics geometry. The alpha and beta plane equation coefficients may be passed from the viewport stage to downstream shader stages through the shader stages rather than being stored into an attribute structure. In other embodiments a different stage of the graphics pipeline that is upstream from the pixel shader stage computes the plane equation coefficients for the alpha and beta barycentric coordinates. The plane equation coefficients are used by the pixel shader stage to compute per pixel or per sample attributes. The pseudo code shown in TABLE 1 may be used to compute the alpha and beta values.

In a conventional graphics processing pipeline the viewport stage computes plane equation coefficients for all of the attributes that will be interpolated by the pixel shader stage. The plane equation coefficients are computed for graphics geometry that may not reach the pixel shader stage due to z buffering or other culling operations. Therefore computing only plane equations for alpha and beta may be a significant reduction in the amount of data that is passed from the viewport stage to the pixel shader stage . Reducing the number of plane equation coefficients that are computed earlier in the graphics processing pipeline may also reduce the amount of power consumed.

At step the alpha and beta plane equation coefficients are received by the pixel shader stage . In one embodiment the alpha and beta plane equation coefficients may be received from the rasterization stage . At step the pixel shader stage reads the vertex attributes from the attributes structure. As previously explained the pixel shader stage may read vertex attributes for one or more different levels of representation of the graphics geometry. In contrast a conventional pixel shader stage receives only per primitive vertex attributes for points lines and triangles generated by the geometry shader stage .

At step the pixel shader stage computes per pixel or per sample attributes using the alpha and beta plane equation coefficients and the vertex attributes read from the attribute structure. The pseudo code shown in TABLE 2 may be used to compute an arbitrary attribute using the alpha and beta values.

The ability of the pixel shader stage to access vertices stored in an attribute structure enables the pixel shader stage to compute per pixel and or per sample attributes using barycentric coordinates using vertices for graphics geometry stored at different levels.

Also only the plane equation coefficients for the barycentric coordinates need to be passed through the downstream stages to reach the pixel shader stage rather than passing separate plane equation coordinates for each attribute that is interpolated by the pixel shader stage to compute the per pixel and or per sample attributes. Furthermore computations are postponed other than the computation of alpha and beta until after z testing and other culling operations. In conventional graphics processing pipelines the per attribute plane equation coefficients that are computed before z testing and other culling operations may be discarded before reaching the pixel shader stage . In contrast in one embodiment a limited number of plane equation coefficients are computed e.g. alpha and beta so fewer computed coefficients are discarded as the result of z testing and other culling operations reducing the amount of storage needed to store attributes and possibly reducing power.

The domain shader stage may then compute the position at the vertices of each tessellated graphics geometric primitive. Conventionally the domain shader stage would also compute other vertex attributes such as lighting texture coordinates and the like. However when attributes structures are available the computation of the other vertex attributes may be performed by the pixel shader stage using data stored in one or more of the attribute structures and .

At step the domain shader stage computes the world space position at the tessellated vertices using the u v coordinates computed by the tessellation primitive assembly stage . At step the domain shader stage computes normal vectors for each vertex displaces the vertices along the normal vectors and then transforms the displaced vertex positions in world space with the view projection matrix.

At step vertex attributes computed by one or more of the shader stages e.g. the vertex shader stage the hull shader stage the domain shader stage and the geometry shader stage or the tessellation primitive assembly stage may be stored into an attribute structure. In particular the attributes produced at the control points by the hull shader stage are stored in the attribute structure .

At step the u v coordinates perspective corrected or non perspective corrected are received by the pixel shader stage . In one embodiment the u v coordinates may be received from the rasterization stage . At step the pixel shader stage reads the per control point attributes from the attributes structure. As previously explained the pixel shader stage may read vertex attributes for one or more different levels of representation of the graphics geometry. At step the pixel shader stage computes per pixel or per sample attributes using the u v coordinates and the vertex attributes read from the attribute structure including the per control point attributes computed at step .

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

