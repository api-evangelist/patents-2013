---

title: Dynamically scalable modes
abstract: The present disclosure includes techniques for storing indexed values that may increase computing performance. In one example, a method includes receiving a request to store an input value in a data structure. The method also includes determining the input value is not represented by an index value of the first group of index values, generating an index value that represents the input value, and determining the generated index value is not included in the first group of representations. The method also includes generating a second group of index values wherein a first size of index values of the first group is different than a second size of index values of the second group. The method also includes modifying a storage capacity of the data structure to store the index values of the second group of the second size and storing the second group of index values in the data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08812560&OS=08812560&RS=08812560
owner: International Business Machines Corporation
number: 08812560
owner_city: Armonk
owner_country: US
publication_date: 20130228
---
This application is a continuation of Ser. No. 13 168 537 filed on Jun. 24 2011 entitled DYNAMICALLY SCALABLE MODES the entire content of which is incorporated herein by reference.

The size of an image may be proportional to the information density of the image. For example increasing the quantity of pixels in an image or including more information per pixel may increase the size of an image. However compression techniques are known that increase information density without increasing a stored image size. In some cases images may be manipulated in memory where a block of memory is used to store the pixels of an image. The memory used to manipulate the image can be reduced using indexed colors where each pixel specifies an index in a palette of colors rather than the color itself.

In one example a method includes receiving by a computing device a request to store an input value in a data structure wherein the data structure stores one or more index values of a first group of index values wherein the first group of index values uniquely represent storage values wherein the one or more index values comprise a first group of representations of the storage values. The method also includes determining by the computing device that the input value is not represented by an existing index value of the first group of index values. The method further includes generating by the computing device an index value that represents the input value. The method also includes determining by the computing device that the generated index value is not included in the first group of representations. The method further includes responsive to determining that the generated index value is not included in the first group of representations generating by the computing device a second group of index values comprising a second group of representations that uniquely represent all of the storage values and the input value wherein a first size of index values of the first group is different than a second size of index values of the second group modifying by the computing device a storage capacity of the data structure to store the index values of the second group of the second size and storing by the computing device the second group of index values in the data structure.

In one example a computing device includes a computer readable storage medium one or more processors an input device to receive a request to store an input value in a data structure of the computer readable storage medium wherein the data structure stores one or more index values of a first group of index values wherein the first group of index values uniquely represent storage values wherein the one or more index values comprise a first group of representations of the storage values and a graphics module executable by the one or more processors to determine that the input value is not represented by an existing index value of the first group of index values. The graphics module is further executable to generate an index value that represents the input value and determine that the generated index value is not included in the first group of representations. The graphics module is also executable to responsive to determining that the generated index value is not included in the first group of representations generate a second group of index values comprising a second group of representations that uniquely represent all of the storage values and the input value wherein a first size of index values of the first group is different than a second size of index values of the second group modify a storage capacity of the data structure to store the index values of the second group of the second size and store the second group of index values in the data structure.

In one example a computer program product for re allocating index values the computer program product comprising a computer readable storage medium having computer readable program code embodied therein. The computer readable program product includes computer readable program code to receive a request to store an input value in the computer readable memory wherein the computer readable memory stores one or more index values of a first group of index values wherein the first group of index values uniquely represent storage values wherein the index values comprise a first group of representations of the storage values. The computer readable program product also includes computer readable program code to determine the input value is not represented by one of the index values. The computer readable program product also includes computer readable program code to generate an index value that represents the input value. The computer readable program product also includes computer readable program code to determine the generated index value is not included in the first group of representations. The computer readable program product further includes computer readable program code to generate responsive to determining the generated index value is not included in the first group of representations a second group of index values comprising a second group of representations that uniquely represent all the storage values and the input value wherein a first size of index values of the first group is different than a second size of index values of the second group. The computer readable program product also includes computer readable program code to modify a storage capacity of the data structure to store the index values of the second group of the second size. The computer readable program product also includes computer readable program code to store the second group of index values in the computer readable memory.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

In general the present disclosure is directed to techniques for storing indexed values in a bitmap that may improve storage efficiency and in some cases increase computing performance. For example images may be manipulated quickly and efficiently in memory using an image bitmap. In the image bitmap a block of memory may be used to store an array of pixels that comprise the image. Memory used to represent the image may be reduced using index values such that each pixel is represented in the bitmap by an index value. The index value is further mapped to an actual color value in a palette of colors.

Techniques of the present disclosure may improve memory utilization by generating index values using only a fewest number of bits to uniquely represent each actual color value of pixels in the image. The index values may be generated using a fewest number of bits based on the number of uniquely identifiable colors stored in the image bitmap. The techniques further allow the size of index values to increase granularly as new colors are stored in the image. As the number of index values increase when new colors are stored in the image bitmap techniques of the present disclosure may dynamically increase the size of the index values reassign the index values to existing and newly added colors and further allocate additional memory to store the larger index values if needed. Thus using techniques of the present disclosure memory may be used efficiently by generating index values based on the number of uniquely identifiable colors used in an image bitmap and granularly increasing the size of index values as more colors are included in the image.

Images in memory may need to be manipulated quickly and efficiently. In some examples a graphics library may provide a bitmap representation of an image. The bitmap representation may be stored in memory where a block of memory is used to store an array of pixel values. In a direct color mode each pixel value in a bitmap comprises an actual color value e.g. 32 bits . Memory use may be reduced by indexing color values to index values where each pixel specifies an index value in a palette of colors rather than the color value itself. This approach may save memory when the index values may be less than 32 bits e.g. 8 or 16 bits.

To determine whether direct or index mode will provide better performance a programmer or other user of the graphics library may be required to know beforehand which of the two modes to use. For example in the case of indexed colors the programmer may be required to know what size of the index values to use. In some examples a programmer may use a 32 bit bitmaps to allow 32 bit color depth in all cases even when not required. Because images due to the pixel based representations may use substantial memory the manipulation of a few images at once may cause a great number of memory page swaps to occur or slow down garbage collection heavily reducing performance of the system. Also many new small devices can have limited memory or significant memory restrictions.

Techniques of the present disclosure analyze image contents at run time and based on the contents dynamically change the size of the image bitmap which provides improved scalability and reduced memory foot prints that are based on the actual needs of the user image. Thus aspects of the disclosure may reduce memory needed to uniquely identify the color of each pixel in the palette and each color value in an image bitmap. Techniques described herein for accessing and manipulating each pixel in the bitmap may use the palette size e.g. number of color values included in an image to determine the number of bits of each index value and to update pixel values in the bitmap. In this way the pixel values may remain contiguous in memory for easy management while memory use for each pixel may be reduced.

Computing device in some examples includes or is a part of a portable computing device e.g. mobile phone netbook laptop tablet device or a desktop computer. Computing device may also connect to a network including a wired or wireless network using a network device. Computing device may also include output device as further described in . In some examples output device may be programmed by computing device to display graphical content. Graphical content generally includes any visual depiction displayed by presence sensitive screen . Examples of graphical content may include images A D videos visual objects and or visual program components such as scroll bars text boxes buttons etc. In one example application may cause output device to display GUI .

Computing device may further include one or more input devices further described in . In some examples an input device may be a mouse keyboard touch sensitive screen or other device capable of translating a human stimulus into data comprising an input value. Such input values may be used by applications and other components of computing device . In this way input device enables user to interact with application .

As shown in application may execute on computing device . Application may include program instructions and or data that are executable by computing device . One example of application may include a program for displaying and manipulating images A D in response to user input received via input device . For example images A D may include graphs photos or other visual data. Using input device user may provide input values that modify data comprising images A D.

In some examples application causes GUI to be displayed by output device . GUI may include interactive and or non interactive graphical content that presents information of computing device in human readable form. In some examples GUI enables user to interact with application through input device . For example user may use a mouse to direct a cursor displayed by output device and provide one or more input values that select graphical content e.g. a control button displayed in GUI . In this way GUI enables user to create modify and or delete data of computing device .

As shown in application further includes graphics module . Graphical module may provide various functions to manipulate images such as images A D. One example of image manipulation may include changing pixel values of an image based on a user selection to change a color of the image. In another example application may change pixels values of an image in response to data received a via a network connection or from other applications executing on computing device . In any case graphics module includes various functions to change the data of images such as images .

In some examples output device may display many different images in GUI . As the number of images displayed in GUI increase greater amounts of memory are used to store the increasing number of images. In one example use case images A D may each comprise a different chart that represents data from various data sets. User may provide multiple user inputs to manipulate each of images A D. As user manipulates the images pixel values in the manipulated images are changed. Such manipulation may cause computing device to perform memory page swaps as each different image is manipulated. Techniques of the present disclosure may reduce such memory page swaps and further improve garbage collection thereby improving performance of computing device . Such techniques are described in further detail in the following figures.

As shown in the specific example of computing device includes one or more processors memory a network interface one or more storage devices input device and output device . Computing device also includes an operating system . Computing device in one example further includes application which may be an example of application as shown in . Application is executable by computing device . Each of components may be interconnected physically communicatively and or operatively for inter component communications.

Processors in one example are configured to implement functionality and or process instructions for execution within computing device . For example processors may be capable of processing instructions stored in memory or instructions stored on storage devices .

Memory in one example is configured to store information within computing device during operation. Memory in some examples is described as a computer readable storage medium. In some examples memory is a temporary memory meaning that a primary purpose of memory is not long term storage. Memory in some examples is described as a volatile memory meaning that memory does not maintain stored contents when the computer is turned off. Examples of volatile memories include random access memories RAM dynamic random access memories DRAM static random access memories SRAM and other forms of volatile memories known in the art. In some examples memory is used to store program instructions for execution by processors . Memory in one example is used by software or applications running on computing device e.g. application and or one or more other applications to temporarily store information during program execution.

Storage devices in some examples also include one or more computer readable storage media. Storage devices may be configured to store larger amounts of information than memory . Storage devices may further be configured for long term storage of information. In some examples storage devices include non volatile storage elements. Examples of such non volatile storage elements include magnetic hard discs optical discs floppy discs flash memories or forms of electrically programmable memories EPROM or electrically erasable and programmable EEPROM memories.

Computing device in some examples also includes a network interface . Computing device in one example utilizes network interface to communicate with external devices via one or more networks such as one or more wireless networks. Network interface may be a network interface card such as an Ethernet card an optical transceiver a radio frequency transceiver or any other type of device that can send and receive information. Other examples of such network interfaces may include Bluetooth 3G and WiFi radios in mobile computing devices as well as USB. In some examples computing device utilizes network interface to wirelessly communicate with an external device not shown such as a server mobile phone or other networked computing device.

Computing device in one example also includes one or more input devices . Input device in some examples is configured to receive input from a user through tactile audio or video feedback. Examples of input device include a touch sensitive screen a mouse a keyboard a voice responsive system video camera microphone or any other type of device for detecting a command from a user.

One or more output devices may also be included in computing device . Output device in some examples is configured to provide output to a user using tactile audio or video stimuli. Output device in one example includes a touch sensitive screen sound card a video graphics adapter card or any other type of device for converting a signal into an appropriate form understandable to humans or machines. Additional examples of output device include a speaker a cathode ray tube CRT monitor a liquid crystal display LCD or any other type of device that can generate intelligible output to a user.

Computing device may include operating system . Operating system in some examples controls the operation of components of computing device . For example operating system in one example facilitates the interaction of application with processors memory network interface storage device input device and output device . As shown in application may include graphics module . Graphics module may each include program instructions and or data that are executable by computing device . For example graphics module includes instructions that cause application executing on computing device to perform one or more of the operations and actions described in this disclosure. In some examples graphics module may receive input from one or more input devices of computing device .

Any applications e.g. application implemented within or executed by computing device may be implemented or contained within operable by executed by and or be operatively communicatively coupled to components of computing device e.g. processors memory network interface storage devices input device and or output device .

In one example a user may provide a user input at input device that causes processor to load instructions of graphics module into memory . Graphics module may further cause processor to load an image from storage device into memory . The image data may be loaded by graphics module into memory in the form of image bitmap as shown in .

In graphics module may store pixel values in image bitmap that comprise index values representing actual color values. For example actual colors values may be represented as 32 bit values in computing device . To reduce memory usage when fewer colors are required in an image graphics module may use a color palette to map 32 bit color values to 8 bit index values as shown in . Color palette may be implemented as a map or other associative data structure. In this way graphics module may store an 8 bit index value as pixel value in image bitmap rather than a 32 bit actual color value .

Techniques of the present disclosure may improve the scalability and memory usage of computing device by using only as much or approximately only as much memory for each pixel as is required to uniquely identify each color of color palette . For example graphics module may initially select an image file from storage device and determine that 256 colors are included in the image. Graphics module may then calculate the fewest number of bits that may be required to uniquely represent each of the 256 colors included in the image. In one example calculation for 256 colors graphics module may determine that 7 log 256 8. Consequently graphics module may generate 8 bit index values to represent each of the actual color values. The 8 bit index values may comprise a group of finite representations from 00000000 11111111. A group of finite representations represent a fixed quantity of values e.g. color values. For instance only 256 colors may be represented by 8 bit indexes and a 9 bit index value would therefore not be included in a group of 8 bit finite representations.

By using the actual quantity of color values in the calculation e.g. the size of the color palette graphics module may dynamically calculate a fewest number of bits required to uniquely identify each of the storage values e.g. actual colors stored in image bitmap . Furthermore graphics module may generate a group of finite representations with the fewest number of bits required to represent each of the color values. In this way techniques of the present disclosure may improve memory use efficiency and system performance while reducing programmer effort.

Techniques of the present disclosure may be provided transparently via an Application Programming Interface API for fast and efficient manipulation of the image while reducing programmer effort by hiding the implementation of the example techniques. For example an API may accept and return 32 bit color values but may implement the image bitmap using techniques described herein to dynamical reallocate memory for the image bitmap as colors are added and removed In this way underlying complexity of techniques of the present disclosure may be hidden by the graphics library from the programmer or other user.

In one example technique illustrated in the number of colors in image bitmap may increase from 256 as shown in to 257 colors as shown in . For instance an additional color may be added to the image represented by image bitmap as the image is being manipulated in memory by graphics module . Initially graphics module may receive a request to store an input value e.g. the 257th color in image bitmap . The request may further specify the 257th color will replace pixel value of image bitmap . The 257th color may be color value as shown in color palette of . Upon receiving the request to store the 257th color graphics module may determine that the 257th color is not represented by an index value in color palette .

In response to determining the 257th color is not represented in color palette graphics module may generate an index value that represents the 257th color. In some examples graphics module may use the number of colors e.g. to calculate the fewest number of bits required to represent each of the 257 colors. To calculate the fewest number of bits for 257 colors graphics module may perform a calculation to determine 8 log 257 9. Consequently graphics module may generate 9 bit index values to represent each of the 257 colors. Each of the 9 bit index values may be mapped to color values in color palette e.g. color value may be mapped to 100000000 or 0100000000 .

In some examples graphics module may increase the number of bits for each index value by more than 1 bit. For instance graphics module may determine that 9 bits comprise the fewest number of bits to represent 257 colors however graphics modules may increase the number of bits for each index value by 2 bits as shown in . By increasing the number of bits by 2 graphics module may reduce the number of times memory is reallocated when additional colors are added to image bitmap and colors values are remapped to index values with greater numbers of bits.

In some examples graphics module may determine upon generating an index value that the number of bits required to represent an additional color is less than or equal to the current size of index values stored in color palette . For instance if only 255 colors are presently stored in color palette a 256th color may be added to color palette and mapped to an 8 bit index that is not presently mapped to another color value. For example the 256th color value may be mapped to color palette index value and the index value may be stored in image bitmap as pixel value .

Returning to the current example of replacing pixel value with an index value representing a 257th color graphics module may determine the generated 10 bit index value e.g. 0100000000 corresponding to the 257th color is not included in the finite group of 8 bit representations that comprise the index values of color palette . Consequently upon determining the 10 bit index value is not included in the finite group of 8 bit index values graphics module may increase the size of each index value by two bits as shown in . To accommodate the increase in size of each index value computing device may modify a storage capacity of the data structure e.g. bitmap to store the 10 bit index values. In one example a storage capacity of the data structure may refer to a number of bits the data structure is capable of representing. In other examples a storage capacity of the data structure may refer to a number of index values the data structure is capable of representing. In any case graphics module may dynamically modify the storage capacity of bitmap in order to store the increased number of bits generated by increasing index values from a size of 8 bits to a size of 10 bits.

As shown in color palette includes each color value of color palette as shown in and additionally a color value that comprises the 257th color. Each color value in is re mapped by graphics module to a 10 bit index value that corresponds to the 8 bit index values of color palette . More specifically each color value of color palette may be re mapped to an index value in color palette that is generated from the index value of color palette associated with the color value. For example color value is represented by index value as shown in . Graphics module may select index value associated with color value . As shown in graphics module generates a mapping that maps color value to index value . Index value may be a 10 bit representation generated by graphics module based on index value of color palette . Finally color value that represents index value is further associated with index value in color palette .

Upon re mapping each color value to a corresponding 10 bit index value graphics module may dynamically allocate additional memory to store the 10 bit values. In some examples graphics module determines the amount of memory required based on the size of each index value and the number of index values stored in the image bitmap. For example as shown in image bitmap includes eight pixel values represented by index values. Consequently graphics module when generating image bitmap may allocate two additional bytes of memory for image bitmap to accommodate the 10 bit index values that represent each pixel. For instance eight pixel values that increase by two bits each require two additional bytes of memory in image bitmap .

After memory has been allocated and image bitmap has been generated graphics module may store the eight 10 bit pixel values in image bitmap . For example pixel value of that corresponds to index value in may be stored in the first 10 bits of bitmap . Similarly graphics module may store the next 10 bit index value that corresponds to pixel value of in the 10 bits following pixel value . Thus graphics module stores the 10 bit index values in image bitmap in the same order as image bitmap . In this way colors of the image remain the same although the size of each pixel value has increased from 8 bits to 10 bits. After the index values have been stored in image bitmap graphics module may set pixel value to index value that represents color value e.g. the 257th color.

As shown in the examples of graphics module may dynamically increase the size of index values to accommodate additional color values in color palette and in some examples use only as much or approximately only as much memory is as is required to store the index values. Consequently the memory footprint of the image bitmap may grow as needed while maintaining fast and efficient manipulation of the image bitmap in memory . Techniques to grow the image bitmap as shown in may be performed in reverse order to shrink image bitmap as fewer colors are included in the image. In some examples memory may be de allocated as image bitmap is shrunk. In this way graphics module may shrink the image bitmap as colors are removed from the image.

In some examples graphics module may switch from index mode as described in to direct mode. In direct mode graphics module may store color values directly in image bitmap . In one example graphics module may initially generate image bitmap as a byte array and operate in index mode. As more colors are added to the image graphics module may generate index values that include greater numbers of bits to uniquely represent newly added colors. In some examples graphics module may include a threshold that when satisfied causes graphics module to switch from index mode to direct mode. A threshold may be user specified or comprise a computer generated value. For example the threshold may specify a number of bits of an index value or a number of color values in a color palette. In one example if graphics module when increasing the size of index values e.g. because a new color has been added to color palette determines that a number of color values in a color palette satisfies the threshold graphics module may switch from index mode to direct mode. In one example graphics module may determine the threshold is satisfied when the number of colors in a color palette is greater than the threshold. When switching from index mode to direct mode graphics module may replace each pixel value comprising and index value in image bitmap with its corresponding color value of color palette . In some examples graphics module may generate 32 bit values for each color value and may further reallocate additional memory to store each 32 bit value as described in .

In some examples graphics module may when initially generating an image bitmap determine whether to operate in index or direct mode. For example graphics module may receive data that specifies an initial size of the image bitmap. In one example such data may include a total number of rows and a total number of columns of the bitmap. Multiplying the number of rows and columns provides the total number of pixels in the bitmap. Graphics module may further compare the size of the image bitmap to a threshold that when satisfied causes graphics module to operate in direct mode initially instead of index mode. A threshold may be user specified or comprise a computer generated value. In one example graphics module may determine the threshold is satisfied when the number of bits initially satisfied for the image bitmap is greater than a threshold. In such an example graphics module may operate in direct mode initially instead of index mode. Therefore graphics module may store color values directly in the image bitmap.

As shown in graphics module may receive a request to store an input value in a memory wherein the memory stores a first group of index values that uniquely represent storage values wherein the index values comprise a first group of finite representations of the storage values . In some examples the input value may comprise a color value. Each color value may comprise a storage value in a color palette e.g. color palette of . The request may further include x axis and y axis position coordinates that together comprise a position of a pixel value within an image bitmap. Thus the request may include one or more instructions and data including a color value and position coordinates to set a pixel value at the specified position coordinates to the specified color value.

Upon receiving the request graphics module may determine whether the color value is represented by an index value in color palette . If the color value is represented by an index value graphics module may store the color value at the position coordinates specified in the request . If the color value is not represented by an index value graphics module may generate an index value that represents the color value . In some examples graphics module may determine whether the generated index value is included in the first group of finite representations e.g. index values in color palette . For instance one or more 8 bit representations may not presently be assigned as index values to color values in color palette . In such examples graphics module may generate an 8 bit index value that is not presently assigned to a color value in color palette . Because the generated index value is 8 bits graphics module may determine the generated index value is included in the finite group of 8 bit representations . Consequently graphics module may assign the generated index value to the color value received in the request .

In some examples each 8 bit index value in color palette may already represent a color value. Because the number of 8 bit index values are finite graphics module may generate e.g. a 10 bit index value as described in . Graphics module may further determine if the 10 bit index value is included in the finite group of 8 bit representations . Since the 10 bit index value is not already included in the finite group of 8 bit representations graphics module may generate a second group of 10 bit index values that include a second group of finite representations that uniquely represent all the storage values e.g. existing color values of color palette and the input value e.g. the color value received in the request . Graphics module may further modify the storage capacity of the image bitmap in order to store 10 bit index values. For example graphics module may increase the size of the bitmap to store the larger 10 bit index values and accommodate the 2 bit increase in size of each index value. In some examples graphics module may allocate additional memory for the image bitmap in order to increase the storage capacity of the image bitmap. Using techniques described in graphics module may map each existing color value in color palette to a 10 bit index value as shown in color palette of . Each 10 bit index value of color palette may correspond to an 8 bit color index of color palette . In this way graphics module may dynamically increase the number of colors that may be represented in an image bitmap and granularly increase the number of bits of the index values to improve storage efficiency of pixel values in the image bitmap.

Although techniques of the present disclosure have been described using an example of pixel values stored in an image bitmap the techniques may be applicable more generally to any type of index based data structure e.g. array where the required size of the index values is not initially known at the time of allocation or changes frequently and where the access and manipulation of the index values may require efficient performance.

For instance an example may include an ordered list of unique identifiers that represent a queue of customers. The unique identifiers may comprise index values that link to customer records stored in a database. If the queue is manipulated often such as a prioritized queue then the operations on the queue may require efficient performance and could be implemented using an array of identifiers. If new customers are added and removed from the system on a frequent basis the number of possible identifiers may not be known. Growing and shrinking the number of bits of the identifiers and the size of the queue using techniques of the present disclosure may allow the queue to use less memory when the number of identifiers are few and still grow to accommodate increases in the number of identifiers.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions.

These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the disclosure. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

Various embodiments of the disclosure have been described. These and other embodiments are within the scope of the following claims.

In some examples techniques of the present disclosure that set a pixel value may be implemented using the following pseudocode. Although the following pseudocode does not further include memory allocation logic to modify the size of the image bitmap such logic may be implemented according to the preceding description.

Techniques are further disclosed using the following and foregoing pseudocode to retrieve a pixel value.

