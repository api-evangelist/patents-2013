---

title: Polymorphic computing architectures
abstract: Polymorphic computing architectures can support and control separate, independently executable domains and other components on a computing platform. In some embodiments, the architectures may control the different domains and/or components according to different purposes. In some embodiments, the architectures can control domains and/or components to enforce a desired “purpose” of a domain/component while simultaneously denying a corresponding “anti-purpose”.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501666&OS=09501666&RS=09501666
owner: SRI INTERNATIONAL
number: 09501666
owner_city: Menlo Park
owner_country: US
publication_date: 20131011
---
This application claims the benefit of and priority to U.S. Provisional Patent Application Ser. No. 61 839 202 filed Jun. 25 2013 which is incorporated herein by this reference in its entirety.

This application is related to U.S. Utility application Ser. No. 13 872 865 filed Apr. 29 2013 of Oberg et al. titled Operating System Independent Integrity Verification which is incorporated herein by this reference in its entirety.

This application is related to U.S. Utility application Ser. No. 14 051 923 filed on even date herewith of Oberg et al. titled Componentized Provisioning which is incorporated herein by this reference in its entirety.

This application is related to U.S. Utility application Ser. No. 14 052 080 filed on even date herewith of Forsberg et al. titled Flexible Policy Arbitration Control Suite which is incorporated herein by this reference in its entirety.

This application is related to U.S. Utility application Ser. No. 14 052 169 filed on even date herewith of Saidi et al. titled Polymorphic Virtual Appliance Rule Set which is incorporated herein by this reference in its entirety.

This invention was made in part with government support under contract number M67854 12 C 2408 awarded by the United States Marine Corps Systems Command. The United States Government has certain rights in this invention.

Traditional system architectures for computing platforms and mobile computing systems in particular such as smart phones tablet computers wearable devices and others have a monolithic vertical software design in which execution of applications stored on the file system device drivers and software stacks is controlled by the operating system kernel. Traditional hardware architectures include the co located system components and resources as a monolithic fixed system. A consequence of traditional system software architectures is the co location of the software into a single general purpose environment resulting in several million lines of software code for a single system. While this may provide a convenient architecture to develop applications the general purpose design results is a highly complicated co mingled architecture in which it is extremely difficult to manage and ensure control of the device for specific functions and in the presence of vulnerabilities. As computing platforms may be used to access and control other devices and systems the same management and control implications are present.

While the concepts of the present disclosure are susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and are described in detail below. It should be understood that there is no intent to limit the concepts of the present disclosure to the particular forms disclosed. On the contrary the intent is to cover all modifications equivalents and alternatives consistent with the present disclosure and the appended claims.

Existing mobile device management MDM and other policy solutions implement static monolithic security policies that are designed for the traditional architectures. As a result these solutions are unable to dynamically control the use and sharing of resources e.g. based on the purpose of an installed component and the current context of its use operation. For example traditional policy solutions are unable to detect whether in a given circumstance a device or a component thereof is being used for a specific purpose such as a personal matter or a business related transaction. As such these solutions result in inflexible and often over restrictive policy as the lack of context means they must always enact the most protective measures.

Polymorphic computing system architectures composed of provisioned verified and policy controlled components or domains either physically co located and or networked together for one or more defined purposes are disclosed herein. A system domain manager provides selective activation of one or more components or domains in accordance with a semi dynamic policy arbitration subsystem that may transform the system into a specific purpose defined computing device. In some embodiments this polymorphic computing architecture can be delivered on a general purpose device that when provisioned with on and off device components and configured with purpose derived system policy becomes a purposed system. The purposed system architecture is polymorphic in that system components can be activated deactivated or re provisioned in response to authenticated user control or contextual policy conditions.

Additionally embodiments of a polymorphic computing system architecture include software and hardware components that can be individually composed provisioned and controlled for specific policy defined purposes. In systems where multiple co existing provisioned domains or modules are simultaneously sharing resources a policy manager policy engine and policy arbitrator assures compliance to defined policy without requiring each domain to have prior knowledge of the other domains. Embodiments of the system include provisioned trust tokens and policy artifacts that can be generated by collecting the natural language expressions of purpose policy and context for the system. The natural language expressions use an ontology framework for automated generation of purpose and anti purpose based policy artifacts rule sets and trust tokens that are configured to realize the desired purpose and preclude the possibility of the associated anti purpose.

In some embodiments MILS Multiple Independent Levels of Security concepts can be applied to these and other computing environments to provide a modular component based approach to secure system architectures component provisioning policy provisioning and purpose policy enforcement and system certification. In general a MILS based platform is comprised of components that share physical resources while creating strongly separated exported resources. When composed additively these resources form a distributed resource sharing substrate which may be referred to as a MILS platform. In high assurance applications the use of a separation kernel is a component of the MILS platform. The separation kernel architecture provides for a functionally distrusted system of individual separated components with well defined limited communication channels between the components distrusted in the sense that the individual components are not assumed to be trusted from a security standpoint . As used herein a well defined communication channel may refer to among other things one or more signal paths which can be implemented in hardware or software and may be implemented as a logical interface between two logical e.g. virtualized units where the interface is clearly defined so that the entities on either end of the communication channel or channel are known and unchangeable and the type of communications that are permitted to be sent over the communication channel channel are also known and unchangeable. Once each of these well defined communication channels or channels has been validated as such it need not be continuously re validated.

There are few if any integrity verification approaches that can reliably determine the integrity of operating systems system files libraries and other software at both at load time and at run time as needed. Many existing techniques are either integrated with the operating system itself or must be executed offline. As described in this disclosure a physical or virtualized device block based verification of firmware or software at load time or at run time can be leveraged to provide more robust and flexible integrity verification services that operate independently of the operating system.

In general computer files can become corrupted as a result of for example storage media failures transmission errors write errors that occur during copying or moving of the files or computer program bugs. Additionally untrusted parties may intentionally modify computer files to insert malicious code during use transmission or storage of the file. Accordingly as used herein integrity verification refers generally to the use of computerized algorithms methods or procedures for determining whether the integrity and or authenticity of a computer file e.g. data and or computer program instructions software or firmware has been corrupted or otherwise compromised.

As disclosed herein a component provisioning subsystem can be realized for example upon a MILS based platform. For example aspects of the component provisioning subsystem can be realized by operational components of the system architecture to achieve particular component specific purposes. In the abstract the architecture defines components e.g. subjects objects domains applications subsystems and interactions between the components. Isolation and information flow control policies govern the existence of the architectural components on the platform and their interactions with system resources and other components. Isolation policies provide that only controlled well defined interfaces thus limiting the type and scope of interaction are allowed for direct interaction between components. Furthermore the data allowed to pass through these interfaces can be controlled by the trusted side of the connection or by a trusted component inline of the connection. Information flow control policies define explicitly permitted causality or interference between the components. Whereas current mobility policy and MDM solutions are only as secure as their parent process the disclosed approach can provide a peer based architecture in which peer components such as those found in a virtualized system are isolated from one another so as to be protected from other peer components should any of the components be compromised. Among other things a peer based policy architecture as disclosed herein enables individual components policies to exist without prior or current knowledge of other individual component policies.

In some embodiments the component provisioning subsystem can be employed to provide a high assurance of security for multiple personality computing devices. In such devices different user level execution environments e.g. personal and enterprise domains or unclassified and classified domains may be isolated from one another using the MILS based techniques so as to for example simultaneously protect personal privacy and enterprise security e.g. address the need to protect while also enabling appropriate data sharing e.g. the need to share . For instance one domain may allow a mobile device user to access personal records such as e mail medical data or financial reports but deny access to other domains while another domain may permit access to data and applications involving very highly confidential or secret business information processes or operations but deny such access to other domains. To do this embodiments of the component provisioning subsystem may cooperate with domain isolation encryption policy and other related security technologies developed by SRI International which can be embedded into smart phones and other mobile platforms as described in more detail below and in other patent applications of SRI International including the related patent applications identified above. Some examples of high assurance multiple personality mobile devices that have been developed by SRI International were mentioned in the press release SRI International Begins Final Development of Commercial Trusted Mobility Devices for U.S. Marine Corps Apr. 8 2013.

As disclosed herein a flexible distributed policy architecture can be realized for example upon a MILS based platform. Such a policy architecture can be realized by operational components of the architecture to achieve a particular system purpose. In the abstract the policy architecture defines components e.g. subjects objects domains applications and interactions between the components. Isolation and information flow control policies govern the existence of the architectural components on the platform and their interactions with system resources and other components. Isolation policies provide that only controlled well defined interfaces thus limiting the type and scope of interaction are allowed for direct interaction between components. Furthermore the data allowed to pass through these interfaces can be controlled by the trusted side of the connection or by a trusted component inline of the connection. Information flow control policies define explicitly permitted causality or interference between the components. Whereas current mobility policy and MDM solutions are only as secure as their parent process the disclosed approach can provide a peer based architecture in which peer components such as those found in a virtualized system are isolated from one another so as to be protected from other peer components should any of the components be compromised. Among other things a peer based policy architecture as disclosed herein enables individual components policies to exist without prior or current knowledge of other individual component policies.

Some embodiments of the disclosed policy arbitration subsystem are embodied in a context aware device e.g. a mobile device equipped with one or more environment sensors such as a GPS accelerometer and or others . Such embodiments can extend a MILS based policy architecture by enabling semi dynamic policy implementations in the context aware device. For example the policy arbitration subsystem can manage and enforce the embedded policies of isolated distributed architectural components that are designed for specific purposes. Such policies may be statically pre defined e.g. as information flow control channels between isolated MILS based components. As used herein policy may refer to among other things an expression of enforcement monitoring and or other capabilities that are needed on the computing device to ensure that the computing device or a component thereof operates according to a defined purpose and does not perform the associated anti purpose. For example a policy may define criteria for sharing and or protecting information and components of the computing device under various conditions and contexts. The policy may be implemented for example as a set of rules instructions data values parameters or a combination thereof which may be stored in for example a database or table. As used herein policy provisioning or domain provisioning may refer to among other things the process of provisioning a domain for use on a computing device in a way that the domain can coexist with other domains that may have conflicting policies e.g. by installing new policy artifacts for the domain as described herein whereas purpose provisioning or component provisioning may refer to among other things provisioning a domain or other type of component for use on a computing device in accordance with a domain or component specific purpose which may be unique to the domain component e.g. during installation of a new component on the computing device . Where the term provisioning is used herein without the purpose or policy modifiers provisioning may refer more generally to the process of configuring a domain or component for use on a computing device e.g. including purpose provisioning and or policy provisioning . Moreover where the term purpose is used it may refer to among other things a purpose that is associated with a domain policy that is provisioned by for example the disclosed policy arbitration subsystem e.g. a domain purpose or a purpose that is associated with a component or component resource which may be provisioned by for example the disclosed provisioning subsystem e.g. a component purpose . The intended use of these terms should be apparent from the context where not otherwise explained.

In some embodiments references to policy provisioning and policy arbitration relate to systems and rule sets for handling well defined shared system services e.g. system services that require a system API and integrated trigger enforcement capability although other embodiments of the disclosed policy arbitration subsystem can operate in a distributed environment e.g. across computing systems. As described in more detail below in some embodiments component purpose provisioning can be applied to shared system services where each shared system service is a provisionable component for example to component owners stakeholders to real well defined component resources or to abstract component resources. Such component resources may be shared across a network with an external resource receiver shared locally on the device platform as global system resource or shared exclusively across a set of components or may be a private resource known only to a single component. When shared across a network with an external resource receiver the component resource may be provided with attestation and integrity of the component purpose rule set and digitally signed by the purpose enforcement engine for verification by any component resource receiver. In addition confidentiality may be incorporated and accommodated by using a suitable encryption technique e.g. if the purpose enforcement engine or purpose rule has the resource receiver s public key or even a pre shared key associated with the rule and receiver . Encryption and integrity implementations may even be layered or unique to each purpose rule set e.g. encryption key A with rule 1 and key B with rule 2 may be combined serially .

Referring now to an illustrative computing device platform is embodied as a computing device configured with a modular virtualized system architecture as described in more detail below. It should be understood however that the computing device platform may be any type of computing device or platform e.g. a device that has a virtualized architecture a traditional system architecture or a traditional system architecture configured to provide some virtualization features. For example the computing device platform may be embodied as any type of personal computer e.g. desktop laptop net book e reader tablet smart phone body mounted device or mobile appliance a server server farms hosted in the cloud an enterprise computer system a network of computers the network infrastructure itself a combination of computers and other electronic devices or other types of electronic device including wearable computing devices smart appliances medical monitoring and sensing devices commercial personal devices health monitoring devices embedded scientific and sensing devices UAV s unmanned aerial vehicles SUAV s small unmanned air vehicles other types of unmanned vehicles and other safety critical systems.

In some embodiments the disclosed architectures and subsystems extend the purpose anti purpose concepts discussed in Denker et al. Policy Based Downgrading Toward a Semantic Framework and Automated Tools to Balance Need to Protect and Need to Share Policies IEEE International Symposium on Policies for Distributed Systems and Networks 2010 to a MILS enabled architecture. For instance MILS based components and policies that are only designed to achieve a particular purpose or desired function may in some contexts result in realizing an anti purpose of the system an unintended consequence . As an example a banking application may need to share account information with others to achieve a defined purpose e.g. to effectuate a transfer of funds but in doing so the degree of granularity of the shared information may violate a security policy anti purpose e.g. I would like to pay my bills but I don t want the payee to know my account balance or have the right to change the dollar amount. As another example a high resolution GPS Global Positioning System location of an asset may need to be used by a security vetted domain to achieve a defined purpose but in doing so the required amount of detail of the shared location information may violate a security policy anti purpose of the domain e.g. I would like certain trusted people to know the specific location of the asset . . . but other people do not need to know exactly where it is located. In this case the disclosed domain manager subsystem may restrict access to or downgrade the GPS data provided to other domains while the domain requiring higher resolution location information is activated.

Some embodiments of the disclosed architectures and subsystems are embodied in a context aware device e.g. a mobile device equipped with one or more environment sensors such as a GPS accelerometer and or others . Such embodiments can extend a MILS based architecture by enabling semi dynamic provisioning implementations in the context aware device. For example the various subsystems can alone or in combination manage and enforce the embedded policy and purpose rule sets of isolated distributed architectural domains and other components that are designed for specific purposes. Such policies purposes rule sets may be statically pre defined e.g. as information flow control channels between isolated MILS based components. As used herein terms such as policy and purpose rule sets may refer to among other things an expression of enforcement monitoring and or other capabilities that are needed on the computing device platform to ensure that the computing device platform or a component thereof operates according to a defined purpose and does not perform the associated anti purpose. For example a purpose rule set may define criteria for sharing and or protecting information and or components of the computing device under various conditions and contexts. The purpose rule set may be implemented for example as a set of rules instructions data values parameters or a combination thereof which may be stored in computer memory in for example a database or table.

In some embodiments one or more security keys used by the secure boot logic and or other modules may be stored in the firmware device . The security keys may include for example one or more public keys used in a digital signature scheme which may be employed to authenticate one or more integrity parameters . The integrity parameters may include trusted block device hashes which may be computed at initial installation of a software module by a trusted party. The integrity parameters may also include current block device hashes that are computed during use of the computing device platform e.g. at software load time. More generally the integrity parameters can include or reference information such as hash values that can be evaluated by the secure boot logic and or other modules to check the integrity of executable components of the computing device platform including but not limited to the component provisioning subsystem at load time or at run time. The integrity parameters and the use thereof by the computing device platform are described in more detail in Oberg et al. U.S. patent application Ser. No. 13 872 865.

Each or any of the disclosed subsystems of the trusted computing base may be embodied as a suite of software components such as API Application Programming Interface extensions. However some embodiments extend beyond software only implementations. For example some embodiments enable policy or purpose based component controls in systems that are designed with advanced materials in which physical properties are modified in specific contexts such as temperature radio frequency RF fields electro magnetic fields and or others. In some instances the physical properties themselves may be a realization of a physics based embedded policy designed for a specific purpose. Where an anti purpose would otherwise result embodiments of the disclosed architectures may deny access by the component to selected parts of the system. For example component based power control can in itself be a realization of the MILS based isolation policy. As such powering down a GPS or radio receiver is one form of isolation. Thus in some cases each or any of the disclosed subsystems of the trusted computing base alone or in combination with other subsystems of the trusted computing base may be used to implement low level resource management e.g. device management that extends beyond the software application layer to hardware firmware layers and other similar concepts where low level control of system components can achieve a desired purpose and deny the anti purpose. 

The illustrative computing device platform includes at least one central processing unit or processor e.g. a microprocessor microcontroller digital signal processor etc. memory trusted protected memory and an input output I O subsystem . In the illustrated embodiment the processor s include a baseband processor and an applications processor . In various embodiments features of the baseband processor and the applications processor may be located on the same or different hardware devices e.g. a common substrate . In general the baseband processor interfaces with other components of the device platform and or external components to provide among other things wireless communication services such as cellular BLUETOOTH WLAN and or other services. In general the applications processor handles processing required by software and firmware applications running on the computing device platform as well as interfacing with various sensors and or other system resources . However it should be understood that features typically handled by the baseband processor may be handled by the applications processor and vice versa in some embodiments.

The processor s and the I O subsystem are communicatively coupled to the memory and the trusted protected memory . The memory and the trusted protected memory may be embodied as any type of suitable computer memory device e.g. volatile memory such as various forms of random access memory . More specifically the illustrative trusted protected memory is configured to provide component isolation in accordance with the MILS based techniques as described in more detail below with reference to .

The I O subsystem may include among other things an I O controller a memory controller and one or more I O ports. In some embodiments the I O subsystem may form a portion of a system on a chip SoC and be incorporated along with the processor s and other components of the computing device platform on a single integrated circuit chip. As such each or any of the components coupled to the I O subsystem may be located on a common integrated circuit chip in some embodiments.

The illustrative I O subsystem is communicatively coupled to a number of hardware firmware and software components including a firmware device a number of executable modules a number of user interface devices e.g. a touchscreen keyboard virtual keypad microphone etc. one or more sensors e.g. optical sensors motion sensors location sensors global positioning system GPS receivers digital cameras and the like controllers e.g. memory controllers I O controllers network interface controllers graphics controllers etc. other peripheral devices e.g. cameras audio recorders modems data storage interfaces displays speakers and other peripheral devices the communication subsystem a virtualization service a power supply e.g. a battery and or power management unit one or more data storage devices and one or more software module management services . Illustratively integrity parameters and purpose trust tokens described below are embodied at least temporarily in the data storage device however it should be understood that other data components may at least temporarily reside in the data storage device alternatively or in addition. The illustrative firmware device is embodied as a persistent storage device such as a non volatile or read only memory device e.g. NAND or NOR flash memory . In the illustrative embodiments the firmware device stores secure boot logic . The secure boot logic includes the set of computer routines commonly known as for example the bootloader Unified Extensible Firmware Interface UEFI or Basic Input Output System BIOS . The secure boot logic enables the computing device platform to start its operation once electrical power to the device is switched on or to restart its operation in response to a user command. In some embodiments e.g. traditional system architectures the secure boot logic loads and starts an operating system and communicates with the various other components and devices that are coupled to the I O subsystem . In the illustrative virtualized mobile device architecture however the secure boot logic loads and starts the virtualization service directly from the firmware device independently of or prior to launching any operating systems. As used herein operating system may refer to among other things traditional desktop or laptop operating systems mobile device operating systems network operating systems real time operating systems RTOS which may be used to control for example unmanned or driverless vehicles safety critical systems such as insulin pumps and other medical devices and or others.

In the illustrative computing platform depicted by the modules include shared modular security services and other shared modular services that together with the virtualization service form the trusted computing base TCB . The shared security services illustratively include an integrity verification subsystem the component provisioning subsystem a policy arbitration subsystem and a domain manager subsystem . The shared security services are described in more detail with reference to . The other shared services include system level services such as device drivers which are in more traditional system architectures typically provided by the operating system kernel. As used herein shared service may refer to a firmware or software based executable module that allows operating systems and other executable applications and processes to interface with the shared system resources of the computing device platform which may include for example physical or hardware resources such as one or more of the processors memory memory I O subsystem and or any of the devices and components that are coupled to the I O subsystem whether such components are coupled directly e.g. via bus or over a network.

In the illustrative device platform the shared services are virtualized at the module level so that in a given virtualized execution environment of the computing device platform the shared services each map to a corresponding system resource. For example some of the shared services may be embodied as device drivers that each map to a physical device driver for a different hardware component of the computing device platform . By modularizing and isolating the shared services independently of any particular component or domain access to the shared resources of the computing device platform can be monitored controlled and restricted at the module level. In general the modules are illustrated as such for discussion purposes and such illustration is not intended to imply that any specific implementation details are required. For example any of the modules may be combined or divided into submodules subprocesses or other units of computer code or data as may be required by a particular design or implementation of the computing device platform .

In the domain specifications represent runtime specifications for individual specially partitioned execution environments that can be executed by the virtualization service during operation of the computing device platform . As used herein domain may be used to refer to among other things a machine executable unit that can request access to one or more system resources where such accesses can be controlled by the trusted computing base e.g. by the policy arbitration subsystem . For example some domains may be embodied as very small specialized functional units. Additionally each of the individual security services and or shared services may be embodied as domains in some cases. Other domains may be embodied as user domains through which a person such as an end user may interact with the computing device platform . The domains are examples of user domains as explained further below.

The domain specifications for each domain specify one or more executable modules that are permitted to execute in the domain to request access to one or more shared system resources . For example the domain specifications for each user domain may specify user level software that is permitted to execute in the user domain. The user level software includes for example an operating system and one or more user level software applications. Thus with respect to the domain specifications the term modules may refer to module or modules e.g. the user level software that is associated with the domain specification rather than the specification itself. Each domain specification may define a different purpose or personality of the computing device platform as may be needed or desired depending on the particular design purpose or usage context of the computing device platform . Moreover individual components within a domain may separately and or independently establish different purposes that govern their operation and use in different contexts.

The domains are examples of components that may be provisioned by the component provisioning subsystem for use on the computing device platform and or computing system . Other examples of components include individual user level or system level software applications firmware hardware and or combinations thereof. In some embodiments the component provisioning subsystem manages component specific purposes and associated rule sets during operation and use of the components on the computing device platform such that the individual components can operate without a priori knowledge of other components purposes and or policies rule sets. In doing so embodiments of the component provisioning subsystem can manage individual component purposes without changing or adversely affecting the enforcement of the purposes of other components. As a result each component s purpose can be enabled while the anti purpose is reliably denied independently of the purposes of other components of the device platform . Moreover some embodiments have the flexibility to enable the component specific purposes and deny the corresponding anti purposes in specific contexts as detected by a context aware platform. In these and other ways it can be said that aspects of the disclosed component provisioning subsystem can independently component provision and control the behavior and activities of specific components of a device without managing the entire device.

To address these issues in some embodiments the disclosed policy arbitration subsystem manages the policies of all executable components of the computing device such that the individual components can operate without a priori knowledge of other components policies. In doing so embodiments of the disclosed policy arbitration subsystem can manage each domain s policy without changing or adversely affecting the enforcement of the policies of other domains. As a result each domain s purpose can be enabled while the anti purpose is reliably denied. Moreover some embodiments have the flexibility to enable the purpose and deny the anti purpose in specific contexts detected by a context aware platform using a semi dynamic policy arbitration suite as described in more detail below. In these and other ways it can be said that aspects of the disclosed policy arbitration subsystem can independently control the behavior and activities of specific components of a device without managing the entire device.

Referring to a policy manager of the disclosed policy arbitration subsystem is charged with executing and enforcing all of the disparate domain policies of all of the existing domains that are provisioned on the device during operation and use of the device. To do this in some embodiments the policy arbitration subsystem or more particularly the policy arbitrator acts as a supervisory or higher privileged authority with respect to the domains and the policy arbitration subsystem assumes that all of the domains that are provisioned on the device are peers to one another. In these embodiments no domain s policy has a higher priority than any other domain s policy from the standpoint of the policy arbitration subsystem and it is the policy arbitration subsystem s job to ensure that the domain specific policies are properly reconciled and collectively enforced on the device.

In some embodiments policy artifacts discussed below are only known to the issuing domain and the policy arbitration subsystem . That is using the isolation strategies described herein the domain specific policies can be kept confidential from other domains. In some cases the submission of a policy artifact by a domain to the policy arbitration subsystem and the acceptance of the submitted policy by the policy arbitration subsystem creates a form of a social contract or mutual agreement between the domain and the corresponding set of respective stakeholders that created the policy artifact and the policy arbitration subsystem that in exchange for the assurance provided by the policy arbitration subsystem that the domain s policy will be reliably enforced in all relevant contexts the domain cedes control of the enforcement of its policy to the policy arbitration subsystem .

As described in more detail below the trusted computing base e.g. the policy arbitration subsystem alone or in combination with other subsystems of the trusted computing base can adapt or extend static domain policies to a multiple domain environment in which different domains execute independently of one another and execute independently of the policy arbitration subsystem . In some cases the domains may be configured and provisioned by different entities or stakeholders e.g. outside agents such as application service providers or third party MDM providers . As such or for other reasons each of the domains may have its own policy or set of policies that are applicable only to that particular domain and not to other domains. Thus in many cases each of the domains may be internally unaware of the policies of the other domains and may even be unaware of other domains that exist on the computing device platform . Accordingly the policy arbitration subsystem acts as a mediator in that it resolves conflicts between domain specific policies at the global device level and controls access to the system resources by the domains in accordance with the domain specific policies as reconciled at the global device level.

In the illustration of the other shared services include executing instances of a block storage subsystem a sensor subsystem a communication subsystem and a user interface device subsystem . Other system services such as audit services encryption services and or many others may be similarly modularized and virtualized although not specifically shown. The illustrative shared services are both memory isolated and process isolated from the domains which as illustrated include at least a domain 1 and a domain N . Additionally the domains are both memory isolated and process isolated from each other and from the executing instances of the components of the trusted computing base. As such the illustrative domains are independently executable and independently controllable by the trusted computing base or more specifically by the virtualization service interacting with the share security services and with the other shared services . While only two domains are shown in the illustration it should be understood that the computing device platform may support any number N of domains according to the requirements of a particular design of the computing device platform .

The illustrative virtualization service is embodied as a type of hypervisor or separation kernel system e.g. with paravirtualized guest operating systems or with hardware based virtualization extensions which is launched by the secure boot logic directly from the firmware rather than by another operating system. For example the virtualization service may be embodied as a thin hypervisor which may refer to a type of hypervisor that is designed to be small in the sense that only the core functions that are needed to establish virtualization on the computing device platform are included in the hypervisor. For example in the illustrative embodiment many if not all of the shared services are not built into the hypervisor but operate at a level of abstraction above the hypervisor e.g. as middleware . In some embodiments some components of the shared services are built into the hypervisor e.g. communication channels which allow the secure connection between two components modules domains .

In some embodiments however the virtualization service may include a more traditional hypervisor virtual machine manager VMM or similar virtualization platform. In some embodiments the virtualization service may be embodied as a bare metal hypervisor which can execute directly from the system hardware e.g. by a communication subsystem rather than the secure boot logic or an operating system .

In general the virtualization service is embodied as a privileged software component that facilitates and manages the virtualization of the shared resources of the computing device platform . In some embodiments portions of the virtualization service may be firmware based rather than software based. The virtualization service allows the domains defined by the domain specifications to execute concurrently or serially on the computing device platform in isolated virtualized execution environments. To increase the strength of the social contract or for other reasons some embodiments may utilize a priority based schedule to ensure triggers and other event based policy control subsystems are processed first and or exclusively e.g. to reduce or eliminate the security vulnerability during the small gap between an event triggering and the resulting action to be performed.

As mentioned above in the illustrative embodiments the virtualization service is launched directly by the secure boot logic rather than by an operating system. In other embodiments e.g. traditional system architectures the virtualization service may be launched by an operating system or by system hardware e.g. a communication subsystem . In any case the virtualization service executes in a higher privileged system mode of the computing device platform as opposed to a lesser privileged mode. As such in operation the virtualization service may have substantially full control of the system resources of the computing device platform . Further the other components of the trusted computing base e.g. the shared security services and the other shared services may when called upon by the virtualization service also have substantially full control of one or more of the system resources of the computing device platform with which they are designed to communicate. That is due to their modularity the shared services may each be capable of controlling only a specific resource or a specific feature of a resource of the computing device platform in some embodiments. In some embodiments the modularized control of the system resources by the trusted computing base is aided by the use of well defined communication channels as described herein.

Referring now to an embodiment of a modular virtualized execution environment that may be established on the computing device platform is shown. At runtime an executing instance of the virtualization service interfaces with the system resources e.g. processor s memory I O subsystem and or devices through one or more submodules or subprocesses referred to herein as a memory manager and a process scheduler which are also part of the trusted computing base . The memory manager allocates virtual memory to each of the executing instances of the domains and shared services that corresponds to their respective assigned physical memory e.g. trusted protected memory so as to implement and maintain the memory isolation technology described herein. The individual instances of the domains and shared services and or individual executing components thereof may be referred to herein as components for ease of discussion. The process scheduler schedules and regulates communications between the components and the virtualization service over the well defined communication channels as described herein so as to implement and maintain the process isolation technology described herein.

Referring now to an embodiment of the memory isolation features of the illustrative device platform is shown. The computing device platform includes physical memory e.g. trusted protected memory which is abstracted to virtual memory by the virtualization service . The physical memory includes a number of physical address spaces . When the physical memory resources are virtualized by the virtualization service in conjunction with a modular shared service in some embodiments the components are each mapped to separate isolated portions of the physical memory . The assignment of physical memory address spaces to components e.g. shared services security services domains and the assignment of security labels to memory addresses may be performed at the time that the computing device platform is created and provisioned e.g. by an original equipment manufacturer OEM or dynamically created e.g. via a Trusted Platform Management TPM for example. In some embodiments unique security labels may be associated with each of the memory addresses to facilitate the security features provided by the security services . For example the policy arbitration subsystem may use such security labels to determine whether to permit a domain to perform a read or write memory access to a portion of the physical memory .

Referring now to a simplified example of the process isolation or information flow isolation features of the illustrative device platform is shown. illustrates a MILS based embodiment comprising architectural components e.g. components and explicitly defined interactions between the components e.g. arrows where the presence or absence of an arrow is significant e.g. the absence of an arrow indicates the absence of a communication channel . The bidirectional arrows each represent a well defined communication channel that may be unidirectional for some domains or shared services and bidirectional for other domains or shared services depending upon the applicable security policy. As used herein well defined refers to a communication channel e.g. any suitable type of wired wireless or logical signal path that only has two possible endpoints e.g. a source and destination or vice versa and cannot be modified by any domains or shared services . For instance in some embodiments hardware restrictions may be provided by a computing device s original hardware design e.g. an I2C bus layout or intra bus connects within an SoC . In the context of software virtualization of a communication bus a privileged controller e.g. a hypervisor supervising single service access to an approved hardware resource can restrict access to a communication channel by different users e.g. domains services rather than designing the device hardware to include additional buses for each special purpose channel e.g. lx physical bus per virtualized service . In other words the well defined communication channels may be embodied as for example hypervisor supervised secure multiplexed communications over a single bus physical transport or as multiple independent buses that each ensure singleton security.

Thus in the embodiment of each of the domains can only access the system resources through the respective defined communication channels and can only do so through the virtualization service and shared services . However the arrangement shown in is by no means the only possible arrangement of communication channels. For example in other embodiments the domains may communicate with the shared services through the policy arbitration subsystem e.g. communications may be monitored by the policy arbitration subsystem for policy compliance . Further it should be understood that similar communication channels exist between components of the modular security services and other shared services even though not explicitly shown in the drawings.

Unique security labels may be programmatically associated with each of the well defined communication channels so that the components of the trusted computing base can monitor communications that are sent between the different components e.g. domains and shared services of the computing device platform . For instance the policy arbitration subsystem can mediate the communications that occur over the channels according to applicable policies in accordance with the requirements of the computing device platform . The assignment of communication channels to the components and the assignment of security labels to communication channels may be performed at the time that the computing device platform is designed and or provisioned e.g. by an original equipment manufacturer or OEM . For example the communication channels may be established at or around the time that the memory partitions for the domains and shared services are created.

Some embodiments of the illustrative device platform are modularized in the sense that at runtime each of the running instances of the domains defined by the domain specifications as well as the components of the trusted computing base are both memory isolated e.g. data separation and process isolated e.g. information flow control from one another. To do this as illustrated by at installation time the shared services shared security services domains and the virtualization service are each allocated and assigned to their own address space in physical memory e.g. block storage . Further as illustrated by and described below only well defined e.g. by static firmware enforced or physical hardware restrictions communication channels exist between the modules and the virtualization service so that module communications can be tightly controlled according to the requirements of the current configuration of the computing device platform . As such in some embodiments the modular virtualized architecture described herein represents an application of certain aspects of the MILS architecture mentioned above.

The illustrative data storage device is embodied as persistent physical storage e.g. as a block device which can read and write data in blocks having a fixed or nominal size e.g. 512 bytes or a multiple thereof . As such the data storage may include one or more hard drives optical drives e.g. CD or DVD ROM compact flash memory e.g. memory sticks or memory cards and or other such devices.

In some embodiments the integrity parameters used by the secure boot logic and or other modules are stored at least temporarily in the data storage . In some embodiments portions of the security keys the virtualization service and or the modules may reside at least temporarily in the data storage as well. Portions of the security keys any of the modules the virtualization service and or the integrity parameters may be copied to the memory during operation of the computing device platform for faster processing or other reasons.

As noted above the communication subsystem may communicatively couple the computing device platform to other computing devices and or systems by for example a cellular network a local area network wide area network e.g. Wi Fi personal cloud virtual personal network e.g. VPN enterprise cloud public cloud Ethernet and or public network such as the Internet. For instance any or all of the various subsystems of the trusted computing base may be used in the context of cloud virtualized services in some embodiments. The communication subsystem may alternatively or in addition enable shorter range wireless communications between the computing device platform and other computing devices using for example BLUETOOTH and or Near Field Communication NFC technology. Accordingly the communication subsystem may include one or more optical wired and or wireless network interface subsystems cards adapters or other devices as may be needed pursuant to the specifications and or design of the particular computing device platform .

As shown in the illustrative communication subsystem includes one or more telephony subsystems which enable the computing device platform to provide telecommunications services e.g. via the baseband processor . The telephony subsystem s generally include a longer range wireless transceiver such as a radio frequency RF transceiver and other associated hardware e.g. amplifiers etc. . To provide voice communication services the telephony subsystem may include an audio subsystem which may include for example an audio CODEC one or more microphones and one or more speakers and headphone jacks. In some embodiments other wireless communication subsystems e.g. Ethernet BLUETOOTH wireless LAN WLAN etc. and or other services e.g. GPS may interface with the baseband processor alternatively or in addition to the applications processor .

The computing device platform may include other components sub components and devices not illustrated in for clarity of the description. In general the components of the computing device platform are communicatively coupled as shown in by electronic signal paths which may be embodied as any type of wired or wireless signal paths capable of facilitating communication between the respective devices and components.

The software module management service s may include for example third party platform management services e.g. MDM services or similar services that may be in communication with the computing device platform over a network or a variety of different types of networks and communication media via the communication subsystem . Such services may be used to for example develop manage and implement security policies for the computing device platform such as enterprise security policies or mobile device BYOD bring your own device policies.

The illustrative domain manager subsystem represents an executing instance of the domain manager subsystem which defines rules and specifications for and in operation controls and manages the initialization execution activation and deactivation of the domains globally e.g. at the computing device level. An illustrative example of the domain manager subsystem is described in more detail in the aforementioned related application Saidi et al. U.S. application Ser. No. 14 052 169.

The domain manager subsystem can switch operation of the computing device platform from a highly sensitive domain e.g. an enterprise domain to a less sensitive domain e.g. a personal social use domain or vice versa in response to a triggering event e.g. dynamically or in real time . Such a triggering event may include for example the receipt of user input such as tactile or speech input a gesture a specific software command or a user name and password. The detection of certain inputs from one or more of the sensors may also act as a triggering event. For example if the computing device platform detects based on sensor data that the user has entered a highly secure geographic area such as a corporate office or a research facility the domain manager subsystem may autonomously e.g. without requiring any user input disable the user s access to any less secure domains and only permit the user to access a highly secure domain on the computing device platform .

Using these technologies the virtualization service in conjunction with the shared services controls the use and sharing of the various system resources by the domains according to the security policies or requirements of the computing device platform . For instance the trusted computing base can mediate software module communications so that the system resources may each be accessed and used by only one of the domains at any given time. As an example if the user of the computing device platform is operating in an enterprise user domain and the user is a lawyer recording a deposition or a police officer videotaping a crime scene the trusted computing base can ensure that while the enterprise domain is using the device s camera the camera cannot be accessed by the user s personal user domain e.g. to take pictures or video.

Virtualized software services may be provided by any virtual service provider such as those to which the policy arbitration subsystem can control access including local software or hardware services e.g. encryption services network access touchscreen display audio input or output etc. . At runtime the virtualization service communicates with the virtual service provider modules that are embedded in the shared services and the virtual service enabler modules that are embedded in the domains respectively. The virtual service providers translate and map the virtualized operations of their respective shared service to its physical counterparts in order to provide access to a corresponding system resource to e.g. a domain . Similarly the virtual service enablers translate and map the virtualized operations of their respective domains to enable the domains to utilize or consume system resources to which access is provided by the service providers . Together the virtualization service the modularized virtual service providers and the modularized virtual service enablers provide a level of abstraction between the components e.g. each of the domains and the shared services and the system resources . In other words the virtualization service the virtual service providers and the virtual service enablers provide e.g. hardware abstractions of some or all of the system resources for each of the domains and the shared services . As shown by and described in more detail below the policy arbitration subsystem alone or in conjunction with other modular security services oversees the communications between the virtual service providers the virtual service enablers and the system resources through the virtualization service .

In the example execution environment of the trusted computing base which generally operates in the privileged mode of the computing device platform includes the executing instance of the virtualization service and the executing instances of the shared services . In some embodiments the privileged shared services are implemented as middleware that interfaces with the virtualization service to control and manage the execution of the various domains . The shared services include the executing instances of the modular shared security services and the other shared services .

The other shared services communicate with the virtualization service through a respective virtual service provider to provide their respective hardware abstractions in a modular way. For instance the block storage subsystem virtualizes the I O communications with block storage devices such as the firmware or data storage . The block storage subsystem thereby acts as a virtual device driver service that can be called upon by other modules of the trusted computing base or by the domains through the virtualization service to move data out of block storage and into random access memory or vice versa. As an example the integrity verification subsystem may through the virtualization service communicate with the block storage subsystem to obtain one or more of the integrity parameters .

The sensor subsystem the communication subsystem and the user interface device subsystem operate similarly in that they provide access to their respective system resources through modularized abstractions e.g. virtual drivers . For example the domain manager subsystem may obtain sensor data from the sensor subsystem through its interface with the virtualization service and the virtual service provider . As another example the integrity verification subsystem may send integrity data e.g. an indication of whether a particular software module passed or failed an integrity check to a mobile device management system by interfacing with the virtualization service and the virtual service provider . Through this modularization of the system architecture and the isolation techniques described herein embodiments of the computing device platform can confine security issues to the components and or system resources that may be affected.

In the illustrative execution environment the domains are embodied as user domains that execute as guests of the virtualization service . That is the user domains execute in a lower privileged mode as to not be able to bypass or reconfigure the memory or process isolation provided by the virtualization service . As a result the domains are lesser privileged execution environments than that provided by the higher privileged virtualization service . The operating systems and software applications executing in each of the domains may be the same or different. For instance in some embodiments the domain may execute the ANDROID operating system while the domain may execute the QNX operating system or the domains may execute different versions of the same operating system. As another example the domain may execute a self contained e mail program and a web browser without a typical operating system while the domain may execute an electronic medical records system but not e mail or web browser applications.

The illustrative security services operate independently but in conjunction with one another and with the other shared services and the virtualization service to provide security features for the various domains running on the computing device platform . For instance the integrity verification subsystem may be called upon by the virtualization service to check the integrity of a module or component of the computing device platform e.g. at load time or at run time and or in response to a triggering event. An illustrative example of the integrity verification subsystem is described in the aforementioned Oberg et al. U.S. patent application Ser. No. 13 872 865.

The illustrative provisioning subsystem represents an executing instance of the component provisioning subsystem which defines verifies and maintains the component configuration for the device and each of the individual domains according to component specific purposes. An illustrative example of the component provisioning subsystem is described in more detail below with reference to .

The illustrative policy arbitration subsystem represents an executing instance of the policy arbitration subsystem which among other things defines the protocols for and in operation regulates the electronic communications between the domains and the virtualization service . The policy arbitration subsystem alone or in combination with one or more of the shared services mediates these communications in accordance with security policies that may be specifically applicable to the individual domains . An illustrative example of the policy arbitration subsystem is described in the aforementioned Forsberg et al. U.S. patent application Ser. No. 14 052 080.

The methods and processes disclosed herein and illustrated in the drawings are simplified for discussion purposes but it should be understood that the device platform and or the computing system may undertake any of the disclosed methods or processes concurrently or in parallel e.g. for each of the executing domains . For example the device platform and or the computing system may perform an analysis of any policy artifacts domain triggered events and or event triggers that it receives from any or all of the domains in whatever order or sequence they may occur.

In some embodiments communication channels similar to those shown in described above are defined between the domains and the component provisioning subsystem so that communications such as various event triggers can only be sent from the domains to the trusted computing base or subsystems thereof over the defined communication channels and the triggers cannot be sent from the domains directly to any of the system resources that is without going through the trusted computing base . In this way the configuration of communication channels enables the subsystems of the trusted computing base to act as intermediaries to for example prevent event triggers which may have been initiated by potentially untrusted or assumed untrusted domains from reaching the system resources without the proper vetting which may be performed by the component provisioning subsystem and or other components of the trusted computing base .

Portions of this disclosure describe embodiments that are adapted for use on a mobile computing platform that has a modular virtualized system architecture. Some embodiments of modular virtualized mobile computing platforms can be configured with multiple user level execution environments each of which may be tailored for a different use or application of the mobile device. A mobile platform designed with such an architecture can for example address security issues that commonly arise when personal mobile devices are used for business purposes or vice versa. Nonetheless it should be appreciated that the disclosed approach is not limited to virtualized mobile platforms rather aspects of the disclosed approach can be used in traditional and or virtualized platforms to for example extend a static global policy to a more flexible implementation in which multiple independent and potentially conflicting component specific policies can be mitigated using a variety of techniques.

Referring now to an embodiment of an integrity verification process for the computing device platform is shown. As discussed above embodiments of the computing device platform have a privileged or system mode and a non privileged or user mode . At least the secure boot logic executes in the privileged mode . In the illustrative embodiments the virtualization service and the shared services also execute in the privileged mode while the user domains execute in the non privileged mode . Illustratively the operation of the computing device platform is divided into phases a pre boot phase a boot phase a load time phase and a run time phase .

The pre boot phase occurs just after the computing device platform is powered on and is executed by the processor . The integrity of the secure boot logic which may be embodied as a chain of bootloaders where each bootloader stage verifies a subsequent link is verified during the pre boot phase as shown by step . To do this the processor may use a security key to verify a digital signature of the next stage boot image. For example a public key stored in SoC ROM may used to verify the digital signature of a subsequent boot image where the digital signature has been previously generated by the corresponding private key . As used herein boot image refers generally to a computer file that contains the system components that are needed in order for the processor to boot the computing device platform . For example the secure boot logic and or portions of the virtualization service and shared services may be part of the boot image in some embodiments.

The boot image may be created and written to the firmware device at the time that the computing device platform is made or provisioned e.g. by an OEM . The security key may be a public key of a digital signature scheme that is also written into the firmware device by the manufacturer of the SoC or the computing device platform or another certifying authority. As used herein digital signature refers to a mathematical scheme that can be used to demonstrate the authenticity of a computer file. In general a signing algorithm is used to create the digital signature based on the computer file and a private security key which should be kept secret by the certifying authority . A verifying algorithm can then be used to verify the digital signature based on the digital signature and a public key. Some examples of digital signature schemes include the RSA Rivest Shamir Adleman algorithm and hash trees tree data structures in which each non leaf node is labeled with the hash of the labels of its child nodes .

A hash of the boot image rather than the boot image itself may be used as input to the signing algorithm to create the digital signature. For example the OEM or other certifying authority may generate a hash tree of the known good boot image where each leaf of the hash tree includes a hash of a block of the boot image and then digitally sign the hash tree. Any suitable hash algorithm including cryptographic hash functions like SHA 1 MD5 SHA e.g. SHA 256 and SHA 512 or other secure hash algorithms may be used to generate the hash tree for the boot image.

The digitally signed hash tree can be used to verify that the boot image was created by a known party and that the boot image has not been altered since its original creation. The processor can thus verify the authenticity of the secure boot logic using the public key and the verifying algorithm of the digital signature scheme. The processor can verify the integrity of the secure boot logic by comparing the hash of the secure boot logic or one or more blocks thereof to the corresponding value s in the hash tree. Any difference between the known good version of the boot image and the current version of the boot image will cause the corresponding hash values to differ and will thus cause the comparison to fail. If the integrity of the secure boot logic is confirmed the processor executes the secure boot logic .

The secure boot logic verifies the integrity of the virtualization service in a similar way. That is the secure boot logic compares a hash value generated from one or more blocks of the virtualization service to the corresponding hash value in the hash tree of the verified boot image. If the secure boot logic is able to successfully verify the integrity of the virtualization service the secure boot logic starts up the virtualization service thereby initiating the boot phase of the computing device platform . If the integrity check of either the secure boot logic or the virtualization service fails the computing device platform will not boot successfully.

Once verified and booted the executing instance of the virtualization service performs an integrity check of the integrity verification subsystem in a similar way at step . That is the virtualization service hashes or obtains a hash value for one or more blocks of the integrity verification subsystem and compares the current hash values to the trusted hash values stored in the corresponding leafs of the hash tree of the verified boot image. Alternatively or in addition a modular service such as the block storage subsystem may compute the current hash values of one or more blocks of the integrity verification service as the blocks are loaded from persistent storage into memory and provide the current hash values to the integrity verification subsystem .

If the integrity check of the integrity verification subsystem fails the virtualization service may respond in accordance with the applicable security policy. For example the virtualization service may display a message on a user interface device e.g. a display of the computing device platform to inform the user that the integrity check failed and ask if the user wishes to continue booting the computing device platform . As another example the virtualization service may continue booting the device platform but allow only certain domains or portions thereof to boot e.g. domains or applications executable therein that are not considered essential to the security of the computing device platform .

If the integrity check of the integrity verification service is successful the integrity verification service may be launched by the virtualization service . Depending on the applicable security policy for the device platform and or the domains the integrity verification service may perform an integrity check each time a software module is loaded into memory or may perform integrity checks only for certain software modules or types of software modules or may perform integrity checks in response to certain triggering events either during load time or run time of a software module. For instance the loading of a software module from persistent storage into memory may act as a triggering event step in some cases. In some embodiments a message received by the virtualization service from a mobile device management service or other software module management service step may trigger an integrity check. For example the computing device platform may receive a mobile device management command from a mobile device management service and initiate an integrity check in response to such command. During run time certain system level commands executed by the software module may trigger an integrity check. As an example if a software module attempts to send data off of the mobile computing device or access a suspicious web site such activity may trigger an integrity check.

The integrity verification service performs the integrity checks in a similar manner as described above and in more detail below with reference to . The integrity verification service may report the results of its integrity checks to for example one or more of the software module management services step . Such services may include for example third party mobile device management services and or similar services. In some embodiments software module management services may be embodied as portions of the virtualization service and or other services of the trusted computing base of the computing device platform . In any case a software module management service may determine how to respond to the results of the integrity check and provide instructions to the virtualization service or the integrity verification subsystem accordingly. In other embodiments the integrity verification service itself may contain such logic. For instance either the integrity verification service or the software module management service may initiate the execution of an integrity checked software module step if the integrity check is successful or in some cases even if the integrity check is not successful. For example depending upon the applicable security policy some software modules may be approved for execution even if their integrity check is unsuccessful. If it is determined e.g. by the integrity verification service or the software module management service that the integrity check failed and the software module should not be executed the integrity verification service may in conjunction with the user interface device subsystem in some embodiments inform the user by presenting a message on a user interface device fail to complete the load of the software module or take some other action consistent with the applicable security policy.

Referring now to an illustrative method for verifying the integrity of a software module is shown. The method may be embodied as computerized programs routines logic and or instructions which may be executed by the computing device platform e.g. by the integrity verification subsystem . At step the method monitors the execution environments of the computing device platform e.g. the domains for an event in response to which integrity verification is to be initiated. As discussed above the triggering event may include for example the loading of a software module or a specific type of software module into random access memory for execution the receipt of a message or command from a software module management service or another type of triggering event. In this way fine granularity integrity verification can be provided. That is the method can be selectively executed by the virtualization service or the integrity verification subsystem . For example in some embodiments the method may be executed only for selected security critical software components of the computing device platform or only for certain software components of a particular domain .

If the computing device platform detects a triggering event the method generates a current integrity parameter at step . The current integrity parameter is generated or derived from the software module that is the subject of the integrity check. For instance the current integrity parameter may include a hash value that is computed by applying a hash algorithm to one or more blocks of the software module to be verified. To do this the block s of the software module are used as input to a hash function and the resulting hash value s are used as the current integrity parameter. The hash function may be any of the cryptographic hash algorithms mentioned above or another type of hash function. In more detail at step a block address of a portion of the software module stored in a block device is obtained from e.g. the virtualization service or the block storage subsystem . At step the method obtains the hash value that corresponds to the block address obtained at step . In some embodiments the method may simply obtain the hash value from the block storage subsystem . The obtained hash value may be calculated when requested by the integrity verification subsystem e.g. on the fly or calculated opportunistically and cached when the block is read from persistent storage. Further highly optimized hardware that provides persistent block storage may calculate and store hashes so that negligible computational overhead is incurred. In other embodiments the method may read the portion of the software module stored at the block address into memory and compute the hash value at that time.

At step the method determines the trusted integrity parameter that corresponds to the same block of the software module as is used to determine the current integrity parameter at step . If the software module being integrity checked is part of the boot image the trusted integrity parameter may be determined from the hash tree of the boot image which is trusted due to its earlier integrity verification as described above with reference to step of . In some embodiments the trusted integrity parameter may be a digitally signed hash value that is created by the developer of the software module or another trusted party. In that case the signed hash value may be appended to the software file during transmission or download. The method may verify the digital signature associated with the hash value using for example a public key provided to the computing device platform at some earlier time by the software developer or another trusted party such as a mobile device manager service . It should be appreciated from the foregoing discussion that the modular system architecture of the computing device platform allows different portions of the boot image to be signed by different trusted parties during the provisioning of the computing device platform . Thus the security key may include a number of different security keys corresponding to the number of trusted parties providing components for the provisioning of the computing device platform .

At step the method compares the current integrity parameter to the trusted integrity parameter to determine whether the current version of the software module which is the subject of the current integrity check is the same as the trusted version of the same software module from which the trusted integrity parameter was generated. Of course this comparison assumes that the same hash algorithm is used to both create the trusted integrity parameter in the first place and to compute the current integrity parameter at a later time. In some embodiments the integrity parameters may be stored as binary hashes and compared for differences. In other embodiments the integrity parameters may be stored as ASCII encoded strings and a conventional string comparison function may be used. If the method determines that the integrity parameters do not match the method may conclude that the integrity check failed at step and proceed to step . If the method determines that the integrity parameters match the method may conclude at step that the integrity check was successful and proceed to step .

At step the method determines whether to verify another block of the current version of the software module that is the subject of the integrity check. To do this the method may consult an applicable security policy and or consider the software module type. For instance the method may perform integrity checks on multiple blocks of software modules that are considered important to the security of the computing device but only perform an integrity check on one or a small number of blocks for software modules that are considered less security critical or less of a security risk. If the method determines that an integrity check should be performed on another block of the software module being verified the method returns to step . In some embodiments where multiple blocks are integrity checked the hash values for the multiple blocks may be computed serially or in parallel and compared individually or as a set. Further where multiple blocks are integrity checked and not all of the blocks pass the integrity check the method may determine whether the software module passed or failed the integrity check based on an applicable security policy or set of security rules. At step the method communicates the integrity check results to the requesting process e.g. a software module management service and returns to step .

Embodiments of the above described integrity verification techniques can provide operating system independence and component specific event driven or on demand integrity verification that has many potential applications. For example some embodiments of the integrity verification service can be used by mobile device management services and other third parties for auditing purposes particular since they may do so without requiring direct software read access. Additionally using the foregoing approaches security critical software modules may be periodically integrity checked to for example detect sideloading or run time compromise attacks. Some examples of such security critical modules include for example software and firmware modules embedded in or installed on medical monitoring and sensing devices health monitoring devices unmanned vehicles and other remotely controlled devices to control the operation of such devices data acquisition by the devices and or other functions. Further software modules may be periodically checked to determine whether a software upgrade or other modification is needed.

As another example some versions of the integrity verification subsystem can be utilized by software application developers or application providers to check the integrity of their applications as a prerequisite or pre condition to their distribution. For instance application providers may require an integrity check prior to the release of digital media content or before enabling additional licensed features e.g. prior to releasing content governed by digital rights management DRM or other sensitive content or prior to unlocking advanced application capabilities or features . In some cases applications providers may wish to bundle content additional plug ins capabilities features or third party content licenses with a version of the integrity verification subsystem . A third party license agreement may restrict the usage of the content or features based on the agreement terms of use and the integrity verification subsystem may be used to enforce the contractual restrictions.

To further demonstrate this potential consider a media content provider application that provides streaming of multiple levels of inexpensive standard and premium content some of which may be advertisement subsidized subject to basic retransmission licensing or subject to per user view fees . The content provider may restrict the availability of certain features e.g. high definition unless various integrity assurances can be provided. As an example an application may permit multiple different levels of content streaming that are conditioned upon the successful completion of integrity checks initiated by the integrity verification subsystem . Some content may not be subject to any restrictions but other content e.g. premium or subscription based content may be only permitted to be streamed onto certain types of secure devices that have been updated with the latest patched software. In addition the content provider may desire to audit the full software stack of the computing device on demand if unusual streaming behavior is detected. Aspects of the integrity verification subsystem may be used for these and other purposes. For example application providers may wish to bundle the integrity verification service with their application as a means to ensure that the application is operating in compliance with the applicable terms of service and within the terms of third party licensing agreements.

The illustrative integrity verification subsystem which operates outside of the control of the operating system or other service that is being inspected to provide independent remote attestation is by no means limited to benefitting only mobile applications. Embodiments of the subsystem can be integrated into virtualized personal computer or server farm operating systems e.g. cloud based computing services . The integrity verification subsystem can be used to detect when a node e.g. a website host in a server farm cloud is compromised in a manner that alters content e.g. by the injection of malware .

In a similar manner any digital content perhaps in the form of software firmware upgrades and security patches audio video media etc. can be published and verified in a distributed cloud environment. In other words versions of the integrity verification subsystem can be integrated with distributed and virtualized services such as cloud networks. In such a scenario the integrity subsystem may publish the existing and or recently generated integrity parameters to a cloud based integrity service. The cloud based integrity service or more simply put an authorized software agent or computer program may perform integrity checks on content continually e.g. wherever and whenever the content is replicated in the cloud. The integrity verification subsystem may be configured to receive notifications from the integrity service whenever specific types of content are created by the user e.g. taking a picture recording notes etc. or when a file download occurs for example. The integrity verification subsystem may then generate or record the integrity parameters associated with the content i.e. integrity parameters generated at content creation or when the content is shared . If the integrity parameters are generated at the creation of the content the integrity verification service may check to make sure that the content did not change between the time of creation and the share event. Further when a user shares a piece of content the integrity verification subsystem may be notified e.g. by the content sharing service and in response to the notification the integrity verification subsystem may send the integrity parameters to an audit subsystem or relay the integrity parameters directly to interested consumers e.g. a cloud based content integrity parameter database that a cloud integrity subsystem uses to check the content stored on its cloud nodes .

An audit subsystem may publish specific integrity check results e.g. TWEETS or RETWEETS to a particular subscriber of the audit service. For instance in a messaging system like TWITTER an integrity check may be triggered in response to a TWEET or RETWEET of content and the result of the integrity check may be published to a cloud based integrity service that is designed to ensure that all nodes are replicating content without modifications. The cloud based integrity subsystem may alternatively or in addition periodically verify that content is replicated consistently across all nodes of the cloud service.

Additionally some versions of the integrity verification service may be used by everyday consumers to check the integrity of their own content and provide virtually irrefutable attestation of the content s author originator and the content s integrity as it is replicated across a distributed network. As an example a user of a social media application may take a picture or post a document and then select share on the content. Such content is often shared seamlessly with social or enterprise networks such as FACEBOOK TWITTER and GOOGLE as well as company intranets and community court records for example . While users typically need to enter a user name and password to use these applications the sites can be hacked and thus it can be difficult to determine whether the content share was actually performed by the user or by a hacker. In these cases the integrity verification subsystem may cooperate with an auditing subsystem to more or less simultaneously share the content ID and integrity parameters e.g. hashes with a cloud based audit network to create an independent integrity attestation of the content and its originator.

A user may also lease content to commercial content providers such as search engines and social networks and the integrity verification service may be used in this context as well. For instance if a user posts a video file to a social network the user may use the integrity verification service to periodically check the integrity of the video file. If the integrity check fails the user may revoke the lease or take some other action to protect the user from misrepresentation and liabilities if their content is altered. In some form this could allow for the remote attestation verification of published content advertisements TWEETS etc. across a decentralized and distributed hosting network.

Many computer security measures focus on the need to protect sensitive information from unauthorized uses without fully considering the affirmative need to use and share such information in appropriate circumstances. As the number and types of potential security breaches is large and always changing security measures are frequently over restrictive sometimes to the point of defeating the intended use or desired purpose of a computing device. Thus while such measures may initially give users some confidence in the security of the device the inability to accomplish desired objectives within the confines of the security protocol can lead to user frustration and even abandonment of the security scheme.

Moreover the traditional monolithic architecture of mobile devices typically requires the operating system and preloaded software stack to be provisioned as a whole. For example mobile devices are typically provisioned with a single operating system and a basic set of software applications including phone messaging calendar and email services. The end user and or an authorized third party is not able to re provision these base services or replace them with their own preferred services without jailbreaking or rooting the device which typically voids the manufacturer s warranty . Componentized provisioning techniques as disclosed herein can enable mobile devices and other computing platforms to be selectively provisioned component by component according to user defined component and or context specific purposes. As such individual components of the traditional monolithic software stacks can be separately and independently provisioned to individual hardware components or a set of hardware components either residing on the device or under its control.

As described in more detail below embodiments of the component provisioning subsystem as disclosed herein can separately and or independently provision different components of a computing platform or groups of components for different purposes or provision the same component for different purposes in different domains . In doing so embodiments of the component provisioning subsystem may provision a component or group of components to be used in accordance with a specified purpose and also expressly provision the component not to be used for a specified or derived anti purpose. In some cases the disclosed component provisioning subsystem can receive and implement rules for the use and sharing of specific component resources and such rules may be context dependent e.g. triggered by different operating contexts of the computing device platform . As used herein components may refer to among other things any provisionable operable or executable object or entity that may exist on the computing device platform . A provisionable component may include for example hardware software peripheral devices subsystems computer programming constructs and or others including sub components of vertical software stacks user installable components non user installable components components that communicate with other devices e.g. over a network and components that are controlled or executed by the baseband processor . Some provisionable components may create access operate on receive or transmit component resources. As used herein component resource may refer to among other things data instructions communications computer programming constructs or a combination thereof. As an example a banking application may be a component that accesses component resources e.g. user name password biometric identifier account number dollar amount etc. creates and transmits component resources e.g. balance inquiry transfer request etc. and receives and processes component resources e.g. account balance information transaction confirmation etc. .

In embodiments in which the computing device platform is configured as a multiple personality device having multiple independent execution environments or domains as described above the component provisioning subsystem as disclosed herein can separately and independently provision each domain and or separately and independently provision individual components within each domain according to one or more specified purposes. In doing so the component provisioning subsystem may allow permitted and unpermitted uses of components and component resources to be defined and enforced with a high degree of granularity thereby alleviating the potentially adverse effects of monolithic over restrictive security policies and other existing underspecified generalized e.g. monolithic device provisioning mechanisms. Additionally individual components can be provisioned differently for different domains . For example a banking application may be provisioned to allow the transfer of sensitive financial information to trusted external recipients in one domain but the same banking application may be provisioned only to allow the viewing of such information on the provisioned device in another domain where both domains are installed on the same device. In another representative example a health application may be provisioned to allow the transfer of sensitive Health Insurance Portability and Accountability Act HIPAA information to trusted external recipients in one domain but the same health application may be provisioned only to allow the viewing of such information on the provisioned device in another domain where both domains are installed on the same device.

Again referring to the illustrative component provisioning subsystem is embodied as software firmware hardware or a combination thereof to perform component provisioning services for a computing device platform . In some embodiments the component provisioning subsystem comprises a suite of computer programming constructs e.g. both on and off device. For example the component provisioning subsystem may define an application programming interface API or a suite of APIs or API extensions. The APIs may be implemented as a software library a software framework e.g. a collection of different software libraries implementing different APIs a protocol or set of protocols or another type of programming interface that allows computer programs to communicate with each other and with shared computing resources such as shared system resources . As noted above embodiments of the component provisioning subsystem or portions thereof may be implemented in or to control hardware components e.g. as physics based policies .

While not specifically shown in it should be understood that portions of the component provisioning subsystem can reside on other computing devices or computing systems in some embodiments as a distributed component provisioning system. For example a portion of the component provisioning subsystem may be local to the computing device platform while another portion may be distributed across one or more other computing systems or devices that are in communication with the computing device platform by one or more electronic communication networks via the communication subsystem for example. In other embodiments the component provisioning subsystem may be located entirely on the computing device platform .

Referring now to an embodiment of the illustrative component provisioning subsystem includes a number of computerized executable modules that in some embodiments may exist within an isolated domain e.g. APIs physics based controls software applications RTOS etc. as mentioned above and configured to develop and implement component specific purpose rule sets and component control as described in more detail below. The illustrative component provisioning subsystem is embodied as a component purpose provisioning module component purpose rule sets and a purpose enforcement engine . In some embodiments a purpose assistant interacts with the user to create a purpose trust token in response to a provisioning trigger such as the purchase or downloading of a new or updated component . The purpose assistant communicates the purpose trust token to the component purpose provisioning module . While shown as a module that is external to the component provisioning subsystem it should be understood that the purpose assistant may be incorporated as a part of the component provisioning subsystem in some embodiments. An embodiment of the purpose assistant is described in more detail below with reference to .

Operation of the component purpose provisioning module may be initiated or triggered by a provisioning trigger which may result in the generation of a new or updated purpose trust token or by another type of provisioning trigger . In general any event the response to which requires provisioning of a component of the computing device platform may operate as a provisioning trigger or may result in the generation of a purpose trust token . As noted above component provision or component provisioning may refer to among other things the process of installing and configuring a domain or other component on a device in a way that it can be used to handle and share component resources in conformity with the component s purpose which may be implemented as context and or resource specific rules.

As described in more detail below with reference to purpose trust tokens may be used to authenticate a component s purpose as specified by an owner of the component or a component resource handled thereby. As such purpose trust tokens may embody owner credentials as well as an associated component purpose rule set. In other words a purpose trust token may embody an owner specific rule set to govern the use operation and control of a component in accordance with the owner specified purpose. For example a banking application may be component provisioned on a device to allow the transfer of sensitive financial information to trusted external recipients in one domain but the same banking application may be component provisioned only to allow the viewing of such information on the provisioned device in another domain where both domains are installed on the same device. Potential owners of components and component resources include for example end users component providers mobility policies MDM services and recipients of component resources. Provisioning triggers may be similarly authenticated and may also include automated events such as the receipt of a new or updated application package identifier e.g. a Uniform Resource Locator URL or Uniform Resource Identifier URI from a remote source e.g. connected by a network or Uniform Serial Bus USB cable etc. .

In response to a purpose trust token or a provisioning trigger e.g. at initial boot or as needed at runtime the component purpose provisioning module undertakes to component provision the component associated with the purpose trust token or the provisioning trigger as the case may be in accordance with its defined purpose. The end result of such provisioning by the component purpose provisioning module is to establish a secure execution environment on the computing device platform for the execution of the component provisioned component which during use execution of the component enables the execution of system operations that are permitted by the component purpose and does not allow the execution of system operations that are not permitted by the component purpose or which fall within a defined anti purpose of the component .

The illustrative component purpose provisioning module includes an integrity ownership check module and an install update scheduler module . The integrity ownership check module verifies that a trusted boot of the platform the computing device platform has occurred. To do this at initial start up of the computing device platform the integrity ownership check module verifies the integrity of the components involved in the device boot up to and including the component provisioning subsystem . At start up and at runtime e.g. in response to a provisioning trigger the integrity ownership check module verifies the integrity of the component and any or all of the component s specified dependent and related subsystems shared services modules components before the component is provisioned on the computing device platform . An example of a dependent subsystem of a provisionable component may be a media application e.g. NETFLIX ITUNES etc. that specifies in its component provisioning configuration that an operating system cipher or software media decoding libraries have not been unaltered from the firmware default configuration e.g. at boot . In this example the OS cipher and software media decoding libraries would be the dependent components of the media application component. As another example a banking application may specify certain secure protocols e.g. Secure Socket Layer SSL Transport Layer Security TLS and or Certification Authority CA trust certifications or security keys . In this example the SSL TLS and CA would be the dependent components of the banking application component.

In general such integrity ownership checking involves authenticating each component e.g. each component in the boot sequence and or the component to be component provisioned and the associated component purpose as having a trusted owner and verifying that the component has not been altered since its receipt from the trusted owner. To verify that the component has a trusted owner the integrity ownership check module may authenticate user credentials e.g. user name password etc. or security keys e.g. public keys such as Public Key Infrastructure PKI keys and or others using for example cryptographic techniques. Integrity and ownership checking may be performed according to one or more of the techniques described above and in Oberg et al. U.S. patent application Ser. No. 13 872 865 for example.

The install update scheduler analyzes the component purpose rule set associated with the component to be provisioned verifies that the component purpose rule set does not have any unresolvable conflicts with other component purpose rule sets associated with the same component e.g. component purpose rule sets of other component owners and initiates component provisioning of the component or schedules such provisioning to occur at a later time e.g. on the next boot in accordance with its associated rule set. As a result the new or updated upgraded component is installed on the computing device platform and its associated component purpose rule set is made accessible to the purpose enforcement engine for runtime enforcement. The new as in the case of a newly installed component and updated component purpose rule sets may be added to a global compilation of component purpose rule sets . The compilation of component purpose rule sets includes the individual component specific rule sets for each of the N where N is a positive integer components that are component provisioned on the device platform .

The purpose enforcement engine operates to enforce the component specific purpose rule sets as they are implicated from time to time by purpose enforcement triggers that occur during operation use of the device platform . Purpose enforcement triggers include for example requests to access component resources. Such requests may be initiated by other users software applications or devices which may be referred to herein as resource recipients . As an example a mobile device user may initiate through a mobile banking application an inquiry as to the current balance of the user s bank account. In this case the user s balance inquiry acts as a purpose enforcement trigger .

The purpose enforcement engine includes a purpose monitor module an auditor profiler module and a purpose learning module . The purpose monitor module monitors operation of the computing device platform and detects purpose enforcement triggers . The purpose monitor determines which of the component purpose rule sets or context or resource specific rules thereof are applicable to the purpose enforcement triggers and evaluates the purpose enforcement triggers in view of the applicable rule set or sets . As some components may have multiple owners issuing component purpose rule sets in some embodiments the purpose monitor may reconcile the rule sets of the various owners and determine whether the action requested by the purpose enforcement trigger is permitted by the applicable rule sets collectively. In other embodiments the rule sets of the various owners may be compiled and reconciled prior to their entry in the global purpose rule sets e.g. by the purpose assistant . The purpose monitor generates a purpose result in response to each purpose enforcement trigger that implicates one or more of the component purpose rule sets . The purpose result may be embodied as a message instruction parameter or data value for example which indicates whether the action requested by the purpose enforcement trigger is permitted. If the purpose result is favorable indicating that the requested action is permitted at least in part the purpose monitor issues a purpose trust token embodying the purpose result to the resource recipient . In the above banking example the purpose trust token includes a purpose result that indicates to the banking application or directly to the resource recipient that the request is permitted and indicates any context or resource specific restrictions that are applicable to the request. For example the purpose result and thus the purpose trust token may stipulate that the account balance information only be provided to the verified requester when the requester is not connected to a public unsecured wireless access point and that such information is not provided when the requester is connected to other wireless access points . Thus if the user connects to an unsecured wireless network the purpose trust token issued by the purpose monitor may stipulate that the balance inquiry is to be denied or may allow the user to override the restriction.

The auditor profiler module keeps track of purpose enforcement triggers and the associated purpose results determined by the purpose monitor and stores them in memory e.g. a log file for auditing and learning. The purpose learning module employs for example artificial intelligence based techniques such as various supervised or unsupervised machine learning techniques to e.g. by executing background processes observe and learn from the user s behavior in response to the purpose results . For example after many instances of observing that a user overrides a particular component purpose rule in a particular operating context of the computing device platform the purpose learning module may propose a modification to the rule and if approved by the applicable component owners incorporate corresponding purpose rule updates into the component purpose rule sets .

Referring now to an illustrative computing system includes an embodiment of the purpose assistant embodied in a computing device and an embodiment of the component provisioning subsystem embodied in another computing device . The computing devices are in communication with each other via one or more networks . For example the network s may communicatively couple the computing devices to each other and or to other computing devices and or systems by for example a cellular network a local area network wide area network personal cloud virtual personal network VPN enterprise cloud public cloud and or public network such as the Internet. The illustrative computing devices and the network are depicted in simplified form for ease of discussion. It should be understood that either or both of the computing devices may be configured in a similar manner to the computing device platform and have one or more similar components thereto. For example the computing device and or the computing device may include all or a subset of the components of the computing device platform . In general the components of the computing system having similar or identical names to components shown in and or described above may be embodied in a similar fashion to the corresponding components described above. As such reference is made here to the foregoing description and such description is not repeated here.

In the computing system the purpose assistant is in communication with a natural language processor which applies a purpose ontology to natural language purpose input of a user e.g. a component or resource owner to derive therefrom one or more policies purposes and or anti purposes to be implemented on the computing device by the component provisioning subsystem in connection with the component provisioning of a component for use on the computing device . That is the component provisioning subsystem is extended by the purpose assistant to facilitate purpose anti purpose generation by one or more stakeholders e.g. end users component owners component providers etc. . Similarly signed purpose contexts which in some embodiments may be formulated as signed purpose tokens can be transferred across networks and heterogeneous computing systems devices to for example provide assurance that a component purpose provisioned task event has been verified authorized by an active purpose enforcement engine for a given user and resource. In the banking example a mobile user could be pre authorized by a bank to transfer small increments of funds e.g. up to a percentage of equity in their authorized account by a bank to another mobile user party without requiring an active authorization from a bank or credit issuer. Such a form of secure pre authorization may allow for transfers to occur even offline e.g. without the two parties being connected to a banking network point of service PoS terminal or the Internet .

In different embodiments the purpose assistant may have a number of different front end interfaces which will help gather component purpose context which will be used to create the component purpose rule sets . As such the purpose assistant may include a natural language parser a step by step wizard based solution or direct definitions for example. In any case the purpose assistant is configured to process the high level descriptive details about component purposes and policy requirements derive the component purpose and anti purpose and then convert these into a component purpose rule set . The context provided by using high level descriptions of the component purpose allow the component purpose rule sets to be applied more flexibly in different operating contexts of the device .

For example in some embodiments the purpose assistant is embodied as or as a component of a virtual personal assistant which can engage a person in a natural language dialog to achieve the goal of developing a component purpose rule set for a component to be purpose provisioned on the computing device . Such a virtual personal assistant may be embodied as a computerized application that employs natural language processing NLP and or natural language understanding NLU techniques to interpret natural language input e.g. conversational input or dialog including spoken natural language dialog received by one or more user interface devices e.g. a microphone keypad etc. and generate a machine readable semantic representation of the user s intended meaning of the natural language input. The machine readable semantic representation of the user s natural language policy or purpose statement may be stored as a component purpose rule set which may be embodied as machine executable rules and or computer program logic statements for example.

Some aspects of virtual personal assistants all or portions of which may be used in connection with or to implement one or more aspects of the purpose assistant are described in at least the following patent applications of SRI International Yadgar et al. U.S. patent application Ser. No. 13 314 965 filed Dec. 18 2011 entitled Generic Virtual Personal Assistant Nitz et al. U.S. patent application Ser. Nos. 13 585 003 and 13 585 008 filed Aug. 14 2012 both entitled Method System and Device for Inferring a Mobile User s Context and Proactively Providing Assistance and Kalns et al. U.S. patent application Ser. Nos. 13 891 858 and 13 891 864 both filed May 10 2013 both entitled Rapid Development of Virtual Personal Assistant Applications. 

Briefly the conversational e.g. unstructured natural language policy or purpose inputs are received and processed by for example a user intent interpreter module of the natural language processor or the purpose assistant which analyzes the input and formulates therefrom a likely intended goal or objective of the user with regard to establishing a purpose or policy for a component to be purpose provisioned on the computing device . Such a goal or objective may be referred to as a user intent. In some embodiments the user intent may be formulated as an intermediate structured representation of the conversational natural language input. For example if the natural language policy statement includes the phrase Only share account information when user is connected to a secure wireless network the corresponding user intent may be formulated as e.g. a combination of structured statements such as ShareData Account Info Secure WAP and ProtectData Account Info All Other WAP . The purpose assistant analyzes the natural language input and or the user intent as needed and based on its analysis executes one or more task flows e.g. machine executable routines to generate the component specific purpose rule sets . For example the ShareData Account Info Secure WAP and ProtectData Account Info All Other WAP statements may be translated to a series of lower level machine executable instructions that can be executed by the component provisioning subsystem . Additionally the purpose assistant may generate purpose trust tokens for each of the component purpose rule sets as described herein. The component purpose rule sets and the purpose trust tokens may be stored in the data storage .

Where spoken natural language is used to input a policy or purpose statement the user intent interpreter module analyzes the words and or phrases produced by e.g. an automated speech recognition ASR system which generally converts speech to the corresponding text e.g. words and phrases . In this case the user intent interpreter module may apply for example a rule based parser and or a statistical parser to determine based on the verbal context the likely intended meaning of spoken words or phrases that have multiple possible definitions e.g. the user may have intended the word net to mean Internet or subnet or something else depending on the context . An illustrative example of a natural language understanding component that may be used in connection with or as a part of the user intent interpreter module is the SRI Language Modeling Toolkit available from SRI International. In some embodiments the user intent interpreter module combines the likely intended meaning goal and or objective derived from the natural language input as determined with any multi modal inputs e.g. GPS location etc. and the purpose assistant synthesizes the combination of natural language inputs and other multi modal inputs to generate the component purpose rule sets .

The purpose ontology is embodied as for example a database or knowledge base which defines semantic relationships between various natural language terminology and their machine readable counterparts. For example the purpose ontology may define checking account as referring to a specific banking account number of a specific user or may define my house as referring to a specific wireless access point or may define all social media as a list of social media sites services e.g. FACEBOOK TWITTER LINKEDIN TUMBLR etc. . In this way the purpose ontology facilitates not only purpose creation but also purpose maintenance in that changes made to the ontology can be automatically propagated to component purpose rule sets that reference the ontology . Moreover platform specific configuration details can be reflected in the ontology thereby allowing just the ontology and not the individual component rule sets to be updated in response to platform operating system or software upgrades.

Referring now to an illustrative method for provisioning an electronic device e.g. device platform device and or device is shown. illustrate simplified depictions of the electronic device platform during different stages of the provisioning method of . The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing system by the component provisioning subsystem for example . At block the method is initiated by the manufacture of the electronic device e.g. a mobile wearable portable embodiment of the computing device platform . In the status of the device is represented by the single block e.g. hardware only with nothing installed . The device is initially provisioned e.g. by the original equipment manufacturer OEM or telecommunications carrier with a hardware security key or set of keys boot extensions for the integrity checking and provisioning subsystems and the initial software stack e.g. loaded by the OEM carrier . At this stage components e.g. bootloader operating system native applications are provisioned on the device.

At block the computing device platform receives an initial provisioning trigger which may be the purchase of the electronic device by a customer for example. The initial provisioning trigger may be as simple as a power on of the device or the input receipt of user credentials. At block the platform system determines whether the device is enabled for cellular telecommunications services. If the device is not enabled for cellular service the method proceeds to block where user customization of the device is initiated. If the device is cellular enabled the device is configured according to a selected carrier and or cellular plan at block . The carrier and or cellular plan may be selected by the end user or an enterprise e.g. a corporate administrator for example. At block the platform system determines whether the device is to be provisioned with a new phone number or with an existing phone number. If the device is to be provisioned with a new phone number the new phone number is obtained at block e.g. from the carrier and at block the device is provisioned for use with the selected carrier s cellular network. If the device is not provisioned with a new phone number the method proceeds to block directly. Once the device has been provisioned for access to the carrier s cellular network the device s cellular provisioning is complete at block and the platform system proceeds to user customization of the device at block . In the status of the device now includes mobility e.g. cellular service and a connection to a carrier network . User customization may include for example establishing the end user s preferred email service and email address wireless networks etc. as well as any other customizations e.g. settings preferences .

Referring now to the method follows the method in the illustrated embodiment. In other embodiments the method may operate in conjunction with or parallel to the method . For example in some embodiments the carrier set up block and or carrier network provisioning block may be purpose provisioned according to the method . That is in some embodiments the method enables aspects of the cellular configuration of the device to be provisioned according to user specified purposes as disclosed herein. At block the platform system determines whether a provisioning trigger in the form of a new component request has been received. The new component request may take the form of a request to download a new component or install a new component found scheduled in persistent storage cache as may be the case in device implementations that schedule application operating system or other firmware updates based on the presence of a new or updated component in a defined storage location . For example if a new component request is not received the device begins or continues normal customer use at block . If a new component request is detected the platform system determines whether the component is eligible for purpose provisioning at block . To do this the platform system may determine whether the new component has an associated purpose trust token. If the component is not to be purpose provisioned the platform system proceeds with the purchase or download e.g. from an app store or app market of the component block and normal customer use block . In the device now includes multiple separately provisioned domains and other independently provisioned components C1A C1B and C2 where C1A represents a purposed provisioning of a component C1 for use within the domain A C1B represents a different purposed provisioning of the same component C2 for use with in the domain B and C2 represents another purpose provisioned component outside of the domains A and B.

If the new component is to be purpose provisioned the platform system proceeds to execute computer program logic to define the component specific purpose block e.g. via the purpose assistant purchase and or download the component block establish the purpose trust token s associated with the component and the component stakeholder s block for use by e.g. the purpose enforcement engine complete the component purpose provisioning block and begin or resume normal customer use block .

Referring now to an illustrative method for creating or updating a purpose trust token is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing system by the purpose assistant for example . At block the method is initiated by a trigger to create or update a purpose trust token e.g. by the purchase of the device by a component download etc. . As discussed above the purpose trust token may be embodied as an encrypted or otherwise secured element comprised of authenticated user credentials and user defined component specific purposes and policies e.g. a component purpose rule set . In other words the purpose trust token provides a trusted indication of the permitted and unpermitted users of its associated component in various operating contexts of the device. At block the platform system authenticates the user to the device. To do this the platform system may verify a user name and password fingerprint or other biometric identifier or use other authentication techniques. At block the platform system defines the component specific purpose and any context specific rules and policies related thereto. To do this the platform may interact with the user using for example the purpose assistant . At block the platform system obtains the user authentication credentials to be incorporated into the purpose trust token to validate the purpose based rules and policies as authentic to the user. These credentials may be unique or specific to the purpose context trust token or may be more globally defined e.g. as a global common user to device authentication . In some instances the user may not know the credentials as they may be securely transferred to the device and stored by an automated process. In the banking example a bank s automated teller machine ATM may authorize a user s device as well as the bank application component provisioned thereon via a unique code sent via e.g. NFC RFID radio frequency identification barcode etc.

At block the platform system derives the anti purpose s associated with the purpose obtained at block . To do this the platform system may refer to pre established relationships between defined purposes and anti purposes which may be stored in for example a lookup table database or the purpose ontology . At block the platform system compiles the purpose trust token from the defined purpose context s policies anti purpose s and authentication credentials. As used herein context may refer to among other things the current calendar date the current time the current geographic location nearby wireless access points cell tower locations and or other indicators of the current operating context of the platform system as may be detected by sensors and or other context detecting mechanisms of the platform system . Thus in some embodiments the purpose trust token may include for example a date time stamp and or other context indicators.

At block the platform system obtains a user specific private salt such as the user supplied answer to a security question or some other user supplied data . At block the platform system executes a cryptographic hash function e.g. a Secure Hash Algorithm using the private salt and the purpose trust token as inputs. The output of the cryptographic hash function is stored as the new or updated purpose trust token in a secure form e.g. not easily derived or ascertained at block .

Referring now to a simplified illustration of component purpose rule sets is shown. In the illustrative example a separate component rule set is defined for each of N provisionable components of the platform system . As shown each component rule set may have a different set of rules for each domain in which the component is purpose provisioned. Further each component rule set may have different rules that apply during different operating contexts of the platform system . Moreover each component rule set may have different rules that apply to different component resources involve in the use or execution of the component. In this way the component purpose rule sets allow for finer granularity and context dependency of restrictions on the use of component resources and for the release of restrictions when the conditions context giving rise to the restrictions cease to exist. The component purpose rule sets may be embodied as for example computer readable instructions directives or statements which may be developed by the purpose assistant and processed by the component provisioning subsystem as described above.

Referring now to an illustrative method for creating or updating a component purpose is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing platform system or by the computing device by the purpose assistant for example . As described herein the creation or updating of a component purpose may involve input from or negotiation among multiple stakeholders such as the component owner and end user. Thus in some embodiments a component purpose represents an agreement among multiple parties as to how a component may be used by the end user and as to how the end user s component resources e.g. personal private data may be used and shared by the component. However certain types of purposes may be open ended in that resource recipients are not yet defined. Such may be the case where a component owner defines a purpose for use of the component on a device but the component or the device is not yet configured for a specific end user. For instance the component resources may include bank funds personal IDs social media IDs e.g. FACEBOOK LINKEDIN SKYPE etc. user IDs and related private information that the resource component owner may want to share on a limited basis in the future but with a common set of purpose conditions restrictions. That is to say that some purpose conditions restrictions may be applicable more generically to multiple different component resources in some embodiments. For example multiple different social media resources may have a common set of purpose conditions restrictions e.g. sharing of a user ID but not a friends followers or contacts list and not the user s date of birth contact info pictures etc. . At block the method is initiated by the detection of an electronic communication comprising a request or trigger to generate a new or updated component specific purpose for a component provisioned or to be provisioned on the platform system . For example the method may be initiated by the purchase of an electronic device embodying the platform system a user request e.g. the purchaser or a system administrator etc. At block the platform system identifies the component stakeholders e.g. the end user component provider device manufacturer resource receivers etc. . At block the computing device platform or computing system e.g. the computing device operating the purpose assistant obtains a natural language expression or expressions from the various stakeholders of the component specific purpose. In some embodiments the component specific purpose contains a number of different elements that identify the applicable provisionable components in cases where a purpose spans multiple components the applicable component resource identifiers e.g. bank account numbers etc. the applicable resource owners which may be tracked by publicly shared keys the applicable resource receivers which may receive purpose approved resources but may not directly submit new purposes for the specified resources and the purpose criteria and rule matching result actions e.g. the criteria for determining whether a purpose matches a purpose enforcement trigger event and the action to be taken if a match occurs .

At block the computing device platform or computing system derives the component specific purpose and anti purpose from the received natural language expression s . To derive the purpose and anti purpose the device platform may apply the purpose ontology to for example determine relationships between the stated purpose and purpose policy anti purpose information contained in or referenced by the purpose ontology and or an associated knowledge base which may include for example searchable database tables populated with specific data values rules and or computer instructions that relate to natural language statements and thereby map elements of the natural language expression to elements of the ontology and or associated knowledge base.

At block the device platform generates or updates as the case may be the component purpose rule set which as discussed above may include a number of different component resource and or context specific rules. To do this the device platform may again refer to the purpose ontology and or an associated knowledge base to map the derived purpose and anti purpose to their corresponding machine readable semantic representations instructions and or data values. At block the device platform obtains acknowledgements from the identified stakeholders indicating approval of the new or updated component purpose rule set. Digital signatures or other methods may be used to authenticate and verify stakeholder approval. The new or updated component purpose rule set is then stored in a suitable data structure e.g. a searchable database in persistent storage such as the data storage and shared with all relevant interested parties e.g. resource recipients which may include the stakeholders . At block the device platform verifies that the component purpose implemented as a component purpose rule set is compatible with other component purposes and has been successfully installed on the device platform . In some cases block is executed to confirm that in the event that a time elapse occurs between the component purpose rule set generation and the completion of stakeholder acknowledgements the new component purpose is still valid e.g. the new purpose does not conflict with any purpose rule sets installed or updated during the time elapse .

Referring now to an illustrative method for booting an electronic device including a component provisioning subsystem as disclosed herein is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing system by the virtualization service and or other components of the trusted computing base for example . At block the platform system boots e.g. in response to a power on event . As part of the boot process the virtualization service e.g. hypervisor or pre boot loader loads the component provisioning subsystem into memory. To do this the component provisioning subsystem may be downloaded e.g. from a networked server computer in the cloud or a boot image may be loaded into memory from block storage for example. At block the platform system performs an integrity verification check on the chain of trust from the bootloader to the component provisioning subsystem as described above. At block the platform system executes a provisioning check to see if any components need to be purpose provisioned on the platform system e.g. for a new domain or purpose. That is if a component is already installed on the device it may not need to be purpose provisioned. However the component may need to be purpose provisioned e.g. as an extension of a typical user customization e.g. for a new domain or user. For example an already installed email application may be purpose provisioned as disclosed herein for use in a personal domain with a user s GMAIL account and also separately purpose provisioned for use in an enterprise domain with an employer issued email account.

If the platform system detects a provisioning event e.g. that there is a provisionable component needing to be provisioned as indicated by for example a provisioning trigger or purpose trust token the method proceeds to block . In some embodiments the domain manager subsystem may determine active domains and initiate purpose provisioning of a domain that is available to run on the platform system e.g. certain default domains . If there are no components that need to be purpose provisioned the platform system proceeds to block . For example the platform system can start e.g. launches initializes and or begins execution of the next stage bootloader e.g. hypervisor domain component manager etc. or the component per operating system and component dependencies at block . For example in some embodiments a component may be an application operating system subsystem etc. that is arranged to start in a system dependent order or as needed on demand.

If it is determined at block that a component needs to be provisioned the device platform determines the provisioning configuration and purpose provisions the component for use on the device platform using the techniques described herein at block . At block the platform system checks to see if additional component provisioning needs to be performed. If there is additional provisioning checking to be performed the method returns to block . If no other components need to be checked for provisioning the method proceeds to block . Once purpose provisioning is complete the purpose provisioned components are available to execute and or accept or issue tasks events in accordance with their provisioned purpose.

Referring now to an illustrative method for enforcing a component specific purpose during operation of the platform system is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing system by the component provisioning subsystem for example . At block the method is initiated by an electronic communication indicating a request or trigger for component purpose enforcement such as a new task or event that is received or started by an executing component. At block the platform system identifies the type of task or event being requested by the component to determine if the detected task event is governed by any rules in the applicable component purpose rule set . In some cases new or unrecognized task events may be evaluated and associated with a task event type or classification. The task event type may be used for example to distinguish task events from one another at a higher level of abstraction e.g. to categorize them so that every individual task event need not be separately analyzed. If the task event is not governed by one or more of the component purpose s where a component may have multiple different purposes as described herein the platform system executes the task event as requested at block . If the task event is governed by one or more component purpose s at block the platform system compares the behavior of the component task event to the anti purpose s and then the purpose s defined for the component e.g. as implemented in the component purpose rule set . If the behavior of the task event matches one or more of the defined anti purpose s block or does not match a purpose block the platform system allows a user user agent or VPA for example to resolve the conflict between the task event behavior and the purpose anti purpose s block and proceeds to block . If the task event behavior matches a purpose that is permitted by the component rule set block the method proceeds to block . At block the platform system logs the task event information and the result of the purpose anti purpose analysis e.g. the purpose result and determines whether to permit e.g. without a purpose context purpose permit e.g. endorse the task with a purpose context or deny the task event block . As used herein purpose permit may refer to among other things the platform system s ability to enable task events with a purpose context that is not necessarily restrictive. For example in some embodiments the purpose context can serve as and encapsulate both a simple or fine grain restrictive description of the accepted task event and or as a guarantee of security by providing a digitally signed security context e.g. token implementation .

At block the determination to permit purpose permit or deny the task event may be based on user input received at block may be the result of machine learning conducted at block e.g. the component purpose or anti purpose may be modified based on for example a prior history of user or task event behavior or other criteria. If the platform system determines that the task event should be denied the task event is ended e.g. application closed or terminated at block . If at block the platform system determines that execution of the task event should be permitted without purpose context enforcement the task event is executed block . If at block the platform system determines that execution of the task event should be permitted the platform system may add a permissive audit caveat to the purpose context and generate an aggregate purpose context as described below modified as needed in accordance with the applicable component purpose s resource specific rule s and or context specific rule s at block associate the permitted context with the task event block and execute the task event in accordance with the purpose and context at block .

If at block the platform system determines that the task event s behavior does not match any of the anti purposes associated with the component the platform system determines whether the behavior of the task event matches a purpose in the component purpose rule set at block . If there are no rules in the component purpose rule set the platform system at block notifies the user that the requested task event is associated with a purpose that is currently not implemented in the component purpose rule set and follows the path through blocks in a similar manner as described above. In this way component purposes and rule sets can be dynamically created and modified at runtime for example in response to component task events that may not have been anticipated at the time the component was initially purpose provisioned. If at block the platform system determines that the task event s behavior or purpose corresponds to a rule in the component purpose rule set the platform system at block determines and annotates an acceptable operating context for the task event behavior based on the purpose anti purpose rules matched in blocks and and any permissive or user resolution events in blocks and . To do this the platform system analyzes the task event behavior and applies the matching context specific rules in the component purpose rule set . Upon final compilation of the purpose context portions of the context may include digital signatures from applicable rule matches. As an example a bank may digitally sign a purpose rule that allows for transactions from a specific resource account owner to transfer less than X funds.

In addition the entire context may be digitally signed as an endorsement of the applicable rules that were evaluated and enforced. This can for example provide a form of attestation to a component resource receiver that the purpose enforcement engine is operating. At block the platform system associates the acceptable approved context determined at block with the task event e.g. by generating a purpose trust token . At block the platform system executes the approved task event in accordance with the approved purpose and context and the task event ends at block .

The foregoing methods and processes are simplified for discussion purposes but it should be understood that the computing device platform and or the computing system may undertake any of the foregoing methods or processes concurrently or in parallel e.g. for each of the executing domains and or any components thereof. For example the computing device platform and or the computing system may perform an analysis of any provisioning triggers that it receives from any or all of the domains or other components in whatever order or sequence they may occur.

Embodiments of the above described component provisioning techniques can provide dynamic finer grained control of components of electronic devices that has many potential applications. For example some embodiments of the component provisioning subsystem can be used to supplement and extend existing static mobile device policies that are managed by mobile device management services and other third parties to a virtualized multiple personality mobile computing platform or mobile virtual appliance. Purposed component specific provisioning as described herein is applicable to banking financial healthcare medical enterprise and personal applications among others.

In one example a bank s mobile banking application includes an account access component for a bank account managed owned by the bank. The component rule set associated with the account access component specifies that the end user cannot directly read or write data to the bank account e.g. to prevent the user or someone who has infiltrated the user s device from attempting to hack into the bank s computing infrastructure . The bank provides a purpose trust token with the account access component when it is purpose provisioned. The purpose trust token may be used as part of the user authentication procedure and may be unique to user. Further the purpose trust token maybe only valid on the provisioned device e.g. the user s device on which the banking application is installed . The token and its provisioned purposes may be mapped to only apply to certain bank accounts. Additional restrictive and permissive criteria may also be applied to a token so that for example it is only valid when used by a specific user domain execution environment or context . Further the user may customize the token so that different rules apply in different contexts in which the account access component may be used. The user may customize the token so that his or her retirement accounts may be only be accessed with permission to read general information and so that write or transaction access is denied unless the user is a trusted party such as a fiduciary or wealth manager appointed by the user.

In another example a user may customize a purpose trust token so that only certified medical professionals may unlock medical records stored on the user s mobile device. Further a user s customized purpose trust token may permit only certain trusted parties e.g. a beneficiary or appointed fiduciary to access a living will or power of attorney stored on the user s device. Similarly the user may create and share purpose trust tokens to allow only certified law enforcement officers to access the user s driver s license stored on the user s mobile device or to allow only certified customs officers to access passport information. In some cases tokens may have time or persistence limitations e.g. tokens may expire after passage of a defined amount of time .

In still another example purpose trust tokens may be used to control third party accesses to social media pages. Purpose trust tokens may be established so that third party logins to e.g. FACEBOOK or LINKEDIN permit the user s identity to be verified but deny access to the user s entire Facebook profile.

Other applications of the foregoing provisioning techniques can be applied to smart appliances mobile virtual appliances etc. In a smart home environment many traditional but now networked smart appliances and devices such as entertainment systems home security systems heating and cooling systems kitchen appliances clocks vehicles etc. can communicate with and thus be controlled by mobile electronic devices. For example a home entertainment system may be purpose provisioned by the user s mobile device to be permitted to use the mobile device s music player application e.g. ITUNES and denied access to all other applications on the mobile device. Similarly a home refrigerator may be purpose provisioned to be permitted to communicate grocery inventory data e.g. RFID tagged goods located in the refrigerator to a grocery application on the user s mobile device but denied access to all other applications on the mobile device. Such networked appliances and other devices may be provided with purpose trust tokens to continue to access their provisioned resources on the mobile devices long as the trust tokens are valid.

In still other applications purpose trust tokens may be used to establish and rescind and transfer real time control of systems under control of the computing device. In systems where the mobile computing device may serve as a real time controller for networked or connected systems such as robotics strategic unmanned aerial vehicles SUAVs and machine systems.

Referring now to an illustrative computing system includes a policy reasoner embodied in a computing device and an embodiment of the policy arbitration subsystem embodied in another computing device . The computing devices are at times in communication with each other via one or more networks i.e. during provisioning policy updates and status reporting back to the component provisioning subsystem . For example the network s may communicatively couple the computing devices to each other and or to other computing devices and or systems by for example a cellular network a local area network wide area network personal cloud virtual personal network VPN enterprise cloud public cloud and or public network such as the Internet. The illustrative computing devices and the network are depicted in simplified form for ease of discussion. It should be understood that either or both of the computing devices may be configured in a similar manner to the computing device platform and have one or more similar components thereto. For example the computing device and or the computing device may include all or a subset of the components of the computing device platform . In general the components of the computing system having similar or identical names to components shown in and or described above may be embodied in a similar fashion to the corresponding components described above. As such reference is made here to the foregoing description and such description is not repeated here.

Referring now more specifically to the illustrative policy arbitration subsystem is embodied as a number of computerized modules that in some embodiments may exist within an isolated domain e.g. APIs physics based controls etc. as mentioned above that utilize the policy artifacts as described in more detail below. The illustrative policy arbitration subsystem is embodied as a policy manager which includes a policy provisioning module a least restrictive conforming policy LRCP engine a policy arbitrator and an event trigger handler . The policy provisioning module creates and maintains a policy pool which includes or contains references to the policy artifacts of all of the domains that have been successfully provisioned on the computing device platform . The policy pool may be implemented as for instance a database table linked list or similar suitable data structure. The LRCP engine applies conflict detection and solution finding algorithms to the policy pool to determine the active device policy . The policy arbitrator more or less continuously applies the active device policy to the current operating context of the computing device platform and re engages the LRCP engine as needed to handle changes to the policy pool caused by domain provisioning policy updates and domain deprovisioning. The policy event handler discussed in more detail elsewhere in this document receives and analyzes domain triggered events and or event triggers to among other things determine if said event will cause an action based on the current active device policy .

Again referring now to the illustrative policy arbitration subsystem is embodied as software firmware hardware or a combination thereof to perform policy rule arbitration services during the operation of the computing device platform . In some embodiments the policy arbitration subsystem comprises a suite of computer programming constructs e.g. both on and off device. For example the policy arbitration subsystem may define an application programming interface API or a suite of APIs or API extensions. The APIs may be implemented as a software library a software framework e.g. a collection of different software libraries implementing different APIs a protocol or set of protocols or another type of programming interface that allows computer programs to communicate with each other and with shared computing resources. As noted above embodiments of the policy arbitration subsystem or portions thereof may be implemented in or to control hardware components e.g. as physics based policies .

Thus while not specifically shown in it should be understood that portions of the policy arbitration subsystem can reside on other computing devices or computing systems in some embodiments as a distributed policy system. For example a portion of the policy arbitration subsystem may be local to the computing device platform while another portion may be distributed across one or more other computing systems or devices that are in communication with the computing device platform by one or more electronic communication networks via communication subsystem for example. In other embodiments the policy arbitration subsystem may be located entirely on the computing device platform .

As mentioned above in some embodiments each domain or other components or group of domains or components has its own defined policy which may specify for example permitted accesses and uses of the various system resources by the domains and or other components in different contexts. In some embodiments these domain specific for ease of discussion policies are embodied as policy artifacts . The policy artifacts may be derived from natural language statements and may include instructions relating to a purpose and an anti purpose as described above and in more detail below with reference to .

To provide scope for the various actions performed as described below embodiments of the disclosed policy arbitration subsystem use event triggers created by processing and monitoring the shared services subsystems described above. In some embodiments event triggers are provided directly by the trusted domains e.g. network I O and domain management subsystems . In other embodiments inline monitor domains can be used to provide trusted triggers. In any embodiment some examples of triggers include but are not limited to timers sensor input i.e. GPS accelerometer proximity I O i.e. touchscreen buttons network actions i.e. magic packets subnet computer connectivity WIFI access points externally networked devices and events created by the domain management subsystem i.e. initialization execution activation domain switch . Additionally the policy artifact of a domain can contain triggers which the user domain can directly trigger i.e. mode switch . As many triggers have bounded scoped i.e. a region defined by GPS coordinates a WIFI AP SSID Service Set Identifier e.g. a public name for a wireless network a IP Internet Protocol subnet mutual exclusive non overlapping regions allows cases where policy restrictions to a trigger source can still allow detection and triggering events in non restricted regions as examples are provided below when discussing rule chains . While the interface is similar between these normal event triggers and domain event triggers there are some differences. For example in some embodiments the trusted status of the normal event triggers allows the disclosed policy arbitration subsystem to utilize other components within a Trusted Platform Module TPM to determine if items are mutually exclusive or not as required by the LRCP engine discussed below. In these embodiments the policy arbitrator is simplified as it does not need to include the logic specific to each trigger or discussed next action. As user domains are part of the TPM they may not be trusted to perform this logic for the policy arbitration subsystem. Furthermore the policy arbitration subsystem may not know when the generic domain event trigger is mutually exclusive. As such mutual exclusivity or scope reduction can occur if a domain event trigger cannot be triggered when the domain is not executing.

An example of a domain triggered event is an event that arises from the operation of a domain such as user level software executing in a domain requesting access to a system resource . As such domain triggered events may include among other things application or operating system requests to activate the camera obtain GPS information send or receive a message connect to a wireless access point etc. An example of an event trigger is an event that arises out of the current operating context of the device typically independently of any domain or component of the device. Event triggers may include information that is sensed or otherwise detected or obtained by any of the sensors other peripheral devices or communication subsystem . As such event triggers may include among other things the detection or lack of detection of particular GPS locations wireless access points or IP addresses or the occurrence of an activation or deactivation of a camera microphone or other system resource . In some instances event triggers may be initiated by or result from the activities of a component of the trusted computing base such as the virtualization service or a shared service . For ease of discussion domain triggered events and event triggers may be referred to herein collectively as event triggers events or triggers. 

The policy artifacts contain rule chains of triggers and actions of different types. Some rules chains e.g. disable actions may completely restrict access to or use of a system resource at least temporarily while the chain is in effect. Other rule chains e.g. filter actions may only partially restrict access to or use of a system resource . Further some of the rule chains may be unconditional in that they apply in all circumstances while others may be conditional in that they are only enforced in response to a defined trigger event. For example an artifact issued by an enterprise domain may contain a rule chain that completely disables a camera feature of the computing device platform for a personal domain when the computing device platform detects using e.g. an integrated sensor or peripheral device such as a GPS transceiver that the device platform is at a particular geographic location e.g. on company property . Similarly the policy artifact issued by the personal domain may contain another rule chain completely disable a microphone of the computing device platform for the enterprise domain when the user has answered a telephone call in the personal domain. Another rule chain of the enterprise domain issued artifact may prevent the personal domain from connecting to a particular IP address when the device platform is in a particular geographic location e.g. on company property . Another rule chain of the personal domain artifact may prevent the enterprise domain from connecting to the user s home wireless access point when the device platform is in a particular geographic location e.g. within range of the user s home . Yet another rule chain of the personal artifact may prevent the use of a touchpad of the device platform for text messaging when the device platform determines e.g. using an integrated sensor such as the GPS that the user is likely to be driving a vehicle.

In addition the policy arbitration subsystem which arbitrates communication channels may provide for the downgrading or filtering of information on such channels to different domains. As an example where the computing device platform captures GPS data the policy arbitration subsystem may permit the computing device platform to send highly accurate geographic location values to a security vetted domain but only permit the computing device platform to send rough approximations of the same geographic location information to un vetted third party domains. Other sensors and data types can also benefit from the arbitration of content downgrading by performing similar per domain resolution adjustments and other data manipulations.

To do this the illustrative policy arbitration subsystem stipulates that each domain s policy artifact includes a number of policy implementation options 1 to N where N is any positive integer as well as a set of minimum domain provisioning requirements and a set of derived minimum runtime requirements . In general the minimum provisioning requirements comprise essentially non optional domain provisioning policies e.g. conditions that must be satisfied in order for a domain to be successfully provisioned on a device both in terms of functionality and security requirements. For example an enterprise domain may have a domain policy minimum provisioning requirement MPR that the device have access to GPS information. If an attempt is made to policy provision the enterprise domain on a device that does not have GPS capabilities the MPRs will instruct the policy provisioning module that the policy provisioning attempt should fail unless the MPRs are flagged as suggested or optional as discussed later . Another example is a requirement that the policy artifact be updated by a certain event or time deadline to ensure a given domain s policy is regularly updated. Should the deadline expire this MPR could trigger the domain to delete itself from the device. MPRs can also be hardware or platform requires such as non bypassable DIT Data in Transit and DAR Data at Rest hardware encryption or high security key storage.

Similarly the minimum runtime requirements derived from the active policy implementation selected from the policy artifact comprise essential runtime policies e.g. conditions that must be satisfied in order for a domain to be permitted to execute on a device. For example a financial services domain may have a minimum runtime requirement MRR that no other domain can have access to or use any camera of the device while the financial services domain is running. If an attempt is made to launch the financial services domain while another domain is running that has access to the camera s of the device the MRRs will instruct the policy arbitrator module that the financial services domain cannot run until the other domain is deactivated or releases access to the camera. Some other examples of system resources that may be the subject of minimum runtime requirements include network services which may be required to for example enable MDM services and memory devices which may be required to for example store and provide digital certificates or authentication keys . As with the MPRs there may be some instances in which MRRs are flagged as suggestion or optional as the lack of the requirement will provide a degrade user experience but still fulfilling the security requirements. Like the above MPR example regarding a policy artifact to be updated by a deadline a MRR could instead just not allow a domain with an expired policy artifact to execute or simply display a dialog every time the domain is activated.

Referring now to a simplified embodiment of the policy artifact is shown. The policy artifact comprises a number of policy implementation options 1 to N . Illustratively the implementation option 1 includes a number of rule chains 1 to N where each rule chain includes one or more scope conditions and one or more rules triggered by each scope condition. The policy implementation options allow the policy arbitration subsystem to seek the least restrictive conforming policy across all of the policy provisioned domains on the device and the rule chains enable the policy arbitration subsystem the flexibility to tailor the least restrictive conforming policy to the current device context. Through the rule chains the implementation options can specify implicitly or explicitly their requirements. For example Enterprise may wish to block other domains from accessing a given subnet when connected to the corporate network. One implementation option could block said subnet whenever Enterprise can connect to a known corporate server thus may require the device to be capable of pinging the subnet address. However an implementation option that stipulates block if connected to access point may achieve the same end result without requiring the ability to ping the subnet and can thus circumvent attempts to disable pinging. As an example the rule chain 1 specifies a scope requirement on provisioning meaning that the rule chains 1.1 and 1.N are to be enforced when the domain is policy provisioned. Thus in this example the affected device is to geo fence an area A and disable the device s camera when the domain is policy provisioned where geo fence may refer to a system defined geographical area or the perimeter of such an area which may be predefined or dynamically generated . As a result such geo fencing and disabling of the camera may occur even if the domain is not currently executing on the device.

The rule chain 1 contains a second level rule 1.1.1 which specifies that if A is geo fenced then the device s microphone is to be disabled. As such disabling the microphone need only occur if the geo fence condition is already met. Further the rule chain N is implicated on execution of the domain and calls for blocking a subnet upon domain execution. As such the subnet need only be blocked if the domain is executing and not for example if the domain is merely policy provisioned initialized or has been deactivated . In this way the rule chains allow for finer granularity and context dependency of restrictions on the use of system resources and for the release of restrictions when the conditions giving rise to the restrictions cease to exist.

At times the stakeholder of a policy artifact may want to provide a suggested ability be present for the functionality the paired user domain. For example in order for the Enteprise e mail to function the user domain needs access to the corporate mail server at a given address. If for some reason said server address has been restricted by another pre policy provisioned domain this would cause a conflict that would prevent the successful policy provisioning of the Enterprise domain. As e mail access may only be one of many features provided by the Enterprise domain the stakeholder may simply make this a suggested or optional requirement. Should this policy be used a warning may be displayed to the user notifying them of the functionality reduction and the user may be allowed to override the conflict thus allow the domain to be policy provisioned.

In embodiments where the policy artifacts are policy provisioned per user domain and the user domains are unaware of the other domains on the device a number of apparent limitations may appear should a stakeholder wish to have more than one domain on a device. For example if a domain stakeholder desired to prevent all other domains from accessing subnet A in both domains then domain 1 would prevent domain 2 from having access to subnet A and domain2 would likewise prevent such access by domain 1. To account for this embodiments of the policy artifacts can be signed with an asymmetric key and the stakeholders can share a resource i.e. network with those domains having a matching key. In embodiments where policy artifacts are not shared with other domains the policy arbitration subsystem may perform the comparison of keys and internally bond the specified resource of user domains with a successful match.

One application of the disclosed suite of utilities is in the enterprise BYOD market corporations and other employers can configure a user domain with all of the tools and shortcuts required by their employees along with the policy required by the corporation. As corporations often have different stakeholders e.g. divisions departments job roles for each employee some embodiments of the policy arbitration subsystem may be dynamically configured for per employee customization based upon roles responsibilities or other factors. In such a system stakeholders may contribute high level policies to a corporate database. With each change to the policy storage database an automated system updates all policy artifacts for the employees affected by the change. For example if a certain department adds a requirement for a given IP address then the policy artifacts for all employees of that department will be automatically updated as well. In turn this may queue a policy artifact update either by direct or private domain store for any employee that had previously policy provisioned a device.

Another application of the disclosed policy arbitration suite is to create general purpose ready to use user domains as well as purpose specific mobile appliances. In these applications policy artifacts may be generic across users and the more generic public domain store option for policy provisioning may apply. While a general purpose personal user domain may have very little included in its policy artifact other embodiments such as a financial institutions mobile appliance may include heavy restrictions and requirements for privacy and security.

Referring now to an illustrative method for generating a policy artifact is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing device by the policy reasoner for example . At block the method is initiated by the receipt by the device platform of an electronic communication containing a request or trigger to generate or update a policy e.g. a domain specific policy . In response to the request or trigger the device platform identifies the relevant stakeholders. Such stakeholders may include for example the various internal organizations of the domain owner e.g. division department job title user specific information . To enable the lookup of applicable stakeholders identifying information of the end user may be contained in the request or trigger communication or may be provided electronically by the stakeholder in response to the device platform s acknowledgment of the trigger for example.

At block the device platform obtains one or more conversational natural language expressions of a purpose or policy for a domain. As described above the device platform may invoke a virtual personal assistant type application to engage the stakeholder in a person device conversational dialog exchange to obtain the needed information about the domain and the desired purpose or policy for the domain. At block the device platform derives the policy purpose and anti purpose from the natural language expression s obtained at block . As mentioned above the purpose of a domain may include an expression of some beneficial activity that is desirable for the domain to perform while the anti purpose may include an expression of a harmful or potentially harmful activity that is desired to be precluded when the corresponding purpose is enabled. For example a purpose may be expressed as allow the enterprise domain to connect to the corporate subnet when I am on company property while a corresponding anti purpose may be to prevent the personal domain from connecting to the corporate subnet. 

In different embodiments the policy reasoner may have a number of different front end interfaces that will help gather policy context which may be used to create the policy artifact . Such front end interfaces may include for example a natural language parser a step by step wizard based solution or direct definitions. In any case the policy reasoner can process the high level descriptive details about policy requirements and policy enforcement environment s e.g. what could be used to define work resources for a particular user or to detected when the user is at work derive the policy purpose and anti purpose and then convert these into a policy artifact which contains multiple implementations based on various options presented by the architecture and policy enforcement environments. The context provided by using high level descriptions and overview of the enforcement environment s allow the various implementation options to handle possible resource restrictions that may be imposed by another domain that is already policy provisioned on the device platform .

To derive the purpose and anti purpose the device platform applies the policy ontology to for example determine relationships between the stated purpose or policy and purpose policy anti purpose information contained in or referenced by the policy ontology and or an associated knowledge base which may include for example searchable database tables populated with specific data values rules and or computer instructions that relate to natural language statements and thereby map elements of the natural language expression to elements of the policy ontology and or associated knowledge base. At block the device platform generates or updates as the case may be the domain policy artifact which as discussed above may include a number of policy implementation options. To do this the device platform again refers to the policy ontology and or an associated knowledge base to map the derived purpose and anti purpose to their corresponding machine readable semantic representations instructions and or data values. The new or updated policy artifact is then stored in a suitable data structure e.g. a searchable database in persistent storage such as the data storage .

In another embodiment of the computing system the policy reasoner is in communication with a natural language processor which applies a policy ontology to natural language policy or purpose input of a user to derive therefrom one or more policies purposes and or anti purposes to be implemented on the computing device by the policy arbitration subsystem . That is the policy arbitration subsystem is extended by the policy reasoner to facilitate policy generation by one or more stakeholders e.g. the domain owners various organizations that apply for the end user . For example in some embodiments the policy reasoner is embodied as or as a component of a virtual personal assistant which can engage a person in a natural language dialog to achieve the goal of developing a policy for the computing device or a component thereof. Such a virtual personal assistant may be embodied as a computerized application that employs natural language processing NLP and or natural language understanding NLU techniques to interpret natural language input e.g. conversational input or dialog including spoken natural language dialog received by one or more user interface devices e.g. a microphone keypad etc. and generate a machine readable semantic representation of the user s intended meaning of the natural language input. The machine readable semantic representation of the user s natural language policy or purpose statement may be stored as a policy artifact or set of policy artifacts which may be embodied as machine executable rules and or computer program logic statements for example.

Some aspects of virtual personal assistants all or portions of which may be used in connection with or to implement one or more aspects of the policy reasoner are described in at least the following patent applications of SRI International Yadgar et al. U.S. patent application Ser. No. 13 314 965 filed Dec. 18 2011 entitled Generic Virtual Personal Assistant Nitz et al. U.S. patent application Ser. Nos. 13 585 003 and 13 585 008 filed Aug. 14 2012 both entitled Method System and Device for Inferring a Mobile User s Context and Proactively Providing Assistance and Kalns et al. U.S. patent application Ser. Nos. 13 891 858 and 13 891 864 both filed May 10 2013 both entitled Rapid Development of Virtual Personal Assistant Applications. 

Briefly the conversational e.g. unstructured natural language policy or purpose inputs are received and processed by for example a user intent interpreter module of the natural language processor or the policy reasoner which analyzes the input and formulates therefrom a likely intended goal or objective of the user with regard to establishing a purpose or policy for the computing device or a component thereof e.g. a domain . Such a goal or objective may be referred to as a user intent. In some embodiments the user intent may be formulated as an intermediate structured representation of the conversational natural language input. For example if the natural language policy statement includes the phrase Enterprise domain needs exclusive use of camera when I am on company property the corresponding user intent may be formulated as e.g. a combination of structured statements such as DisableCamera All Other Domains Company Location . The policy reasoner analyzes the natural language input and or the user intent as needed and based on its analysis executes one or more task flows e.g. machine executable routines to generate the policy artifacts . For example the Disable Camera All Other Domains Company Location may be translated to a series of lower level machine executable instructions that can be executed by the policy arbitration subsystem to assure that except for the enterprise domain no other domain can use the camera when the computing device is located on company property. Furthermore as the Company Location could be defined as one or a combination of several different sensors i.e. geo fenced region Wi Fi AP SSID NFC or BLUETOOTH trigger based on using device for site access or user contextual operation e.g. business functions performed on site etc. several compliant implementations can be formulated and included in the single policy artifact in case some devices have been restricted via other domain policies.

Where spoken natural language is used to input a policy or purpose statement the user intent interpreter module analyzes the words and or phrases produced by e.g. an automated speech recognition ASR system which generally converts speech to the corresponding text e.g. words and phrases . In this case the user intent interpreter module may apply for example a rule based parser and or a statistical parser to determine based on the verbal context the likely intended meaning of spoken words or phrases that have multiple possible definitions e.g. the user may have intended the word net to mean Internet or subnet or something else depending on the context . An illustrative example of a natural language understanding component that may be used in connection with or as a part of the user intent interpreter module is the SRI Language Modeling Toolkit available from SRI International. In some embodiments the user intent interpreter module combines the likely intended meaning goal and or objective derived from the natural language input as determined with any multi modal inputs e.g. GPS location etc. and the policy reasoner synthesizes the combination of natural language inputs and other multi modal inputs to generate the policy artifacts .

The policy ontology is embodied as for example a database or knowledge base which defines semantic relationships between various natural language terminology and their machine readable counterparts. For example the policy ontology may define corporate subnet as referring to one or more specific internet protocol IP addresses associated with a company network or may define my house as referring to a specific wireless access point or may define all social media as a list of social media sites services e.g. FACEBOOK TWITTER LINKEDIN TUMBLR etc. . In this way the policy ontology facilitates not only policy creation but also policy maintenance in that changes made to the ontology can be automatically propagated to policy artifacts that reference the ontology . Moreover device specific configuration details can be reflected in the ontology thereby allowing just the ontology and not the individual domain policies to be updated in response to device operating system or software upgrades. Also as mentioned earlier the policy ontology can reference to a set of options used to create policy artifacts and multiple implementations of compliant policies.

Where multiple domains exist on a device the policy arbitration subsystem the policy manager or more particularly the policy provisioning module is charged with ensuring that domains can only be policy provisioned or executed on the device if their policies can function compliantly without invalidating the requirements and thus social contract of the policies of other provisioned domains. However in some cases the policy manager may permit a domain to be policy provisioned on the device even if its policy has an unresolvable conflict with other existing domain policies but MPR requirements are still met. In other words the domain may be policy provisioned but not permitted to load or execute.

To perform its policy mediating functions the policy arbitration subsystem maintains a global set of policy artifacts which may be referred to herein as an active device policy . In some embodiments the active device policy comprises a least restrictive conforming policy global set of policy implementation as described in more detail below. The active device policy is dynamic in that at any given time it reflects the set of policy rules that are currently active e.g. actively being enforced on the device platform . As described in more detail below the policy arbitration subsystem continuously updates the active device policy as it receives domain triggered events and event triggers from the various domains or the trusted computing base e.g. the shared services or the virtualization service .

The policy artifacts may be embodied as computer readable instructions directives or statements that are submitted to the policy arbitration subsystem from time to time by the policy provisioning subsystem of the various domains independently of one another and typically without knowledge of the policies of the other domains to define permitted and unpermitted accesses and uses of one or more of the system resources by one or more of the domains . As such the policy artifacts may affect the ability of any of the domains including the domain that issued the artifact to access and use a system resource . However the policy artifacts may be specifically designed to protect the interests of the particular domain that issued the artifacts and its associated assets e.g. data that is stored on the device platform or accessible to the device platform via the artifact issuing domain without regard to the other domains. Thus some of the policy artifacts may be implicated only when the issuing domain is running on the computing device platform while others may be effective even if the issuing domain is not executing or active.

Referring now to an illustrative method for performing policy provisioning is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing device platform by the policy provisioning module for example . At block the method is initiated by the detection of an electronic communication comprising a request or trigger to start policy provisioning for a domain. For example the method may be initiated by the policy provisioning module upon receipt of a new or updated candidate policy artifact which may have been integrity checked from a domain. At block the device platform compares the new or updated policy artifact to the minimum provisioning requirements for the domain described above. If the candidate policy artifact does not satisfy the minimum provisioning requirements the device platform determines at block whether the unsatisfied MPR can be overridden. If the unsatisfied MPR cannot be overridden the domain policy provisioning fails and the method ends. If the unsatisfied MPR is permitted to be overridden e.g. flagged as optional or suggested the method proceeds to block .

At block the MPR approved candidate policy artifact is added to the policy pool . The update to the policy pool triggers a re determination of the least restrictive conforming policy which occurs at block . An example of a method for making the LRCP determination is described in more detail below with reference to . Once the LRCP for all of the possible policy implementations in the policy pool has been determined they are merged to update the active device policy at block . The algorithms performed at blocks are designed to result in the reconciling of the new or updated policy artifact with all of the other domain policies existing on the device so that none of the policies violates the requirements or social contract of any of the other domain policies with in some cases the exception of those flagged as optional by the domain owner and stakeholders.

At block however the device platform determines whether the merging of the LRCPs was successful that is whether the new or updated policy artifact can be reconciled with the policy artifacts in the existing active device policy or whether the requirements of the new or updated policy artifact conflict with other aspects of the existing active device policy in a way that cannot be resolved by for example adopting a different policy implementation . If a conflict between the new or updated policy and the existing active device policy cannot be resolved in a manner that conforms to all of the domain policies a notification is generated e.g. an error or warning message . At block the device platform determines whether the conflict can be overridden in a similar manner as described above. If the conflict cannot be overridden the policy provisioning process ends unsuccessfully and the policy artifact is rejected. In some embodiments rejection of the new or updated policy artifact may require that the requesting domain not be policy provisioned on the device. If the conflict can be overridden the new or updated policy artifact is accepted into the active device policy and if not already policy provisioned the domain may be policy provisioned on the device. In some cases where a conflict is overridden the domain may be policy provisioned but with restrictions that allow it to exist without conflicting with any of the other domain policies. For example the domain may be permitted to load initialize or execute but not as a background process e.g. it can only be used active and only when other domains are not executing or active.

Referring to block the device platform determines whether to load a new or updated domain on the device in accordance with the policy artifact as accepted by the device platform . Such may be the case if the trigger for initiating domain policy provisioning is the receipt of a new or updated policy artifact for a domain or version thereof that does not already exist on the device. If only the policy artifact for the domain is updated and not the domain itself the method ends with the creation of the new or updated active device policy . If the domain issuing the policy artifact needs to be loaded or updated on the device the method adjusts the device configuration e.g. a list of all domains policy provisioned on the device to include the new or updated domain at block and loads and integrity checks the domain payload e.g. the operating system applications or other components of the domain at block . Integrity checks as mentioned in the context of the method may be performed by for example the integrity verification subsystem described above. At block the device platform determines whether the new or updated domain has been successfully loaded and if so the method ends with the generation of the new or updated active device policy and the new or updated device configuration. If the new or updated domain is not successfully loaded the device reconfiguration is reversed at block e.g. the domain and its associated policy artifact are removed from the device configuration and from the active device policy .

The LRCP engine considers the available implementation options for each domain and develops the active device policy by selecting implementation options for each domain that effectuate the purpose or policy of each domain without conflicting with the other domain purposes or policies. The event trigger handler may in some cases re engage the LRCP engine from time to time to reconfigure the active device policy as may be needed in response to event triggers caused by changes in the policy pool e.g. policy provisioning policy update deprovisioning .

Referring now to an illustrative method for generating a least restrictive conforming policy is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing device by the LRCP engine for example . At block the method is initiated by an electronic communication such as a notification that the policy pool has been updated with a new or updated policy artifact. The device platform begins by selecting the lowest cost implementation for each policy artifact and sorting all of the combinations of policy implementations e.g. implementations from the set of policy artifacts from least to greatest cost. This enables the device platform to consider the lowest cost implementations first and only consider higher cost implementations if an unresolvable conflict is found in the lower cost implementations. Cost as used herein may refer to a measurable parameter that may be reflected in a data value that is assigned or associated with each implementation . For example a lower cost may indicate a less restrictive policy option and vice versa.

At block the device platform begins the process of iteratively seeking the first e.g. lowest cost combination of policy implementation options e.g. candidate implementation options that do not conflict or whose conflict is mutually exclusive. Mutually exclusive as used herein refers to policy conflicts that occur in different contexts and thus are not true conflicts. For example two domains may have policy rules that specify when I am active I have exclusive access to the microphone. Initially these rules appear to conflict. However further analysis of the rule chains may indicate that one of the domains can only be active when the other domain is not active. Thus the conflict is mutually exclusive and the combination of the two policy implementation can be acceptable to both domains.

The iterative loops illustrate that each rule chain of each candidate implementation of each policy artifact of each domain is pairwise compared to determine whether a conflict exists starting with the lowest level of each rule chain blocks . If no conflict is found at the lowest level of the rule chains being compared the loop exits and the loop continues with examining the next rule chain combination in the current implementation combination. If the individual rule chain items being compared at block do potentially conflict then the loop is initiated to backward traverse the next lowest level in each of the rule chains being compared the parent pair . If the comparison of the parent pair indicates that the lower level pair conflict is mutually exclusive the loop exits and the loop continues on with examining the next rule chain combination in the current implementation combination. If the comparison of the parent pair does not indicate mutual exclusivity then the next lowest level parent pair is checked for mutual exclusivity. In the loop the rule chains are backward traversed until either mutual exclusivity is found or there is no higher level in the rule chains to compare. When the loop exits with a mutually exclusive determination the loop moves on to the next comparison of the rule chain items for the current implementation combination. If the loop exits with a determination that an unresolvable conflict exists the loop moves on to a comparison of the next implementation combination.

At block the device platform determines whether the current rule chain combination has a mutually exclusive conflict or no conflict . If the rule chain combination has a conflict that is not mutually exclusive the loop exits and the loop moves on to the next combination of implementation options. If the device platform determines at block that a mutually exclusive conflict exists between two candidate implementation options then the method ends with the found LRCP as the combination of such candidate implementation options. The loop iterates through all of the available candidate implementation options until it either finds a combination of implementation options that has a mutually exclusive conflict or finds a combination of implementation options that has no conflict. If no such combination is found after all possible combinations have been examined it is possible that the combination of domain policies may be unacceptable and need to be either rejected or accepted with revisions or acknowledgement of risk.

As described in more detail below with reference to the illustrative policy arbitration subsystem represents an executing instance of the policy arbitration subsystem which among other things defines the protocols for and in operation regulates the electronic communications between the domains and the virtualization service . The policy arbitration subsystem alone or in combination with one or more of the shared services mediates these communications in accordance with security policies that may be specifically applicable to the individual domains . Without requiring a priori component policies to be enforced cumulatively or additively at the global device level the system is enabled to enforce each domain s purpose and deny the corresponding anti purpose. For example the policy arbitration subsystem may enforce a domain policy that requires information flow controls to prevent data from a highly secure domain from leaking over into another less secure domain without proper encryption or other filtering e.g. to prevent private or confidential data from being sent off of the computing device platform through e mail or other services without VPN Virtual Private Network and a domain policy to prevent multiple domains from using a system resource at the same time. For instance rather than summing all of the domain policies to create a monolithic device policy the policy arbitration subsystem can enforce only the portions of each policy needing to be compliant according to the current operating context of the device.

As another example the policy arbitration subsystem may restrict access to particular hardware components by specific domains to deny an anti purpose of the system. In particular access by a domain to device drivers that control hardware components that are capable of capturing personal or confidential information like the camera phone GPS and microphone may be selectively restricted. In other words the policy arbitration subsystem may not only prevent data from leaking from highly secure to less secure domains but can also effectively control access to specific system resources based on a security policy or in response to real time information such as the current geographic location of the computing device platform the current time of day and or other aspects of the current context of the computing device platform that may be detected for example by sensors . For instance the policy arbitration subsystem may enforce a domain specific access policy that governs the use of a system resource or the transfer of data content from one domain to another domain based on the time of day location or based on a current context captured as a state of the computing device platform .

A component of the policy arbitration subsystem includes the detection of event triggered actions which may have originated from but are not limited to a user interaction i.e. buttons touchscreen an environmental change i.e. sensor change such as location or proximity network availability or connection changes in hardware i.e. enabling or disabling of hardware components battery state physics based policy or system operation e.g. policy provisioning policy updates . In some cases policy actions need to be enacted in order to control i.e. deny filter and downgrade similar items as those detected via triggers. Both of these functions may be provided via trusted components of the platform on device platform . As previously mentioned in some embodiments the communication channels between the policy arbitrator and these trusted components are well defined and not able to be spoofed or otherwise prevented or modified via an untrusted component. In some embodiments these tasks can be performed by the virtual service providers of those functions. Other embodiments may use components inline between the main virtual service provider and connected virtual service enabler . To minimize the specialized per service logic required by the policy arbitration subsystem some embodiments utilize these trusted components to perform the comparison of actions and triggers with others in order to detect conflicts and mutually exclusive scoping as discussed in more detail below with reference to the LRCP engine algorithm.

In cases where the active device policy is implicated by a domain triggered event or an event trigger the policy arbitrator determines an appropriate policy action as specified in the implementation include in the policy artifacts . The policy arbitrator communicates policy actions to the affected domains and communicates policy actions to the affected shared services . The policy actions generally include messages or instructions that can be interpreted by the recipient e.g. the domains or the shared services and executed e.g. by the trusted computing base in order to control one or more of the system resources to effectuate the policy or policies implicated by the event trigger . In some cases policy actions may be embodied as electronic communications between the virtual service providers and or the virtual service enablers .

Referring now to an illustrative method for enforcing a policy in response to an event e.g. a domain triggered event or an event trigger is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform or by the computing device by the policy arbitrator and or the event trigger handler for example . At block the method is initiated by an electronic communication indicating a request or trigger for policy enforcement such as a domain triggered event or an event trigger . At block the device platform determines whether the trigger causes a change to the current trigger rule set e.g. the trigger matches the head of an active rule chain. If the trigger changes the current trigger rule set the device platform updates the current set of trigger rules accordingly at block and then initiates the loop which iterates for all of the domains that are enabled on the device to determine whether operation of any of the domains is affected by the triggered action s completed by the policy enforcement. If the trigger does not change the current trigger rule set the device platform continues with normal runtime operation at block . In the loop each domain is checked beginning at block . At block a determination is made as to whether the domain s minimum runtime requirements are still satisfied in light of the occurrence of the triggered action s . If the domain s MRRs are not satisfied the device platform determines whether the domain is currently actively running at block . If the domain is not currently running no action is required with respect to that domain and the loop proceeds to evaluate the next domain. If the domain is currently running the device platform stops execution of the domain at block and displays output to the system domain or user interface to a limited set of the devices core functions including hardware and software state to indicate that the domain s MRRs are no longer satisfied at block . Among other reasons this can occur due to a required resource being restricted a domain being disabled or another system event. If at block the device platform determines that the domain s MRRs are satisfied in light of the triggered action s the device platform similarly determines whether the domain is currently actively running on the device at block . If the domain is currently running the device platform performs no action and the loop moves on to evaluate the effect of the triggered action s if any on the next domain. If the domain is not currently running the device platform may begin executing the domain in that its MRRs are satisfied at block and the loop continues on to evaluate the effect of the trigger if any on the next domain. This particular event can happen when a domain is marked as enabled as such event may act as a trigger in the platform s policy. When all of the enabled domains on the device have been evaluated as described above the device platform continues runtime operation until the next trigger at block .

Embodiments of the above described policy management techniques can provide dynamic finer grained policy control that has many potential applications. For example some embodiments of the policy arbitration subsystem can be used to supplement and extend existing static mobile device policies that are managed by mobile device management services and other third parties to a virtualized multiple personality mobile computing platform or mobile virtual appliance.

In one example a device platform includes integrated phone and microphone features. Also the exemplary device platform has two domains a personal domain and an enterprise domain. The personal domain has a domain policy that specifies that the enterprise domain is not permitted to listen in on telephone calls that the user receives when the calls are taken by the user with the device platform in the personal domain. In the illustrated example a phone call arrives and the user answers the call in the personal domain. The answering of the call acts as an event trigger. The policy arbitration subsystem receives the event trigger over a well defined communication channel as described above. The policy arbitration subsystem analyzes the active device policy and issues a policy action in the form of a disable microphone instruction for the enterprise domain. The policy arbitration subsystem sends the disable microphone instruction to the microphone virtual service provider. The microphone virtual service provider executes the command to disable the microphone only for the enterprise domain. As a result the user of the device platform is permitted to talk securely on the microphone in the personal domain without fear that the enterprise domain may also have access to the conversation. When the user ends the personal phone call the policy arbitration subsystem issues a policy action to the microphone virtual service provider to re enable the use of the microphone by the enterprise domain. In this way the static policy of don t allow the enterprise to listen to my personal calls is flexibly implemented by the policy arbitration subsystem.

In another example the device platform is again policy provisioned with a personal domain and an enterprise domain. Here the enterprise domain has a local policy that prohibits the user of the device platform from accessing certain intranet internet protocol IP addresses when they are on company property and are not using the enterprise domain. The device platform has wireless internet e.g. WIFI capabilities that allow it to automatically monitor for the presence of WIFI access points in the immediate geographic area. The domain local policy requires that intranet subnet access is restricted to only the enterprise domain when the device platform is connected to the company s WIFI access point. Further the enterprise policy prohibits the employee from recording video pictures or audio of proprietary information while on company property. In this case the event trigger handler of the policy arbitration subsystem detects that the device platform has connected to the company s wireless access point. In response the event trigger handler sends policy actions to the virtual service providers controlling the camera microphone and intranet access. In this example a policy action restricts only the personal domain intranet access while another policy action restricts all domains camera and microphone in response to the trigger event of the user having arrived on company property.

Once the user of the device platform leaves the company property the event trigger handler will no longer detect a connection to the corporate wireless access point. In response the policy arbitration subsystem verifies that no other existing policy artifacts in the active device policy require the restrictions that were required by policy action and then issues policy actions to the virtual service providers controlling the intranet access camera and microphone features of the device platform . In this way the policy arbitration subsystem selectively controls access to the system resources by multiple different domains.

Suppose that the domain owner in the previous example wants to further ensure no phones are allowed onto the corporate property unless it is assured that the company s policy is enacted on the device via the enterprise domain . When an employee arrives at work the device automatically connects to the corporate access point performs the policy restrictions i.e. camera and microphone makes the enterprise domain active foreground and for the user to approach the security checkpoint. At this point the security checkpoint initiates a prompt response query via the WIFI connection to the enterprise domain and a random color text or other response is shown to confirm connectivity and the appropriate policies are being enforced. To ensure the user does not deprovision the enterprise domain and thus policy some implementations may prevent deprovisioning while on corporate grounds require GPS access so that the deprovisioning can be reported against the user with their user coordinates via WIFI or other protective measures. Of course when the user is away from the corporate grounds these restrictions are not required and thus are not enforced thus allowing normal use of the user device platform .

The suite of tools disclosed herein extends to a number of embodiments platforms and devices. In this example the device being shared is a corporate cloud service which may include a server farm end user computers and mobile devices. In this system domains are created to both host isolated services based on project job other task specific as well as to provide remote connectivity to said services. The domains may be stored in a private domain store hosted on a secure server at the company s facility that provided secure connectivity to the various devices for deployment. Each of these domains includes their own policy artifact with accompanying multiple implementations which are designed to protect the company s interests. Furthermore each policy artifact may be created via the summation of all stakeholders i.e. company department project requirements as defined to protect the stakeholders individual interests. In addition to the previously discussed policy requirements i.e. subnet access and restriction requirements for performance i.e. CPU speed memory network speed data security i.e. site security data encryption storage on physically self destructive drives and system cohabitation restrictions i.e. only domains with a key based shared resources can also be on the device. These extra restrictions in addition to the authentication requiring deployment systems allows domain creators to not have to manually load each device and user but rather utilize the policy suite and accompanying policy to control the deployment. For example a mobile device could be allowed to policy provision a highly sensitive piece of information assuming it met the MPRs as the company has an assurance that the data is sufficiently protected e.g. the storage could be physically destroyed should the password be mis entered multiple times or the network command to delete wipe is issued. This can also ease the software management burden in the server farm as the virtualization service can automatically load balance the services based on their performance requirements. Furthermore high security elements can coexist in the cloud but be limited to highly physically secured servers. By enabling per domain policy creation the domain creators rather than the corporate device managers can define the domain specific security requirements for deployment.

The policy arbitration subsystem disclosed herein is by no means limited to benefitting only mobile device applications. For instance embodiments of the policy arbitration subsystem can be integrated into virtualized personal computer or server farm operating systems e.g. cloud based computing services .

Referring now to the illustrative domain manager subsystem is embodied as software firmware hardware or a combination thereof to perform domain activation switching and deactivation services during the operation of a computing device platform . The domain manager subsystem responds to user initiated domain triggers and or event triggers by activating and deactivating domains and by switching from one active domain to another in accordance with an applicable policy or policies of the computing device platform . As noted above embodiments of the domain manager subsystem or portions thereof may control or initiate control of shared system resources including hardware components in response to a domain activation or deactivation. For example access to a camera microphone or sensor data may be selectively restricted or enabled as part of a domain activation or deactivation handled by the domain manager subsystem .

In some embodiments the domain manager subsystem comprises a rule set of computer programming constructs e.g. both on and off device. For example the domain manager subsystem may define an application programming interface API or a suite of APIs or API extensions. The APIs may be implemented as a software library a software framework e.g. a collection of different software libraries implementing different APIs a protocol or set of protocols or another type of programming interface that allows computer programs to communicate with each other and with shared computing resources.

The illustrative domain manager subsystem represents an executing instance of the domain manager subsystem which defines rules and specifications for and in operation controls and manages the activation and deactivation of the domains globally e.g. at the computing device level. The domain manager subsystem can for example switch operation of the computing device platform from a highly sensitive domain e.g. an enterprise domain to a less sensitive domain e.g. a personal social use domain or vice versa in response to a triggering event e.g. dynamically or in real time . Such a triggering event may include for example the receipt of user input such as tactile or speech input a gesture a specific software command a user name and password etc. The detection of certain inputs from one or more of the sensors may also act as a triggering event. For example if the computing device platform detects based on sensor data that the user has entered a highly secure geographic area such as a corporate office or a research facility the domain manager subsystem may autonomously e.g. without requiring any user input disable the user s access to any less secure domains and only permit the user to access a highly secure domain on the computing device platform .

The domain manager subsystem regulates the activation and deactivation of the domains in accordance with the applicable domain and or device policies. In response to the activation or deactivation of a domain by the domain manager subsystem access may be restricted to particular hardware components by specific domains to deny an anti purpose of the system or an activated domain. In particular access by a domain to device drivers that control hardware components that are capable of capturing personal or confidential information like the camera phone GPS and microphone may be selectively restricted. In this way data can be prevented from leaking from highly secure to less secure domains and access to specific system resources can be controlled based on a policy or in response to real time information such as the current geographic location of the computing device platform the current time of day and or other aspects of the current context of the computing device platform that may be detected for example by sensors .

In addition communication channels may be controlled in response to the activation or deactivation of a domain to provide for the downgrading or filtering of information on such channels to different domains. As an example if a security vetted domain is activated the security vetted domain may be permitted to receive highly accurate geographic location values from a GPS but other un vetted domains may be only permitted to receive rough approximations of the same geographic information.

Referring now to the illustrative domain manager subsystem is embodied as a number of computerized components or modules that in some embodiments may exist within an isolated domain e.g. APIs physics based controls firmware etc. that can dynamically and selectively activate and deactivate domains on the computing device platform as described in more detail below. As used herein activate may refer to among other things the process of launching a domain for execution by the computing device platform whether as an active domain e.g. where the domain is running in the foreground enabling user interaction with the domain or another type of executing domain e.g. where the domain is running as a background process where user interaction with the domain is not enabled . Similarly as used herein deactivate may refer to among other things the process of temporarily freezing execution of a domain or closing a domain by ending its execution whether foreground or background . Where a domain is temporarily frozen by the domain manager subsystem e.g. as a result of the policy implications of activating another domain such freezing may be accomplished by for example transferring the execution of the domain to a passive or background mode in which the domain is temporarily denied privileges to access and use one or more of the shared system resources in accordance with the applicable policy. Such freezing or deactivating operations may be accomplished by for example the domain manager subsystem in communication with the virtualization service or by the domain manager subsystem in communication with one or more of the shared services e.g. via the policy arbitration subsystem .

The illustrative domain manager subsystem is embodied as a domain manager which includes a domain activation trigger handler a domain initialization module a domain activation module a user interface UI configuration module and a domain deactivation module . The domain activation trigger handler communicates with a user control to receive the user initiated domain triggers . The domain activation trigger handler also communicates with e.g. shared services such as virtual service providers to receive the event triggers . Further the domain manager subsystem communicates with the policy arbitration subsystem to receive policy actions in response to policy triggers which may be initiated by the domain manager e.g. as a result of the activation initialization or deactivation of a domain .

The domain activation trigger handler applies policy rules to the user initiated domain triggers and event triggers to determine whether to activate or deactivate any domains in response to the triggers and to determine which if any shared system resources need to be controlled in response to the activation or deactivation as the case may be of a domain. In the illustrative embodiment such policy rules are supplied to the domain activation trigger handler by the policy arbitration subsystem in the form of policy actions . Some techniques for determining policy actions are described in more detail above and in the aforementioned Forsberg et al. U.S. application Ser. No. 14 052 080.

If a domain is to be activated in response to a trigger domain initialization and domain activation modules initialize and activate the domain in accordance with the applicable policy of the domain which in some cases is combined and reconciled with the policies of other domains on the computing device platform in a least restrictive conforming way. As described in the aforementioned Forsberg et al. U.S. application Ser. No. 14 052 080 least restrictive conforming may refer to among other things a policy that is determined by a process of synthesizing the policies of multiple domains of a computing device such that each domain s respective policy is satisfied in a least restrictive way. To do this each domain s policy may include a number of different implementation options e.g. to achieve a particular purpose and prevent an anti purpose . The different implementation options of the policies may be dynamically selected and implemented depending on the requirements of other domain policies and or the current operating context of the computing device platform . If a domain is to be deactivated in response to a trigger a domain deactivation module deactivates the domain similarly in accordance with the applicable policy of the domain which in some cases is combined and reconciled with the policies of other domains on the computing device platform in a least restrictive conforming way .

The UI configuration module updates a user interface of the computing device platform e.g. a visual display screen to communicate to the user information relating to domain activations as they occur. Alternatively or in addition the UI configuration module may issue audio or tactile notifications or utilize any suitable means of interacting with a user of the computing device platform to communicate to the user information relating to the current status of the device in terms of activated and or deactivated domains the occurrence of a switch from one activated domain to another and or other domain related information. In some embodiments a colored border or frame may appear on a display screen of the computing device platform or the background of the visual display may change to indicate that a domain change has occurred or that a certain domain is active. For example a red border may indicate that a highly restrictive domain is active while a green or blue border may indicate that a less restrictive domain is active where highly restrictive or less restrictive may indicate the degree to which other domains are prevented from using shared system resources while the domain is running . Some examples of domains that may be considered highly restrictive include mobile virtual appliance applications that are specifically designed to control the operation of or communicate with smart homes e.g. home security systems consumer appliances climate control systems etc. vehicles machines and or electromechanical devices such as medical devices physiological monitors and healthcare equipment or applications that require access to sensitive information such as financial medical and health related applications or domains that are designed for use by children or young adults. Some examples of domains that may be considered less restrictive in the sense that the domains may not require the use of shared system resources to be restricted for other domains while the domain is active include for example general purpose domains and domains that are used primarily for browsing or reading e.g. Internet surfing e readers etc. general social media communications or entertainment.

As noted above such switches from one domain to another may be initiated by the user or by other events detected by the computing device platform . In the illustrative embodiment a user control or a number of user controls provide the mechanism by which the user may initiate a domain activation or deactivation. In general the user control provides a user authenticated trust path interface in that signals received by the domain manager from the user control can be trusted as having been generated in response to input by an authorized user of the computing device and such that the signals generated in response to the user input can be trusted as not having been tampered with in an unauthorized way prior to receipt by the domain manager . As such the user control may be embodied as a virtual or physical user touch tap or gesture based control such as a touchscreen graphical control or a physical push button slide dial switch etc. as a voice based control e.g. microphone or image based control e.g. camera detecting facial characteristics including human eye features and gaze . In some embodiments software or firmware based biometric authentication techniques such as fingerprint recognition face or iris recognition or voice biometrics may be used in combination with the user control to establish user authentication. Well defined communication channels as described above may be used to provide the trusted path from the user control to the domain manager . Illustrative embodiments of the user control are shown in described below.

Referring now to an illustrative method for starting a computing device platform provisioned with one or more domains is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform by the domain manager for example . At block the method is initiated by the power on of the device platform . At block the trusted computing base of the device platform e.g. the virtualization service and or one or more of the shared services performs component based purpose provisioning and or domain policy provisioning to for example check and install any updates to the device platform including any updates to the domains or their respective components purposes and or policies. Some examples of mechanisms for provisioning the device platform and or its components are described in the aforementioned Forsberg et al. U.S. application Ser. No. 14 051 080 and the aforementioned Oberg et al. U.S. application Ser. No. 14 051 923.

At block core services that are needed for the operation of the device platform are loaded into memory e.g. memory . The core services that are loaded at block may include for example one or more of the virtual service providers and or one or more of the virtual service enablers . For instance if the device platform is provisioned with a financial services domain the financial services domain may require use of the device s camera e.g. to photograph checks for deposit . As such a virtual service provider for the access and use of the camera may be loaded at block .

At block the device platform loads the platform user interface into memory and displays the platform user interface on a visual display of the device platform . The platform user interface may display for example a splash screen with a logo and or a listing of the domains that have been provisioned on the device platform but which are not yet active . At block the device platform determines the default domains that is the domains that are to be activated automatically upon start up of the device e.g. in the absence of any triggers or policy actions dictating otherwise . Once the default domains are determined the device platform enters an iterative loop to activate each of the identified default domains blocks . While illustrated as a loop it should be understood that the activation of domains may occur concurrently or in parallel rather than sequentially in some cases. Some examples of procedures that may be executed by the device platform for activating the domains are illustrated in described below. Following activation of the default domains the device platform begins or resumes normal runtime operation at block .

Referring now to an illustrative method for activating a domain or more specifically a domain that implements a mobile virtual appliance on a general purpose or multi purpose device is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform by the domain manager for example . At block the method is initiated during device startup as described above or during normal runtime operation of the device platform e.g. by the detection of a trigger . At block the device platform determines that the trigger for domain activation includes an activation request to activate a mobile virtual appliance MVA where the request has been authenticated. That is the device platform has received a request to activate a mobile virtual appliance e.g. a mobile device implementation of a polymorphic virtual appliance and the source of the request e.g. a user or a sensing device has been authenticated. Such authentication may be performed by for example the integrity verification subsystem . In general a polymorphic e.g. mobile virtual appliance may refer to a type of domain that is configured to cause a computing device to perform a single dedicated function or set of functions that are related to a single purpose. For convenience MVA may be used herein to refer to such polymorphic e.g. mobile virtual appliances. Some examples of polymorphic e.g. mobile virtual appliances may include device control applications such as medical device control applications and or others. At block the device platform reviews the rule set or policy associated with the polymorphic e.g. mobile virtual appliance and verifies that the current operating context of the device platform complies with the MVA rule set policy. As an example an MVA rule set for a medical device MVA may stipulate that no other domain can have network connectivity while the medical device MVA is running. As another example an MVA rule set for a bank MVA may require that no other domain can use the device s camera while the bank MVA is in use or at least while the deposit feature of the bank MVA is in use. If the device s current context violates the MVA s rule set then appropriate actions are taken by the device platform to conform the current operating context to the MVA s rule set. This may involve deactivating one or more other domains partially or fully disabling certain shared system resources for some domains and or enabling certain shared system resources for exclusive use by the MVA as described above.

At block the selected requested MVA is activated assuming access and use of the shared system resources is successfully configured and controlled as required by the MVA s rule set or policy . To do this the device platform may launch the MVA e.g. in a similar manner to which software applications are typically launched or activated by an operating system. In some embodiments the device platform may perform policy provisioning on the MVA prior to its activation as described below with reference to . At block a visual display of the device platform is updated e.g. by changing a border or background color etc. as described above or some other action is generated by the device platform to communicate the activation of the MVA to the user of the device platform . The device platform continues normal runtime operation now acting solely as the MVA however and not as a general purpose device at block . In this way the method can effectively transform the general purpose or multi purpose device platform into a specific purpose MVA at least temporarily.

Referring now to another illustrative method for activating a domain is shown. The method may be embodied as computerized programs routines logic and or instructions executed by the computing device platform by the domain manager for example . At block the method presents a notification of domains that are available for activation to the user e.g. as a list displayed on a display screen of the computing device platform . In some embodiments the available domains may include domains that are not yet provisioned on the computing device platform . For example the method may periodically ping or receive notifications from one or more cloud based app stores or app markets as to new or updated domains that are available. At block the device platform receives a domain selection or request which may take the form of for example a user initiated domain trigger or an event trigger . For instance the user may select a domain from an app store or a domain may be selected as a result of a context trigger such as the detection by the device platform of a wireless communication with another device e.g. a WIFI communication from a medical device a smart TV or some other networked device .

At block the method determines whether the selected requested domain is already provisioned e.g. installed and configured for use in accordance with applicable policies on the device platform . If the domain is not already provisioned on the device platform policy provisioning and or component purpose provisioning is performed at block . Some examples of techniques for policy provisioning and componentized purpose provisioning a domain on a device are described above. For example in some embodiments the domain s policy may be combined and reconciled with the policies and or component purposes of other domains on the device platform or with an existing device policy or component purpose as mentioned above. At block the device platform determines whether any of the selected requested domain s policy ies or purpose s conflict with the existing device policy or with any of the policies or purposes of the other domains on the device platform . The domain s policy or purpose may conflict with another policy or purpose if for example both domains require exclusive access to a shared system resource at the same time. If the provisioning concludes that there are no policy or purpose conflicts the method proceeds to block . If the provisioning concludes that the selected requested domain s policy or purpose conflicts with one or more other policies or purposes governing the operation of the device platform the method may deactivate the domains having conflicting policies purposes or allow the user or another higher privileged authority to override the conflict block and continue with the domain initialization block . In general domain initialization involves executing procedures on the computing device platform to load the domain into memory and make it available for execution.

In some embodiments or contexts of component purpose provisioning deactivating may simply mean the revoking of privileges or security contexts to certain tasks or events as opposed to stopping execution of the task or event. For example a domain can be a simple or complex multiple task event execution environment that may have the ability to be deactivated e.g. stopped if running descheduled or marked as unavailable to run . However a task event once purpose permitted accepted may only be able to be revoked if the security context purpose trust token etc. has not already left the device platform s control e.g. if the security context or component resource has not already been shared transferred to an external party network . If the task or event is still being executed on the device platform the platform could revoke the security context effectively pulling the rug out from the task event as it is being processed handed but in some cases this may be possible only if the task event has not been given full access to the security context.

If at block the domain is already provisioned on the device platform the method proceeds to block where it determines whether the domain is already initialized. If the domain has not been initialized initialization is performed at block as described above. If the domain has already been initialized or if initialization is determined successful block the device platform sets a domain state flag to indicate that the domain is enabled or activated block updates the domain activation status on the user interface of the device platform block and begins or continues normal runtime operation of the domain block . If the domain initialization is not successful e.g. if the domain is not successfully loaded due to an integrity check failure the domain activation fails and a communication to that effect is generated at block .

During runtime operation of the domain block various event triggers e.g. policy triggers purpose triggers context triggers etc. may occur from time to time on the computing device platform . Such event triggers may include user initiated and or system detected events that implicate one or more of the domain policies and or component purposes that are currently active on the device platform . Such events may include for example connection of the device platform to a certain wireless access point location of the device platform in a geofenced area or the sending of an electronic communication to a particular email address or to another device. A policy purpose trigger handler handles the policy purpose event triggers as described above for example e.g. policy enforcement and or purpose enforcement . The handling of policy purpose event triggers may involve a change in the status of the domain activation. For example a policy purpose event trigger may implicate a policy that requires the domain s access or use of certain shared system resources to be modified enabled or disabled in which case the necessary changes are implemented and the method returns to block . While not specifically shown it is of course possible that in some cases a policy purpose event trigger may require the domain to be deactivated. In these cases the domain is deactivated the domain state flag is set to disabled or deactivated and the domain status is updated.

The foregoing methods are simplified for discussion purposes but it should be understood that the device platform may undertake any of the foregoing methods or processes or blocks or steps thereof concurrently or in parallel e.g. for each of the executing domains . For example the device platform may perform an analysis of any triggers that it receives from any or all of the domains in whatever order or sequence they may occur.

Referring now to embodiments of the above described domain management techniques can provide finer grained context aware control over the use of shared system resources in response to domain activations and deactivations which has many potential applications. In a general purpose or multi purpose mobile computing device is embodied to include a housing made of a rigid or non rigid material e.g. plastic metal glass or a combination thereof . The housing supports a display screen a number of sensors e.g. optical sensor microphone accelerometer etc. and a number of user controls . In the display screen graphically displays a frame or border and a number of user selectable icons or tiles . Each of the icons or tiles represents a domain that is available for use on the device and can be selectively activated by the user or by an event trigger. The illustrative user control is embodied as a rotatable member e.g. a dial or wheel which can be rotated in either a clockwise or counterclockwise direction as indicated by the bidirectional arrow . The illustrative user controls are embodied as touch sensitive buttons e.g. push buttons . In some embodiments the user control is operable to switch between active domains. For example if the bank domain is activated rotating the control in a clockwise direction may operate to deactivate the bank domain and activate the health plan domain . Along with the activation of the domain and deactivation of the domain such rotation of the control also accomplishes the necessary changes to the access and use of shared system resources in accordance with the applicable domain policies e.g. the policy of the on coming domain . The user controls in some embodiments respectively enable navigation within an active domain and navigation out of an active domain back to the home screen e.g. .

The frame or border may be displayed in a specific color or pattern for example to indicate the status of the device platform as having one or more particular domains active. Such display may be dynamically changed as the active domains change. Further as shown in the display of certain domains may be configured to indicate the status of the domain. For example the display of the enterprise domain may be emphasized to indicate that it is currently active while the display of the bank domain may be displayed with a contrasting color border represented by dashed lines to indicate that it is not currently active but is currently selected e.g. by the wheel or dial .

As shown in selection of the bank domain e.g. via the wheel or dial results in the activation of the bank domain . Activation of the bank domain transforms the multi purpose device into a specific purpose device or mobile virtual appliance MVA . That is while the bank domain is activated the device cannot be used for another purpose e.g. to access one s health plan or personal domain. Of course in some embodiments portions of the device may still be used for other limited purposes in accordance with the applicable policy. For example the device s phone may continue to receive telephone calls if permitted by the MVA s policy. In accordance with the domain change the frame or border is changed to a different color or pattern . Additionally user selectable graphical controls are presented for each of the various domain specific functions of the bank domain . A camera icon is displayed in connection with the deposit feature to indicate that use of the device s camera is available when the deposit feature is activated but not available for any of the other features .

Referring now to an illustrative computing system includes a mobile virtual appliance and domain manager subsystem embodied in a computing device and a device control system embodied in another device . In the illustrative embodiment the computing device is embodied as a general purpose or multi purpose mobile computing device such as a smartphone tablet wearable device etc. while the computing device is embodied as an MVA controlled device e.g. another device that is not a general purpose or multi purpose computing device. The devices are in communication with each other via one or more networks . For example the network s may communicatively couple the computing devices to each other and or to other computing devices and or systems by for example a cellular network a local area network wide area network personal cloud virtual personal network VPN enterprise cloud public cloud and or public network such as the Internet or by short range wireless communication e.g. Near Field Communication or NFC . The illustrative computing devices and the network are depicted in simplified form for ease of discussion. It should be understood that either or both of the computing devices may be configured in a similar manner to the computing device platform and have one or more similar components thereto. For example the computing device and or the computing device may include all or a subset of the components of the computing device platform . In general the components of the computing system having similar or identical names to components shown in and or described above may be embodied in a similar fashion to the corresponding components described above. As such reference is made here to the foregoing description and such description is not repeated here.

The mobile virtual appliance is embodied as a specific purpose domain that is configured specifically to control the operation of the MVA controlled device as described above. For example the MVA may be embodied as a user level glucose monitor control application such that when the MVA is activated on the general purpose or multi purpose computing device the device is temporarily transformed into a glucose monitor control capable of interacting with the user only for the purpose of communicating with and controlling the operation of the MVA controlled device e.g. a glucose monitoring device . To do this the domain manager subsystem implements the MVA rule set as described above to deactivate any other active domains while the MVA is activated and enables exclusive access by the MVA to the communication subsystem and UI devices which effectuate communications between the user and with the device control system . With assurance that the computing device is only operating as the MVA during the time that the MVA is active being provided by e.g. a MILS based architecture the system allows for among other things validation of the MVA without requiring validation of the entire device .

The domain manager systems disclosed herein are by no means limited to benefitting only mobile device applications. For instance embodiments of the disclosed domain manager subsystem can be used in connection with for instance virtualized personal computer or server based systems including cloud based computing services.

In accordance with at least one aspect of this disclosure a computing device includes a processing unit including one or more hardware processors a context detector in communication with the processing unit to receive data indicating a current operating context of the computing device shared system resources in communication with the processing unit the shared system resources comprising one or more of a telephony subsystem a camera subsystem and a network subsystem machine accessible storage media and a plurality of well defined communication channels operably coupling the processing unit with the context detector the shared system resources and the machine accessible storage media wherein the machine accessible storage media has embodied therein a plurality of isolated independently executable domains each domain having a domain specific purpose governing use by the domain of the shared system resources the domain specific purpose being different for each of the domains and wherein the processing unit monitors the current operating context of the computing device and for each of the domains enables the domain to use the shared system resources if the current operating context of the computing device does not conflict with the domain s domain specific purpose and disables the domain s use of one or more of the shared system resources if the current operating context conflicts with the domain specific purpose.

The processing unit may maintain data relating to the domain specific purposes of all of the domains and for each of the domains may enable the domain to use the shared system resources if the current operating context of the computing device does not conflict with any of the domains domain specific purposes and disables the domain s use of one or more of the shared system resources if the current operating context conflicts with any of the domains domain specific purpose. The processing unit may modify without fully disabling the domain s use of one or more of the shared system resources if the current operating context conflicts with the domain specific purpose. The processing unit may cause data to be shared by the domain with another entity to be modified before the data is shared by the domain with the other entity if the current operating context conflicts with the domain specific purpose. The processing unit may prevent data from being shared by the domain with another domain on the computing device if the current operating context conflicts with the domain specific purpose. The processing unit may enable data to be shared by the domain with another domain on the computing device if the current operating context does not conflict with the domain specific purpose.

In accordance with at least one aspect of this disclosure a method for activating an executable component on a polymorphic computing device includes with the polymorphic computing device receiving data indicating a current operating context of the polymorphic computing device and in response to the data independently of any operating system running on the polymorphic computing device verifying the integrity of the component determining a defined purpose of the component determining an anti purpose corresponding to the defined purpose of the component determining if a use of the component in the current operating context is permitted by the purpose determining if the current operating context enables the use of the component for the anti purpose and activating the component on the polymorphic computing device only if the use of the component in the current operating context is permitted by the purpose and the current operating context does not enable the use of the component for the anti purpose.

The method may include receiving natural language input from a user of the polymorphic computing device determining the purpose based on the natural language user input and deriving the anti purpose from the purpose. The method may include determining if a use of a shared system resource of the polymorphic computing device by the component in the current operating context is permitted by the purpose determining if the current operating context enables the use of the shared system resource for the anti purpose and enabling use of the shared system resource by the component only if the use of the shared system resource by the component in the current operating context is permitted by the purpose and the current operating context does not permit the use of the shared system resource for the anti purpose. The method may include disabling the use of the shared system resource by the component if the use of the shared system resource by the component in the current operating context is not permitted by the purpose and the current operating context permits the use of the component for the anti purpose. The method may include determining if a sharing of data by the component with another entity in the current operating context is permitted by the purpose determining if the current operating context would permit the sharing of the data by the component for the anti purpose and enabling the sharing of the data by the component only if the sharing of the data by the component in the current operating context is permitted by the purpose and the current operating context does not permit the sharing of the data for the anti purpose. The method may include preventing the sharing of the data by the component if the sharing of the data by the component in the current operating context is not permitted by the purpose and the current operating context permits the sharing of the data for the anti purpose.

In accordance with at least one aspect of this disclosure a polymorphic computing device includes a processing unit comprising one or more processors one or more context detectors in communication with the processing unit to receive data indicating a current operating context of the polymorphic computing device shared system resources in communication with the processing unit and machine accessible storage media having embodied therein a plurality of independently executable domains each domain having a domain specific purpose governing use by the domain of the shared system resources and a plurality of components executable within the domain each component comprising a component specific purpose governing the sharing of component resources by the component with other components an integrity verification system to verify the integrity of each of the domains and components independently of any operating system running on the polymorphic computing device a provisioning system to provision each of the components for use on the polymorphic computing device independently of the provisioning of the other components and according to the component specific purpose a policy arbitration system to determine a global policy for use of the shared system resources by the domains wherein the global policy is a combination of all of the domain specific purposes that does not violate any of the domain specific purposes and the policy arbitration system enforces the global policy during operation of the polymorphic computing device and a domain manager to activate and deactivate the domains on the polymorphic computing device in accordance with the global policy wherein the processing unit selectively executes the domains the components the integrity verification system the provisioning system the policy arbitration system and the domain manager in response to the data indicating a current operating context of the polymorphic computing device.

In the polymorphic computing device both the domain specific purpose and the component specific purpose may be defined differently for different operating contexts of the polymorphic computing device. In the polymorphic computing device the domain specific purposes may be different for each of the plurality of domains. In the polymorphic computing device the component specific purposes may be different for each of the plurality of components. In the polymorphic computing device each domain may have a domain specific anti purpose corresponding to the domain specific purpose and the policy arbitration system may enforce the global policy to prevent execution of the domain specific anti purposes. In the polymorphic computing device each component may have a component specific anti purpose corresponding to the component specific purpose and the provisioning system may provision each of the components for use on the polymorphic computing device to prevent execution of the component specific anti purpose. The polymorphic computing device may be arranged according to a Multiple Independent Levels of Security MILS architecture where each of the domains is memory isolated from each of the other domains and each of the domains communicates with other domains only through well defined communication channels. The polymorphic computing device may comprise a mobile computing device arranged according to a mobile device virtualization architecture.

In the foregoing description numerous specific details examples and scenarios are set forth in order to provide a more thorough understanding of the present disclosure. It will be appreciated however that embodiments of the disclosure may be practiced without such specific details. Further such examples and scenarios are provided for illustration and are not intended to limit the disclosure in any way. Those of ordinary skill in the art with the included descriptions should be able to implement appropriate functionality without undue experimentation.

References in the specification to an embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is believed to be within the knowledge of one skilled in the art to effect such feature structure or characteristic in connection with other embodiments whether or not explicitly indicated. For instances features structures and characteristics having the same or similar names but shown in multiple figures and or embodiments with different reference numerals may have any of the features structures or characteristics of the other similarly named elements whether or not explicitly stated.

Embodiments in accordance with the disclosure may be implemented in hardware firmware software or any combination thereof. Embodiments may also be implemented as instructions stored using one or more machine readable media which may be read and executed by one or more processors. A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computing device or a virtual machine running on one or more computing devices . For example a machine readable medium may include any suitable form of volatile or non volatile memory.

Modules data structures and the like defined herein are defined as such for ease of discussion and are not intended to imply that any specific implementation details are required. For example any of the described modules and or data structures may be combined or divided into sub modules sub processes or other units of computer code or data as may be required by a particular design or implementation.

In the drawings specific arrangements or orderings of schematic elements may be shown for ease of description. However the specific ordering or arrangement of such elements is not meant to imply that a particular order or sequence of processing or separation of processes is required in all embodiments. In general schematic elements used to represent instruction blocks or modules may be implemented using any suitable form of machine readable instruction and each such instruction may be implemented using any suitable programming language library application programming interface API and or other software development tools or frameworks. Similarly schematic elements used to represent data or information may be implemented using any suitable electronic arrangement or data structure. Further some connections relationships or associations between elements may be simplified or not shown in the drawings so as not to obscure the disclosure.

This disclosure is to be considered as exemplary and not restrictive in character and all changes and modifications that come within the spirit of the disclosure are desired to be protected.

