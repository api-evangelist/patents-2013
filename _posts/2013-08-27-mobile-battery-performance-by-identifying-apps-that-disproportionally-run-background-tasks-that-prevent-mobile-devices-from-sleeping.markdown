---

title: Mobile battery performance by identifying apps that disproportionally run background tasks that prevent mobile devices from sleeping
abstract: Power consumption on a mobile computing device is reduced, by identifying and managing apps that prevent the mobile device from sleeping while the screen is off. It is detected when the screen is turned off and when it is subsequently turned back on. During the ensuing period of time, it is determined which specific apps prevent the mobile device from sleeping. This can take the form of identifying each specific app on the mobile device that has an unreleased wake lock at any point during the given period of time while the screen is off. The prevention of the device from sleeping while the screen was off is quantified by app according to power consumption, based on factors such as duration. Any apps for which the quantified prevention of the mobile device from sleeping while the screen was off meets a specific threshold are identified and managed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09229522&OS=09229522&RS=09229522
owner: Symantec Corporation
number: 09229522
owner_city: Mountain View
owner_country: US
publication_date: 20130827
---
This disclosure pertains generally to managing mobile battery performance and more specifically to improving battery performance on mobile computing devices by identifying and managing apps that disproportionally prevent the mobile device from sleeping when the screen is off.

Mobile computing devices such as smartphones and tablets are becoming more widely used every day. Android is an open source Linux based operating system for such mobile devices. Android which continues to gain increasingly prevalent market share accounted for approximately 80 of all smartphones shipped in the second quarter of 2013. A large community of developers write applications apps that run on Android devices. Many Android apps are available either for purchase or for free through Google Play formerly known as Android Market . Android apps can also be downloaded from other online stores and additional third party sites.

In addition to phone and Wi Fi connectivity current mobile computing devices are typically equipped with a variety of popular features such as a web browser a digital camera and apps to manage a library of photographs and videos sound input output hardware and apps for managing a library of audio recordings Bluetooth NFC apps for interacting with social media sites apps for reading print media etc. These devices are also generally equipped with a GPS and many apps provide services to users based on current physical location. The devices can also include input hardware such as an accelerometer gyroscope and proximity sensor which can be used to control and customize interaction with the user in a wide variety of different ways. Thus a current mobile device puts a great deal of computing power in the user s pocket or purse.

Current mobile computing devices require a significant amount of power to run and are powered by rechargeable batteries. A mobile computing device s battery is charged by connecting the device to an external power source such as a wall socket via a USB connection and an adaptor. An external power source is not always available and even when it is charging a mobile device can be inconvenient for the user. Generally improvements in mobile batteries have lagged behind developments in processors and other mobile computing technology. The limited capacity of the battery can be a weak point in the capabilities of a mobile device. With the intensive power demands of mobile devices many users find that the amount of time for which battery power is available between changes is less than ideal. Therefore it is desirable to conserve power to the extent practicable and not drain the battery any faster than necessary.

For this reason Android uses a sleep mode in which the screen is turned off and the operations of the system are suspended. This significantly decreases power consumption and thus prolongs the battery life. Android puts a device into sleep mode after a given amount of time has passed without activity or in response to an indication from the user typically a quick press of the power switch . However Android allows apps to run background tasks when the screen is off and the mobile device would otherwise be in sleep mode which can be useful but also draws power. It is desirable for some background activity to occur during these times. For example a user may want to continue listening to music even after the screen times out in response to no user activity occurring for a given period of time which requires that the music player continues to operate in the background with the screen off. As another example a phone might be configured to periodically pull e mail from a server when the screen is off and the phone would otherwise be sleeping. However if background tasks are run too often or for too long the battery can be drained significantly when the device is supposed to be sleeping. Some badly designed apps prevent the mobile device from sleeping in order to run their own background tasks without proper regard for power consumption and thus run down the battery while the phone is meant to be in sleep mode.

Power consumption on a mobile computing device is reduced by identifying and managing apps that disproportionally prevent the mobile computing device from going into sleep mode while the screen is off. It is detected when the screen of the mobile computing device is turned off and when it is subsequently turned back on. During the ensuing period of time while the screen is off it is determined which specific apps on the mobile computing device prevent it from sleeping. This can take the form of identifying each specific app on the mobile computing device that has an unreleased wake lock at any point during the given period of time while the screen is off. For example the wake lock status of each app on the mobile computing device can be read in response to the screen being turned off such that each specific app that is holding a wake lock at that time is identified. While the screen is off all wake lock acquisitions and wake lock releases by specific apps can be detected. The wake lock status of each app can be read again in response to the screen being turned back on to identify each app that is holding a wake lock then. This information unearths all apps on the mobile computing device that prevented it from sleeping during the given period of screen off time. The wake locks in question can be of a type which prevents the CPU from sleeping but allows the screen to be turned off such as those of Android type PARTIAL WAKE LOCK. A reflection API e.g. the Android Java reflection API can be used to glean this type of information concerning specific apps on the mobile computing device preventing it from sleeping while the screen is off.

For each app determined to have prevented the mobile computing device from sleeping while the screen was off the prevention by that specific app is quantified according to power consumption. For example the length of time during which each app prevented the mobile computing device from sleeping while the screen was off can be determined and the quantification can be based on these lengths of time since the longer the device is prevented from sleeping the greater the power that is consumed all else being equal. These lengths of time can be determined by flagging a start and an end of each period of time that each specific app prevents the mobile device from sleeping while the screen is off based on reading a system time counter a when the screen is turned off b whenever a wake lock is acquired by an app while the screen is off c whenever a wake lock is released by an app while the screen is off and d when the screen is turned back on. If a single app prevents the device from sleeping for multiple separate periods of time during a single period of time when the screen is off the lengths of each of these separate periods are added to calculate the total length of time for that app. In other embodiments the quantification can be based on additional factors instead of or in addition to duration. For example usage of specific resources and execution of specific operations associated with power consumption can be monitored and an app s prevention of the mobile computing device from sleeping can be quantified based at least in part on these activities.

Any apps for which the quantified prevention of the mobile computing device from sleeping while the screen was off meets a specific threshold are identified and at least one further action is taken to manage these apps. For example information concerning an identified app s prevention of the mobile computing device from sleeping while the screen is off can be output to the user of the mobile computing device and or transmitted to a central server for tracking. Instead or in addition an identified app can be blocked from preventing the mobile computing device from sleeping while the screen is off in the future for example by killing the app when the screen is turned off.

The features and advantages described in this summary and in the following detailed description are not all inclusive and particularly many additional features and advantages will be apparent to one of ordinary skill in the relevant art in view of the drawings specification and claims hereof. Moreover it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter resort to the claims being necessary to determine such inventive subject matter.

The Figures depict various embodiments for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein.

Clients and servers can be implemented using computer systems such as the one illustrated in and described below. The clients and servers are communicatively coupled to a network for example via a network interface or modem as described below in conjunction with . Clients are able to access applications and or data on servers using for example a web browser or other client software not shown . Clients can be in the form of desktop laptop computers or various types of mobile computing devices . A mobile computing device can be in the form of any portable computer system capable of connecting to a network and running applications. Such mobile computing devices are sometimes referred to as smartphones although many mobile phones not so designated also have these capabilities. Tablet computers are another example of mobile computing devices . A laptop computer is also a form of mobile computing device albeit one with somewhat less convenient portability.

Although illustrates three clients and two servers as an example in practice many more or fewer clients and or servers can be deployed. In one embodiment the network is in the form of the Internet. Other networks or network based environments can be used in other embodiments.

Other components not illustrated may be connected in a similar manner e.g. document scanners digital cameras printers etc. . Conversely all of the components illustrated in need not be present e.g. smartphones and tablets typically do not have optical disk drives external keyboards or external pointing devices although various external components can be coupled to mobile computing devices via e.g. USB receptacles . The various components can be interconnected in different ways from that shown in .

The bus allows data communication between the processor and system memory which as noted above may include ROM and or flash memory as well as RAM. The RAM is typically the main memory into which the operating system and application programs are loaded. The ROM and or flash memory can contain among other code the Basic Input Output system BIOS which controls certain basic hardware operations. Application programs can be stored on a local computer readable medium e.g. hard disk optical disk and loaded into system memory and executed by the processor . Application programs can also be loaded into system memory from a remote location i.e. a remotely located computer system for example via the network interface or modem . In the sleep mode preventing app management system is illustrated as residing in system memory . The workings of the sleep mode preventing app management system are explained in greater detail below in conjunction with .

The storage interface can be coupled to one or more hard disks and or other standard storage media . The hard disk s may be a part of computer system or may be physically separate and accessed through other interface systems.

The network interface and or modem can be directly or indirectly communicatively coupled to a network such as the Internet. Such coupling can be wired or wireless.

As illustrated in a sleep mode preventing app management system runs on a mobile computing device e.g. a smartphone or tablet and identifies apps that disproportionally run background tasks when the mobile computing device is supposed to be sleeping. By identifying which apps are preventing the mobile device from sleeping too often and or for too long the sleep mode preventing app management system can manage the behavior of the apps or enable the user to do so thereby preserving the life of the battery .

In order to identify apps that are disproportionally running background tasks and preventing the mobile device from sleeping a screen status detecting module of the sleep mode preventing app management system detects when the screen of the mobile computing device is turned off which indicates that the device is supposed to be going into sleep mode. The screen can be turned off in response to an explicit indication from the user e.g. the user taps the power button or as a result of timing out i.e. a period of inactivity of a given length transpires . The screen timeout period is a user configurable setting which is typically set to a length of time ranging from seconds e.g. 10 seconds 20 seconds 45 seconds to minutes e.g. 2 minutes 10 minutes 20 minutes . In any case the screen status detecting module detects when the screen is turned off.

In some embodiments when the screen is turned off a time counter reading module of the sleep mode preventing app management system reads one or more system time counters in order to subsequently determine for how long various apps prevent the mobile device from sleeping during the period of time when the screen was off. For example Android maintains an uptime counter and a real elapsed time counter . Both of these counters are initialized to zero when system boots. The uptime counter is only incremented when the CPU is active and thus does not track time when the mobile device is sleeping. By contrast the real elapsed time counter tracks the actual time since the last reboot including time when the device is in sleep mode. The counter reading module can thus read these or other counters that enable the subsequent determination of the time period during which the screen of the mobile device is off and any times within that window during which any app prevented the mobile device from sleeping. The process of making these determinations is described in greater detail below. It is to be understood that the specific formats and names of the counter s can vary between different embodiments for example based on the mobile OS and version thereof on the mobile computing device .

When the screen is off a sleep prevention determining module of the sleep mode preventing app management system determines whether any of the apps on the device are preventing the mobile computing device from sleeping. The Android API provides a mechanism called a wake lock which can be used by an app to force the mobile device to remain awake. To prevent the mobile device from sleeping an app acquires a wake lock . When the app no longer needs to prevent the device from going into sleep mode the app releases the wake lock . As long as there is at least one unreleased wake lock on the system the device cannot go into sleep mode. Under current versions of Android wake locks are instantiated as objects of the class WakeLock. The sample code in Table 1 illustrates an app acquiring and subsequently releasing a wake lock to prevent the mobile device from sleeping when the screen is off.

Note that Android supports multiple kinds of wake locks with the type specified by the value of the first parameter passed to the constructor pm.newWakeLock . It is wake locks of the kind PARTIAL WAKE LOCK that are of interest in the context of the sleep mode preventing app management system because the other kinds SCREEN DIM WAKE LOCK SCREEN BRIGHT WAKE LOCK and FULL WAKE LOCK force the screen to remain on as well as the CPU and are thus not relevant to preventing the mobile computing device from sleeping while the screen is off.

As long as at least one PARTIAL WAKE LOCK is held the CPU will remain on regardless of the state of the screen even if the user presses the power button. It is to be understood that under different versions of Android the kinds of wake locks and or the names thereof may vary. Additionally other mobile operating systems and or versions of Android may provide a differently implemented and or differently named mechanism that enables an app to prevent the CPU from entering sleep mode while the screen is off. Thus although an embodiment using Android s PARTIAL WAKE LOCK. type wake locks is described extensively herein it is to be understood that in other embodiments the same functionality is implemented in the context of differently named and or formatted mechanisms for preventing a mobile computing device from sleeping while the screen is off. In different embodiments in order to perform the functionality described herein the sleep prevention determining module can utilize whatever resources are exposed by the relevant API or are otherwise accessible that allow apps to prevent the CPU from entering sleep mode while the screen is off.

In one embodiment a wake lock status detecting module of the sleep mode preventing app management system reads the wake lock status of each app on the mobile computing device in response to the screen being turned off. This enables the wake lock status detecting module to identify which apps were holding wake locks of the kind PARTIAL WAKE LOCK at the time the screen went off. Note that the public method WakeLock.isHeld returns true if the wake lock has been acquired but has not yet been released. In some embodiments this method is used to determine an app s wake lock status.

In addition the wake lock status detecting module can detect all acquisitions of PARTIAL WAKE LOCK type wake locks while the screen is off in order to detect any apps that acquire a wake lock after the screen has already been turned off but before it has been turned back on. When the acquisition of such a wake lock is detected the time counter reading module can read the relevant system time counter s to note the time of acquisition which will subsequently be used to determine the length of time the wake lock was held while the screen was off.

To complete the picture the wake lock status detecting module can also detect all releases of PARTIAL WAKE LOCK type wake locks while the screen is off in which case the time counter reading module reads the system time counter s and records the release time. Thus wake lock releases by apps after the screen has already been turned off but before it has been turned back on are also detected.

Finally the screen status detecting module detects when the screen is turned back on the time counter reading module reads the system time counter s and the wake lock status detecting module reads the wake lock status of each app again to determine which apps are still holding PARTIAL WAKE LOCK wake locks when the screen is turned back on.

By detecting when the screen is turned off and then back on determining which apps are holding PARTIAL WAKE LOCK wake locks at these times and detecting and recording the times of all acquisitions and releases of PARTIAL WAKE LOCK. wake locks while the screen is off all of the information is gleaned for determining the lengths of time for which each app prevents the mobile device from sleeping while the screen is off as described in more detail below.

In order to access an app s wake lock information at runtime the wake lock status detecting module can use the Android Java reflection API. In the context of computer programming reflection is the ability of a computer program to examine and modify the structure and behavior of an object at runtime. In an object oriented programming language such as Java in which Android apps are typically written reflection makes it possible to inspect classes interfaces fields and methods at runtime without knowing their names at compile time. Java reflection also makes it possible to instantiate new objects invoke methods and get set field values using reflection. Android provides a Java reflection API in the package java.lang.reflect. in other embodiments other APIs are used to glean this information such as the native API.

A prevention quantifying module of the sleep mode preventing app management system quantifies each app s prevention of the mobile computing device from sleeping while the screen is off according to power consumption. In one embodiment this quantification is in the form of using the information gleaned as described above to determine lengths of time for which apps prevent the mobile device from sleeping while the screen is off. For each app determined to have prevented the app from sleeping while the screen was off e.g. any app which held a PARTIAL WAKE LOCK type wake lock at any point during which the screen was off the start and end of the prevention time are identified and the difference between them indicates the duration e.g. in a unit such as milliseconds seconds etc. . The start time is either the time at which the screen was turned off for apps that were holding a wake lock when the screen went off or the time at which the app acquired the wake lock for apps which made the acquisition during the period of time when the screen was off . Conversely the end time is either the time at which the screen went back on for apps that were still holding the wake lock at this point or the time at which the app released the wake lock for apps which performed the release before the screen was turned back on . In the case were a single app held a wake lock for multiple periods of time during a single screen off period e.g. the app acquired and released the wake lock multiple times while the screen was off the above described functionality captures the corresponding information for each of these time periods and the length of time during which the app prevented the mobile device from sleeping is calculated as the sum of the lengths of each separate prevention period. The measurement of the length of time each app prevents the mobile device from sleeping when the screen is off is in effect a quantification thereof according to power consumption. This is so because all else being equal the longer the app prevents the mobile device from sleeping the more power the app is causing the device to consume when the device is supposed to be in sleep mode.

In one embodiment the difference between the real elapsed time and uptime that transpires during the screen off period is calculated using the corresponding counters and only in response to the uptime exceeding a given threshold e.g. as a percentage of the total elapsed time or as a fixed value are the sleep prevention times of individual apps determined and analyzed. The reason for this is that where the threshold of uptime is not reached no individual app could be preventing the device from sleeping to an extent of interest to that embodiment with the floor being indicated by the threshold. The specific value of the threshold is a variable design parameter which can be set or adjusted as desired.

In some embodiments the prevention quantifying module quantifies each app s prevention of the mobile computing device from sleeping while the screen is off according to power consumption based on additional factors instead of or in addition to duration. More specifically the sleep mode preventing app management system can monitor not only the times during which specific apps prevent the mobile device from sleeping while the screen is off but also specific power draining activity the app initiates during that time. More specifically the reflection and or native API s can be used to monitor an app s usage of specific resources associated with power consumption such as motion sensors GPS network battery etc. The execution of specific power consuming operations by an app can also be monitored. The prevention of the device from sleeping while the screen is off can thus be more finely quantified by taking such power consuming activity into account. Which specific resources and operations to track and how specifically to weigh them in the quantification are variable design parameters and different formulations can be utilized in different embodiments as desired.

A threshold exceeding app identifying module of the sleep mode preventing app management system identifies any apps for which the quantified prevention exceeds a given threshold. The specific value of the threshold is a variable design parameter which can be set or adjusted as desired. In this context the threshold represents a value above which the quantified prevention of the device from sleeping by a given app is considered disproportionate and hence desirable to manage.

In different embodiments a disproportionate app managing module of the sleep mode preventing app management system performs one or more additional step s to manage any apps identified as disproportionate sleep preventers. In one embodiment this takes the form of informing the user e.g. through a GUI that the given app s are preventing the mobile device from sleeping while the screen is off with optional additional information such as for how long at what expense to battery life by performing which operations etc. The disproportionate app managing module can also block disproportionate apps from preventing the device from sleeping while the screen is off for example by killing the disproportionate apps when the screen goes off and restarting them when the screen goes back on by using the reflection API to prevent the apps from performing specific operations targeting specific resources etc. Identified disproportionate apps and information concerning their detected activities can also be transmitted to a central server not illustrated in or the like for tracking.

Note that although the above based discussion is centered on embodiments in which the sleep mode preventing app management system runs under Android the above described functionality can be applied under other mobile operating systems in other embodiments provided that the mobile operating system in question allows the detection and identification of information concerning sleep mode and prevention thereof similar in scope to that described above.

As will be understood by those familiar with the art the invention may be embodied in other specific forms without departing from the spirit or essential characteristics thereof. Likewise the particular naming and division of the portions modules agents managers components functions procedures actions layers features attributes methodologies data structures and other aspects are not mandatory or significant and the mechanisms that implement the invention or its features may have different names divisions and or formats. The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or limiting to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain relevant principles and their practical applications to thereby enable others skilled in the art to best utilize various embodiments with or without various modifications as may be suited to the particular use contemplated.

