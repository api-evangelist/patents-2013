---

title: Clustered filesystems for mix of trusted and untrusted nodes
abstract: A cluster of computer system nodes share direct read/write access to storage devices via a storage area network using a cluster filesystem. At least one trusted metadata server assigns a mandatory access control label as an extended attribute of each filesystem object regardless of whether required by a client node accessing the filesystem object. The mandatory access control label indicates the sensitivity and integrity of the filesystem object and is used by the trusted metadata server(s) to control access to the filesystem object by all client nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09405606&OS=09405606&RS=09405606
owner: Silicon Graphics International Corp.
number: 09405606
owner_city: Milpitas
owner_country: US
publication_date: 20130930
---
The present application is a continuation and claims the priority benefit of U.S. patent application Ser. No. 13 438 304 filed Apr. 3 2012 which is a continuation and claims the priority benefit of U.S. patent application Ser. No. 12 648 501 filed Dec. 29 2009 now U.S. Pat. No. 8 151 347 which is a continuation and claims the priority benefit of U.S. patent application Ser. No. 10 414 239 filed Apr. 16 2003 now U.S. Pat. No. 7 640 582 which is a continuation and claims the priority benefit of U.S. patent application Ser. No. 10 197 211 filed Jul. 18 2002 which is a continuation in part and claims the priority benefit of U.S. patent application Ser. No. 10 162 258 filed Jun. 5 2002 now U.S. Pat. No. 6 950 833 which claims the priority benefit of U.S. provisional application No. 60 296 046 filed Jun. 5 2001 the disclosures of which are incorporated herein by reference.

The present invention is related to data storage and more particularly to a system and method for accessing data within a storage area network.

A storage area network SAN provides direct high speed physical connections e.g. Fibre Channel connections between multiple hosts and disk storage. The emergence of SAN technology offers the potential for multiple computer systems to have high speed access to shared data. However the software technologies that enable true data sharing are mostly in their infancy. While SANS offer the benefits of consolidated storage and a high speed data network existing systems do not share that data as easily and quickly as directly connected storage. Data sharing is typically accomplished using a network filesystem such as Network File System NFS by Sun Microsystems Inc. of Santa Clara Calif. or by manually copying files using file transfer protocol FTP a cumbersome and unacceptably slow process.

The challenges faced by a distributed SAN filesystem are different from those faced by a traditional network filesystem. For a network filesystem all transactions are mediated and controlled by a file server. While the same approach could be transferred to a SAN using much the same protocols that would fail to eliminate the fundamental limitations of the file server or take advantage of the true benefits of a SAN. The file server is often a bottleneck hindering performance and is always a single point of failure. The design challenges faced by a shared SAN filesystem are more akin to the challenges of traditional filesystem design combined with those of high availability systems.

Traditional filesystems have evolved over many years to optimize the performance of the underlying disk pool. Data concerning the state of the filesystem metadata is typically cached in the host system s memory to speed access to the filesystem. This caching essential to filesystem performance is the reason why systems cannot simply share data stored in traditional filesystems. If multiple systems assume they have control of the filesystem and cache filesystem metadata they will quickly corrupt the filesystem by for instance allocating the same disk space to multiple files. On the other hand implementing a filesystem that does not allow data caching would provide unacceptably slow access to all nodes in a cluster.

Systems or software for connecting multiple computer systems or nodes in a cluster to access data storage devices connected by a SAN have become available from several companies. EMC Corporation of Hopkington Mass. offers HighRoad file system software for their Celerra Data Access in Real Time DART file server. Veritas Software of Mountain View Calif. offers SANPoint which provides simultaneous access to storage for multiple servers with failover and clustering logic for load balancing and recovery. Sistina Software of Minneapolis Minn. has a similar clustered file system called Global File System GFS . Advanced Digital Information Corporation of Redmond Wash. has several SAN products including Centra Vision for sharing files across a SAN. As a result of mergers the last few years Hewlett Packard Company of Palo Alto Calif. has more than one cluster operating system offered by their Compaq Computer Corporation subsidiary which use the Cluster File System developed by Digital Equipment Corporation in their TruCluster and OpenVMS Cluster products. However none of these products are known to provide direct read and write over a Fibre Channel by any node in a cluster. What is desired is a method of accessing data within a SAN which provides true data sharing by allowing all SAN attached systems direct access to the same filesystem. Furthermore conventional hierarchal storage management uses an industry standard interface called data migration application programming interface DMAPI . However if there are five machines each accessing the same file there will be five separate events and there is nothing tying those DMAPI events together.

It is an aspect of the present invention to allow simultaneously shared direct access to mass storage such as disk drives in a clustered filesystem accessed by a mixture of trusted and untrusted nodes.

It is another aspect of the present invention to ensure that all shared data is stored with labeling used by the trusted nodes.

It is a further aspect of the present invention to share file data and metadata between trusted and untrusted nodes in a clustered filesystem.

It is yet another aspect of the present invention to enforce file data and metadata access limits based on labeling used by trusted nodes in a clustered filesystem accessed by a mixture of trusted and untrusted nodes.

At least one of the above aspects can be attained by a cluster of computer systems sharing direct read write access to filesystems administered by at least one trusted metadata server node on storage devices connected to the computer system nodes via a storage area network including assigning a mandatory access control label as an extended attribute of each filesystem object administered by the at least one trusted metadata server node regardless of whether required by a client node accessing the filesystem object. Preferably the trusted metadata server node uses one of three sources for the mandatory access control label assigned to the filesystem object when the client node requesting access to the filesystem has no mandatory access control label for accessing the filesystem. A filesystem mandatory access control label is used if previously assigned to the filesystem. Alternatively a networking mandatory access control label is used if previously assigned to the client node and no filesystem mandatory access control label is assigned to the filesystem. If neither a filesystem nor a networking mandatory access control label is available a default label providing the least possible access is used.

These together with other aspects and advantages which will be subsequently apparent reside in the details of construction and operation as more fully hereinafter described and claimed reference being had to the accompanying drawings forming a part hereof wherein like numerals refer to like parts throughout.

Following are several terms used herein that are in common use in describing filesystems or SANs or are unique to the disclosed system. Several of the terms will be defined more thoroughly below.

In addition there are three types of input output operations that can be performed in a system according to the present invention buffered I O direct I O and memory mapped I O. Buffered I O are read and write operations via system calls where the source or result of the I O operation can be system memory on the machine executing the I O while direct I O are read and write operations via system calls where the data is transferred directly between the storage device and the application programs memory without being copied through system memory.

Memory mapped I O are read and write operations performed by page fault. The application program makes a system call to memory map a range of a file. Subsequent read memory accesses to the memory returned by this system call cause the memory to be filled with data from the file. Write accesses to the memory cause the data to be stored in the file. Memory mapped I O uses the same system memory as buffered I O to cache parts of the file.

A SAN layer model is illustrated in . SAN technology can be conveniently discussed in terms of three distinct layers. Layer is the lowest layer which includes basic hardware and software components necessary to construct a working SAN. Recently layer technology has become widely available and interoperability between vendors is improving rapidly. Single and dual arbitrated loops have seen the earliest deployment followed by fabrics of one or more Fibre Channel switches.

Layer is SAN management and includes tools to facilitate monitoring and management of the various components of a SAN. All the tools used in direct attach storage environments are already available for SANs. Comprehensive LAN management style tools that tie common management functions together are being developed. SAN management will soon become as elegant as LAN management.

The real promise of SANS however lies in layer the distributed shared filesystem. Layer and layer components allow a storage infrastructure to be built in which all SAN connected computer systems potentially have access to all SAN connected storage but they don t provide the ability to truly share data. Additional software is required to mediate and manage shared access otherwise data would quickly become corrupted and inaccessible.

In practice this means that on most SANS storage is still partitioned between various systems. SAN managers may be able to quickly reassign storage to another system in the face of a failure and to more flexibly manage their total available storage but independent systems cannot simultaneously access the same data residing in the same filesystems.

Shared high speed data access is critical for applications where large data sets are the norm. In fields as diverse as satellite data acquisition and processing CAD CAM and seismic data analysis it is common for files to be copied from a central repository over the LAN to a local system for processing and then copied back. This wasteful and inefficient process can be completely avoided when all systems can access data directly over a SAN.

Shared access is also crucial for clustered computing. Access controls and management are more stringent than with network filesystems to ensure data integrity. In most existing high availability clusters storage and applications are partitioned and another server assumes any failed server s storage and workload. While this may prevent denial of service in case of a failure load balancing is difficult and system and storage bandwidth is often wasted. In high performance computing clusters where workload is split between multiple systems typically only one system has direct data access. The other cluster members are hampered by slower data access using network file systems such as NFS.

In a preferred embodiment the SAN includes hierarchical storage management HSM such as data migration facility DMF by Silicon Graphics Inc. SGI of Mountain View Calif. The primary purpose of HSM is to preserve the economic value of storage media and stored data. The high input output bandwidth of conventional machine environments is sufficient to overrun online disk resources. HSM transparently solves storage management issues such as managing private tape libraries making archive decisions and journaling the storage so that data can be retrieved at a later date.

Preferably a volume manager such as XVM from SGI supports the cluster environment by providing an image of storage devices across all nodes in a cluster and allowing for administration of the devices from any cell in the cluster. Disks within a cluster can be assigned dynamically to the entire cluster or to individual nodes within the cluster. In one embodiment disk volumes are constructed using XVM to provide disk striping mirroring concatenation and advanced recovery features. Low level mechanisms for sharing disk volumes between systems are provided making defined disk volumes visible across multiple systems. XVM is used to combine a large number of disks across multiple Fibre Channels into high transaction rate high bandwidth and highly reliable configurations. Due to its scalability XVM provides an excellent complement to CXFS and SANs. XVM is designed to handle mass storage growth and can configure millions of terabytes exabytes of storage in one or more filesystems across thousands of disks.

An example of a cluster computing system formed of heterogeneous computer systems or nodes is illustrated in . In the example illustrated in nodes run the IRIX operating system from SGI while nodes run the Solaris operating system from Sun and node runs the Windows NT operating system from Microsoft Corporation of Redmond Wash. Each of these nodes is a conventional computer system including at least one and in many cases several processors local or primary memory some of which is used as a disk cache input output I O interfaces I O devices such as one or more displays or printers. According to the present invention the cluster includes a storage area network in which mass or secondary storage such as disk drives are connected to the nodes via Fibre Channel switch and Fibre Channel connections . The nodes are also connected via a local area network LAN such as an Ethernet using TCP IP to provide messaging and heartbeat signals. In the preferred embodiment a serial port multiplexer is also connected to the LAN and to a serial port of each node to enable hardware reset of the node. In the example illustrated in only IRIX nodes are connected to serial port multiplexer .

Other kinds of storage devices besides disk drives may be connected to the Fibre Channel switch via Fibre Channel connections . Tape drives are illustrated in but other conventional storage devices may also be connected. Alternatively tape drives or other storage devices may be connected to one or more of nodes e.g. via SCSI connections not shown .

In a conventional SAN the disks are partitioned for access by only a single node per partition and data is transferred via the LAN. On the other hand if node needs to access data in a partition to which node has access according to the present invention very little of the data stored on disk is transmitted over LAN . Instead LAN is used to send metadata describing the data stored on disk token messages controlling access to the data heartbeat signals and other information related to cluster operation and recovery.

In the preferred embodiment the cluster filesystem is layer that distributes input output directly between the disks and the nodes via Fibre Channel while retaining an underlying layer with an efficient input output path using asynchronous buffering techniques to avoid unnecessary physical input outputs by delaying writes as long as possible. This allows the filesystem to allocate the data space efficiently and often contiguously. The data tends to be allocated in large contiguous chunks which yields sustained high bandwidths.

Preferably the underlying layer uses a directory structure based on B trees which allow the cluster filesystem to maintain good response times even as the number of files in a directory grows to tens or hundreds of thousands of files. The cluster filesystem adds a coordination layer to the underlying filesystem layer. Existing filesystems defined in the underlying layer can be migrated to a cluster filesystem according to the present invention without necessitating a dump and restore as long as the storage can be attached to the SAN . For example in the IRIX nodes XVM is used for volume management and XFS is used for filesystem access and control. Thus the cluster filesystem layer is referred to as CXFS.

In the cluster file system of the preferred embodiment one of the nodes e.g. IRIX node is a metadata server for the other nodes in the cluster which are thus metadata clients with respect to the file system s for which node is a metadata server. Other node s may serve as metadata server s for other file systems. All of the client nodes and including metadata server provide direct access to files on the filesystem. This is illustrated in in which vnode presents a file system independent set of operations on a file to the rest of the operating system. In metadata client the vnode services requests using the clustered filesystem routines associated with dcvn which include token client operations described in more detail below. However in metadata server the file system requests are serviced by the clustered filesystem routines associated with dsvn which include token client operations and token server operations . The metadata server also maintains the metadata for the underlying filesystem in this case XFS .

As illustrated in according to the present invention a vnode contains the head of a chain of behaviors . Each behavior points to a set of vnode operations and a filesystem specific inode data structure . In the case of files which are only being accessed by applications running directly on the metadata server only behavior is present and the vnode operations are serviced directly by the underlying filesystem e.g. XFS. When the file is being accessed by applications running on client nodes then behavior is also present. In this case the vnode operations manage the distribution of the file metadata between nodes in the cluster and in turn use vnode operations to perform requested manipulations of the file metadata. The vnode operations are typical file system operations such as create lookup read write.

The tokens operated on by the token client and token server in an exemplary embodiment are listed below. Each token may have three levels read write or shared write. Token clients and obtain tokens from the token server . Each of the token levels read shared write and write conflicts with the other levels so a request for a token at one level will result in the recall of all tokens at different levels prior to the token being granted to the client which requested it. The write level of a token also conflicts with other copies of the write token so only one client at a time can have the write token. Different tokens are used to protect access to different parts of the data and metadata associated with a file.

Certain types of write operations may be performed simultaneously by more than one client in which case the shared write level is used. An example is maintaining the timestamps for a file. To reduce overhead when reading or writing a file multiple clients can hold the shared write level and each update the timestamps locally. If a client needs to read the timestamp it obtains the read level of the token. This causes all the copies of the shared write token to be returned to the metadata server along with each client s copy of the file timestamps. The metadata server selects the most recent timestamp and returns this to the client requesting the information along with the read token.

Acquiring a token puts a reference count on the token and prevents it from being removed from the token client. If the token is not already present in the token client the token server is asked for it. This is sometimes also referred to as obtaining or holding a token. Releasing a token removes a reference count on a token and potentially allows it to be returned to the token server. Recalling or revoking a token is the act of asking a token client to give a token back to the token server. This is usually triggered by a request for a conflicting level of the token.

When a client needs to ask the server to make a modification to a file it will frequently have a cached copy of a token at a level which will conflict with the level of the token the server will need to modify the file. In order to minimize network traffic the client lends its read copy of the token to the server for the duration of the operation which prevents the server from having to recall it. The token is given back to the client at the end of the operation.

DVN EXIST is the existence token. Represents the fact that a client has references to the vnode. Each client which has a copy of the inode has the read level of this token and keeps it until they are done with the inode. The client does not acquire and release this token around operations it just keeps it in the token client. The server keeps one reference to the vnode which keeps it in memory for each client which has an existence token. When the token is returned this reference count is dropped. If someone unlinks the file which means it no longer has a name then the server will conditionally recall all the existence tokens. A conditional recall means the client is allowed to refuse to send the token back. In this case the clients will send back all the tokens and state they have for the vnode if no application is currently using it. Once all the existence tokens are returned the reference count on the server s vnode drops to zero and this results in the file being removed from the filesystem.

DVN IOEXCL is the I O exclusive token. The read token is obtained by any client making read or write calls on the vnode. The token is held across read and write operations on the file. The state protected by this token is what is known as the I O exclusive state. This state is cached on all the clients holding the token. If the state is true then the client knows it is the only client performing read write operations on the file. The server keeps track of when only one copy of the token has been granted to a client and before it will allow a second copy to be given out it sends a message to the first client informing it that the I O exclusive state has changed from true to false. When a client has an I O exclusive state of true is allowed to cache changes to the file more aggressively than otherwise.

DVN IO is the I O token which is used to synchronize between read and write calls on different computers. CXFS enforces a rule that buffered reads are atomic with respect to buffered writes and writes are atomic with respect to other writes. This means that a buffered read operation happens before or after a write never during a write. Buffered read operations hold the read level of the token buffered writes hold the write level of the token. Direct reads and writes hold the read level of the token. DVN PAGE DIRTY represents the right to hold modified file data in memory on a system.

DVN PAGE CLEAN represents the right to hold unmodified file data in memory on a computer. Combinations of levels of DVN PAGE DIRTY and DVN PAGE CLEAN are used to maintain cache coherency across the cluster.

DVN NAME is the name token. A client with this token in the token client for a directory is allowed to cache the results of lookup operations within the directory. So if we have a name we are looking up in a directory and we have done the same lookup before the token allows us to avoid sending the lookup to the server. An operation such as removing or renaming or creating a file in a directory will obtain the write level of the token on the server and recall the read token invalidating any cached names for that directory on those clients.

DVN ATTR protects fields such as the ownership information the extended attributes of the file and other small pieces of information. Held by the client for read and by the server for write when the server is making modifications. Recall of the read token causes the invalidation of the extended attribute cache.

DVN TIMES protects timestamp fields on the file. Held at the read level by hosts who are looking at timestamps held at the shared write level by hosts doing read and write operations and held at the write level on the server when setting timestamps to an explicit value. Recall of the shared write token causes the client to send back its modified timestamps the server uses the largest of the returned values as the true value of the timestamp.

DVN SIZE protects the size of the file and the number of disk blocks in use by the file. Held for read by a client who wants to look at the size or for write by a client who has a true IO exclusive state. This allows the client to update the size of the file during write operations without having to immediately send the updated size back to the server.

DVN EXTENT protects the metadata which indicates where the data blocks for a file are on disk known as the extent information. When a client needs to perform read or write operation it obtains the read level of the token and gets of a copy of the extent information with it. Any modification of the extent information is performed on the server and is protected by the write level of the token. A client which needs space allocated in the file will lend its read token to the server for this operation.

DVN DMAPI protects the DMAPI event mask. Held at the read level during IO operations to prevent a change to the DMAPI state of the file during the IO operation. Only held for write by DMAPI on the server.

Data coherency is preferably maintained between the nodes in a cluster which are sharing access to a file by using combinations of the DVN PAGE DIRTY and DVN PAGE CLEAN tokens for the different forms of input output. Buffered and memory mapped read operations hold the DVN PAGE CLEAN READ token while buffered and memory mapped write operations hold the DVN PAGE CLEAN WRITE and VN PAGE DIRTY WRITE tokens. Direct read operations hold the DVN PAGE CLEAN SHARED WRITE token and direct write operations hold the DVN PAGE CLEAN SHARED WRITE and VN PAGE DIRTY SHARED WRITE tokens. Obtaining these tokens causes other nodes in the cluster which hold conflicting levels of the tokens to return their tokens. Before the tokens are returned these client nodes perform actions on their cache of file contents. On returning the DVN PAGE DIRTY WRITE token a client node must first flush any modified data for the file out to disk and then discard it from cache. On returning the DVN PAGE CLEAN WRITE token a client node must first flush any modified data out to disk. If both of these tokens are being returned then both the flush and discard operations are performed. On returning the DVN PAGE CLEAN READ token to the server a client node must first discard any cached data for the file it has in system memory.

An illustration to aid in understanding how tokens are requested and returned is provided in . A metadata client dcvn needs to perform an operation such as a read operation on a file that has not previously been read by that process. Therefore metadata client sends a request on path to token client at the same node e.g. node . If another client process at that node has obtained the read token for the file token client returns the token to object client and access to the file by the potentially competing processes is controlled by the operating system of the node. If token client does not have the requested read token object client is so informed via path and metadata client requests the token from metadata server dsvn via path . Metadata server requests the read token from token server via path . If the read token is available it is returned via paths and to metadata client which passes the token on to token client . If the read token is not available for example if metadata client has a write token the write token is revoked via paths and .

If metadata client had wanted a write token in the preceding example the write token must be returned by metadata client . The request for the write token continues from metadata client to token client via path and is returned via paths and to metadata server which forwards the write token to token server via path . Once token server has the write token it is supplied to metadata client via paths and as in the case of the read token described above.

Appropriate control of the tokens for each file by metadata server at node enables nodes in the cluster to share all of the files on disk using direct access via Fibre Channel . To maximize the speed with which the data is accessed data on the disk are cached at the nodes as much as possible. Therefore before returning a write token the metadata client flushes the write cache to disk. Similarly if it is necessary to obtain a read token the read cache is marked invalid and after the read token is obtained contents of the file are read into the cache.

Mounting of a filesystem as a metadata server is arbitrated by a distributed name service DNS such as white pages from SGI. A DNS server runs on one of the nodes e.g. node and each of the other nodes has DNS clients. Subsystems such as the filesystem when first attempting to mount a filesystem as the metadata server first attempt to register a filesystem identifier with the distributed name service. If the identifier does not exist the registration succeeds and the node mounts the filesystem as the server. If the identifier is already registered the registration fails and the contents of the existing entry for the filesystem identifier are returned including the node number of the metadata server for the filesystem.

According to the present invention extended attributes are basically name value pairs of information associated with a filesystem object. Each extended attribute includes a free form data area associated with any filesystem object that provides separate storage from the file data or device. The structure of the value is defined by the applications that use the extended attribute. One example of an application that uses extended attributes is the data migration package.

There may be two types of extended attributes short form and regular. When there is extra space in an inode due to the padding and buffering requirements of the filesystem an extended attribute that is small enough may be stored in the extra unused space of an inode to save disk space. XFS stored extended attributes for recording inside the inode in this manner.

Special extended attributes called root attributes are writable only by privileged user applications and system software. One example of a root extended attribute in CXFS is SGI DMI DMFATTR which contains a file s DMF status information. A major use of root extended attributes is storing access control lists ACLs and mandatory access control MAC labels for filesystem security. Examples are SGI MAC FILE used to hold an object s MAC label and SGI ACL FILE used to hold an object s access control list . These extended attributes are used in high security systems such as those handling government classified data. TRIX is a version of IRIX which uses extended attributes for increased security while other versions of IRIX use extended attributes to store other information related to filesystem objects.

Each node in a TRIX cluster is a trusted entity and thus has full access to the filesystem. Therefore the extended attributes including those used for security can be distributed by the filesystem server to the filesystem clients and cached by the filesystem clients without any security concerns. Each node controls access by users and applications to the filesystem. Caching of extended attributes distributes the state of the attributes to the filesystem clients which makes it possible to maintain access control lists and mandatory access control information on a file in a distributed manner while still maintaining the security of that file. This provides the benefit of optimizing access control checks to improve the performance of a secure system.

The extended attributes for a file object are stored on a disk separate from the file data and are therefore accessible only by the filesystem server. If extended attributes used to hold security information about a filesystem object are not cached the filesystem client needs to request those extended attributes every time a check is performed. In some cases the same attribute needs to be checked several times for a single filesystem object during a single operation. By caching the extended attributes which are protected by the operating system the filesystem client only needs to make one request for the attribute. When the client needs to check the attribute later the filesystem client uses its local copy of the attribute.

To access an extended attribute in the local cache a CXFS client uses an ATTR token to protect the coherency of the client s attribute cache. The CXFS server issues the CXFS client the ATTR read token when the client requests an extended attribute. The client s cached value for the extended attribute is valid as long as it has the ATTR read token. Any number of filesystem client nodes can have outstanding ATTR read tokens. If an application program executing on a filesystem client wants to modify a file system object s attribute it sends a message to the filesystem server. Only the filesystem server has access to the extended attributes stored on disk. Therefore if a client wants to change an extended attribute it has to ask the server to do it on behalf of the client. Before the server changes the value of the extended attribute it will send a message to all clients that have outstanding ATTR read tokens telling them to release their ATTR read token. When a CXFS client receives the request to release it s ATTR read token it clears and invalidates its extended attribute cache. Subsequent checks against the extended attribute would generate a request to the server for the new value of the extended attribute.

As noted above one use of extended attributes is to store access control lists. An access control list ACL is a list of file permissions that are more extendable than the standard UNIX owner group other permissions. The standard UNIX owner group other permissions allow a filesystem object to have only three sets of permissions for different classes of users one for the owner of the file the UID assigned to the file one for a group the file s GID and one for any user who s not the owner and not in the group. The standard UNIX environment can control read write and execute permissions for those three classes. An ACL may contain several entries for individual users or groups each with different sets of permissions. An access control list identifies particular user s who have specific permissions and particular groups may have specific permissions. The ACL is a list of those permissions for any filesystem object such as a particular file or directory.

Preferably an access control list may be used to control operations on each directory. In addition each directory may have a default access control list that is assigned to new files created in that directory. In a secure system it is preferable that files do not exist without an access control list. Therefore when a file is created its initial or default access control list is inherited from an extended attribute which is held in the parent directory.

In addition to or as an alternative to ACLs a clustered filesystem according to the present invention may include root extended attributes called mandatory access control MAC labels which provide compartmentalization of data in a system. According to the present invention a MAC label has two parts. One part deals with sensitivity of data to indicate whether any user or process can look at the data or just certain users and processes. The other part deals with the integrity of data to indicate whether the data came from a reliable source. If any user is permitted to modify the contents of a file it is given a low integrity rating mintlow . If a file may be modified by only specified user s it is given a high integrity rating minthigh . If a file may be viewed by anyone it would have a low sensitivity rating msenlow . It a file contains information only a few people should know about it would have a high sensitivity rating msenhigh .

In a preferred embodiment a cluster having a mixture of TRIX and non TRIX nodes uses TRIX nodes as metadata servers for all filesystems which will have MAC label file data and metadata access limits enforced. Only a TRIX node has the software necessary to enforce file access limits based on MAC labels. An application can check the integrity rating of a filesystem object to verify that it meets it s criteria.

For example MAC labels may be assigned to non TRIX nodes in one of three ways. The first alternative into use a default MAC label for the filesystem. One of the options when mounting a filesystem is to assign a default MAC label for accesses to the filesystem by nodes without MAC labels. If the filesystem being accessed was mounted using this option the default MAC label for the filesystem is used.

If the filesystem doesn t have a default MAC label the second alternative is to use a default MAC label assigned to the node. A TRIX node maintains a remote host database in the kernel that includes an IP address for each host in communication with the TRIX node and trust attributes for the node regardless of whether the node is a TRIX or non TRIX node. The default MAC label for the node is obtained from the remote host database if the filesystem was not assigned a MAC label.

If for any reason no entry can be found for the non TRIX node in the database e.g. the access request is being handled during reloading of the remote host database preferably the weakest possible access is assigned to the request. In this case the access request is considered to be highly sensitive but not from a reliable source msenhigh mintlow .

In addition to caching data that is being used by a node in the preferred embodiment hierarchical storage management HSM such as the data migration facility DMF from SGI is used to move data to and from tertiary storage particularly data that is infrequently used. As illustrated in process es that implement HSM preferably execute on the same node as metadata server for the file system s under hierarchical storage management. Also residing on node are the objects that form DMAPI which interfaces between HSM and metadata server .

Flowcharts of the operations performed when client node requests access to data under hierarchical storage management are provided in . When user application issues I O requests the DMAPI token must be acquired . This operation is illustrated in where a request for the DMAPI token is issued to metadata client . As discussed above with respect to metadata client determines whether the DMAPI token is held at client node . If not a lookup operation on the metadata server and the token request is sent. When metadata server receives the token request it is determined whether the token is available. If not the conflicting tokens are revoked and metadata server pauses or goes into a loop until the token can be granted . Files under hierarchical storage management have a DMAPI event mask discussed further below which is then retrieved and forwarded with the DMAPI token. Metadata client receives the token and the DMAPI event mask and updates the local DMAPI event mask. The DMAPI token is then held by token client

As illustrated in next the DMAPI event mask is checked to determined whether a DMAPI event is set i.e. to determine whether the file to be accessed is under hierarchical storage management. If so another lookup of the metadata server is performed as in step so that a message can be sent to the metadata server informing the metadata server of the operation to be performed. When server node receives the message metadata server sends notification of the DMAPI event to DMAPI . The DMAPI event is queued and subsequently processed by DMAPI and HSM .

The possible DMAPI events are read write and truncate. When a read event is queued the DMAPI server informs the HSM software to ensure that data is available on disks. If necessary the file requested to be read is transferred from tape to disk. If a write event is set the HSM software is informed that the tape copy will need to be replaced or updated with the contents written to disk. Similarly if a truncate event is set the appropriate change in file size is performed e.g. by writing the file to disk adjusting the file size and copying to tape.

Upon completion of the DMAPI event a reply is forwarded by metadata server to client node which receives the reply and user application performs input output operations. Upon completion of those operations the DMAPI token is released .

In addition to high speed disk access obtained by caching data and shared access to disk drives via a SAN it is desirable to have high availability of the cluster. This is not easily accomplished with so much data being cached and multiple nodes sharing access to the same data. Several mechanisms are used to increase the availability of the cluster as a whole in the event of failure of one or more of the components or even an entire node including a metadata server node.

One aspect of the present invention that increases the availability of data is the mirroring of data volumes in mass storage . As in the case of conventional mirroring during normal operation the same data is written to multiple devices. Mirroring may be used in conjunction with striping in which different portions of a data volume are written to different disks to increase speed of access. Disk concatenation can be used to increase the size of a logical volume. Preferably the volume manager allows any combination of striping concatenation and mirroring. provides an example of a volume that has a mirror with a leg that is a concatenation of data on two physical disks and an interior mirror of two legs that are each striped across three disks and .

The volume manager may have several servers which operate independently but are preferably chosen using the same logic. A node is selected from the nodes that have been in the cluster membership the longest and are capable of hosting the server. From that pool of nodes the lowest numbered node is chosen. The volume manager servers are chosen at cluster initialization time or when a server failure occurs. In an exemplary embodiment there are four volume manager servers termed boot config mirror and pal.

The volume manager exchanges configuration information at cluster initialization time. The boot server receives configuration information from all client nodes. Some of the client nodes could have different connectivity to disks and thus could have different configurations. The boot server merges the configurations and distributes changes to each client node using a volume manager multicast facility. This facility preferably ensures that updates are made on all nodes in the cluster or none of the nodes using two phase commit logic. After cluster initialization it is the config server that coordinates changes. The mirror server maintains the mirror specific state information about whether a revive is needed and which mirror legs are consistent.

In a cluster system according to the present invention all data volumes and their mirrors in mass storage are accessible from any node in the cluster. Each mirror has a node assigned to be its mirror master. The mirror master may be chosen using the same logic as the mirror server with the additional constraint that it must have a physical connection to the disks. During normal operation queues may be maintained for input output operations for all of the client nodes by the mirror master to make the legs of the mirror consistent across the cluster. In the event of data loss on one of the disk drives forming mass storage a mirror revive process is initiated by the mirror master e.g. node which detects the failure and is able to execute the mirror revive process.

If a client node e.g. node terminates abnormally the mirror master node will search the mirror input output queues for outstanding input output operations from the failed node and remove the outstanding input output operations from the queues. If a write operation from a failed process to a mirrored volume is in a mirror input output queue a mirror revive process is initiated to ensure that mirror consistency is maintained. If the mirror master fails a new mirror master is selected and the mirror revive process starts at the beginning of the mirror of a damaged data volume and continues to the end of the mirror.

When a mirror revive is in progress the mirror master coordinates input output to the mirror. The mirror revive process uses an overlap queue to hold I O requests from client nodes made during the mirror revive process. Prior to beginning to read from an intact leg of the mirror the mirror revive process ensures that all other input output activity to the range of addresses is complete. Any input output requests made to the address range being revived are refused by the mirror master until all the data in that range of addresses has been written by the mirror revive process.

If there is an I O request for data in an area that is currently being copied in reconstructing the mirror the data access is retried after a predetermined time interval without informing the application process which requested the data access. When the mirror master node receives a message that an application wants to do input output to an area of the mirror that is being revived the mirror master node will reply that the access can either proceed or that the I O request overlaps an area being revived. In the latter case the client node will enter a loop in which the access is retried periodically until it is successful without the application process being aware that this is occurring.

Input output access to the mirror continues during the mirror revive process with the volume manager process keeping track of the first unsynchronized block of data to avoid unnecessary communication between client and server. The client node receives the revive status and can check to see if it has an I O request preceding the area being synchronized. If the I O request precedes that area the I O request will be processed as if there was no mirror revive in progress.

Data read from unreconstructed portions of the mirror by applications are preferably written to the copy being reconstructed to avoid an additional read at a later period in time. The mirror revive process keeps track of what blocks have been written in this manner. New data written by applications in the portion of the mirror that already have been copied by the mirror revive process are mirrored using conventional mirroring. If an interior mirror is present it is placed in writeback mode. When the outer revive causes reads to the interior mirror it will automatically write to all legs of the interior mirror thus synchronizing the interior mirror at the same time.

In the preferred embodiment a common object recovery protocol CORPSE is used for server endurance. As illustrated in if a node executing a metadata server fails the remaining nodes will become aware of the failure from loss of heartbeat error in messaging or by delivery of a new cluster membership excluding the failed node. The first step in recovery or initiation of a cluster is to determine the membership and roles of the nodes in the cluster. If the heartbeat signal is lost from a node or a new node is detected in the cluster a new membership must be determined. To enable a computer system to access a cluster filesystem it must first be defined as a member of the cluster i.e. a node in that filesystem.

As illustrated in when a node begins operation it enters a nascent state in which it detects the heartbeat signals from other nodes and begins transmitting its own heartbeat signal. When enough heartbeat signals are detected to indicate that there are sufficient operating nodes to form a viable cluster requests are sent for information regarding whether there is an existing membership for the cluster. If there is an existing leader for the cluster the request s will be sent to the node in the leader state . If there is no existing leader conventional techniques are used to elect a leader and that node transitions to the leader state . For example a leader may be selected that has been a member of the cluster for the longest period of time and is capable of being a metadata server.

The node in the leader state sends out messages to all of the other nodes that it has identified and requests information from each of those nodes about the nodes to which they are connected. Upon receipt of these messages nodes in the nascent state and stable state transition to the follower state . The information received in response to these requests is accumulated by the node in the leader state to identify the largest set of fully connected nodes for a proposed membership. Identifying information for the nodes in the proposed membership is then transmitted to all of the nodes in the proposed membership. Once all nodes accept the membership proposed by the node in the leader state all of the nodes in the membership transition to the stable state and recovery is initiated if the change in membership was due to a node failure. If the node in the leader state is unable to find sufficient operating nodes to form a cluster i.e. a quorum all of the nodes transition to a dead state .

If a node is deactivated in an orderly fashion the node sends a withdrawal request to the other nodes in the cluster causing one of the nodes to transition to the leader state . As in the case described above the node in the leader state sends a message with a proposed membership causing the other nodes to transition to the follower state . If a new membership is established the node in the leader state sends an acknowledgement to the node that requested withdrawal from membership and that node transitions to a shutdown state while the remaining nodes transition to the stable state .

In the stable state message channels are established between the nodes over LAN . A message transport layer in the operating system handles the transmission and receipt of messages over the message channels. One set of message channels is used for general messages such as token requests and metadata. Another set of channels is used just for membership. If it is necessary to initiate recovery the steps illustrated in are performed. Upon detection of a node failure by loss of heartbeat or messaging failure the message transport layer in the node detecting the failure freezes the general message channels between that node and the failed node and disconnects the membership channels. The message transport layer then notifies the cell membership services CMS daemon.

Upon notification of a node failure the CMS daemon blocks new nodes from joining the membership and initiates the membership protocol represented by the state machine diagram in . A leader is selected and the process of membership delivery is performed as discussed above with respect to .

In the preferred embodiment CMS includes support for nodes to operate under different versions of the operating system so that it is not necessary to upgrade all of the nodes at once. Instead a rolling upgrade is used in which a node is withdrawn from the cluster the new software is installed and the node is added back to the cluster. The time period between upgrades may be fairly long if the people responsible for operating the cluster want to gain some experience using the new software.

Version tags and levels are preferably registered by the various subsystems to indicate version levels for various functions within the subsystem. These tags and levels are transmitted from follower nodes to the CMS leader node during the membership protocol when joining the cluster. The information is aggregated by the CMS leader node and membership delivery includes the version tags and levels for any new node in the cluster. As a result all nodes in the know the version levels of functions on other nodes before any contact between them is possible so they can properly format messages or execute distributed algorithms.

Upon initiation of recovery the following steps are performed. The first step in recovery involves the credential service subsystem. The credential subsystem caches information about other nodes so that each service request doesn t have to contain a whole set of credentials. As the first step of recovery the CMS daemon notifies the credential subsystem in each of the nodes to flush the credentials from the failed node.

When the CMS daemon receives acknowledgment that the credentials have been flushed common object recovery is initiated . Details of the common object recovery protocol for server endurance CORPSE will be described below with respect to . An overview of the CORPSE process is illustrated in beginning with the interrupting of messages from the failed node and waiting for processing of these messages to complete. Messages whose service includes a potentially unbounded wait time are returned with an error.

After all of the messages from the failed node have been processed CORPSE recovers the system in three passes starting with the lowest layer cluster infrastructure and ending with the file system. In the first pass recovery of the kernel object relocation engine KORE is executed for any in progress object relocation involving a failed node. In the second pass the distributed name server white pages and the volume manager such as XVM are recovered making these services available for filesystem recovery. In the third pass the file system is recovered to return all files to a stable state based on information available from the remaining nodes. Upon completion of the third pass the message channels are closed and new nodes are allowed to join.

As illustrated in the first step in CORPSE is to elect a leader for the purposes of recovery. The CORPSE leader is elected using the same algorithm as described above with respect to the membership leader . In the event of another failure before recovery is completed a new leader is elected . The node selected as the CORPSE leader initializes the CORPSE process to request the metadata client processes on all of the nodes to begin celldown callouts as described below. The purpose of initialization is to handle situations in which another node failure is discovered before a pass is completed. First the metadata server s and clients initiate message interrupts and holds all create locks.

The next step to be performed includes detargeting a chandle. A chandle or client handle is a combination of a barrier lock some state information and an object pointer that is partially subsystem specific. A chandle includes a node identifier for where the metadata server can be found and a field that the subsystem defines which tells the chandle how to locate the metadata server on that node e.g. using a hash address or an actual memory address on the node. Also stored in the chandle is a service identifier indicating whether the chandle is part of the filesystem vnode file or distributed name service and a multi reader barrier lock that protects all of this. When a node wants to send a message to a metadata server it acquires a hold on the multi reader barrier lock and once that takes hold the service information is decoded to determine where to send the message and the message is created with the pointer to the object to be executed once the message reaches the metadata server.

With messages interrupted and create locks held celldown callouts are performed to load object information into a manifest object and detarget the chandles associated with the objects put into the manifest. By detargeting a chandle any new access on the associated object is prevented. The create locks are previously held on the objects needed for recovery to ensure that the objects are not instantiated for continued processing on a client node in response to a remote processing call RPC previously initiated on a failed metadata server. An RPC is a thread initiated on a node in response to a message from another node to act as a proxy for the requesting node. In the preferred embodiment RPCs are used to acquire or recall tokens for the requesting node. During celldown callouts the metadata server recovers from any lost clients returning any tokens the client s held and purging any state held on behalf of the client.

The CORPSE subsystems executing on the metadata clients go through all of the objects involved in recovery and determine whether the server for that client object is in the membership for the cluster. One way of making this determination is to examine the service value in the chandle for that client object where the service value contains a subsystem identifier and a server node identifier. Object handles which identify the subsystems and subsystem specific recovery data necessary to carry out further callouts are placed in the manifest. Server nodes recover from client failure during celldown callouts by returning failed client tokens and purging any state associated with the client.

When celldown callouts have been performed for all of the objects associated with a failed node the operations frozen previously are thawed or released . The message channel is thawed so that any threads that are waiting for responses can receive error messages that a cell is down i.e. a node has failed so that that the threads can do any necessary cleanup and then drop the chandle hold. This allows all of the detargets to be completed. In addition the create locks are released . The final result of the operations performed in step is that all client objects associated with the filesystem are quiesced so that no further RPCs will be sent or are awaiting receipt.

After the celldown callouts have processed the information about the failed node s vote callouts are performed in each of the remaining nodes to elect a new server. The votes are sent to the CORPSE leader which executes election callouts to identify the node s that will host the new servers. The election algorithm used is subsystem specific. The filesystem selects the next surviving node listed as a possible server for the filesystem while the DNS selects the oldest server capable node.

When all of the nodes are notified of the results of the election gather callouts are performed on the client nodes to create manifests for each server on the failed node s . Each manifest contains information about one of the servers and is sent to the node elected to host that server after recovery. A table of contents of the information in the bag is included in each manifest so that reconstruct callouts can be performed on each object and each manifest from each of the nodes.

The reconstruct callouts are executed on the new elected server to extract information from the manifests received from all the nodes while the chandles are detargeted so that none of the nodes attempt to access the elected server. When the reconstruct callouts are completed a message is sent to the CORPSE leader that it is ready to commit to instantiate the objects of the server. The instantiate callouts are then performed and upon instantiation of all of the objects a commitment is sent to the CORPSE leader for retargeting the chandles to the elected server. The instantiate commit and retarget commit are performed by the CORPSE leader to save information regarding the extent of recovery in case there is another node failure prior to completion of a pass. If a failure occurs prior to instantiate commit the pass is aborted and recovery is restarted with freezing of message channels. However once the CORPSE leader notifies any node to go forward with instantiating new server s recovery of any new node failure is delayed until the current pass completes then recovery rolls back to freezing message channels. If the failed node contains the elected server the client nodes are targeted to the now failed server and the process of recovering the server begins again.

In the case of the second pass WP XVM a single chandle accesses the DNS server and the manifest created at each client node contains all of the file identifiers in use at that node prior to entering recovery. During the reconstruct callouts of the second pass the DNS server goes through all of the entries in the manifest and creates a unique entry for each filesystem identifier it receives. If duplicate entries arrive which is likely since many nodes may have the entry for a single filesystem tokens are allocated for the sending node in the previously created entry.

After all of the retargets are performed in each of the nodes a complete callout is performed by the subsystem being recovered to do any work that is required at that point. Examples are deallocating memory used during recovery or purging any lingering state associated with a failed node including removing DNS entries still referencing a failed node. As discussed above with respect to the steps illustrated in are preferably repeated in three passes as different subsystems of the operating system are recovered. After completion of the last pass CORPSE is completed.

As noted above the first pass of recovery is to recover from an incomplete relocation of a metadata server. The kernel object relocation engine KORE is used for an intentional relocation of the metadata server e.g. for an unmount of the server or to completely shutdown a node at which a metadata server is located to return the metadata server to a previously failed node or for load shifting. Provided no nodes fail during relocation an object manifest can be easily created since all of the information required for the new i.e. target metadata server can be obtained from the existing i.e. source metadata server.

As illustrated in KORE begins with source node prepare phase which ensures that filesystem is quiesced before starting the relocation. When all of the objects of the metadata server are quiesced they are collected into an object manifest and sent to the target metadata server. Most of the steps performed by the target metadata server are performed in both relocation and recovery. The target node is prepared and an object request is sent from the target metadata server to the source metadata server to obtain a bag containing the state of the object being relocated.

In response the source metadata server initiates retargeting and creation of client structures objects for the vnodes and the vfs then all clients are informed to detarget that node as the metadata server. When the source metadata server has been informed that all of the clients have completed detargeting a source bag is generated with all of the tokens and the state of server objects which are sent to the target metadata server. The target metadata server unbags the objects and initiates execution of the metadata server. The target metadata server informs the source metadata server to inform the clients to retarget the target metadata server and processing resumes on the target metadata server. The source metadata server is informed when each of the clients completes retargeting so that the source node can end operation as the metadata server.

The stages of the relocation process are illustrated in . As illustrated in during normal operation the metadata clients MDCs and at nodes and send token requests to metadata server MDS on node . When a relocation request is received metadata server sends a message to node to create a prototype metadata server as illustrated in . A new metadata client object is created on node as illustrated in but initially messages to the prototype metadata server are blocked. Next all of the metadata clients are instructed to detarget messages for the old metadata server as illustrated in . Then as illustrated in the new metadata server is instantiated and is ready to process the messages from the clients so the old metadata server instructs all clients to retarget messages to the new metadata server as illustrated in . Finally the old metadata server node is shut down as illustrated in and the metadata client is shut down on node as illustrated in . As indicated in the token client continues to provide local access by processing tokens for applications on node as part of the metadata server

Preferably interruptible token acquisition is used to enable recovery and relocation in several ways 1 threads processing messages from failed nodes that are waiting for the token state to stabilize are sent an interrupt to be terminated to allow recovery to begin 2 threads processing messages from failed nodes which may have initiated a token recall and are waiting for the tokens to come back are interrupted 3 threads that are attempting to lend tokens which are waiting for the token state to stabilize and are blocking recovery relocation are interrupted and 4 threads that are waiting for the token state to stabilize in a filesystem that has been forced offline due to error are interrupted early. Threads waiting for the token state to stabilize first call a function to determine if they are allowed to wait i.e. none of the factors above apply then go to sleep until some other thread signals a change in token state.

To interrupt CORPSE and KORE each wake all sleeping threads. These threads loop check if the token state has changed and if not attempt to go back to sleep. This time one of the factors above may apply and if so a thread discovering it returns immediately with an early status. This tells the upper level token code to stop trying to acquire lend etc. and to return immediately with whatever partial results are available. This requires processes calling token functions to be prepared for partial results. In the token acquisition case the calling process must be prepared to not get the token s requested and to be unable to perform the intended operation. In the token recall case this means the thread will have to leave the token server data structure in a partially recalled state. This transitory state is exited when the last of the recalls comes in and the thread returning the last recalled token clears the state. In lending cases the thread will return early potentially without all tokens desired for lending.

The many features and advantages of the invention are apparent from the detailed specification and thus it is intended by the appended claims to cover all such features and advantages of the invention that fall within the true spirit and scope of the invention. Further since numerous modifications and changes will readily occur to those skilled in the art it is not desired to limit the invention to the exact construction and operation illustrated and described and accordingly all suitable modifications and equivalents may be resorted to falling within the scope of the invention.

