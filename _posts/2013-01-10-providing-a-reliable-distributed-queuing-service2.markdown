---

title: Providing a reliable distributed queuing service
abstract: A method, system, and computer-readable medium is described for facilitating interactions between software programs by providing a reliable data queuing service that enables the programs to store and retrieve elements of data queues. In some situations, the data queuing service is provided to users who purchase usage of the data queuing service for application programs executed by or otherwise affiliated with the users. In addition, accessibility of the data queuing service to remote executing programs may be enhanced via a defined API of the data queuing service, such as a Web services-based API. Availability of the data queuing service may also be enhanced in some situations by using multiple alternative distributed systems for a data queue such that each of the alternative systems stores a subset of the elements of the data queue.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09632723&OS=09632723&RS=09632723
owner: Amazon Technologies, Inc.
number: 09632723
owner_city: Incline Village
owner_country: US
publication_date: 20130110
---
The following disclosure relates generally to facilitating interactions between executing software programs and more particularly to facilitating such interactions by providing a data queuing service to remote executing programs such as a data queuing service that uses distributed storage systems to reliably store elements of data queues for the remote executing programs.

Multiple computer systems often interact in order to achieve a goal such as when an application program on a computer system interacts with other remote systems and applications in order to obtain various types of information and functionality that are not part of the application program. By performing such interactions an application program may be able to leverage information and functionality from vast numbers of other computer systems over the Internet or other networks.

In order to enable such interactions between remote computer systems and application programs various programmatic interaction mechanisms have been developed. For example remote procedure call RPC protocols have long existed that allow a program on one computer to cause a program on another computer to be executed and various object oriented architectures such as CORBA Common Object Request Broker Architecture and DCOM Distributed Component Object Model provide similar capabilities. In addition a variety of middleware programs have been implemented to connect separate applications often of distinct types and from unrelated sources to allow communication. For example various EDI Electronic Data Interchange networks exist that provide standard mechanisms to allow a computer system of one user of the network to send data to a computer system of another user of the network.

The widespread popularity of the World Wide Web Web has provided additional opportunities for computers to inter communicate. For example much current Web use involves users interactively requesting Web pages from Web servers e.g. via executing Web browser applications of the users and receiving the requested information in response. In addition to such interactive user specification of requested information there is also growing use of the Web to support the programmatic interaction of remote applications to exchange information via defined APIs application program interfaces such as APIs based on Web services interaction mechanisms. Such Web services allow heterogeneous applications and computers to interact and can be defined and implemented using a variety of underlying protocols and techniques. For example some Web service implementations return data in XML eXtensible Markup Language format using HTTP HyperText Transport Protocol in response to a Web service invocation request specified as a URI Uniform Resource Identifier such as a URL Uniform Resource Locator that includes a specified operation and one or more query parameters. In other implementations additional underlying protocols are used for various purposes such as SOAP Simple Object Access Protocol for standard message exchange WSDL Web Services Description Language for description of service invocations and UDDI Universal Description Discovery and Integration service for discovery of available services.

Unfortunately while Web services and other programmatic interaction mechanisms allow various application programs and computers to interact such interactions are typically limited in various ways. For example the types of information and functionality that are available to be requested using such programmatic interactions are typically restricted to very limited types of requests that the remote computer systems and applications can automatically fulfill e.g. to provide a specified predefined group of information such as a Web page or file or to perform a specified database query on a specified database but there are often additional needed capabilities that are not available as part of the existing programmatic interaction mechanisms.

As one example of additional programmatic interaction capabilities that are often needed one or more source or producer software programs may often need to provide multiple groups of data e.g. messages over time to one or more other destination or consumer software programs in a sufficiently reliable manner that the provided groups of data are rarely or never lost. However such reliable data exchange creates various difficulties. As a threshold issue the source and destination programs will typically need to be known to each other at design time so that they can be created in such a manner as to enable the data exchange interaction such as by creating and including specialized functionality in the source and or destination programs to enable the data exchange. Moreover to actually perform the data exchange the source and destination programs will both typically need to be simultaneously executing and accessible to each other and the data exchange is susceptible to the loss of data in various situations such as due to an occurrence of an error in or unexpected termination of one of the programs or based on a network error that interrupts communication between the programs. In addition a common problem in such situations occurs when the source and destination programs have different abilities to process data such as the source programs being able to send data more quickly than the destination programs can receive and process data if so complicated predefined techniques may be needed to regulate the flow of data or instead groups of data being exchanged may be lost. Another common problem occurs in situations in which multiple programs wish to exchange data with multiple other programs as such interactions are often difficult to organize and coordinate.

Thus given the existing limitations regarding exchange of data between programs it would be beneficial to provide a solution that enables software programs to reliably exchange data in such a way as to minimize or eliminate existing problems as well as to provide a variety of additional capabilities.

A software facility is described that facilitates interactions between software programs by providing a data queuing service that enables remote programs to store and retrieve elements of queues with the queue elements able to store a variety of types of data in various embodiments. In some embodiments the data queuing service is provided by or otherwise affiliated with a merchant e.g. a Web merchant who sells access to or usage of the data queuing service to customers so that application programs executed by or otherwise affiliated with the customers can use the data queuing service. In addition in some embodiments accessibility of the data queuing service is provided to remote executing programs via a defined API application program interface of the data queuing service such as an API based on Web services functionality that is provided by the data queuing service.

In at least some embodiments the data queuing service is provided using a distributed storage architecture to enhance aspects of the service. For example availability of the data queuing service is enhanced in at least some embodiments by using a group of multiple alternative distributed storage systems for a data queue such that each of the alternative systems stores a subset of the elements of the data queue in this manner a new data element being added to a queue also referred to as being enqueued can be stored on any of the alternative systems such as to balance the storage and or computing load on the alternative systems and to handle the situation when an alternative system becomes unavailable e.g. due to hardware failure of the system and or a network connectivity failure by storing new data elements on other alternative systems. In addition reliability of the data queuing service is enhanced in at least some embodiments by using one or more mirror storage systems for each of the alternative storage systems such that each of the mirror systems replicates data queue elements stored on the alternative system that it mirrors in this manner if an alternative system becomes unavailable queue elements stored on that alternative system may still be available on one of the mirror systems for that alternative system.

In the example embodiment illustrated in various customers first interact with a subscription service of a merchant to create subscriptions that allow access to various functionality provided by the merchant. In particular the customers in this example embodiment may create subscriptions that are associated with a data queuing service provided by the merchant such as by creating one or more queues and associating them with their subscriptions after which one or more executing application programs of a customer may interact with the data queuing service to use one or more of the customer s queues. In the illustrated embodiment the subscription service and data queuing service are both provided by a single merchant computing system although in other embodiments the services may execute on distinct computing systems and or may be operated by distinct entities or the data queuing service and subscription service may instead be combined into a single service.

In this example embodiment a variety of types of information can be specified for a subscription to affect use of any data queues associated with the subscription. For example information related to payments for queue related actions may be specified for a subscription such as to specify a payment source for a queue that is provided on a per fee basis e.g. a queue that charges fees on an aggregate basis for a certain number of queue operations and or for a certain time that charges fees on a per queue operation basis etc. . Various configuration information related to the subscription and or associated queues can also be specified such as to specify usage restrictions for the queues e.g. a throughput ceiling and or storage size ceiling to specify access control restrictions for users of the queues e.g. to limit some users to only certain queue related operations such as a read operation to obtain stored data from a queue or to restrict some users from any access to a queue and or to specify other types of queue related information e.g. to specify a degree or level of reliability and or availability for the queue .

After a customer indicates to create a queue associated with a subscription which in the illustrated embodiment is performed based on interactions of the customer with the subscription service the subscription service interacts with the data queuing service to obtain a unique queue identifier for the queue. The subscription service then associates the identifier with the subscription of the customer and provides the queue identifier to the customer although in other embodiments the subscription service may instead generate the queue identifier itself or the customer may instead interact directly with the data queuing service to create the queue. Executing programs that are affiliated with the customer can then use the queue identifier to access the customer s queue via the data queuing service in various ways such as to allow multiple Web applications of the customer that execute remotely from each other and from the queue to use the queue to communicate. For example executing application programs and may interact with a Web services based API of the data queuing service to act as producer programs that enqueue data in queues created by customers affiliated with the application programs and executing application programs and may then interact with the API to act as consumer programs that retrieve the enqueued data in a manner convenient to those consumer programs.

Since the data queuing service acts as an intermediary in the illustrated embodiment when interacting with remote third party programs of customers the queuing service can be used by customers programs in a variety of ways. For example in some situations a single application program may store data in a queue and later retrieve and use that data such as to use the queue for buffering purposes to hold incoming data that the application is not able to immediately process or instead to store data temporarily while the application program is not executing. Alternatively some application programs e.g. programs may act solely as data producers who enqueue data that is later retrieved by other application programs e.g. programs who act only as consumers of the enqueued data. Such decoupling of data producers and consumers not only accommodates different abilities to provide and consume data e.g. the ability to process data at different rates but also allows multiple unrelated applications to provide data to a single queue and or allows multiple unrelated applications to retrieve data from a single queue. In addition such producer and consumer application programs do not need to execute simultaneously since the data queuing service in this example embodiment will reliably store data until it is dequeued e.g. in accordance with the level and type of queuing services subscribed to for the queue and further allows the producer and consumer applications to be heterogeneous with respect to programming language operating systems computing hardware etc. as long as they are both able to access one or more APIs provided by the data queuing service. As another example one or more of the executing application programs may act as a data producer for one queue and a data consumer for another queue whether simultaneously or at different times.

When the API of the data queuing service receives queue usage operation requests such as to enqueue read or dequeue data elements the API forwards the requests to one or more components that in the illustrated embodiment provide distributed storage and retrieval functionality for queued data based on interactions with distributed data storage systems . The data storage systems may take various forms in various embodiments including computing systems with attached or otherwise associated storage database servers for databases stand alone network storage devices etc. Furthermore there may optionally be multiple copies of the data queuing service executing simultaneously in some embodiments whether on a single computing system or multiple computing systems such as to allow greater throughput of queue usage operations if so such multiple copies will interact with a single set of distributed data storage systems in the illustrated embodiment although in other embodiments such multiple copies may instead be associated with distinct sets of data storage systems. If multiple data queuing service copies are executing simultaneously requests via the API can be forwarded to an appropriate one of the copies in various ways such as via the use of a load balancer not shown .

In this example embodiment the distributed data storage systems assist to provide high availability and high reliability for the data queuing services. In particular each queue may be associated with a group of multiple alternative data storage systems that each store a subset of the data elements for the queue and each such alternative data storage system may have at least one other data storage system that mirrors the alternative system in order to provide a redundant copy of the enqueued data elements as discussed in greater detail with respect to . In this example embodiment at least some of the distributed data storage systems may also be clustered together such as by using multiple data centers that each include multiple data storage systems although other data storage systems e.g. and are stand alone systems in this illustrated embodiment. When selecting a data storage system to mirror another data storage system the mirror data storage system in this example embodiment is chosen in such a manner as to maximize the likelihood that the failure of one of the data storage systems does not result in the failure of the other data storage systems. For example to select a mirror data storage system for system in data center the mirror data storage system will typically be selected outside of data center e.g. data storage system in data center so that a failure of power and or connectivity to data center will not result in a loss of access to the mirror storage system. While in some embodiments a data storage system may act as a mirror for multiple other data storage systems assignments of mirror systems are also performed in such a manner as to prevent overloading of the mirror systems.

In particular illustrates examples of how the data queuing service of may store queue elements in a distributed manner among the data storage systems of with three queues and being stored on several of the data storage systems in the illustrated example of . For example queue in this example is stored across three alternative data storage systems that each may store subsets of the queue elements with data storage system storing a portion of the queue that currently includes 2 queue data elements those being queue elements and data storage system storing a portion of the queue that currently includes 1 queue data element that being queue element and data storage system storing a portion of the queue that currently includes 1 queue data element that being queue element . In this example queue data element was previously enqueued in queue portion and subsequently dequeued.

When a new data element is to be enqueued in queue any of the three alternative data storage systems may be selected to store the new data element and when a stored data element is to be read from the queue any of the three alternative data storage systems may similarly be selected for use in satisfying the read request although if one of the alternative data storage systems did not currently have any stored data elements and others did then that one data storage system would not be selected . Thus when a request to read a queue element from queue is next received it is possible that data storage system will be selected to handle the request thus allowing queue element to be returned before earlier enqueued queue elements on data storage systems and . However when a queue element is next read from queue portion on data storage system the earliest enqueued of the two data elements in that queue portion in this example will be selected thus preventing queue elements to become stuck in the queue. While the illustrated embodiment thus provides a relaxed FIFO First In First Out queue behavior in which enqueued data will be dequeued in a timely manner but not necessarily in the exact order enqueued in other embodiments other queue behaviors may instead be provided such as to provide strict FIFO ordering with enqueued data being dequeued in the order enqueued to provide relaxed or strict LIFO Last In First Out queue behavior and or to use other element ordering schemes such as for a priority queue e.g. by using priorities associated with queue elements .

Queue is similarly stored across two alternative data storage systems in the example shown in with data storage system storing a portion of the queue that currently does not include any queue data elements and with data storage system storing a portion of the queue that currently includes 2 queue data elements those being queue elements and . In addition in this example queue is stored in a single data storage system that being data storage system and does not currently include any queue data elements e.g. due to queue currently being suspended or inactive such as due to the subscription associated with the queue not shown having expired . In some embodiments the number of alternative data storage systems may be configurable for some or all queues e.g. by the customer and or the merchant such as to accommodate different levels or types of queue capabilities purchased or otherwise requested by a customer or instead to accommodate varying numbers of currently available data storage systems based on existing data storage systems becoming unavailable and or new data storage systems becoming available while in other embodiments the number of alternative data storage systems may be fixed for all queues. In addition in some embodiments the multiple alternative data storage systems to use for a queue may be dynamically determined e.g. using a deterministic algorithm at the time of each of some or all types of queue operations for the queue e.g. for enqueue operations such as to easily handle changes to data storage systems that are available.

In the illustrated example data storage system mirrors all of the queues stored on data storage system and consequently includes a queue portion that mirrors queue portion of system a queue that mirrors queue of system and queue portion that mirrors queue portion of system . In particular for each queue related operation that is performed with respect to queue elements for system the same queue related operation is attempted to be performed for mirror system . Thus if system were to become unavailable mirror system would be able to take its place in handing queue related operations for queues and .

In embodiments in which a queue related operation is guaranteed to be successfully performed against a system and all its mirror systems those systems should always have the same contents. However such systems may result in lower availability for the data queuing service as a queue related operation will fail if the operation fails for any of the system and its mirror systems. Data storage system of illustrates that in this example embodiment some queue related operations may be treated as successful even if the operation does not succeed for a system and every one of its mirror systems. In particular system also operates as a mirror system with regard to queue for system and thus includes a queue portion to mirror queue portion of system . However in this example queue portion of system does not currently have the same contents as queue portion of system and in particular includes queue element that is not currently present in queue portion and does not include queue element that is currently present in queue portion

The inconsistency with respect to queue element between the systems may result for example if a copy of the queue element was successfully enqueued in queue portion but not in queue portion and has not yet been dequeued. Alternatively copies of the queue element may have been successfully enqueued in both queue portions and and perhaps in queue portion as well but a subsequent dequeue operation may have succeeded for queue portion but not for queue portion . In the latter case it is possible that the copy of queue element in queue portion will cause the queue element to be provided a second time to one or more queue consumers for queue and furthermore that the second or later copy of queue element may be provided after other later enqueued elements have been provided e.g. after queue element from queue portion of system this behavior is particularly likely in embodiments in which any of a data storage system and its mirror systems may be selected to respond to a queue related operation such as when all such systems are treated equally with respect to queue operations rather than treating the mirror systems as secondary or backup systems. Similarly the inconsistency between queue portions and with respect to queue element may occur in various ways e.g. an initial enqueue of the data element succeeding for queue portion but not for but should not cause problems with operation of queue unless system and other mirror systems that have stored queue element e.g. system fail or otherwise become inaccessible before the queue element is dequeued.

As previously noted in the illustrated embodiment system operates as a mirror system with regard to queue for system but it does not operate as a mirror system for system for the other queues stored on system . In other embodiments however mirror systems may always mirror all queue elements stored on the systems being mirrored or instead mirror systems may be selected on a per queue element basis rather than a per queue basis. In this example embodiment system does not replicate queue or queue portion from system but does include a queue portion for queue in this example the queue portion may be a mirrored queue portion for another system or instead one or more other systems may mirror queue portion on system

By maintaining such information about data storage systems used by the data queuing service new data storage systems can easily be added for use with the data queuing service and existing data storage systems can easily be removed when they fail or otherwise become unavailable. To incorporate such changes available data storage systems to use for a queue operation may in at least some embodiments be dynamically selected at the time of at least some queue operations. In addition by enabling the easy addition of new data storage systems the data queuing service can easily scale to handle increasing queue related workloads and or to handle increasing sizes of queues. Moreover the ability to easily remove and replace failed systems also allows low cost commodity and or failure prone systems e.g. systems providing less than four nines 99.99 or five nines 99.999 guaranteed uptime to be used for data storage systems in at least some embodiments. In particular when an existing data storage system fails in the illustrated embodiment e.g. due to a hard disk crash or failure of other hardware that prevents a system from rebooting software bugs that cause a system to hang or reboot failure of a network connection to the data storage system permanent destruction of a data center etc. another new data storage system may be used to replace the failed system for new queue operations but the stored queue elements on the failed system are not replicated on the new replacement data storage system in other embodiments such stored queue elements on a failed system may instead be replicated on a new replacement data storage system e.g. based on information from one or more mirror systems for the failed system . In addition in some embodiments the determination of mirroring relationships between systems may be re evaluated after any change to the current data storage systems such as based on a deterministic algorithm to select mirror systems. Furthermore in some embodiments the data queuing service or the merchant or other entity providing the service may guarantee levels of service or reliability to customers based on an estimated probability of failures of data storage systems such as the likelihood of losing an enqueued data element due to all storage systems that have a stored copy of the data element becoming unavailable before the element is dequeued.

In the illustrated embodiment the read lock timeout value is used when reading and dequeuing elements from queues. In particular in order to ensure that queued data is successfully obtained by a consumer program in the illustrated embodiment a consumer program first accesses an enqueued data element by requesting that the data element be read without having the element be removed from the queue. If the enqueued data element is successfully received by the consumer program the program then requests that the element be dequeued from the queue such as by indicating the queue element using a queue element identifier that was received by the program as part of the response to the prior read request. While this technique ensures that queued data is received by a consumer program an issue occurs with a first queue element that has been read by one consumer program when another consumer program executes a read request before that first queue element has been dequeued in particular that same first queue element may be returned in response to the subsequent read request. In order to address this issue in some embodiments an enqueued data element that has been read but not yet dequeued is placed in a locked state for a limited period of time e.g. a time equal to the read lock timeout value such that any such locked enqueued data elements are not returned for any subsequent read requests with the read lock timeout value being configurable for each queue. In addition in some embodiments a similar technique could be used to lock queue elements as they are being enqueued such as to ensure that sufficient time exists to allow a queue element to be enqueued on or more mirror systems before it is read and or dequeued e.g. in situations in which queue elements are read very quickly such as with a LIFO queue .

In the illustrated embodiment an example Queue Service Subscription system is executing in memory in order to provide subscription related services to users such as users of user computing system over network . For example one of the users may use a browser executing in memory of a user computing system to interact with the Queue Service Subscription system in creating and providing information about a subscription of the user including to create and or associate one or more queues with a subscription. However while queues are associated with subscriptions of users in the illustrated embodiment in other embodiments queues need not be associated with such subscriptions e.g. if no payment or usage restrictions are to be used with the queues or such subscriptions may not be present at all. In the illustrated embodiment the Queue Service Subscription system stores received subscription information in a subscription information database on storage and may further store additional received user related information if any in an optional other user information database . For example in some embodiments the Queue Service Subscription system may be provided by or on behalf of a merchant and the users of the user computing systems may be customers of that merchant if so various customer related information about users that is not specific to customer subscriptions may be obtained and stored for later use in transactions with the merchant. Various types of information can also be specified for queues such as to configure their operation and if so the Queue Service Subscription system stores the received queue configuration information in a queue configuration database on storage . For example configuration information may include details about access controls e.g. to limit some or all queue related operations to specified users queue operation information e.g. how long to lock a queue element that is read such as 60 seconds how long to maintain queued elements that have not been dequeued such as 30 days how large or how many or what type of data may be stored in a queue such as a maximum of four thousand queue elements that may each contain four kilobytes of any type of UTF 8 encoded XML data etc. .

An example embodiment of DQS system is also executing in memory to provide queue related services to executing programs. In particular in the illustrated embodiment an application program is executing in memory of each of one or more client computing systems and those application programs may interact with the DQS system to obtain distributed queue services. In the illustrated embodiment a client computing system may have one or more data elements on storage and may wish to store those data elements in a queue for its own later use and or for later use by other application programs. In order to enqueue such data elements the application program sends a corresponding request to the DQS system to add one or more of the data elements to a specified queue such as by providing a unique queue identifier for a queue that was previously created e.g. by a user of one of the user computing systems with whom the application program is associated and included as part of the application program or provided in a manner otherwise accessible to the application program. The request may be sent to the DQS system by for example invoking an API not shown provided by the DQS system such as an API based on Web services. In some embodiments the request may further include an indication of an associated subscription and or of a user on whose behalf the enqueue request is made such as to allow the DQS system to determine whether the request is allowed for the queue based on usage restrictions and or access controls.

When the DQS system receives an enqueue request and associated data element s the system forwards the request and associated data to a Queue Operation Processer component for processing. In some embodiments multiple such components may be simultaneously executing e.g. for load balancing and or scalability reasons whether as part of a single computing system or on multiple systems and if so the request and data may be forwarded to any of the components for handling in the illustrated embodiment. After a component receives the data enqueue request it obtains information from a data storage system database or db on storage to identify a group of one or more alternative data storage systems that are associated with the queue and available for storing the data element s such as based on a dynamically executed algorithm e.g. a consistent hashing algorithm . The component then selects one of those identified data storage systems e.g. at random and sends the data enqueue request to that data storage system. In some embodiments the component may further identify one or more mirror data storage systems for the selected alternative data storage system e.g. from the database and if so sends the data enqueue request to each of those mirror data storage systems as well. After receiving an indication of success for the enqueue operation which in the illustrated embodiment is based on success of at least one of the selected alternative data storage system and mirror systems in performing the enqueue operation the component provides a corresponding response to the application program that sent the enqueue request.

In a similar manner when an application program desires to obtain one or more enqueued data elements whether the same program that performed the enqueuing or a distinct program the program sends a request to the DQS system to obtain one or more of the enqueued data elements. In particular as discussed in greater detail elsewhere in the illustrated embodiment the application program will first request to read the data element s and after the read is successfully performed will request to remove the data element s using a dequeue operation. When the DQS system receives a read or dequeue request it forwards the request to the Queue Operation Processor component . For a read request the component identifies one or more data storage systems that store at least one queue element for the queue e.g. by using a queue storage location database as discussed below and selects one of those identified data storage systems e.g. at random . For a dequeue request of a specified enqueued data element the component instead selects the data storage system that stores that data element such as based at least in part on information in the dequeue request that identifies that data element and or system. After selecting a data storage system for a read or dequeue operation the component then sends the request to that data storage system as well as to mirror data storage system s if any for the selected data storage system. After receiving an indication of success for the operation which in the illustrated embodiment is based on success of at least one of the selected data storage system and mirror systems in performing the operation the component provides a corresponding response to the application program that sent the request including any retrieved queue element s for a read request.

In order to assist in the identification of an appropriate data storage system that stores queued data elements for a queue identified in a read request the component uses a queue storage location database in the illustrated embodiment. In particular when the component enqueues a data element on a queue it stores an indication in the queue storage location database that the data storage system has at least one stored data element for that queue. If an attempted read of a queue element for a queue on the data storage system later indicates that no data elements are currently stored the component updates the queued storage location database to reflect that the data storage system does not store any data elements for the queue.

In addition each of the data storage systems will occasionally e.g. every few seconds send status messages to the DQS system in the illustrated embodiment to indicate that they are still functioning and accessible such as if the data storage system is able to execute a dummy query on a database used to store queue elements in some embodiments the status messages may simply be a heartbeat message indicating that the data storage system is alive with little or no additional substantive data about the system. Thus if the DQS system and in particular a Queue Distributed Storage Manager component of the system does not have any interactions with a data storage system for a sufficiently long period of time e.g. does not receive 3 consecutive heartbeat messages or instead has two requested operations to the system timeout without a response the component will update the data storage system database and queue storage location database to indicate that the data storage system is not currently available and does not store any data elements for any queues e.g. by removing entries corresponding to that data storage system . New data storage systems similarly interact with the component to provide information about their availability which is stored in the data storage system along with indications of one or more mirror systems for the data storage system. In some embodiments the component will determine appropriate mirror systems for each of the available data storage systems such as after each occurrence of adding a new data storage system or of removing an existing data storage system that is no longer available.

When a DQS Interacter component at a data storage system receives an enqueue request from the DQS system it attempts to store the data element s as queue elements in a manner associated with the indicated queue. The data storage system then provides an indication of success or failure to the DQS system. Similarly when a DQS Interacter component at a data storage system receives a read request from the DQS system it attempts to retrieve stored data element s from the queue and if successful returns the retrieved queue elements to the DQS system for forwarding to the application program that made the read request. In addition when a DQS Interacter component at a data storage system receives a dequeue request from the DQS system it attempts to remove the specified data element s from the indicated queue and then provides an indication of success or failure to the DQS system. Other queue related operations will similarly be handled in appropriate manners by the DQS Interacter components for the data storage systems.

In the illustrated embodiment an optional Payment Processor component is also executing as part of the DQS system such as to obtain payments as appropriate for queue related operations in embodiments in which fees are charged by the DQS system e.g. by using payment source information associated with queues with subscriptions associated with the queues and or with one or more users associated with the queues . Similarly one or more other systems may also be executing in memory e.g. a monitoring program to track queue and or data storage system usage and if so may interact with the DQS system and or the information stored on the storage as appropriate.

Those skilled in the art will appreciate that computing and data storage systems and are merely illustrative and are not intended to limit the scope of the present invention. Computing system may be connected to other devices that are not illustrated including through one or more networks such as the Internet or via the World Wide Web Web . More generally a client or server computing system or data storage system may comprise any combination of hardware or software that can interact and perform the described types of functionality including without limitation desktop or other computers database servers network storage devices and other network devices PDAs cellphones wireless phones pagers electronic organizers Internet appliances television based systems e.g. using set top boxes and or personal digital video recorders and various other consumer products that include appropriate inter communication capabilities. In addition the functionality provided by the illustrated system components may in some embodiments be combined in fewer components or distributed in additional components. Similarly in some embodiments the functionality of some of the illustrated components may not be provided and or other additional functionality may be available.

Those skilled in the art will also appreciate that while various items are illustrated as being stored in memory or on storage while being used these items or portions of them can be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively in other embodiments some or all of the software components and or modules may execute in memory on another device and communicate with the illustrated computing system device via inter computer communication. Some or all of the system components or data structures may also be stored e.g. as software instructions or structured data on a computer readable medium such as a hard disk a memory a network or a portable media article to be read by an appropriate drive or via an appropriate connection. The system components and data structures can also be transmitted as generated data signals e.g. as part of a carrier wave or other analog or digital propagated signal on a variety of computer readable transmission mediums including wireless based and wired cable based mediums and can take a variety of forms e.g. as part of a single or multiplexed analog signal or as multiple discrete digital packets or frames . Such computer program products may also take other forms in other embodiments. Accordingly the present invention may be practiced with other computer system configurations.

The routine begins at step where an indication is received of a request for a queue related operation or information related to one of the distributed data storage systems. In some embodiments queue related operation requests may be received via an API provided to external entities such as a Web services based API invoked by executing application programs of customers of the distributed queuing services. Similarly in some embodiments interactions with data storage systems and or other executing programs e.g. a subscription service for a merchant who is providing the distributed queuing service may similarly occur via a provided API such as a Web services based API.

In the illustrated embodiment the routine continues to step to determine whether the indication received in step was to create a new queue such as a request from a customer s application program or from a subscription service. If so the routine continues to step to generate a unique identifier for the new queue and in step stores the queue identifier and other received information related to the queue e.g. configuration information such as access controls related to use of the queue and or other usage restrictions a subscription identifier associated with the queue information about operating parameters for the queue an expiration date or other effective times for the queue etc. . While not illustrated here in other embodiments additional types of functionality may be provided such as to verify that the requester is authorized to create the queue and or to obtain any associated payment for the queue creation before proceeding. Similarly in some embodiments an initial group of one or more data storage systems to store the data element of the queue could be identified for use with subsequent queue usage operations and stored for later retrieval although in the illustrated embodiment the selection of a group of appropriate alternative data storage systems for a queue is performed dynamically at the time of at least some queue usage operations. After step the routine continues to step to provide an indication of the generated queue identifier to the requester for later use with the queue.

If it is instead determined in step that the received indication in step was not a request to create a queue the routine continues to step to determine whether the indication is a request for a queue usage operation such as to enqueue read or dequeue one or more data elements. If so the routine continues to execute subroutine to process the requested queue usage operation and in step receives a response for the operation e.g. one or more retrieved queue data elements for a read operation or an indication of success or failure for an enqueue or dequeue operation . After step the routine continues to step to send the response information to the requester. If it was instead determined in step that the received indication in step was not a request for a queue usage operation the routine continues to step to determine whether the received indication is information from or related to a data storage system. If so the routine continues to execute subroutine to process the received information in an appropriate manner and in step receives a response related to the handling of the message.

If it was instead determined in step that the indication received in step was not information related to a data storage system the routine continues instead to step to perform another indicated action if appropriate. For example in some embodiments other actions may involve other types of requests related to queues e.g. to change configuration information to delete a queue etc. and if so the requested action will be performed if appropriate e.g. if the requester is authorized to perform the action . Alternatively the indicated action may be related to monitoring the operation of the distributed queuing service or to perform various administrative modifications with respect to the distributed queuing service. After steps or the routine continues to step to determine whether to continue. If so the routine returns to step and if not the routine continues to step and ends.

The subroutine begins at step where an indication is received of a queue usage operation requested by a remote executing program. In some embodiments each queue usage operation request may include an indication of the queue identifier for the queue a subscription ID associated with the queue a user identifier associated with the requester an indication of the type of queue usage operation and optionally data associated with the queue usage operation e.g. one or more data elements to be added to the queue for an enqueue operation . The subroutine next continues to step to verify whether the requested queue usage operation is permitted for the queue and requester such as based on configuration information associated with the queue. If it is determined in step that the queue usage operation is not allowed the subroutine continues to step to return a corresponding error message to the requester. However if it was instead determined in step that the queue usage operation is allowed or if such a check is not performed in other embodiments the subroutine continues to step to determine whether any payment is associated with performance of the queue usage operation e.g. to charge per operation fees for enqueue and or read operations . If so the subroutine continues to step to attempt to obtain the payment e.g. based on the subscription associated with the queue and or from the operation requester such as in an interactive manner . If it is determined in step that the payment was not obtained the subroutine continues to step to return a corresponding error message.

If it was instead determined in step that no payment was needed or in step that any needed payment was obtained or alternatively if payments are instead not used in other embodiments the subroutine continues to step to select a data storage system associated with the queue for use in performing the requested queue operation. In some embodiments and situations a group of multiple alternative data storage systems may be identified for the queue and if so one of those systems can be selected in a variety of ways. For example in situations in which the data storage systems associated with a queue will change rarely or not at all indications of the associated data storage systems for a queue may be initially assigned and then later used for enqueue read and or dequeue operations. However in the illustrated embodiment the data storage systems associated with a queue are dynamically determined for enqueue operations at the time of the operation and the associated data storage systems for a read operation are identified based on a dynamic determination of the data storage systems that currently store at least one data element for the queue. In particular in the illustrated embodiment the associated data storage systems for a queue are identified based on the use of a consistent hashing algorithm that selects one of the currently available data storage systems. If the current queue is to be distributed across a group of multiple alternative data storage systems such as based on the configuration information for the queue and or in a dynamic manner based on current conditions e.g. the load one some or all of the data storage systems the additional data storage systems are identified in the illustrated embodiment by using other data storage systems that consecutively follow the initial matching data storage system based on some consecutive ordering technique for the data storage system e.g. based on network addresses . If multiple alternative data storage systems are identified whether for an enqueue or read operation one of those data storage systems can be selected for use with the operation in various ways such as randomly based on distributing the load across all of the data storage systems as equally as possible etc.

After step the subroutine continues to step to identify any mirror data storage systems for the selected data storage system. In the illustrated embodiment mirror systems are associated with data storage systems in a manner independent of the queues stored on the data storage systems but in other embodiments a data storage system may have distinct mirror systems for distinct queues stored on the data storage system or more generally mirroring could be performed on a per queue element basis. After step the subroutine in step attempts to perform the requested queue usage operation on the selected data storage system and any identified mirror data storage systems such as by sending appropriate request messages to those data storage systems.

In step the subroutine then determines whether the attempted operation succeeded on at least one of those data storage systems such as based on responses received from those systems. If none of the attempted operations succeeded the subroutine continues to step to return an indication that the operation did not succeed. In addition if the usage operation was to read a data element but the selected data storage system and its mirror systems are not currently storing any data elements for the queue information about the selected data storage system is updated in step to reflect that no data elements are currently stored for the queue on that data storage system. In other embodiments if a read operation failed in this manner the subroutine may instead attempt to select a different one of the associated data storage systems for the queue that is believed to currently store one or more data elements for the queue and to return to step for additional processing. While not illustrated here in other embodiments the subroutine could further determine if responses were received from any of the systems that indicate that the systems are functioning properly and if so the subroutine could update information for each of those systems to reflect that they are currently functioning e.g. to assist in later identification of systems that have failed or are otherwise inaccessible due to a lack of communication with those systems for a sufficiently long period of time 

If it was instead determined in step that the requested usage operation did succeed for at least one of the selected and mirrored data storage systems the subroutine continues to step to update information for each of the systems on which the operation succeeded in order to reflect that the system is currently functioning. After step the subroutine continues to step to determine if the usage operation was to enqueue one or more data elements and if so information for the systems on which the operation succeeded are updated to reflect that they currently store at least one data element for the queue e.g. to allow them to be identified as an appropriate data storage system for a later read usage operation . In step the subroutine then returns a message to the requester indicating success including any associated data for the operation such as one or more queue data elements that are retrieved in response to a read operation. After steps or the subroutine continues to step and ends.

The subroutine begins at step where an indication is received of information from or related to a data storage system or instead that a timer has expired such a timer may be repeatedly set to provide polling functionality for the subroutine such as to trigger a check of the current availability of data storage systems that have previously been in use. If it is determined in step that a timer expiration has not occurred the subroutine continues to step to determine if the indicated message reflects that a new data storage system has become available. If so the subroutine continues to step to store information about the new data storage system so that the data storage system will be available for future use to store queue information. The subroutine then continues to step to identify one or more mirroring data storage systems for the new data storage system and to store that information with the information about the new data storage system.

If it was instead determined in step that an indication of a new data storage system was not received the subroutine continues instead to step to determine whether current status information was received from a data storage system. If so the subroutine continues to step to update information for that data storage system to indicate that the data storage system is available as of the time of the message. If it was instead determined in step that information was received that was not a status message the subroutine continues instead to step to perform another indicated operation if appropriate such as to update configuration and or other information for a data storage system that is already in use by the distributed queuing service.

If it was instead determined in step that a timer expiration did occur the subroutine continues to step to determine whether any data storage systems currently in use have become unavailable such as based on not having received a status message from the data storage system for a specified period of time and or having a specified number of attempted operations for that data storage system fail. The subroutine then continues to step to determine if any systems were identified and if so continues to step to update stored information used by the data queuing service to remove any stored indications that the data storage system is available for storing new queue data elements and that the data storage system currently stores any queue data elements. The subroutine then further continues to step to reallocate which data storage systems are mirrors for other data storage systems so that each data storage system has an appropriate number of mirror systems. After steps or the subroutine continues to step and ends.

The routine begins in step where an indication is received of a queue usage operation request or that a timer has expired such a timer may be repeatedly set to provide polling functionality for the routine such as to ensure that the data storage system repeatedly provides status information to the DQS system in a timely manner. The routine continues to step to determine whether an enqueue request was received and if so continues to step to add the one or more data elements included with the request to storage in a manner associated with the identified queue for the request with the storage performed in such a way as to place the new data elements at the end of the queue e.g. by storing them with a timestamp to facilitate later time based sorting .

If it was instead determined in step that the received request was not for an enqueue operation the routine continues to step to determine whether the request was for a read operation. If so the routine continues to step to retrieve one or more of the next available stored data elements for the specified queue and in step places a read lock on those storage data elements for a specified period of time such that they will not be treated as being available for subsequent read requests during that period of time. In step if the operation was successful the routine then provides to the requester the retrieved queue data elements and any identifiers associated with the data elements and otherwise provides an indication that the operation did not succeed e.g. by indicating that no queue elements are currently stored that a read request to an underlying database failed by failing to provide any response within a specified period of time etc. .

If it was instead determined in step that the received request was not for a read operation the routine continues instead to step to determine whether the received request was for a dequeue operation. If so the routine continues to step to remove the one or more identified queue data elements if they are present in storage. After steps or the routine then continues to step to provide an indication to the requester of whether the operation succeeded. If it was instead determined in step that the received request was not for a dequeue operation the routine continues instead to step to determine whether another type of requested operation was received. If so the routine continues to step to perform the requested operation if appropriate.

After steps or or if it was instead determined in step that a request was not received and that a timeout has instead occurred the routine continues to step to determine whether it is time to provide status information to the queuing service. If so the routine continues to step to send a status information message to the service to provide an indication that the data storage system is available and operating. After step or if it was instead determined in step not to send a status message the routine continues to step to determine whether to continue. If so the routine returns to step and if not continues to step and ends.

As previously noted in some embodiments fees may be charged in certain circumstances such as on a per queue operation basis. While such fees may be fixed or pre specified in some embodiments in other embodiments such fees may be determined in other manners such as based on network congestion current storage levels an amount of resources required to satisfy the request etc. In addition the fees may be charged to various parties in some embodiments such as a user that originally created the queue e.g. based on a subscription of the user that is associated with the queue a non creator requester on whose behalf of a queue operation request is received e.g. an end user of an application program provided by the user who created the queue etc.

In addition as previously noted in some embodiments any type and amount of data may be stored in a queue element and or in the aggregate for a queue while in other embodiments only specified types of data and or specified amounts of data may be stored in a particular queue element. In embodiments in which storage restrictions are imposed various additional techniques may be provided to allow users additional capabilities. For example in some embodiments an additional temporary storage facility may be made available to users e.g. for a fee for some or all storage related interactions and or by providing a Web services based API to users whether by the same entity providing the data queuing service or an unrelated third party. If so a user may be directed and or instructed to store at least some types of data in the other storage facility and to then store information in a queue data element to indicate how to access that other stored information e.g. a pointer or identifier for the other stored data an executable program or script access information etc. .

In addition in some embodiments a variety of types of additional functionality that may be used by the data queuing service and or provided to users of the queuing service. For example in some embodiments various types of processing could be provided for information stored in queue elements such as to perform virus checking content analysis and or filtering data conversion e.g. language translation for textual information encryption and or decryption services etc. . Furthermore in some embodiments additional capabilities may be provided to and or suggested to users regarding use of the queues such as techniques for encrypting data before it is provided to the data queuing service to prevent anyone including the data queuing service from accessing enqueued data and for correspondingly decrypting dequeued information.

The following describes additional details regarding specific example embodiments of the data queuing service which are provided for illustrative purposes and are not intended to limit the scope of the invention.

One example of how a customer might use the data queuing service involves communication between loosely coupled sporadically connected clients. In particular the data queuing service can be used to enhance a distributed sales force application that is used for generating and following up on sales leads. In this example a software company sends its sales force out to trade shows all over the country in order to stir up business with the salespeople being given the task of generating leads by working the trade show floor and entering information related to every lead on a potential client into an application running on their PDA. The PDA has very limited local storage so upon inputting a lead it immediately connects to the Internet and enqueues the contact information as a queue data element using the data queuing service.

To follow up on these generated leads the company uses another group of sales people that work from home on a casual basis. When a sales person desires to do some work he she uses the sales force application to contact the data queuing service and read an enqueued lead to be followed up on. Once the lead is followed up on the sales person uses the application to dequeue the queue element that contained the lead information. Since a queued element that is read but not yet dequeued will not be returned by subsequent reads while it is locked a lead retrieved by a salesperson will be visible only to him her until the element is dequeued or the lock expires.

Another example of how a customer might use the data queuing service involves the use of queues to support reliable transaction processing systems. In particular the data queuing service can be used to enhance an order acceptance system for an online retailer that accepts orders from customers over the Internet. This retailer in this example wants to be able to accept orders unconditionally regardless of whether their computer systems fail a natural disaster strikes or even if the order processing software crashes.

In this example customers use the retailer s website or a desktop client application to place their orders. The orders are sent into a queue provided by the data queuing service rather than directly to the retailer because the highly reliable data queuing service allows operations to succeed even if the retailer s servers are down. The retailer s server side order processing software then reads from the queue to retrieve enqueued orders which are processed by the retailer s in house servers. The orders remain in the queue until an order has shipped thus preventing order loss even if the order processing software crashes while processing an order.

As another example of how a customer might use the data queuing service consider a customer who uses a system to process financial transactions e.g. payments for a merchant or a financial institution . In such situations the customer may temporarily enqueue payment related transaction requests and then dequeue them in order to process them. This allows the transaction processing system to ensure that the transaction requests are reliably stored until they are executed as well as to provide a buffer when particularly large numbers of transaction requests are received. Commonly owned U.S. patent application Ser. No. 10 894 347 filed Jul. 19 2004 and entitled Automatic Authorization Of Programmatic Transactions which is hereby incorporated by reference in its entirety discusses one example of a transaction system that may use the data queuing service in this manner.

As previously noted in at least some embodiments the group of alternative data storage systems to be used when enqueuing a new element in a queue is dynamically selected at the time of the enqueuing operation. As one example of such a dynamic selection process the data queuing service uses a variation of consistent hashing to assist in balancing overall load. During this process all data storage system identifiers are hashed onto a unit circle and the queue identifier for the queue is similarly hashed onto the same circle. The next data storage system on the unit circle after the queue identifier is then selected as a first data storage system associated with the queue and an additional K 1 data storage systems that occur on the unit circle in a clockwise direction after the initial data storage system will subsequently be selected as additional alternative data storage systems where K reflects a degree of distributedness of the queue. A K value for a queue can be selected in a variety of ways including by adjusting K dynamically for a queue based on the current load on the queue and or based on other current conditions.

As one example of managing load consider a situation in which the data queuing service supports up to 1 million queues that have an average of 1000 elements per queue with the elements averaging 1 kilobyte. If 20 data storage systems are used that each have 100 gigabyte disks the total data storage capacity will be 2 terabytes which is twice the expected need capacity. If the data queuing service thus operates at 50 capacity concerns about sufficient storage space are significantly minimized.

As previously noted in at least some embodiments each data storage systems will have at least one mirror data storage system that replicates stored data queue elements. As one example of a process of selecting a mirror system the following characteristics are employed a mirror system should be in a different data center from the system being mirrored if at all possible reciprocating mirror system relationships are preferred having one system serve as a mirror for too many other systems should be avoided and the process should be deterministic and very tolerant of data storage system failures. In particular each system in one data center is attempted to be matched up with a system in an other data center that is at the same modulo position with position determined by the sorted order of the system identifiers within the data center to mirror each other. If the data centers have a different number of systems one or more of the systems in the data center having the smaller number of systems may be allowed to serve as a mirror for multiple other systems in the data center having the larger number of systems. If there are too few systems available in the data center having the smaller number of systems a maximum threshold will be reached and mirror systems will begin to be chosen for the systems in the data center having the larger number of systems from that same data center which is beneficial in the situation where a WAN connection between data centers is experiencing an outage.

The following provides examples of techniques for handling various types of failure situations. For a permanent hard disk crash and assuming a non RAID environment the hard disk crash is equivalent to a hard server failure when the server will not reboot since the disk will not be replaced in this example embodiment. The system will naturally fall out of service based on a failure to timely supply status information to the distributed queuing service but every queue element stored in the failed system will have a replica copy in some other mirror system and these copies will be dequeued in time. New replicas of the queue elements that were lost will not be made although the risk of loss of a single copy increases with the time that the data is left in the queue.

For a temporary system failure that causes reboot the server will temporarily be out of service but will re join the set of available systems by sending out a full refresh system status message after the system comes back in service again. There is a possibility that some of the queue elements in the system have already been dequeued from their mirror system s which is considered an acceptable consequence in the illustrated embodiment. Thus no action will be taken to try to find out if queue element replicas have already been dequeued or not and the duplicate queue elements will be served in the normal manner. Similar techniques will be used for a crash or a freeze of a database server process or other data storage and retrieval program and data queuing service process. In other embodiments however additional processing may be performed in such situations such as to determine if queue element replicas have already been dequeued and if so to prevent the serving of the duplicate queue elements to customer programs e.g. by dequeuing those queue element replicas . Similarly additional processing may be performed to determine if new queue elements were added to any mirror systems while the system was unavailable and if so to replicate those new queue elements on the system.

For network isolation of one or more data centers it will appear to each data center like the other data centers have disappeared. Accordingly each data center will automatically re allocate mirror systems for each of the systems in the data center by using other systems in the same data center. When the outage is over there may be duplicate queue elements between data centers since queue elements that were dequeued from one data center may not have been dequeued from the other data center. For permanent destruction of an entire data center all data is still preserved based on mirror systems in other locations. Duplicates may be made in this situation of each of the mirror systems in order to repopulate a replacement data center.

The following provides an example of operations and APIs for at least some embodiments. In particular the following table describes parameters for operation requests and their data types.

Those skilled in the art will also appreciate that in some embodiments the functionality provided by the routines discussed above may be provided in alternative ways such as being split among more routines or consolidated into fewer routines. Similarly in some embodiments illustrated routines may provide more or less functionality than is described such as when other illustrated routines instead lack or include such functionality respectively or when the amount of functionality that is provided is altered. In addition while various operations may be illustrated as being performed in a particular manner e.g. in serial or in parallel and or in a particular order those skilled in the art will appreciate that in other embodiments the operations may be performed in other orders and in other manners. Those skilled in the art will also appreciate that the data structures discussed above may be structured in different manners such as by having a single data structure split into multiple data structures or by having multiple data structures consolidated into a single data structure. Similarly in some embodiments illustrated data structures may store more or less information than is described such as when other illustrated data structures instead lack or include such information respectively or when the amount or types of information that is stored is altered.

From the foregoing it will be appreciated that although specific embodiments have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims and the elements recited therein. In addition while certain aspects of the invention are presented below in certain claim forms the inventors contemplate the various aspects of the invention in any available claim form. For example while only some aspects of the invention may currently be recited as being embodied in a computer readable medium other aspects may likewise be so embodied.

