---

title: Modular model and simulation architecture
abstract: A computer-implemented modeling-and-simulation coordination module is provided for coordinating components by exchanging and sequencing instructions. The module includes a scenario file generator, a plug-in loader, an interface loader, a module classifier, an event detector, a response initiator, a simulation processor, a model request processor, an instance receiver, and an output provider. The scenario file generator creates a blank scenario file. The plug-in loader loads plug-in modules. The interface loader loads GUIs into corresponding containers. The classifier sets a classification to a highest rank plug-in module. The event detector monitors updating events. The response initiator prompts the operator to select an experimental plug-in module. The simulation processor executes a simulation in response to the operator loading a scenario, setting experimental parameters, and selecting the simulator plug-in. The model request processor provides parameters from the experimental frame to the model plug-in module. The instance receiver receives model instances from the model plug-in module. The output provider displays information based on time controls. The simulation processor instructs the simulator plug-in to execute instructions until satisfaction of terminal conditions and in response to initiation by the experimental plug-in module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514254&OS=09514254&RS=09514254
owner: The United States of America as Represented by the Secretary of the Navy
number: 09514254
owner_city: Washington
owner_country: US
publication_date: 20130124
---
Pursuant to 35 U.S.C. 119 the benefit of priority from provisional application 61 632 733 with a filing date of Jan. 24 2012 is claimed for this non provisional application.

The invention described was made in the performance of official duties by one or more employees of the Department of the Navy and thus the invention herein may be manufactured used or licensed by or for the Government of the United States of America for governmental purposes without the payment of any royalties thereon or therefor.

The invention relates generally to computer modeling and simulation. In particular the invention relates to program architecture for connecting modular independent elements of a modeling and simulation system for execution.

Computer simulation involves describing and executing a mathematical representation of a causality based phenomenon such as often encountered in physics or engineering. Often such simulation includes creation of a model that idealizes or simplifies a response driven avatar of an object under evaluation. Boundary and or initial conditions can be imposed on the model to stimulate responses for evaluation whether for transient or steady state scenarios.

As computational ability has improved modeling and simulation M S techniques have expanded in complexity to include either more subtle detail and or to incorporate more encompassing and interrelated processes. This has led to subdivision of coded information into instructions and data nodal or elemental discretized response models library routines event triggering forcing functions separate scenarios for simulation testing and validation.

Discrete Event System Specification DEVS represents an example standard framework or formalism for interoperable modeling and distributed simulation applicable to discrete event systems. DEVS exploits separation between a model responding object an experimental frame stimulating environment and simulator event driver interacting by mathematical rules. DEVS has been used in the development of many diverse applications since its creation in 1976. The use of DEVS in military applications has become increasingly popular particularly because event based simulation can greatly decrease execution time.

In addition DEVS simplifies development by identifying three major objects or frames that compose a system the experimental frame the simulator frame and the model frame. DEVS exploits separation between a model responding object an experimental frame stimulating environment and simulator event driver interacting by mathematical rules. The DEVS framework supports automated integrated development and testing of integrated intricate systems. Further information can be obtained from B. P. Zeigler H. Praehofer and T. G. Kim 2 e Academic Press 2000.

A modeling system under DEVS includes a temporal base states inputs outputs and functions. Inputs can be arranged during arbitrarily spaced moments in time. Functions determine succeeding states and output in response to current states and inputs. DEVS includes three frames model simulator and experiment. The DEVS simulation concept includes a model and a simulator that exchange information across an interfacing protocol. DEVS identifies separation between a model responding object an experimental frame stimulating environment and simulator event driver interacting by mathematical rules.

Conventional modeling and simulation M S architecture yield disadvantages addressed by various exemplary embodiments of the present invention. In particular various exemplary embodiments provide a computer implemented modeling and simulation coordination module for coordinating components by exchanging and sequencing instructions. The module includes a scenario file generator a plug in loader an interface loader a module classifier an event detector a response initiator a simulation processor a model request processor an instance receiver and an output provider. The scenario file generator creates a blank scenario file. The plug in loader for loading an available plurality of plug in modules. The interface loader loads GUIs into corresponding containers. The classifier sets a classification to a highest rank plug in module of the plurality of plug in modules. The event detector monitors updating events. The response initiator for prompting the operator to select an experimental plug in module from an available plurality of experimental plug in modules. The simulation processor for executing a simulation in response to the operator loading a scenario setting experimental parameters selecting the simulator plug in. The model request processor for providing parameters from the experimental frame to the model plug in module. The instance receiver for receiving model instances from the model plug in module. The output provider for disseminating display information based on time controls. The simulation processor instructs the simulator plug in to execute instructions until satisfaction of terminal conditions and in response to initiation by the experimental plug in module.

In the following detailed description of exemplary embodiments of the invention reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized and logical mechanical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

In accordance with a presently preferred embodiment of the present invention the components process steps and or data structures may be implemented using various types of operating systems computing platforms computer programs and or general purpose machines. In addition those of ordinary skill in the art will readily recognize that devices of a less general purpose nature such as hardwired devices or the like may also be used without departing from the scope and spirit of the inventive concepts disclosed herewith. General purpose machines include devices that execute instruction cede. A hardwired device may constitute an application specific integrated circuit ASIC or a field programmable gate array FPGA or other related component.

Various exemplary embodiments enable modeling and simulation M S frames along with output providers to be developed separately as plug in modules by defining a communication protocol. These frames can be and preferably are produced in conformance to Discrete Event System Specification DEVS . An entire M S system can be created by adding removing and swapping these independently developed pieces. Various exemplary embodiments enable input plug in modules e.g. model experimental execution plug in modules e.g. simulator and output plug in modules to be developed separately and pieced together to form a system facilitating development to be compartmentalized.

Modular simulation with independently created components can be treated as a plurality of frames with mutual interface connections. Various exemplary embodiments provide a coordinating module Orchestrated Simulation through Modeling called Osm pronounced awesome as in Awesome is as Osm does that behaves as a conductor defining rules for interaction that other participating components follow to render a performance or execute a simulation. These additional components can include frames or plug in modules for models experiments outputs and simulations. Each of these modules may include or access libraries for further repository information.

In contrast to the orchestral arrangement of Osm a conventional modeling and system framework can be analogized as a one man band. There is one exception basic models are defined within the framework and model plug in modules can be developed to provide more advanced versions of these basic agents. For example a basic model of an airplane can be defined in a framework. A propeller driven biplane model plug in would extend the basic airplane model that is defined in the framework. Conventional M S environments restrict event interactions metric collections etc because this is all defined at the basic agent s level inside of the framework.

By design the exemplary approach limits the traditional model plug in module s ability to define its interactions with other models. Typically open architectures include standards and protocols that enable models to be updated and or added to the M S system readily plug and play. For M S involving a limited number of models the open architecture design centralizes information flow that eventually passes from one model to another. The cost for an element to participate in such an open architecture is usually commensurate with the burden of implementing associated models standards and protocols of information exchange.

This imposition often becomes very difficult for M S involving many elements especially for elements with complicated inter element interactions. Often the composite burdens of these centralized protocols often preclude a systematic characterization of model to model interactions. Conventional M S lacks a methodology that enables models to communicate directly with one another while at the same time exchanging the right level of centralized information to the M S system as a whole.

Osm provides a methodology that fills this M S void by letting different aspects of the M S models interact independently of the centralized aspect of the system while concurrently providing a simplified protocol of information exchange to the system as a whole. In other words Osm enables the M S to better emulate how models interact with each other and as a whole by allowing computer architectures the flexibility of imposing communication standards and protocols at a level that better reflects true interface information exchanges.

Osm represents a methodology that is intended to be constructed into a computer application. Furthermore there is need for methodology to define how outputs experimental frames and simulator frames can actually be developed separately and combined to produce a scalable DEVS compliant system. Much M S effort becomes duplicated often within the same organization because this standard does not exist. There is an unfortunate absence of reusability in the M S community the deficiency of which exacerbates development time and money. The problem amounts to this How can one build a simulation tool that leverages work from others instead of starting over every time The Osm process provides standardization so that pieces can truly be developed separately and combined in a plug and play fashion.

Through Osm DEVS frames and outputs can be written as plug in modules in the same common language protocol. The solution is scalable models can be defined at different levels of detail and anything can be modeled . Where conventional M S software acts as a single musician or one man band the Osm process performs as a conductor that directs musicians working together to form a symphony. Coordination between developers is simplified. Components become interchangeable. An entire system can be dramatically changed by adding removing and swapping DEVS frames and outputs. Osm obviates the necessity to write a whole new system when only a subset of frames or outputs needs to be changed. The conventional framework monopolizes all of the control of options. The Osm framework distributes this authority to the plug in modules. This difference can be analogized to the contrast in early Internet access in the 1990s between America Online later AOL and Netscape. AOL enabled access to a self contained Internet community whereas Netscape provided only a web browser with a communications protocol that enabled webpage content and chat room exchange to be scripted and addressed independently. The Osm process defines how to separate the development of the DEVS frames and outputs through plug in modules to enable maximum ability of reusability of such software components.

The Osm architecture provides a scalable protocol for rapid development of discrete event simulations that employs independent frame plug in modules that can be separately composed. Various exemplary embodiments enable production of DEVS M S frames to be separately developed as plug in modules by defining a communication protocol as well as creating output results independent of these modules. An entire M S system can be created by adding removing and swapping these independently developed pieces. The architecture enables input plug in modules model experimental execution plug in modules simulator and output plug in modules to be developed separately and pieced together to form a system facilitating development to be compartmentalized. The simulation framework can expand in complexity for a system of systems as described by Robert K. Garrett Jr. et al. in Managing the Interstitials a System of Systems Framework Suited for the Ballistic Missile Defense System 2009 .

A scenario represents a concert stage on which the simulation can be executed analogous to an orchestral performance. Models represent Agents based on select quantifiable characteristics to operate under a defined simulation regime. Agents can be distinguished by actor Agents and object Agents. Analogous active Agents would include performance musicians and complementary object Agents would constitute the musical instruments subordinate to their actor Agent counterparts. The musician actor Agents could operate in accord with systemic instructions such as sheet music for the instruments in an orchestral concert as further coordinated by the conductor Osm. The Agents perform actions typically in response to triggering stimuli denoted as temporal Events. Such actions can conditionally instantiate or cancel subsequent or contemporaneous Events depending on the circumstances of the simulation. illustrate exemplary block diagrams of M S architecture using Osm.

A simulator frame shares a simulator plug in module as well as the Event center . An experimental plug in module within an experimental frame selects and executes simulation commands and issues instruction information to a simulator plug in module within the simulator frame . The model plug in module receives setting definitions from the experimental plug in module and definesAgents using get read and create instructions saved to and retrieved from a scenario file in . Creating an Agent can include Events scheduling. The experimental plug in module also communicates with the simulator plug in module to update time for scenario execution for an Event center to execute subsequent Events.

An over simplified chess match can be exhibited as an example event driven scenario amenable to model simulation. Chess involves a pair of players white and black that can move six types of pieces arranged on a square checker board having sixty four tiles. As is well known the pieces for each side include two rooks R two knights N two bishops B one queen Q one king K and eight pawns each piece having defined movements. The objective of each player in the game is to declare check mate by threatening inescapable capture of the opponent s king. Tile positions on the board can be described by columns denoted by letters and rows denoted by numerals that start from the lower left corner. At the beginning of a game the initial condition the pieces are arranged along rows adjacent opposing edges with opposing pawns facing each other.

In this example white and black respectively represent initial and subsequent turn players of their respective pieces. Each player can move the color pieces assigned but not an opposing piece except by capture and resulting seizure of that previously occupied tile. Both players and pieces constitute Agents. The player Agent is an actor that initiates events whereas the piece Agent is an object that can only respond to a player s event. The board represents a stage on which the object Agents operate definable by a scenario plug in module.

The pieces move from one tile to another based on rules such as being prohibited from shifting to a tile occupied or blocked by another piece of the same color or to a tile occupied by an opposing color piece unless by capture. Further a library function can define the types of moves assigned to each piece as object Agent. For example a pawn can only move one tile forward away from its color s initial row edge except for its first move optionally to proceed two tiles forward or diagonal capture of an opposing piece. As other examples a bishop moves diagonally forward and aft a rook moves along its row or column fore and aft a queen can discretionally move as either a bishop or a rook.

In typical notation each turn is denoted by a numeral followed by position changes by the consecutive white and black players. The move of each player triggers a countermove by the opposing player until no further moves are possible or both agree to a draw This represents an Event driven scenario in which each turn has consecutive first and second Events and the second Event of that turn initiates the next turn. Each move of a piece is indicated by the piece s uppercase letter followed by the coordinate of the destination tile. For example Be5 move a bishop to e5 Nf3 move a knight to f3 c5 move a pawn to c5 pawns denoted without a piece letter . Seizure of a tile occupied by an opposing piece indicates its capture. For the scenario shown the board depicts the white king threatened by the black queen as a consequence of positions of the white and black pawns and . The relevant two turn notation for fool s mate can be indicated for the Events in each turn as 1. g4 e5 2. f3 Qh4 mate .

As provided by exemplary embodiments code for the Osm library and executable remain the same irrespective of which plug in modules are employed. To create chess software with Osm involves a set of plug in modules described as follows 

In Chess the Agent types would be king queen knight bishop rook pawn and player. A model plug in of type chess player might define an actor Agent as follows identifier number skill level color white or black number of each object Agent and beginning board position for each object Agent. Note that the object Agent can be described as a child Agent subordinate to the actor Agent. The GUI for such a model plug in can enable the operator to define each player.

The Scenario Definition file created by such a plug in module with two entries might resemble as shown in the instruction list . The actor Agent identification for the first player provides parameters relevant to the scenario. Initial positions of pieces on the board for the first player can be listed beginning with the pawns on the second row and followed by the ranking pieces on the first row. The actor Agent identification for the second player provides complementary information associated with the chess game. Initial positions of pieces on the board for the second player can be listed with the pawns on the seventh row and the ranking pieces on the eighth row. For both players and distinguished by color the pieces are identified by their respective row and column tile on the board at the start of the game.

Through the Osm executable these entries can be saved to a file and reloaded later. The experimental plug in can provide a global audience variable which the model plug in would request for each entry when creating Agents from the Scenario Definition . When creating the Agents the chess player model plug in would request the audience from the experimental plug in . This can be done through a get method in the experimental plug in that enables as input an identifying word and the requestor. For instance the model plug in could state 

which returns an Object of type int. This enables environmental influences to be independently imposed onto actor Agents in this example.

Upon completion of defining the Agent characteristics in the model plug in the simulator plug in can be selected and then executed by the experimental plug in . A first Event begins the game. During the first turn the first player moves e.g. pawn7 at g2 to g4 which schedules the opponent to perform the second turn as a second Event by the simulation algorithm for the second player to move e.g. pawn5 at e7 to e5. This completes the first turn which initiates a third Event beginning the second turn by the simulation algorithm. The first player moves e.g. pawn6 at f2 to f3 and triggering a fourth Event. In response the second player moves e.g. queen at d8 to h4. The white king becomes trapped being subject to capture by the black queen and unable to block or escape resulting in check mate. This final move terminates further turns and thereby any subsequent events and the game concludes with the black player victorious. Artisans of ordinary skill will recognize that such a simplified example can be readily expanded to war game simulation and to other conditional Event triggered modeling scenarios.

The Osm executable populates the add buttons with plug in identifications that instantiate their respective user interfaces and incorporate their entries to the add feature . In this example the three plug in options define themselves under the Threat type. As described for the identification is displayed in a dialog box with quantitatively selectable times and parameters . In response to clicking the add button in the feature a list of Threat plug in modules is displayed in the list . For a scenario in which the operator selects the Raid plug in module the consequence introduces a subsequent plug in module graphical interface in as a pop up feature.

There are sundry arrangements in which data can be displayed in a meaningful format. With output plug ins any data can be displayed in any manner desired. Output plug in modules have access to all of the Agents in a Scenario. The Osm executable s time control sends its current value to each output plug in as the chronology updates. The output plug ins can react in any manner desired and they can interrogate the Metrics Events Notes and any other data that are easily accessible for each Agent . There is no limit to the manner in which information can be visualized.

In step the operator creates a scenario through the model plug in GUIs or alternatively the operator loads an existing scenario file . In step the operator sets experimental parameters including end conditions in the experimental plug in GUI within the experimental frame . In step the operator selects a simulator plug in module in the experimental plug in GUI implicitly or explicitly . In step the operator instructs Osm to execute simulation through the experimental frame. In step model plug in modules request parameters from the experimental frame and the scenario file . In step model plug in modules create model instances from these input parameters. In step the experimental plug in module initiates the simulator plug in s algorithm. In step the simulator plug in modules execute until final conditions are satisfied. In step the operator moves the time control. In step Osm sends time control data to output plug in modules . In step output plug in modules display information based on time control and other input parameters.

Quantitative advantages for the exemplary distributed modular architecture for simulation and modeling as compared to conventional integral techniques can be summarized by the following statistics for projects related to surface warfare SUW and missile defense agency MDA . Lines of code for modules common to both projects are listed as follows 

Additionally the modularity and ability to improve components would be maintained by only one group that has access to that portion of code. With Osm anybody can produce a plug in and so anybody can contribute to such a project without necessity of understanding the entire code. If one had to produce SUW from scratch that project would have required much longer time than the few months that completion was achieved. The realtime simulator plug in module involved small amounts of code to implement but completely changed the purpose of the tool. MDA routinely creates new assignments when only one component need be substituted in exemplary embodiments such as the simulator frame.

While certain features of the embodiments of the invention have been illustrated as described herein many modifications substitutions changes and equivalents will now occur to those skilled in the art. It is therefore to be understood that the appended claims are intended to cover all such modifications and changes as fall within the true spirit of the embodiments.

