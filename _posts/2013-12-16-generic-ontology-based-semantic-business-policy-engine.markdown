---

title: Generic ontology based semantic business policy engine
abstract: Techniques for implementing policies. In an embodiment, first data is stored in a first data store according to a first schema. A second schema is defined based at least in part on a policy and an ontology. Second data, which includes at least a portion of the first data, is stored in a second data store according to the second schema. Storing the second data is based at least in part on a mapping of the first schema to the second schema. At least a portion of the second data is analyzed and results of the analysis are provided to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09449034&OS=09449034&RS=09449034
owner: Oracle International Corporation
number: 09449034
owner_city: Redwood Shores
owner_country: US
publication_date: 20131216
---
This application is a continuation of U.S. patent application Ser. No. 12 684 065 filed on Jan. 7 2010 now allowed which claims the benefit of U.S. Provisional Patent Application No. 61 143 088 filed on Jan. 7 2009 TTC 021756 071101US entitled GENERIC ONTOLOGY BASED SEMANTIC BUSINESS POLICY ENGINE the entire contents of each are incorporated by reference in their entirety for all purposes.

Embodiments of the present invention relate to analysis of date for enforcement of business policies.

Businesses often have internal business policies intended to address a wide range of issues such as security privacy trade secrets criminal activity of employees or others with access to the business and many others. These business policies address various aspects of a business such as purchasing selling marketing and internal administration. Because of the large number of activities occurring during the course of running a business which may have various entities located in a variety of geographical locations it is often impractical to manually monitor all activities in which improper behavior or mistakes may occur.

One approach to implementing business policies has been to monitor and control computer systems used to facilitate a business s activities. For example information regarding various activities such as sales and payroll are often stored in one or more data stores. This information may be analyzed to find activity that might be in violation of a business policy such as an item on an invoice or paycheck to an employee being outside of a specified range or a particular employee attempting to access information to which he or she is not entitled access.

Typically analyzing data requires a high level of technical expertise as the data is often created and stored using a wide variety of business applications which often have differing standards and specifications are often custom built for specific purposes and often lack ability to communicate and share information with one another. Consequently in order to enact business policies the expertise of those familiar with the business applications to which the business policies are to be implemented is often required. For instance in order to analyze data stored in a relational database a person may have to be able to construct a proper SQL statement. Generally commonly used applications typically require users to model policies in SQL PL SQL or another application specific or storage specific language.

Those making the business policies however are often not the same people with detailed knowledge of the business systems to which the policies are to be applied. For instance a person or group of people deciding that to prevent employee fraud all payments over a specific amount should require approval by an appropriate person may not have any understanding how invoice data is stored in the business systems. Such policy makers would prefer to define policies in terms that they understand such as user general ledger organization etc. and not in terms of the applications with which policies will be implemented such as database schema x on host 55.55.55.55 FND USER table and application Y . Such policy makers would likely prefer not to take the time necessary to learn the specific application terminology as their duties typically do not require such technical expertise.

Moreover because businesses typically use several different applications to facilitate their activities it can be burdensome for policy makers to learn specific terminology for several applications. Policy makers would rather prefer that they can use an intuitive interface in order to apply familiar terminology to create policies that may be applied to a variety of applications without having to create a similar policy for each application.

Previous applications for implementing business policies have included applications that work with specific business applications and that require users to have an underlying understanding of the technical design of those business applications. One possible reason for this is that database runtimes which are frequently the underlying runtime for business applications cannot easily share runtime resources across instances and most solutions to policy modeling have either used single database instances or single database connections to support their runtime requirements.

The following presents a simplified summary of some embodiments of the invention in order to provide a basic understanding of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some embodiments of the invention in a simplified form as a prelude to the more detailed description that is presented later.

Embodiments of the present invention provide techniques for analyzing data for the implementation of policies. In one embodiment a method for implementing policies is disclosed. The method may be performed under the control of one or more computer systems configured with executable instructions. In an embodiment the method includes storing first data in a first data store according to a first schema identifying based at least in part on a policy a subset of the first data to store in a second data store determining based at least in part on the policy and an ontology a second schema for the second data store storing second data in the second data store based at least in part on a mapping of the first chema to the second schema of the second data store the second schema organizing data according to the ontology and the second data including at least the subset of first data analyzing based at least in part on the policy and the ontology at least a portion of the second ata to determine at least one conclusion and providing the conclusion to a user of said one or more computer systems. In an embodiment the second schema is optimized based at least in part on the policy and the ontology for analyzing data in the second data store.

Variations of the method are also disclosed in accordance with various embodiments. For example the method may include storing third data in a third data store according to a third schema where the second data includes at least a portion of the third data and where storing second data in the second data store is further based at least in part on another mapping that maps the third schema to the second schema. The third schema may be different from the first schema. As another example the second schema may organize at least a portion of the second data into a collection that corresponds to a semantic concept and that comprises data from the first data store and the second data store. The mapping in an embodiment defines a correspondence from the second data to a plurality of semantic concepts of the ontology. Also the method may further include selecting the mapping from a plurality of mappings that map at least one of a plurality of schemas to the second schema.

In an embodiment a system for storing data is disclosed. The system in an embodiment includes a first data store storing first data according to a first schema and at least one processor operable to define based at least in part on a policy a subset of the first data to store in the second data store to determine based at least in part on the policy and the ontology a second schema of a second data store and a mapping from the first schema to the second schema and cause loading of data into the second data store from the first data store according to the mapping. The second schema may comprise a plurality of tables and the processor may be operable to optimize the second schema for analysis according to the policy. The system may also include a third data store that stores third data according to a third schema where the second data includes at least a portion of the third data and where said at least one processor is operable to cause loading of data into the second data store from the third data store according to another mapping of the third schema to the second schema. The first schema may be different from the third schema. Also the second schema may organize at least a portion of the second data into a collection that corresponds to a semantic concept and that comprises data from the first data store and the second data store. The mapping in an embodiment defines a correspondence from the second data to a plurality of semantic concepts of the ontology. Also the system may further include a data store that stores a plurality of mappings that include the mapping wherein each of the plurality of mappings map at least one of a plurality of schemas to the second schema. As another example said at least one processor is further operable to analyze at least a portion of the second data to determine compliance with at least one policy.

In yet another embodiment a computer readable storage medium having stored thereon instructions for causing at least one processor to store and analyze data is disclosed. The instructions may include instructions that cause said at least one processor to based at least in part on a policy and an ontology identify first data to be loaded from a first data store to a second data store instructions that cause said at least one processor to define based at least in part on the policy and the ontology a second schema for the second data store instructions that cause said at least one processor to direct storage of second data in the second data store based at least in part on a mapping of a first schema of a first data store to a second schema of second data store the second data including at least a portion of the first data instructions that cause said at least one processor to analyze at least a portion of the second data to determine at least one conclusion and instructions that cause said at least one processor to provide the conclusion to a user of said one or more computer systems. The instructions may also include instructions that cause said at least one processor to define as part of the second schema and based at least in part on the policy a plurality of tables constructed to optimize analysis of the second data according to the policy.

In an embodiment the second data includes at least a portion of third data of a third data store the third data being organized by a third schema and the instructions that cause said at least on a processor to direct storage of second data are based at least in part on another mapping that maps the third schema to the second schema. The second schema may organize at least a portion of the second data into a collection that corresponds to a semantic concept and that comprises data from the first data store and the second data store. Also the first schema may be different from the third schema. The mapping may define a correspondence of the second data to a plurality of semantic concepts of the ontology.

In an embodiment the instructions of the computer readable storage medium include instructions that cause said at least one processor to select the mapping from a plurality of mappings that map at least one of a plurality of schemas to the second schema. Also the instructions may include instructions that cause said at least one processor to analyze at least a portion of the second data to determine compliance with at least one policy.

For a fuller understanding of the nature and advantages of the present invention reference should be made to the ensuing detailed description and accompanying drawings.

In the following description for the purposes of explanation specific details are set forth in order to provide a thorough understanding of embodiments of the invention. However it will be apparent that the invention may be practiced without these specific details.

The following description describes an embodiment of the present invention in the business policy domain and specifically with implementing business policies using ontologies that encode business data. However the scope of the present invention is not restricted to business policies but may be applied to other domains or applications. For example any domain or application where a set of rules or criteria is used to analyze data may make use of the present invention. Examples of domains in which embodiments of the present invention may be used include segregation of duties separation of powers transaction monitoring fraud or other crime detection semantic web applications and generally applications dealing with large sets of data.

In general embodiments of the present invention provide techniques for creating policies to be applied to data. As used herein unless otherwise clear from context a policy is a set of one or more conditions and a set of one or more actions to be taken when the set of conditions is met. For example a policy may be that all transactions of a certain type such as credit card charges over a specified amount require approval by a person of a specified class such as a manager. In this example the conditions of the policy are that transactions have a specified type and amount and an action of the policy is authorization of transactions meeting the conditions by a person of a specified class. An action of a policy may also be simply identification of data that meet the policy s condition s . For example a policy may specify that all transactions of a certain type and over a certain amount should be identified. In this example the conditions are the same as in the previous example but the action is identification of transactions meeting the conditions so that for example a manager may review the identified transactions and investigate any transactions he or she deems suspicious.

Typically a policy is used to implement a business policy which is one or more rules guidelines and or principles related to the conduct of a business. For instance a business policy specifying that invoices over a specific amount require manager approval may be implemented by creating a policy that includes criteria for identifying invoices over the specified dollar amount from information stored in one or more data stores.

In a specific embodiment business data is encoded in an ontology and the ontology is processed in order to ensure that business policies are followed. Processing the ontology involves applying graph partitioning techniques in order to distribute the data over a plurality of reasoner instances where a reasoner instance is one or more processors implementing one or more reasoners. Typically each reasoner instance will comprise a single processor implementing a single reasoner although more processors and or reasoners may be possible in a reasoner instance. MapReduce techniques discussed below may be used to coordinate the actions of a plurality of reasoners operating over the nodes. Algorithmic matrix based methodology is used throughout the partitioning and reasoning process.

Turning now to the drawings is a simplified block diagram of a computer system that may be used to practice an embodiment of the present invention. Computer system may serve as a user workstation or server such as those described in connection with below. As shown in computer system includes a processor that communicates with a number of peripheral subsystems via a bus subsystem . These peripheral subsystems may include a storage subsystem comprising a memory subsystem and a file storage subsystem user interface input devices user interface output devices and a network interface subsystem .

Bus subsystem provides a mechanism for letting the various components and subsystems of computer system communicate with each other as intended. Although bus subsystem is shown schematically as a single bus alternative embodiments of the bus subsystem may utilize multiple busses.

Network interface subsystem provides an interface to other computer systems networks and portals. Network interface subsystem serves as an interface for receiving data from and transmitting data to other systems from computer system .

User interface input devices may include a keyboard pointing devices such as a mouse trackball touchpad or graphics tablet a scanner a barcode scanner a touch screen incorporated into the display audio input devices such as voice recognition systems microphones and other types of input devices. In general use of the term input device is intended to include all possible types of devices and mechanisms for inputting information to computer system . A user may use an input device in order to execute commands in connection with implementation of specific embodiments of the present invention such as to implement define policies and or configure various components of an enterprise system such as that described below in connection with .

User interface output devices may include a display subsystem a printer a fax machine or non visual displays such as audio output devices etc. The display subsystem may be a cathode ray tube CRT a flat panel device such as a liquid crystal display LCD or a projection device. In general use of the term output device is intended to include all possible types of devices and mechanisms for outputting information from computer system . Results of implementing policies defining policies and configuring various components of a computer system may be output to the user via an output device.

Storage subsystem provides a computer readable medium for storing the basic programming and data constructs that provide the functionality of the present invention. Software programs code modules instructions that when executed by a processor provide the functionality of the present invention may be stored in storage subsystem . These software modules or instructions may be executed by processor s . Storage subsystem may also provide a repository for storing data used in accordance with the present invention for example the data stored in the diagnostic data repository. For example storage subsystem provides a storage medium for persisting one or more ontologies. Storage subsystem may comprise memory subsystem and file disk storage subsystem .

Memory subsystem may include a number of memories including a main random access memory RAM for storage of instructions and data during program execution and a read only memory ROM in which fixed instructions are stored. File storage subsystem provides persistent non volatile storage for program and data files and may include a hard disk drive a floppy disk drive along with associated removable media a Compact Disk Read Only Memory CD ROM drive an optical drive removable media cartridges and other like storage media.

Computer system can be of various types including a personal computer a portable computer a workstation a network computer a mainframe a kiosk personal digital assistant PDA cellular telephone a server or any other data processing system. Due to the ever changing nature of computers and networks the description of computer system depicted in is intended only as a specific example for purposes of illustrating the preferred embodiment of the computer system. Many other configurations having more or fewer components than the system depicted in are possible.

In accordance with an embodiment the enterprise computer system includes a first location and a second location communicatively connected by a network such as the Internet or any suitable communications network or combination of networks. In an embodiment the first location and second location correspond to separate physical locations of a business such as offices in two separate cities states or countries. While shows two locations it should be understood that a business may have only a single location and may include more than two locations. As shown in the drawing the enterprise computer system may include one or more user workstations a development server and a developer workstation . The user workstation development server and or development workstation may be physically present at any of the locations or at separate locations. In an embodiment the user workstation and development server are communicatively connected to the network so as to access various components of the enterprise computer system. For example the user workstation may include a browser used for viewing content provided from the Internet and or from other systems within the business. Further the developer workstation may be connected to the network through the development server and may be adapted to enable certain employees within the organization to configure install modify and perform other actions in connection with the business computing systems. As an example a developer within the organization may utilize the developer workstation in order to create policies that are used to define policies and execute one or more applications that stores data in one or more ontologies and that reason the data according to the policies in accordance with various embodiments of the invention. Instructions for controlling the applications and the defined policies may be sent over the network to an appropriate computing device executing the one or more applications.

As noted above the first location may include various computer systems used in operating the business. For example as depicted in the first location includes a web server configured to receive requests from various users such as from a user of the user workstation and to respond to the requests over the network . While shows the web server as a hardware component as with any of the servers described herein the web server may also be a software module operating on a computer system. Responses from the web server may be provided from the web server itself or through the web server but from a variety of sources in communication with the web server such as from components of an internal computer system of the first location or from other web servers located at other possibly third party locations.

In an embodiment the web server is communicably coupled to an application server which is a hardware component or software module configured to run one or more applications such as one or more policy engines and other applications for managing organizational data. As is known a user of the user workstation may send a request to the web server that specifies a specific action to be taken in connection with an internal business application implemented on the application server . The web server then relays the request to the application server which takes the specified action and returns the result of that action to the web server which in turn relays the result to the user workstation . In accordance with an embodiment the web server or other component may modify the content returned to the user workstation in accordance with one or more policies applicable to a user of the user workstation .

As shown in the example of the application server interacts with data stored in a first data store and a second data store each of which may store data relevant to the business operation such as in one or more relational or other databases. While the disclosed example shows the first location having two data stores it should be understood that the first location may have less than two data stores or more than two data stores. Information in the data stores can include a wide variety of data such as data relating to business transactions invoices human resources data user account data receipts bank account data accounting data payroll data and generally any data relevant to the operation of a particular business. Information from the data stores and other sources may be extracted from the data stores converted to a uniform format and stored in an ontology in accordance with an embodiment.

In an embodiment the second location includes its own web server application server first data store and second data store which may be configured to function similarly to the identically named components above.

In an embodiment data is stored in an ontology by creating ontology data from various business data sources at a data storage step . As noted below the data can be enterprise business data or generally any type of data. Storage of the data can be performed in a variety of ways. For instance in an embodiment a batch process is periodically executed that causes data stored in data stores to be compiled into an ontology. For instance data stored in a first form can be transformed using one or more adapters configured to convert data from a first form to a form suitable for storage in the ontology. In addition automatic Extract Transfer and Load ETL operations from a business data sources to a semantic data store that embodies the ontology may be defined and set to run when trigger conditions are met such as at certain times or when a certain amount of data has been changed.

At a partitioning step the ontology data is partitioned so as to be distributable among a plurality of processors. Each processor may implement the same or a different reasoner instance. Partitioning the data may include encoding the ontology data in a matrix such as in a manner described below and partitioning the matrix using one or more matrix partitioning techniques. In alternate embodiments the ontology data is not necessarily encoded in a matrix but is distributed using other methods. For instance because ontologies can be represented as graphs such as directed graphs graph partitioning techniques may be used. Generally any technique for partitioning data among a plurality of reasoners may be used.

At a distribution step the partitioned ontology data is distributed among a plurality of processors each of which may implement of instances of the same or a different reasoner. Techniques such as those described in by Jeffery Dean and Janjay Ghemawat published at the Sixth Symposium on Operating System Design and Implementation which is incorporated by reference for all purposes may be used to coordinate the actions of the reasoners. In this manner the processing of the ontology data is performed by a plurality of reasoners so as to reduce the time necessary for processing. At a combination step the results of the processing by the plurality of reasoners are combined into a set of processed data. Combination may include connecting results of separate processing according to relationships associating different sets of separately processed data such as data encoded in intersection vectors such as those described above. Again in an embodiment MapReduce techniques may be used to coordinate combination the results from the reasoners.

In this manner the work done in processing an ontology is performed efficiently and more quickly than if the ontology was processed with a single reasoner. Other benefits in using the above method are also incurred. For example the embodiments of the disclosed method allow for efficient handling of new and or modified data as described in more detail below in connection with .

As businesses and other organizations operate the data they store changes as a result of business operations. New invoices are created new payments are made to vendors employee roles change new people or organizations become customers peoples position within an organization changes and other events happen during the course of operating a business that may influence the addition subtraction or modification of associated data. Moreover because the amount of data stored by a business is typically very large creation or modification of an ontology based on the data typically takes a large amount of resources and therefore is performed as a batch process often during times when a business systems are under a lighter work load such as at a time of the day when many employees may be at home or when most potential customers are asleep.

As a concrete example A may represent John Doe and B may represent a specific class of employee such as a manager. In the relationship shown in the example of the first triple Pconnecting A to B indicates that John Doe is a manager. As shown in the example in relationships between nodes may be directional as indicated in the example by an arrow. For example continuing with the example of the first triple the arrow extending from A to B indicates that John Doe is a manager but not necessarily that all managers are John Doe. A node may relate to more than one other nodes. For example shows a second triple showing a relationship Pbetween the node A and a node D. Thus considering both the first triple and the second triple it can be seen that the node A relates to both B and to D by two different relationships. Specifically A is related to B by Pand related to D by P. For example D may indicate a class of employees having access to a particular system such as a security system accounting computer system and the like. Thus read together the first triple and second triple indicate that John Doe is a manager and John Doe also has access to the system represented by D. In addition various nodes can be related to each other through inferred relationships. Briefly for example shows a third triple showing a relationship Pbetween nodes B and C. Continuing the example discussed above C may be a specific set of accounting data for an organization. Thus the relationship represented by the third triple indicates that all managers have access to the accounting data. Thus when reading the first triple and the third triple together a relationship between A and C may be inferred that John Doe has access to accounting data because John Doe is a manager. Further details on inferred relationships are provided below.

In an embodiment the data set may be represented in a matrix. For example shows a matrix in accordance with an embodiment. The matrix in the example shown is formed by a series of row vectors each row vector corresponding to a relationship of the data set . As shown in the example the order of the row vectors of the matrix does not have any particular significance however specific orderings such as an ordering proceeding according to an index of possible relationships and other orderings may be used.

Each column vector in the matrix represents a node and as with the row vectors the columns need not be in any particular order but may be. Matrix comprises an entry at each intersection of a row vector and a column vector. The entries in the matrix store values that encode data set . In an embodiment that values for the entries in matrix are either zeros or ones. Although the example given shows entries having values of 0 or 1 other values such as Boolean values of true and false or generally any set of distinguishable values may also be used in alternative embodiments.

As noted the columns and rows of the matrix may or may not be in any particular order. For instance in an embodiment data is extracted from one or more data stores and used to construct the matrix and the manner or order in which the matrix is constructed or extracted may dictate the matrix s initial form. For instance in an embodiment rows may be added to the matrix sequentially as relationships between extracted data are determined. In another embodiment columns may be appended to the matrix as each data point is examined to determine the relationships associated with the data point.

In an embodiment a particular row includes entries of zero or one. The relationship associated with the row may be determined by the one entries. Specifically a column of the matrix that intersects the row at a one entry is associated with a node involved in the relationship. Likewise a column of the matrix that intersects the row at a zero entry is associated with a node that is not involved in the relationship. Thus counting from the top looking at the first row of the matrix which corresponds to the relationship P the intersection between the A column and the Prow includes a zero entry thereby indicating that relationship Pdoes not involve the node A. The intersections of the Prow with columns J and I includes entries of one indicating that the relationship Pinvolves I and J. In a like manner ones or zeroes are filled in matrix to represent the relationships represented by data set .

It should be understood that while shows a matrix representation of the data set other representations can be used. For example matrices may be constructed differently than shown in the figures. For instance in an alternative embodiment row vectors may correspond to nodes while column vectors may correspond to relationships. As another example as is known data sets stored in ontologies may be represented in a graph a directed graph or another representation which may encode data differently. Techniques analogous to the techniques described below such as techniques for graph partitioning may also be used in accordance with the present invention. Further it should be understood that while the examples in the figures show graphical representations of specific matrices including the entries of the matrices matrices corresponding to data sets will typically be too large to be displayed in the same manner but may be stored in computer memory either volatile or non volatile in a manner dictated by a specific application used to create the matrices or other representations of the data.

In an embodiment the matrix is partitioned into a convenient form for example by using known techniques of linear algebra. For instance the matrix may be placed into block form by using elementary row operations such as swapping rows. Column operations such as switching columns may also be used. When row column or other operations are used an index vector list or other mechanism that may be part of the matrix or stored in another location may be updated to keep track of which relationships and or nodes correspond to each vector. For example each entry of the first row may include information such as a string or number identifying a particular relationship and the first entry of each column may include information identifying a particular node. In this manner when a row or column operation is performed the identifying information of the associated rows and or columns are affected by the operation in a way that keeps track of the rows and or columns. As a concrete example if the first and second rows are switched in an embodiment the information identifying the first row moves to the second row and the information identifying the second row moves to the first TOW.

In an embodiment partitioning a matrix includes arranging the columns such that the matrix encodes the directions of the relationships of the represented triples. Thus the columns may be arranged such that the column corresponding to the first node in a triple is to the left of the column corresponding to the second node in the triple. Other configurations of matrices that encode the direction of the relationships may also be used such as the inclusion of an additional encoding column that includes entries that correspond to the direction of triples included in a particular row. For instance an additional column may be added to the matrix so that the intersection of a row with the additional column includes a 0 if the order of the columns corresponds to the direction of the relationship encoded in the row and a 1 otherwise. For instance the first row has a 1 in the intersections with the I and J columns but the J column appears before the I column so the order to the I and J columns does not correspond to the relationship Pextending between the I and J nodes. Therefore in this example an encoding column would have a 1 in the intersection of the first row with the encoding column to indicate that the relationship Pextends from I to J.

In an embodiment with the columns arranged the rows are arranged so that the matrix is in block form. Matrices used in accordance with the present invention will generally be sparse matrices because each row in an embodiment will have only two non zero entries corresponding to the specific data represented in the row. As a result such partitioning may be performed to form a matrix having more than one block which is convenient for visualizing and processing of the data set as described more fully below.

Generally when a matrix is used to encode data the matrix can be partitioned into a convenient form such as block form using various techniques. For example spectral partitioning can be used to partition incidence Laplacian or other matrices that encode a graph representative of ontological data. Likewise multilevel coarsening and partitioning techniques such as those that coarsen partition and then uncoarsen a matrix may be used. Of course hybrid approaches of the above techniques and or other techniques can be used as well.

It should be noted that such rearrangement of the columns may not be straight forward if a data set includes a circuit which is a set of one or more nodes and one or more relationships arranged such that an inferred or direct relationship exists between a node and itself. For example a circuit exists in a situation where A relates to B B relates to C and C relates to A with the directions of the relationships extending from A to B from B to C and from C to A. With a circuit it is not straight forward to order the columns in order to encode the directions of the relationships without taking additional measures. For instance in the circuit described above the C column would have to occur simultaneously before and after the A column. Nevertheless one with ordinary skill in the art would recognize that such situations may be remedied through a variety of techniques. For example a data set may be pre processed to locate any circuits. If any circuits are found triples may be removed from the data set to break any circuitous paths. For instance the triple of C to A may be removed in the example given above so that A does not indirectly refer to itself. The removed triples may be separately processed and the results of the separate processing may be combined with results of processing the modified data set.

Because the data set is stored in an ontology it can be considered as a graph having vertices being the nodes and the relationships being edges. In an embodiment partitioning a matrix representative of a data set can be visualized by equivalent operations on a graph representing the data set. For instance shows a representation of a graph of a data set such as the data set above which shows the transitive properties of the data set. For example if A is related to B and B is related to C then the graph shows edges connecting B to both A and C. As shown in the example the graph includes a first subgraph and a second subgraph . The first subgraph and the second subgraph are related to each other through the relationship Pconnecting node E which is in the first subgraph to node F which is in the second subgraph . In this manner processing the data set can be performed by separately processing data in the subgraphs and combining the results. For example the data in the first subgraph may be processed in a first processor executing instructions for a first reasoner instance the data in the second subgraph may be processed in a second processor executing instructions for another reasoner instance which may employ the same or a different set of rules for processing than the first reasoner instance. Either the first or second or another processer may be used to combine the results according to the relationship P.

It should be understood that data sets will vary and as a result decomposition of a graph representing a data set will vary accordingly. For instance a graph may be partitioned into subgraphs that are disconnected or may be partitioned into subgraphs that are connected to one another by more than one edge. In addition a typical data set in accordance with an embodiment will be partitioned into more than two subgraphs which may be processed separately. Further data in some subgraphs may be processed in one processor while data in other subgraphs may be processed in another processor or processors.

Turning to the matrix representation also shows a matrix which has been partitioned into a convenient form. For example the matrix in an embodiment is a matrix resulting from the transformation of the matrix described above. As described above the columns of the unpartitioned matrix have been rearranged such that they encode the direction of the relationships between the nodes. In an embodiment if a relationship extends from a first node to a second node then the column associated with the first node is placed before the column associated with the second node. For example because the relationship Pextends between A and B the A column is placed before the B column.

Further the rows of the matrix have been arranged so as to put the matrix in block form which as described below results in partitioning the data into separately processable partitions. As discussed above many different techniques for partitioning matrices into block form may be used in accordance with various embodiments. As shown the matrix includes a first vector set SET A comprising the upper seven rows of vectors and a second vector set SET B comprising the lower six rows of vectors where the first vector set is above the second vector set . An intersection vector set comprises the row vectors that are common to both the first vector set and second vector set . As discussed the matrix and sub matrices of are provided for the purposes of illustration and generally matrices used in accordance with various embodiments may have vector sets and sub matrices having different characteristics such as more or less rows.

As shown in the example the first vector set includes a first submatrix in the upper left corner that comprises entries that are either zero or one and a first zero matrix in the upper left corner that comprises entries that are all zero. In an embodiment the first submatrix is situated to the left of the first zero matrix . Likewise the second vector set includes a second submatrix and a second zero matrix where the second submatrix sits to the right of the second zero matrix and the second submatrix includes entries being zero or one and the second zero matrix having entries all zero. In this manner it can be seen that the partitioned matrix is partitioned into discreet blocks and may include a vector connecting the blocks. While the partitioned matrix is composed of four block matrices and the intersection vector it should be understood that data sets in general in accordance with an embodiment will be partitioned into a larger or smaller number of blocks which may or may not be separated by non zero intersection row vectors. In addition it should be understood that the particular positioning of the blocks of the matrix is made according to mathematical convention with the blocks located along a main diagonal of the matrix but that other configurations are possible.

Returning to the example in the drawing the first submatrix encodes the first subgraph while the second submatrix encodes the second subgraph in the manner described above. The intersection vector encodes the relationship between the first subgraph and the second subgraph . If a graph of a data set includes two disconnected subgraphs a partitioned matrix representation may not include any intersection vectors between blocks representing the disconnected subgraphs. In addition one or more row vectors of all zero entries may be situated between blocks representing disconnected subgraphs.

In an embodiment a map function and a reduce function are employed in order to distribute the reasoning of an ontology among various processors and to combine the results of the distributed reasoning. Reasoning an ontology may include application of a predefined set of rules to the data of the ontology. As an example a commonly used rule in reasoning ontologies is the transitive rule where if node A relates to node B and node B relates to node C then node A relates to node C. Other rules depending on specific applications may be used in addition to or in place of the transitive rule. In an embodiment the map function takes as input data corresponding to a subgraph of a graph representing an ontology and a set of rules to be used by a reasoner to process the individual triples represented in the subgraph. For a subgraph and set of rules input to the map function the output of the map function includes data corresponding to a subgraph typically a different subgraph and an inferred vector which may encode information about one or more triples. In an embodiment the subgraphs output by the map function may include nodes that are common to more than one subgraph so as to encode any relationships between subgraphs.

Similarly the second vector set encodes the second vector set and the intersection vector described above in connection with thereby encoding the second subgraph and the triple represented by E F and P. As shown in in an embodiment the row vectors of the first set of vectors are simply the row vectors of the first data set and intersection vector . In this manner the map function outputs the first vector set and second vector set . Subgraphs corresponding to the first vector set and second vector set may be ascertained from the entries in the vector sets as described above. In an embodiment the first vector set forms a first matrix which may be in block form and whose columns and rows represent nodes and relationships respectively as described above.

As noted above the map function also outputs inferred vectors which may encode the relationship between two or more nodes as determined by a reasoner. For example a set of rules may include a transitive rule for an ontology which provides for example that if A is related to B and B is related to C then A is related to C. The set of rules may also include information identifying which rows should be considered when implementing the transitive rule. The transitive rule in processing of ontologies is convenient because when matrix representations are used as described above processing the transitive rule on a subgraph can be performed using an OR operation of the relevant rows which is computationally efficient. In an embodiment an OR operation on a plurality of rows is performed by performing an OR operation on corresponding entries in the rows. For example if the third entry of one row is a zero and the third entry of another row is zero an OR operation performed on the two rows will have a zero in the third entry. If the third entry of both rows is a one then an OR operation performed on the two rows will have a zero in the third entry. If one of the rows has a one in the third entry and the other row has a zero in the third entry then the result of an OR operation performed on the two rows will have a one in the third entry.

In an embodiment the inferred vectors form a set of inferred vectors whose columns and rows encode triples as described above. For example a first inferred vector set results from processing the first vector set according to a plurality of user selected or predefined rules of a reasoner. Likewise a second inferred vector set results from processing the second vector set . In the example shown the first row of the first inferred vector set is a result of performing an OR operation on the rows P P Pand Pof the first submatrix . This particular operation for instance may be chosen by a user of the reasoner and any suitable operation or operations may be used. Likewise the remaining rows of the inferred vector set are formed using various OR operations on various rows of the first submatrix depending on the particular rules chosen by the user. Generally the type of operations used to make inferred vector sets will vary depending on specific applications and reasoners and it should be understood that the particular operations used to form the inferred vector sets are chosen merely as an example.

In an embodiment a reduce function is constructed or provided whose input includes information about subgraphs and inferred triples from each subgraph. For example the input of the reduce function may include a list of nodes directly related to nodes of the subgraph. Thus the input of the reduce function may include all the nodes of the subgraph as well as one or more nodes of another subgraph related to the input subgraph by a relationship. For example in reference to the first subgraph and second subgraph shown in the input of the reduce function may include the list A B C D E F F G H I J. In this example the nodes A B C D E and F are from the first subgraph and the nodes F G H I and J are from the second subgraph . The node F is included in both lists because it is the node in the second subgraph to which the first subgraph refers through the relationship P. The input of the reduce function may also include a list of inferred triples within the subgraphs such as a triple including nodes A and E.

The reduce function determines based upon the input whether additional reasoning should take place. For instance referring to the same example because the first subgraph and second subgraph are related to each other by the relationship P the reduce function then takes the inferred triples from each subgraph and applies the rules of the reasoner to the inferred triples input to the function and returns a list of inferences. For complicated data sets the reduce function may be applied repeatedly or recursively to ensure that desirable inferences are identified. Thus for example the output of the reduce function may include an inferred triple that includes the nodes A from the first subgraph and J from the second subgraph because A and J are indirectly related to one another through a series of relationships.

In the example of four different data sources of a business are shown although a business or other entity may use more than four data sources or less than four. Also the four different data sources may be physically realized in separate data stores which may be in separate geographical locations or two or more data sources may be incorporated into a single data store. As shown in the example demonstrated in a business may include a first relational database which is modeled by a first relational schema . As it applies to data storage a schema is a structure configured to organize the data of one or more data sources. For example in a relational database a schema that models the relational database defines the tables of the database the fields of each table and the relationships between the fields and tables.

In the provided example the business may also include a second relational database which is modeled by a second relational schema . There can be various reasons for having more than one source of business data for example for storing data for different aspects of a businesses activities such as sales and human resources. Businesses may also store data in different forms depending on the particular application. For example in a light weight directory access protocol LDAP directory is modeled by a LDAP schema . Likewise a flat file database may be modeled by a flat file schema . Thus in the example shown in a business may include data from a variety of sources in a variety of formats.

As can be seen in the figure data from each of the data sources is mapped to the semantic data store . In an embodiment mapping data from a data source to the semantic data store is described in more detail below but generally includes extracting data from the source and loading it or a portion of it into the semantic data store which may or may not involve reformatting data from one form to a form suitable for the semantic data store . In addition mapping data from a data source to the semantic data store may involve mapping all data from the data source or using a filter to only map some data from the data source. For instance the data source may include data that is not pertinent to the purposes for which the business ontology is used and as a result only pertinent data would be mapped to the semantic data store. A filter may be used to control which data is mapped to the semantic data store. For example the data mappings above can be used in connection with Oracle Data Integration ODI Tools available from Oracle International Corporation in order to perform ETL processes that constrain and filter data from the various data stores and merge the data into a common format in the semantic data store . As described below once maps are constructed the maps can be used in automated processes that extract data from one data store and appropriately load the data into the semantic data store . Extraction and loading of data can occur for example at predetermined intervals such as once a day or at predetermined triggers such as when data is changed.

As shown in the example data from the first relational database is stored in the semantic data store as well as data from the second relational database the LDAP Directory and the flat file database . In an embodiment schemas of various data stores are mapped to the business ontology such that semantic concepts embodied in the data stores are stored in the business ontology . For example the first relational database may include a plurality of tables each table having one or more columns. The first relational schema may relate tables together in a useful manner for example relating customers to invoices such that a customer is related to an invoice for goods or services purchased by the customer. Thus relationships defined by the relational schema are mapped to the business ontology such that semantic concepts defined by the relational schema are preserved in the business ontology .

Also in an embodiment each relation is a binary relationship between two classes. For example a relation orgHasEmployees may be a relationship between a member of an organization class and an employee class. This relationship for example may specify employees that are part of an organization. Relations may be further classified in terms of their domains the class or classes from which they relate and ranges the class or classes to which they relate . Also in an embodiment some relations have super relations. For instance orgHasEmployees may be a super relation of an orgHasManagers relation because for example all managers may be employees.

As shown in the diagram the ontological meta model also includes storage for ontological data types which may be for example strings integers floats dates Boolean or other types of data. In an embodiment data types are the ranges value sets of the attributes and consist of sets of similar data forms. In the embodiment presented in the drawings ontological type data is stored separately from instance data which is stored in a hyper denormalized relationed form. As used herein semantic data that is in hyper denormalized relationed form is stored such that every attribute is stored in its own table. This form provides an advantage in that instance data is easily and quickly accessible which in turn allows for a highly distributed approach to solve problems of inferencing persistence and other issues. In other words the architecture in the disclosed embodiment provides the power and flexibility of ontological storage with the performance of modern relational database management system. However one with skill in the art will appreciate that variations are possible and that in other contexts different architecture may be appropriate. For example one with skill in the art would recognize that type and instance data may be stored in the same storage system and that instance data need not be hyper denormalized but that different degrees of denormalization of data may be used and different kinds of instance data may be combined in one or more containers.

As shown in the drawing in an embodiment between the classes are relations between the classes and there may be relations among the relations . Also each class is an aggregation of attributes in accordance with an embodiment.

As noted above the relational meta model is mapped to the ontological meta model as described more fully below. In an embodiment of relational meta model includes relational concepts which are super classes of tables columns and keys . Also as is known each table is an aggregation of columns. As can be seen various mappings are provided between various elements of the ontological meta model in relational meta model . For instance in an embodiment one or more columns of a table are mapped to an attribute of the ontological meta model . Likewise tables are mapped to classes of the ontological meta model . As keys define relationships between tables in the relational meta model keys of the relational meta model are mapped to relations of the ontological meta model in a manner preserving the relationships between the tables . In an embodiment relational data types are mapped to a ontological data types .

In an embodiment the relational meta model may be implemented using a relational database management system RDBMS and the meta data in the relational meta model is therefore readily available. The mapping shown in in an embodiment may also be achieved by utilizing Application Programming Interfaces APIs exposed by the systems implementing the relational meta model such as Java Database Connectivity JDBC meta data Open Database Connectivity ODBC meta data and the like.

In an embodiment the semantic data store translates policies queries expressed in terms of the sales ontology into queries expressed in terms of the semantic store schema and executing the translated queries on the data store. The actual execution of the query may be delegated to a reasoner. Thus in an embodiment a query expressed in terms of classes and relations will be translated by the semantic data store in terms of tables and keys. For example in an embodiment the ontological query 

In addition appropriate relations may be substituted with foreign key primary key pairings when the query is translated into the relational form.

As discussed above the ontological meta model is comprises of classes relations and attributes . The sales ontology comprises specific instances of the members of the ontology meta model . For example as shown the sales ontology includes several classes including a person class a buyer class an employee class an invoice class and invoice item class . As seen by it s name the person class corresponds to people such as employees buyers and other people. Accordingly the buyer class and employee class are sub classes of the person class . Also clear from its name the invoice class may be associated with invoices and the invoice item class may be comprised of various invoice items such as various products sold by a business employing the disclosed ontology. In an embodiment the employee class invoice class and invoice item class have corresponding tables in the semantic data store . Other classes of the sales ontology may also have corresponding tables in the semantic data store .

As shown the sales ontology includes various relations from the relations such as a buyerOf relation and a sellerOf relation and a hasItems relation . The names of the various relations also may be related to their semantic meaning. For instance as can be seen in the figure a buyer of the buyer class may be related to an invoice of the invoice class by the relation buyerOf because the buyer may have purchased the particular items of the invoice. Likewise an invoice of the invoice class is related to invoice items of the invoice item class by the relation hasItems because the invoice items were included on the invoice. Also the sellerOf relation relates an employee of the employee class to an invoice of the invoice class when the employee was the person who sold the items listed on the invoice. In an embodiment relations are represented in the semantic data store by the pairing of the primary key of the tables of the semantic data store as discussed below.

Further various items of the sales ontology may include various members of the attribute class . As an example person may include a first name and a last name which as indicated in the drawing may be stored as strings. Likewise a buyer may have a buyerID unique to the buyer as may an employee have an employeeID unique to the employee. Continuing this example the invoice may include an invoiceID unique to the invoice and a date for example on which the invoice was created. As a final example an invoice item of the invoiceltem class may include an amount corresponding to the price at which the associated item was sold to the buyer .

As discussed above various items of the sales ontology are stored in a semantic data store . In an embodiment the semantic data store may closely resemble a data store of another data model such as a relational database model. Thus in an embodiment the semantic data store includes a plurality of tables where each table corresponds to a class of the ontology meta model . It should be understood however that the example semantic data store shown in the drawings may be in an intermediate format used to facilitate transformation of the data. Data from the semantic data store may be further transformed for example into a format suitable for use with a particular reasoner operable to reason the data.

Thus as shown in the illustrative example of the semantic data store includes an employee table an invoice table and an invoice item table . Each of the tables of the semantic data store may include a key comprising an attribute unique to the entities represented by the table. For instance the employee table may include a column having each employee ID . Other attributes may also be stored in tables such as the last name and first name attributes of employees in the employee table . Likewise the invoice table may include a column corresponding to an invoice ID primary key employee ID foreign key and buyer ID foreign key such that in this manner for example an ID of an invoice may be located in the invoice table and the employee associated with the invoice and buyer to which items on the invoice are sold may be identified.

The above embodiments and variations thereof provide include features additional to those discussed above. shows an embodiment of an environment in which embodiments of the invention may be practiced. As shown the environment includes a plurality of data stores from which data is extracted and stored in a semantic data store such as in a manner described above. In an embodiment data stored in the semantic data store is reasoned by a reasoner which is operated by a user of a user terminal in accordance with an embodiment. While shows the reasoner analyzing data from a single semantic data store the reasoner may utilize data from multiple semantic data stores as well as from one or more of the data stores or data from other sources. Generally the semantic data store is a data store whose persistence mechanism can be the file system database or memory depending on the usage within the application and as described above may be dynamically optimized for storage of data based on deployed semantic domain definitions. As described above semantic domain definitions may be OWL files that encapsulate domain taxonomy which may be defined by a business expert for a particular domain.

In addition it should be noted that shows a simplified environment for the purposes of illustration but that actual implementations may utilize various components in addition to that which is illustrated and in various embodiments certain components are omitted. For example in an embodiment the reasoner is implemented in one of several layers of a software architecture adapted for enforcing policies. As an example an interface such as a Web 2.0 interface may be provided for users to utilize various components. Customized interfaces for utilizing various components may be created using REST Web Services or services using other protocols such as SOAP. One or more interfaces may be used to operate application services which coordinate components of policy enforcement such as a policy engine that operates the reasoner and the semantic data store data services that coordinate the transfer of data to the semantic data store and report services that provide reporting documents based on analysis of data in the semantic data store and the like. In an embodiment the data services utilize Oracle Data Integrator 11gR1 and the report services utilize Oracle Business Intelligence Publisher both available from Oracle Corporation.

As shown in the drawing the reasoner comprises a plurality of reasoning modules where each reasoning module is configured to apply a set of rules to analyze data in the semantic data store . While shows a certain number of reasoning modules of the reasoner the reasoner may have more or less reasoning modules. When reasoning data the reasoner may use all or some of its reasoning modules depending on the type of reasoning being conducted. For instance a user may through an input device define a particular analysis that the user would like to perform and the reasoner may use one or more applicable modules such as in a manner described below. Further a user may define his or her own reasoning modules which may include a combination of some of the reasoning modules of the reasoner directed to analyze data in a particular manner.

In an embodiment the reasoner includes one or more pattern based reasoning modules abbreviated as PBRM and one or more semantic reasoning modules abbreviated as SRM . In an embodiment a PBRM is a sub reasoner of the reasoner that uses a predefined process for performing statistical analysis on data from the semantic data store in order to infer information from the data. PBRMs may utilize range reasoning where data is looked at over a specified range such as over a specified time period. As an example utilizing a matrix based approach such as the approach described above a covariance matrix of a vector may be constructed in order to measure how the changes of variables in the vector depend on others. Likewise the covariance of two variables may be measured for other objects such as matrices or higher dimensional objects. Correlation between two seemingly random variables such as between invoice amounts and payments unrelated to the invoices may signify fraud. A PBRM may take as input a set of data such as a sampling of numerical values such as invoice line items over a time period and may output conclusions based on a statistical analysis of the numerical values such as covariance matrices or other objects.

Other statistical techniques may be used in PBRMs. For instance pattern recognition may be used to identify activities that are out of the ordinary. As an example certain invoices payments and or other items may be flagged for review if they contain an amount that is above or below a predefined threshold. As another example pattern recognition techniques may be used to flag invoices payments or other items that are not necessarily above or below a threshold but that are otherwise abnormal such as invoice amounts that are larger or smaller than usual but not outside of a range that would cause any flags to be set. Pattern recognition may also be used to compare activity with activity of those having similar duties. For instance pattern recognition may be used to identify through analysis of purchases and or other data that a manager of a location is replacing parts on equipment more frequently than managers of other locations. An investigation may be subsequently made to determine whether the manager is legitimately acting differently from his or her peers whether corrective action needs to be taken and or whether fraud is being committed such as by profiting off the sale of used parts.

Generally techniques that may be employed in PBRMs include cross correlation analysis to discover the relationship between multiple dependent variables Bayesian filters to look at past events and build probabilistic models to predict future events to detect whether past present and or future events violate a policy and wavelets for detection of data that is most likely to be suspect. Other techniques may also be used and as new techniques are developed a user may define reasoning modules that are able to apply any given technique. For instance in an embodiment users may define techniques that may be employed by a PBRM using combinations of the above techniques and or defining additional techniques.

One or more SRMs may be used in connection with one or more PBRMs in order to increase the effectiveness of the modules. In an embodiment an SRM is a reasoning module that applies one or more rules to a set of data which may be put into matrix form as described above in order to provide information about the relationships among the various data. For instance a semantic reasoning module may identify all invoices related to a particular employee. Generally use of SRMs and PBRMs provides increased flexibility in choosing the data to be analyzed and the techniques to be used for analysis. For instance output of one or more SRMs may be used as input for one or more PBRMs. As an example if John Doe is an employee a SRM may be used to identify invoices issued by John Doe such as using any of the techniques or variations thereof discussed above. One or more covariance techniques may be used by one or more PBRMs to determine whether there is a correlation between the invoice amounts and other data such as data not associated with John Doe. An SRM may be used to exclude data from the analysis that typically would be correlated to the invoice amounts such as payments to the vendors identified on the invoices. An SRM may take input objects from the semantic data store may construct appropriate matrices and may perform matrix operations on the matrices depending on the nature of the reasoning being performed although matrices may be input into SRMs in other embodiments. Output from an SRM may be a set of inferences or other conclusions about the relationship among semantic data or may be a set of numerical values such as invoice line items or other data.

Likewise the output of one or more PBRMs may be used as input to one or more SRMs. For instance as discussed PBRMs may be used to find correlations among various data. A SRM may be used to provide useful information about data having correlations such as people roles vendors and others associated with a particular datum. This information may be viewed by an analyst who may decide whether to investigate further and or take corrective action. Additionally the information may be used in order to define rules for additional analysis. The reasoner may include additional logic to coordinate the flow of data among reasoning modules being used such as by formatting output of one reasoning module into a format suitable as input for another reasoning module. For instance if an SRM outputs a set of inferences the reasoner may extract from a semantic data store objects such as numerical values corresponding to objects associated with the inferences and provide those values to a PBRM for processing by the PBRM.

As discussed in the preceding paragraphs SRMs and PBRMs may be used in series where output of one or more modules is used as input for one or more other modules . SRMs and PBRMs may also be used in parallel in appropriate circumstances. For instance output of an SRM and output of a PBRM may together be used as input for one or more other modules each of which may be an SRM or PBRM. Additionally while the above discussion pertains to SRMs and PBRMs other types of modules may be employed. In an embodiment one or more hybrid modules may be used in ways discussed above where a hybrid module is a reasoning module that employs both semantic reasoning such as transitive reasoning of semantic data and statistical reasoning such as pattern based reasoning of numerical data . A hybrid module may comprise a combination of one or more SRMs and or PBRMs in series and or parallel.

In accordance with an embodiment at a semantic data storage step at least a portion of the data stored in the one or more data stores is stored in a semantic data store such as a semantic data store configured as described above. As discussed storing data in the semantic data store may involve the use of various filters in order to exclude some data from the one or more data stores and also may involve the use of various transformations of the data that put the data in a form suitable for storage in the semantic data store such as in a manner described above. In addition while the method describes a single semantic data store more than one semantic data store may be utilized.

At a semantic reasoning step in an embodiment data from the semantic data store is reasoned using a SRM where the SRM may be as described above. For instance a SRM may apply transitive reasoning to data in the semantic data store in order to identify relationships specified by a user of a system employing the method such as all invoices associated with a particular employee and or having particular attributes. Semantic reasoning may include construction of one or more matrices or other objects whose entries signify something in the data such as an amount or a 0 or 1 as described above. Once the matrix or matrices are constructed semantic reasoning may include applying matrix operations and or other analysis to the matrices depending on the particular type of reasoning being performed. At a statistical reasoning step data from the semantic data store is reasoned using a PBRM in accordance with an embodiment. For instance a PBRM may apply statistical reasoning to data specified by a user such as to particular invoice values for the invoices identified by the SRM. As with the semantic reasoning step the statistical reasoning step may include construction and or operations and or other analysis on one or more matrices whose entries have a significance to the data.

While the method shows the semantic reasoning step performed before the statistical reasoning step the steps may be performed in another order or at the same time. For example a PBRM may be used to identify suspicious values in the Semantic data store and a SRM may then identify employees and other semantic objects associated with the suspicious values. Further also described above a plurality of SRMs and or PBRMs may be used to reason data in the semantic data store and may reason data in series and or in parallel. Also reasoning modules other than SRMs and PBRMs may be used as well. In order to provide customizability and or scalability each reasoning module may be adaptable to receive as input from other reasoning modules. For instance operations in an embodiment where matrices are used such as those described above the dimensions of a matrix output by a reasoning module are used by another reasoning module so that operations on the matrix by the other reasoning module proceed properly. The dimensions may vary based on the amount or other characteristics of data being reasoned.

In an embodiment at a results step results of the reasoning are provided to the user. Providing the results may include causing the display of information corresponding to the results through a graphical user interface of the system. The results may be presented in various forms which may employ text graphics video audio and other features. For example graphs that illustrate statistical relationships between semantic objects may be displayed as may text describing the relationships.

In an embodiment at a SRM selection step an SRM is selected. Selection of the SRM may be based at least in part on user input which may be received during performance of the data identification step . For example if a user specifies that he or she would like to analyze all invoices belonging to a particular employee or group of employees an SRM configured to identify invoices associated with the employee s may be selected. At a PBRM selection step in an embodiment a PBRM is selected. As with the SRM selection of the PBRM may be based at least in part on user input. For example if a user specifies that he or she would like to analyze the correlation between invoice values and other semantic objects a PBRM operable to perform this analysis may be selected. For instance a PBRM that constructs a covariance matrix from vectors in a matrix constructed in accordance with the above description may be selected.

While shows the SRM selection step occurring before the PBRM selection step the steps may be performed in another order or at the same time. In addition as discussed above embodiments of the present invention provide for scalability. Accordingly the method may include selection of a plurality of SRMs and or a plurality of PBRMs. In other embodiments one or more SRMs are selected but no PBRMs are selected. Likewise only one or more PBRMs may be selected without selection of any SRMs.

At a data reasoning step the identified data is reasoned according to the selected SRMs and PBRMs in accordance with an embodiment. Reasoning the data may include applying any selected SRMs and PBRMs in an order that is based at least in part on user input. At a results step results of the reasoning are provided such as in a manner described above.

As discussed above users may interact with an interface in order to define the way in which data is analyzed in order to ensure compliance with one or more policies. As an example a user may interact with an interface in order to define how to detect whether fraud is being committed or is potentially being committed. In an embodiment users specify parameters that define how analysis of data is to take place. Parameters may be defined using semantic concepts such as employee invoice line item and the like. The interface may operate according to executable instructions embodied on a computer readable storage medium.

As an example in accordance with an embodiment of the present invention shows an example graphical representation of an analysis to be performed as part of implementation of a policy related to credit card charges specifically a policy relating to credit card charges over 500. Upon receipt of instructions from a user a system performing analysis of data according to the graphical representation may direct a semantic reasoning module to identify from a semantic data store credit card charges on company credit cards that are for amounts greater than 500. Identification of the credit card charges may be performed according to techniques described above or other techniques. This graphical representation may be used for example for the implementation of a business policy specifying that all credit card charges greater than 500 require approval from a specific person or class of persons such as managers. Identification of such credit card charges using the policy allows for implementation of the business policy.

The graphical representation includes a credit card charges object that includes a plurality of options for specifying data that may be related to credit card charges. The specified data may be identified during analysis performed during implementation of the policy. For example a date checkbox allows users to specify by checking the date checkbox that credit card charges identified during implementation of the policy will include date information about the date on which the charge was made or recorded. Likewise a description checkbox and an amount checkbox allow users to specify that credit card charges identified during implementation of the policy will include a stored description of each charge and or an amount of each charge respectively.

In various embodiments users are able to specify various criteria so that implementation of a policy results in the identification of information matching or closely matching the criteria. For example continuing the example of the credit card charges object includes an amount comparison field that allows users to specify that credit card charges that are to be identified by implementation of the corresponding policy should have amounts matching certain criteria. In the example shown the amount comparison field includes an amount condition dropdown box and an amount entry field which collectively allow a user to enter an amount into the amount entry field and specify using the amount condition dropdown box what amount identified credit card charges should have in comparison with the amount entered into the amount entry field . In the example shown a user has selected that each credit card charge identified by the policy should have an amount greater than 500 dollars. In various embodiments credit card charges not matching the selected criteria may be identified by implementation of a policy such as when few or no results match the selected criteria. For example continuing the example shown if implementation of the policy corresponding to the graphical representation does not result in any credit card charges identified credit card charges having amounts less than but near 500 may be included. In accordance with an embodiment fields may be added to or removed from graphical objects as appropriate.

As noted above various objects may be associated with one another for example by graphically linking the objects together for various purposes. For instance the graphical representation includes an employee object which in the example shown has been associated with the credit card charges object by connecting the objects together with a line. In this specific example the results of associating the employee object with the credit card charges object are that a credit card charge identified by implementation of the policy includes information identifying the person who made the charge such as the name of the employee which may be specified by a name checkbox of the employee object . Thus when the policy associated with the graphical representation is executed an SRM may identify from a semantic data store credit card charges having the specified properties. A second SRM may take the identified credit card charges as input and identify names of the employees that made the identified charges. The credit card charges and names may be associated with one another in one or more data records such as in a table in a relational database. Also the credit card charges and names may be displayed to a user such as in a table spreadsheet or other format and or may be used as input into another reasoning module such as a PBRM or another SRM depending on directions from a user.

As seen in the drawing the credit card charges object includes a delete button a test button and a save button. Other elements of an interface employing embodiments of the present invention may include these buttons and or similar buttons or other elements that perform the same and or similar functions. In an embodiment the delete button allows a user to delete the policy thereby disallowing access to the policy and or removing the policy from computer memory. The test button in an embodiment allows a user to analyze data according to the parameters that he or she specified. For instance selection of the test button in may cause a computer system to analyze data in a semantic data store in order to identify credit card charges greater than 500 and display the identified charges with their associated dates descriptions and amounts. As discussed above data in the semantic data store may be stored in a relational database. In this instance selection of the test button may result in appropriate queries being made to the database to identify data according to the defined analysis. Further one or more matrices may be defined and appropriate matrix operations may be performed. Also selection of the test button may cause only a portion of a data store to be analyzed which may be useful when complete analysis would take a long time due to the size of the data store but the user simply wants to determine whether the analysis that he or she designed results in desired information being returned.

Moving on to the save button in an embodiment the save button allows a user to save the graphical representation or other information corresponding to the graphical representation in computer memory which may be non volatile. The policy may be saved in memory as a set of instructions that instruct a computer system to perform an analysis of the data according to specified parameters. A user may access a saved analysis from memory and analyze data according to the policy and or may utilize the policy in connection with other policies. For instance a user may utilize techniques described herein in order to use a policy as a component in another analysis and or to modify the analysis.

The graphical representation shown also includes fields for selecting criteria for various pieces of information associated with purchase orders. Boolean operators are also included in order to provide substantiality for how the criteria are selected. For example in the example of an amount comparison field and a line item comparison field are selected and connected together with an AND operator so that criteria selected with the amount comparison field and with the line item comparison field both must be matched or closely matched during implementation of the policy. Other operators such as OR operators or other Boolean or non Boolean operators may also be included. Various controls for arranging fields such as a delete control for deleting fields may be included to provide robust functionality for creating policies. Other controls such as a test control for testing a created analysis and a save control for saving an analysis may also be included.

In accordance with various embodiments other features are included for user definition of analyses performed in connection with implementation of policies. For instance in accordance with an embodiment various graphical objects corresponding to data analysis techniques are included so that a user may include one or more of the graphical objects into a graphical representation of an analysis to be performed as part of implementation of a business policy so as to indicate that the data analysis technique should be applied during implementation of the policy. As an example an icon representative of an algorithm for detecting micropayment fraud may be placed onto a graphical object such as an object representative of an invoice to indicate that the algorithm should be applied A plurality of graphical objects representative of commonly used data analysis techniques may be included for selection by a user. In addition users may create their own data analysis techniques or modify and or combine data analysis techniques in order to create custom data analysis techniques.

Accordingly shows an example of an interface of a tool for designing analyses used during implementation of policies in accordance with an embodiment. The interface may behave according to executable instructions embodied on a computer readable storage medium. In the example shown the interface is divided into three vertical columns although other arrangements are possible and in an embodiment the arrangement is changeable according to user input. As shown the middle column is labeled as Work Space and the right column is labeled as Pattern Palette. Also as shown the left column includes two rows the upper row being labeled as Predefined Semantics and the second being labeled as Custom Semantics. In the Predefined Semantics row a plurality of semantic elements are provided as selectable interface elements. In an embodiment the predefined semantics may include graphical representations of semantic objects that are provided for use with common software programs. For instance in the example shown predefined semantics are included for E Business Suite application EBS PeopleSoft PSFT available from Oracle Corporation and Quickbooks Enterprise available from Intuit Inc. As shown in the example predefined semantics may be provided through interface elements shown as cubes having a plus sign or a minus sign which may be selected to show the predefined semantics for the associated software by selecting a cube with a plus sign or to hide the predefined semantics for the associated software by selecting a cube with a minus sign .

In an embodiment the semantic elements in the Predefined Semantics row correspond to data items that are commonly used when enforcing policies. For instance in the example shown the semantic elements associated with EBS include a customer element an employee element and invoice element. Elements may also include sub elements. For instance in the example shown the invoice element includes elements commonly associated with invoices such as a line item sub element a purchase order sub element a sales person sub element and a vendor sub element.

A user may interact with the elements on the interface in various ways. For instance a user may use a mouse or similarly operational input device to select an element and drag the element into the Workspace column i.e. the middle column labeled as Work Space . Upon dropping the item into the Workspace column for instance by releasing a mouse button a box corresponding to the element may appear in the Workspace column. For example an Invoice box may appear in the Workspace column upon dragging and dropping an Invoice element from the Predefined Semantics row of the left column into the Workspace column. The box may include elements associated with invoices as described above.

In the Custom Semantics row of the left column in an embodiment the interface may include one or more elements tools that allow a user to define custom semantics such as by labeling items in a data store that do not correspond to any of the predefined semantics or that do correspond to one of the predefined semantics but where the correspondence is not automatically recognized. Users may also define custom semantics using the tools provided in order to define analysis for policies such as in a manner described above. In the example shown the custom semantics includes two categories of custom semantics a Mappings category and an Entities category. In an embodiment the Mappings category includes tools for mapping data from various data sources to semantic objects. For instance as shown the Mappings category includes a flat file mapper for mapping data from flat files a RDBMS mapper for mapping data from relational databases and a custom mapper for mapping data from other data sources. Each of the mappers when selected may provide an interface for identifying data from one or more data sources. Software providing the interface may utilize an API of the data source in order to gain access to the data and the interface may allow developers to input commands according to an API which are not pre loaded with the software. As an example software providing an interface of the RDBMS mapping tool may utilize the API of a particular RDBMS to gain access to tables of a relational database. A user may specify for example that data in a particular column of a particular table correspond to a particular semantic object. For instance the user may specify that data in a column identify customer names. In an embodiment once mappings are made using any of the tools in the Mappings category the mappings may be saved and semantic entities mapped to data sources may appear appropriately in the Predefined Semantics row.

Tools in the Entities category in an embodiment provide for building analyses for policies using various semantic objects. For instance a predicate tool in an embodiment allows one to specify an association between two semantic entities such that when data is analyzed according to an analysis that has been defined data that has the specified association is identified. Graphically the predicate tool connects two graphical objects representative of semantic entities with a line or other device representative of an association. In the example shown in the Work Space column an Invoice object is connected to a Sales Person object with a line and the Sales Person object specifies the name of sales person. In this manner when data is analyzed according to the example arrangement of graphical objects defined in the Work Space column invoices that are identified will be associated with a sales person or perhaps several sales people whose name is Bob. In an embodiment if the checkbox next to name in the Sales Person graphical object is not checked then invoices would be identified as well as sales people associated with the identified invoices regardless of their name. In a similar manner a Lineitem graphical is shown as connected to the Invoice graphical object with a line thereby specifying that lineitems for identified invoices should be identified. In this manner a user may specify the types of information he or she would like to view in connection with any identified invoices.

Another tool in the Entities category in an embodiment is a Group tool which allows a user to specify that certain semantic objects are part of a group such that one or more actions may be taken with respect to the group. In an embodiment the Group tool allows users to graphically surround a plurality of graphical objects in order to specify that semantic objects represented by the graphical objects are part of a group. For instance in the Work Space column the Sales Person graphical object and the Lineitem graphical object are surrounded by a rectangle having a dashed border thereby indicating that sales people and line items applicable to the defined analysis are part of a group. In the example shown an icon labeled FHT has been superimposed onto the border defining the group indicating that a Fast Hough Transform FHT should be computed for the data associated with the grouped graphical objects. In an embodiment the FHT icon is superimposed onto the border of the group through a drag and drop operation by a user from another location on the screen as described below although any type of user interaction with the interface may be used in addition or as an alternative to a drag and drop. Further the FHT icon or any of the other icons that may be used described more completely below may be assigned to a group through other actions such as by a user indicating perhaps through a drag and drop that the FHT icon should appear on the border of the group in the space surrounded by the group or through any other specified user action.

Also in the Entities category in an embodiment a Classifier tool allows users to define new semantic entities or to modify existing semantic entities. For example if a company sells widgets widgets may not appear as a predefined semantic entity but it may wish to define one or more analyses that utilize data related to its widgets. In an embodiment upon selection of the Classifier tool the user is provided with an opportunity to create or modify a semantic entity. Creation and or modification of the semantic entity may involve providing a name to the entity and specifying which attributes the entity should have. In addition a user may be able to define the data types of the attributes of a semantic entity such as integer double string and the like and or the data types may be determined based on a mapping of the semantic entity to a data source which may be completed using one of the mapping tools discussed above . For instance if a column in a RDBMS contains integers and that column has been mapped to an attribute of a created entity then the attribute of the semantic entity may automatically be assigned an integer data type.

As discussed above various types of statistical analysis may be performed for data represented by graphical objects. In an embodiment the Pattern Palette includes a plurality of graphical icons each representative of a type of analysis that may be performed. For instance as discussed above the pattern palette includes an FHT icon for performing Fast Hough Transforms. In addition a Calculator tool may be provided for performing more simple analysis such as addition subtraction multiplication division and the like among data corresponding to one or more of the graphical objects in the Work Space column. For instance the Calculator tool may be used to identify the difference between list prices and sale prices for items identified according to an analysis defined in the Work Space column. If applicable such as with the Calculator tool a user may be provided controls that allow the user to select or otherwise define how the tool behaves. The controls may be provided automatically upon selection of the tool or may be provided upon one or more specified user actions with the graphical icon representative of the tool and or other interactions with the interface.

The Pattern Palette or other portion of a user interface may include other graphical representations of analyses that may be performed on data represented by graphical objects selected and or grouped by the user. For example graphical representations such as icons or other objects may be provided for each of the statistical analyses discussed above and or for user defined analyses. Further in another embodiment a user may group graphical representations of semantic objects in the Work Space without using the Grouping tool discussed above by dragging a graphical representation of an analysis around the graphical representations to be grouped or in other ways.

In an embodiment the method includes providing a graphical objects representative of semantic objects to a user at an object providing step . For example one or more computer systems may cause display of a graphical user interface that a user may interact with using an input device of the computer system s in order to cause the graphical objects to appear and or the interface may include a plurality of displayed graphical objects that the user may select and or move using the input device. The graphical objects may be similar to those illustrative examples described above although their appearance may vary. In addition graphical objects representative of particular types of data analysis such as those described above may be provided as well.

In an embodiment at an arrangement receipt step an arrangement of graphical objects is received. Receiving the arrangement of graphical objects may include receiving a series of commands from the user via the input device where the series of the commands indicates which objects are received and how they are graphically arranged on a display device of the user. For instance referring to the illustrative example of the graphical arrangement of objects in the Work Space column may have been produced according to user interaction with the interface. Receiving the arrangement of graphical objects may also include receiving data that indicates how the graphical objects have been directed to be arranged by the user. In addition the arrangement may include one or more graphical objects representative of particular types of analysis such as pattern or other statistical analysis as described above.

At a conversion step in an embodiment the arrangement is converted to executable instructions for performing analysis that may be implemented such as in a manner described above. For instance executable instructions for execution by an application may be generated based at least in part on the arrangement. Conversion of the arrangement in an embodiment includes identifying a set of conditions for data fulfilling the conditions to be identified upon execution of the policy such as data within specified amounts and or data associated with semantic classes or specific semantic entities. Also conversion of the arrangement may include construction of executable instructions for implementing the policy based at least in part on the arrangement. Conversion of the arrangement may also include identification of one or more actions to be taken for data that fulfill the conditions such as display of the data in one or more formats messages to be sent to specified people and or to be displayed and the like.

As discussed above graphical representations of analysis may specify data to be analyzed where that data may be from various sources. In addition also discussed above various techniques may be used to move data from various data stores used by various applications during an organization s operations. Accordingly demonstrates an environment in which analysis of data from various data stores may be achieved. While the environment is shown having particular components for the purpose of illustration an actual environment in which the invention is practiced may have more or fewer components than what is shown.

As shown in in an embodiment data generated by a plurality of business applications may be stored among a plurality of data stores . The business applications may include applications such as applications such as Oracle E Business Suite applications PeopleSoft Enterprise applications Siebel J D Edwards and others. As discussed above some of the data stores may utilize schemas that differ one from another. One data store may utilize a relational database schema another data store may utilize a flat file schema and other data stores may utilize other schemas. Accordingly in an embodiment a set of individual adaptors is used to collect data from a plurality of data stores. In an embodiment an adaptor is a set of executable instructions that cause a computer system or combination of computer systems to read data from one data store and load it into another data store according to a mapping of the data stores schemas. An adaptor may include instructions for performing appropriate ETL transformations from one schema to another such as ETL operations to move data from various data stores to a semantic data store such as described above in connection with . For example an adaptor may map a column of a relational database table to another relational database table of a different database. In an embodiment adaptors are specific to data source type rather than to instance. Thus if an organization utilizes multiple instances of a single application a single adaptor is all that is necessary to extract data from data stores for each of the instances although more adaptors can be used.

In accordance with an embodiment the each of some of the adaptors maps a schema of one of the data stores to the schema of a semantic data store that is utilized by a reasoner that analyzes the data in the semantic data store . The semantic data store may organize data according to a schema such as a schema in accordance with that described above in connection with although it may utilize a different schema. Generally as discussed the semantic data store in an embodiment stores data in a manner that realizes an ontology by associating data according to their semantic relationships to one another.

For example an adapter may map columns of a relational database to a locations in the semantic data store that corresponds to an appropriate semantic concept such as invoices customer identification numbers and the like. As another example names of employees in an LDAP directory may be mapped to a location in the semantic data store that corresponds to employees. In this manner when data in a data store is updated throughout operations of an organization the updated data can be extracted from the data store transformed to an appropriate format the format used by the semantic data store in an embodiment and loaded into the semantic data store.

In an embodiment software that includes executable instructions for performing functions disclosed herein may be provided with a plurality of pre configured adaptors that are operable to extract data generated by commonly used applications including some of those listed above. Also in an embodiment users of such software can create their own adaptors to extract data generated by applications for which pre configured adaptors are not provided. For instance many organizations build or have built their own applications which store data in a particular way specific to the application. Pre configured adaptors may also be customized by users to better control which data is extracted from an organization s data stores. Adaptors pre configured or custom may be created and or modified using a suitable ETL tool such as Kettle Pentaho Data Integration available from Pentaho Corporation. organizations have at their disposal pre configured adaptors for common applications they have purchased as well as custom built applications.

When the data from the various data stores has been loaded into the semantic data store a user may utilize a user terminal in order to direct an application to analyze data in the semantic data store. The user terminal may be communicably connected to the reasoner directly and or over a communications network such as an intranet or the Internet. A user may for example define how analysis should be performed in a manner in accordance with that described above.

In an embodiment at a map definition step a mapping from the first data store to a second schema of a second data store is define. In an embodiment the mapping is defined based at least in part on the data relevant to one or more policies according to which analysis of data in the second data store will be performed. Thus in an embodiment defining the mapping includes identifying data from the first data store that is relevant to one or more policies and therefore that should be stored in the second data store. The one or more policies may have been selected by a user from a collection of predefined policies or may have been custom made according to instructions from a user.

In an embodiment the method includes defining the second schema of the second data store according to the data from the first data store and from other data stores if applicable that are identified as relevant to the one or more policies. Defining the second schema may be performed as part of the map definition step . In an embodiment the second schema is defined based at least in part on a policy according to which data in the second data store will be analyzed. The second schema may also be defined based at least in part on an ontology relating to the data in the second data store. In an embodiment the second schema is defined as a collection of relational tables that associate data relevant to the policy according to corresponding semantic objects of an ontology such as that in the semantic data store described above. Other schemas may be used as the second schema.

Continuing with the example of a second schema that comprises tables the tables of the second schema may be defined to have a particular degree or normalization according to the type of policy analysis to be performed. For instance in an embodiment certain types of analysis are assigned a predefined degree of normalization for the data that is to be stored in the second data store from the first data store and or from other data stores . For instance in an embodiment policies related to authorization such as whether an employee is acting beyond the scope of his her authorization result in the second schema being hyper normalized or generally relatively more normalized whereas policies related to transactions result in the second schema being hyper denormalized or generally less normalized having more data redundancies . Other types of policies such as for configuration policies prevention policies and the like can each require their own degree of normalization in the second data store. In this manner the second data store is tuned for performance according to the type of analysis to be performed in connection with the data in the second data store. Generally the second schema may be defined in any manner that is suitable for analysis of data in the second schema.

As discussed above policy analysis can be user defined and can span several areas such as authorization prevention configurations prevention and the like. In such situations or in general the second schema may be defined according to the data relevant to a policy analysis to be performed. For instance as discussed data from the first data store is identified with corresponding semantic concepts of an ontology. Thus the ontological concepts applicable to a policy may be used in order to determine a score for how the second schema should be defined. For example transactional concepts such as invoices and payments may be weighted in favor of denormalization while other concepts such as has access and system may be weighted in favor of normalization. Accordingly in an embodiment the weights of the concepts relevant to policy analysis is used to determine how normalized or denormalized tables of the second schema should be.

Defining the second schema may include a mapping selection step a mapping from the first data store to the second data store is selected from a collection of pre defined mappings. Selection of the mapping may be performed by referencing a table that indexes adaptors according to the data stores to which they map. The selected mapping may map the logical schema of the first data store to semantic objects of an ontology modeled by seethe second schema of the second data store. In an embodiment the mapping is selected by selecting an appropriate adaptor from a plurality of adaptors that map a different logical schema to the second logical schema of the second data store. Further in instances when data from a plurality of data stores is to be analyzed a plurality of adaptors may be selected where each adaptor includes a mapping from one of the plurality of data stores to the second schema of the second data store.

At a second data storage step in an embodiment data from the first data store or from a plurality of data stores if appropriate are stored in the second data store according to the mapping. For example one or more ETL operations may be performed in order to extract data from the first data store transform the data into a format suitable for the second data store and then load the data into the second data store. The second data storage step in an embodiment is performed as a batch process during appropriate times. For instance in an embodiment the second data storage step is performed on a daily basis at a time when use of the first data store by one or more applications is relatively light although the step can be performed at other times. Further if data is loaded into the second data store from a plurality of data stores the second data storage step may be performed at different times for each of the data stores. Also the data storage step may be performed over a period of time and not necessarily as a batch process. For example data from the first data store may be loaded to the second data store at times defined by one or more triggers such as when data in the first data store is created or updated. Loading of data into the second data store from the first data store may be performed in response to one or more events that are published by an event subscription service executing in connection with the first data store.

As noted the second data store may organize data in a manner that models an ontology. Accordingly in an embodiment the second data storage step includes extracting data from the first data store and loading the data into the second data store in appropriate locations that correspond to appropriate semantic concepts. For example using the example of a semantic data store described above information that identifies an invoice in the first data store may be stored in the second data store in a location dedicated to invoices. Likewise attributes of an invoice may be stored in an appropriate location dedicated to invoice attributes. Thus a line item of an invoice may be stored in a table dedicated to invoice line items. Relationships between data in the first data store as preserved by the first logical schema in an embodiment are preserved in the second logical schema. Accordingly if a line item is associated with a particular invoice in the first data store the line item will be associated with the invoice in the second data store.

As discussed information identifying a semantic object may be stored in more than one data store of an organization. For example data identifying an employee may be stored in a data store of an accounting system as well as in a data store of a human resources system. The data identifying a semantic object in one data store may be different from data identifying the semantic object in another data store. An employee identifier for example may be a unique number assigned to an employee in one data store and another unique number assigned to the same employee in another data store. Accordingly in an embodiment the second data storage step may include transforming data referring to common semantic objects into a format suitable for the second data store. Thus a single semantic object such as a person may have a single identifier in the second data store regardless of how many identifiers the semantic object has throughout the data stores of an organization. An index or other organizational structure may be maintained in order to keep track of which identifiers are equivalent to other identifiers in other data stores.

At a data analysis step in an embodiment data in the second data store is analyzed. Data analysis may be performed pursuant to one or more of the techniques described above although other techniques may be used. A user of a system that is operable to perform the method for instance may define the analysis to be performed in connection with enforcing one or more policies as described above. For instance a user may specify one or more conditions and or sets of conditions that when met indicate violations of a policy. In an embodiment the data analysis step is performed according to continuous controls monitoring or continuous auditing techniques. For instance the data in the second data store may be analyzed according to one or more conditions and or sets of conditions on the data in order to determine whether a policy has been violated. Analysis may be performed upon updates of the data in the second data store such as when an ETL operation is performed that results in a change in the second data store although analysis may be performed more often. In this manner near real time detection of policy violations is achieved.

In an embodiment at a conclusion providing step results of the analysis are provided to one or more users. Thus a message or other display of information such as a graph table or chart reflecting results of the analysis is provided to a user such as by display on a screen viewed by the user. In an embodiment providing results of the analysis is predicated on one or more events. For instance in an embodiment results of the analysis are provided upon analysis of the data in the second data store indicating that one or more policies have been violated although results can be provided at other times such as upon user requests for results of analysis regardless of whether a policy has been violated. In this manner proper persons and or systems are notified when policy violations occur thereby allowing for quick and appropriate responses.

Although specific embodiments of the invention have been described various modifications alterations alternative constructions and equivalents are also encompassed within the scope of the invention. Embodiments of the present invention are not restricted to operation within certain specific data processing environments but are free to operate within a plurality of data processing environments. Additionally although embodiments of the present invention have been described using a particular series of transactions and steps it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.

Further while embodiments of the present invention have been described using a particular combination of hardware and software it should be recognized that other combinations of hardware and software are also within the scope of the present invention. Embodiments of the present invention may be implemented only in hardware or only in software or using combinations thereof.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that additions subtractions deletions and other modifications and changes may be made thereunto without departing from the broader spirit and scope as set forth in the claims.

Other variations are within the spirit of the present invention. Thus while the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention as defined in the appended claims.

The use of the terms a and an and the and similar referents in the context of describing the invention especially in the context of the following claims are to be construed to cover both the singular and the plural unless otherwise indicated herein or clearly contradicted by context. The terms comprising having including and containing are to be construed as open ended terms i.e. meaning including but not limited to unless otherwise noted. The term connected is to be construed as partly or wholly contained within attached to or joined together even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples or exemplary language e.g. such as provided herein is intended merely to better illuminate embodiments of the invention and does not pose a limitation on the scope of the invention unless otherwise claimed. No language in the specification should be construed as indicating any non claimed element as essential to the practice of the invention.

Preferred embodiments of this invention are described herein including the best mode known to the inventors for carrying out the invention. Variations of those preferred embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate and the inventors intend for the invention to be practiced otherwise than as specifically described herein. Accordingly this invention includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover any combination of the above described elements in all possible variations thereof is encompassed by the invention unless otherwise indicated herein or otherwise clearly contradicted by context.

All references including publications patent applications and patents cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.

For the Examiner s convenience it is noted that this application is a continuation of U.S. application Ser. No. 12 684 065. The claims of the present application are different and possibly at least in some aspects broader in scope than the claims pursued in the parent application. To the extent any prior amendments or characterizations of the scope of any claim or cited document made during prosecution of the parent could be construed as a disclaimer of any subject matter supported by the present disclosure any such disclaimer is hereby rescinded and refracted. Accordingly the references previously presented in one or more parent applications may need to be revisited.

